<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//post/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>dnf 命令的使用</title>
    <url>//post/centos8-dnf.html</url>
    <content><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 `dnf` 的版本</span>
dnf <span class="token parameter variable">--version</span>
<span class="token comment"># 查看软件库</span>
dnf repolist
dnf repolist all
<span class="token comment"># 查看 dnf 所有套件、目前已经安裝的套件、可用套件</span>
dnf list
dnf list installed
dnf list available
<span class="token comment"># 查找套件、查看套件信息 （以套件 nginx 为例）</span>
dnf search nginx
dnf info nginx
<span class="token comment"># 卸载安装</span>
dnf remove nginx
<span class="token comment"># 检查更新</span>
dnf check-update
<span class="token comment"># 查看系统中可使用的DNF软件库</span>
dnf repolist
<span class="token comment"># 清除文件 重建元数据缓存</span>
dnf clean all
dnf makecache 
<span class="token comment"># 查看DNF命令执行历史</span>
dnf <span class="token function">history</span>
<span class="token comment"># 安装软件包及其所需的所有依赖      </span>
dnf <span class="token function">install</span> <span class="token operator">&lt;</span>package<span class="token operator">></span> 
<span class="token comment"># 更新系統、更新套件</span>
dnf update
dnf update nginx
<span class="token comment"># 查看软件包详细信息</span>
dnf info <span class="token operator">&lt;</span>package<span class="token operator">></span>     
<span class="token comment"># 只下载软件包，不安装       </span>
dnf download <span class="token variable">$package</span>   
<span class="token comment"># 删除软件包  </span>
dnf remove <span class="token operator">&lt;</span>package<span class="token operator">></span>
<span class="token comment"># 重新安装特定软件包</span>
dnf reinstall <span class="token operator">&lt;</span>package<span class="token operator">></span>         
<span class="token comment"># 更新软件包到最新的稳定发行版     </span>
dnf distro-sync                            
                                                  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>
<hr>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Dnf</tag>
        <tag>CentOS8</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS8 安装 Docker Engine(Docker CE) 及 Docker Compose</title>
    <url>//post/centos8-install-docker.html</url>
    <content><![CDATA[<blockquote>
<p><strong>相关文档</strong></p>
<p><strong><a href="https://docs.docker.com/engine/install/centos"><code>Docker</code> 官方文档</a></strong></p>
<p><strong><a href="https://github.com/docker/compose/releases"><code>Docker Compose</code> 版本发布页</a></strong></p>
</blockquote>
<span id="more"></span>

<h2 id="添加存储库"><a href="#添加存储库" class="headerlink" title="添加存储库"></a>添加存储库</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf config-manager --add-repo<span class="token operator">=</span>https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="安装Docker包"><a href="#安装Docker包" class="headerlink" title="安装Docker包"></a>安装<code>Docker</code>包</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="设置自启动"><a href="#设置自启动" class="headerlink" title="设置自启动"></a>设置自启动</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="防火墙规则"><a href="#防火墙规则" class="headerlink" title="防火墙规则"></a>防火墙规则</h2><p><strong><code>CentOS 8</code> 使用 <code>Docker</code> 以外的防火墙。因此，如果启用了 <code>firewalld</code>，则需要向其添加伪装规则。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd <span class="token parameter variable">--zone</span><span class="token operator">=</span>public --add-masquerade <span class="token parameter variable">--permanent</span>
firewall-cmd <span class="token parameter variable">--reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="手动安装-Docker-Compose-二进制运行文件"><a href="#手动安装-Docker-Compose-二进制运行文件" class="headerlink" title="手动安装 Docker Compose 二进制运行文件"></a>手动安装 <code>Docker Compose</code> 二进制运行文件</h2><p><strong><code>Docker</code> 通常与 <code>Docker Compose</code> 一起安装。正是这个实用程序允许您使用一个命令将项目部署到另一台机器。要下载它，请运行以下命令：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token string">"https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">)</span></span>"</span> <span class="token parameter variable">-o</span> /usr/bin/docker-compose
<span class="token function">chmod</span> +x /usr/bin/docker-compose
<span class="token function">docker-compose</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="以非-root-用户身份使用-Docker"><a href="#以非-root-用户身份使用-Docker" class="headerlink" title="以非 root 用户身份使用 Docker"></a>以非 <code>root</code> 用户身份使用 <code>Docker</code></h2><p><strong>为了能够以非 <code>root</code> 用户身份使用 <code>Docker</code>，您必须将该用户添加到 <code>docker 组</code>。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">usermod</span> <span class="token parameter variable">-aG</span> <span class="token function">docker</span> username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将用户名替换为所需的用户名。执行此命令后，他将需要退出系统并重新登录。<br>注意！该组的用户可以控制 <code>Docker</code> 主机。</p>
<h2 id="Docker-测试容器运行"><a href="#Docker-测试容器运行" class="headerlink" title="Docker 测试容器运行"></a><code>Docker</code> 测试容器运行</h2><p>您可以通过运行测试容器来验证 <code>Docker</code> 是否正常工作。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Docker-安装-Mysql"><a href="#Docker-安装-Mysql" class="headerlink" title="Docker 安装 Mysql"></a><code>Docker</code> 安装 Mysql</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql/mysql-server
<span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span> <span class="token punctuation">[</span>镜像ID<span class="token punctuation">]</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> mysql/mysql-server
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> e38be4367620 <span class="token function">bash</span>
mysql  mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span>
use mysql<span class="token punctuation">;</span>
update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>
flush privileges<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Docker</tag>
        <tag>Docker Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务 之 服务雪崩</title>
    <url>//post/micro-avalanche.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://zhuanlan.zhihu.com/p/59109569">谈谈服务雪崩、降级、熔断</a></li>
</ul>
<h2 id="服务雪崩现象"><a href="#服务雪崩现象" class="headerlink" title="服务雪崩现象"></a>服务雪崩现象</h2><p><strong>从服务雪崩开始讲起！假设存在如下调用链 :</strong></p>
<p><code>Service A</code>  -&gt;  <code>Service B</code>  -&gt;  <code>Service C</code></p>
<span id="more"></span>
<ul>
<li>此时，<code>Service A</code>的流量波动很大，流量经常会突然性增加！</li>
<li></li>
<li>那么在这种情况下，就算<code>Service A</code>能扛得住请求，<code>Service B</code>和<code>Service C</code>未必能扛得住这突发的请求</li>
<li></li>
<li>如果<code>Service C</code>因为抗不住请求，变得不可用.那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用</li>
<li></li>
<li>紧接着，Service A也会不可用</li>
</ul>
<p><strong>一个服务失败，终将会导致整条链路的服务都失败，我们称之为服务雪崩。</strong></p>
<p><strong>那么，服务熔断和服务降级就可以视为解决服务雪崩的手段之一。</strong></p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p><strong>什么是服务熔断？</strong></p>
<blockquote>
<p><code>服务熔断</code>：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，<br>        不再继续调用目标服务，直接返回，快速释放资源。<br>        如果目标服务情况好转则恢复调用。<br>        需要说明的是<code>熔断</code>其实是一个<code>框架级</code>的处理，那么这套熔断机制的设计</p>
</blockquote>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p><strong>这里有两种场景:</strong></p>
<ul>
<li>当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！</li>
<li>当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！</li>
</ul>
<p><strong>可以这么理解:</strong></p>
<ul>
<li>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级! </li>
<li>服务熔断属于降级方式的一种！</li>
</ul>
<blockquote>
<p>可能有的人不服，觉得熔断是熔断、降级是降级，分明是两回事啊！其实不然，因为从实现上来说，熔断和降级必定是一起出现。</p>
<p>因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。</p>
<p>因此，将熔断降级视为降级方式的一种，也是可以说的通的！</p>
</blockquote>
<p><strong>撇开框架，以最简单的代码来说明！上游代码如下:</strong></p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//调用下游的helloWorld服务</span>
    xxRpc<span class="token operator">.</span><span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//因为熔断，所以调不通</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意看，下游的<code>helloWorld</code>服务因为熔断而调不通。<br>此时上游服务就会进入<code>catch</code>里头的代码块，那么<code>catch</code>里头执行的逻辑，你就可以理解为降级逻辑!</p>
</blockquote>
<blockquote>
<p>服务降级大多是属于一种业务级别的处理。<br>做法很简单，做个开关，然后将开关放配置中心！<br>在配置中心更改开关，决定哪些服务进行降级。至于配置变动后，应用怎么监控到配置发生了变动，这就不是本文该讨论的范围。<br>那么，在应用程序中部下开关的这个过程，业内也有一个名词，称为埋点！</p>
</blockquote>
<p><strong>那接下来最关键的一个问题，哪些业务需要埋点？</strong> </p>
<ol>
<li><p>简化执行流程 自己梳理出核心业务流程和非核心业务流程。然后在非核心业务流程上加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程。</p>
</li>
<li><p>关闭次要功能 一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。然后次要功能加上开关，需要降级的时候，把次要功能关了吧！</p>
</li>
<li><p>降低一致性 假设，你在业务上发现执行流程没法简化了，愁啊！也没啥次要功能可以关了，桑心啊！那只能降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性！</p>
</li>
</ol>
<p><strong>这些都是手动降级，一般需要降级的场景，都是可以预见的，例如某某活动</strong></p>
<hr>
]]></content>
      <categories>
        <category>Micro</category>
      </categories>
      <tags>
        <tag>服务雪崩</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务 之 高可用保障 - 链路追踪、熔断、限流、降级</title>
    <url>//post/micro-high-availability.html</url>
    <content><![CDATA[<p><strong>微服务是一种将应用程序作为独立服务的集合结构的架构风格。这些服务通过API互相通信，设计为具有高度的可扩展性、灵活性和弹性。<br>为了保证微服务环境的高可用性，实施几个关键策略是非常重要的，包括链路追踪、熔断、限流和降级。</strong></p>
<span id="more"></span>
<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>链路追踪是追踪请求在应用中穿过不同微服务的路径的能力。这对于故障排除和调试问题以及监测性能非常重要。</p>
<p>通过实施链路追踪，开发人员可以快速识别问题的根源并采取纠正措施。这也可以通过优化单个服务来提高应用的整体性能。</p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>熔断是一种防止微服务因故障导致整个应用瘫痪的技术。当一个服务不可用时，熔断器会自动打开，阻止请求传递到该服务，并返回预定义的响应。</p>
<p>通过实施熔断，开发人员可以保证即使一个服务出现故障，整个应用也不会停止工作。这有助于保证整个应用的可用性和稳定性。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是一种限制单位时间内请求数量的技术。当请求速率超过预定的阈值时，限流器会阻止进一步的请求，以避免服务器过载。</p>
<p>通过实施限流，开发人员可以保证服务器性能不会因请求速率过快而受到影响。这有助于保证应用的稳定性和可用性。</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>降级是一种在服务不可用时降低功能级别的技术。当一个服务不可用时，降级策略会自动启用，以降低应用的功能级别。</p>
<p>通过实施降级，开发人员可以在服务不可用时保证应用仍然可以继续提供部分功能。这有助于保证应用的可用性。</p>
]]></content>
      <categories>
        <category>Micro</category>
      </categories>
      <tags>
        <tag>链路追踪</tag>
        <tag>熔断</tag>
        <tag>限流</tag>
        <tag>降级</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务 之 幂等性机制</title>
    <url>//post/micro-idempotence.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://www.yuque.com/bobby-zpcyu/">bobby语雀</a></li>
</ul>
<h2 id="http请求的类型："><a href="#http请求的类型：" class="headerlink" title="http请求的类型："></a>http请求的类型：</h2><ul>
<li><code>get</code> 获取商品信息， 这个会引起商品的数据的变化吗？</li>
<li><code>post</code> 比较常见，这种接口需要考虑到幂等性</li>
<li><code>put</code><ul>
<li>没有幂等的问题的情况：把1号商品的价格改为200，网络返回的时候抖动了，重试 ,第二次接口还是会把1号商品的价格改为200 </li>
<li>出现幂等性问题的情况：<ul>
<li>购物车中的商品，调用一次 这个商品的数量加一</li>
<li>第一次调用 原本的值 10 之后价格变为11 - 但是返回的时候出现了网络抖动 </li>
<li>第二次发送 原本的值 11 之后价格变为12 - 但是返回的时候出现了网络抖动，</li>
<li>第三次发送 原本的值 12 之后价格变为13 - 但是返回的时候出现了网络抖动</li>
</ul>
</li>
</ul>
</li>
<li><code>delete</code> 一般不具备幂等性的要求，第一次调用 删除数据，第二次调用 还是删除当前的数据</li>
</ul>
<blockquote>
<p>现在假设，你自己开发了一个支付宝，然后别人在二维码支付页面，先支付了,<br>结果由于网络问题，当前页面一直没有刷新，就让人以为我没有支付，然后我就再次扫码支付，这下完蛋了：你扣了两次款。</p>
</blockquote>
<span id="more"></span>
<h2 id="超时-重试-幂等性机制"><a href="#超时-重试-幂等性机制" class="headerlink" title="超时 重试 幂等性机制"></a>超时 重试 幂等性机制</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>  <code>timeout</code>是为了保护服务，避免<code>consumer</code>服务因为<code>provider</code> 响应慢而也变得响应很慢，这样<code>consumer</code>可以尽量保持原有的性能。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>  如果<code>provider</code>只是偶尔抖动，那么超时后直接放弃，不做后续处理，就会导致当前请求错误，也会带来业务方面的损失。</p>
<p>  对于这种偶尔抖动，可以在超时后重试一下，重试如果正常返回了，那么这次请求就被挽救了，能够正常给前端返回数据，只不过比原来响应慢一点。</p>
<p>  重试可以考虑切换一台机器来进行调用，因为原来机器可能由于临时负载高而性能下降，重试会更加剧其性能问题，而换一台机器，得到更快返回的概率也更大一些。</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>  在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>
<p>  幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p>
<p>  这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
<p>  <strong>例如：</strong> <code>getUsername()</code>和<code>setTrue()</code> 函数就是一个幂等函数. </p>
<p>  <strong>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</strong><br>  <strong>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</strong></p>
<h2 id="常见的幂等性解决方案"><a href="#常见的幂等性解决方案" class="headerlink" title="常见的幂等性解决方案"></a>常见的幂等性解决方案</h2><p>  <strong>1. 查询操作：</strong> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。<code>select</code>是天然的幂等操作  </p>
<p>  <strong>2. 删除操作：</strong> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回<code>0</code>，删除的数据多条，返回结果多个)  </p>
<h3 id="数据库唯一索引，防止新增脏数据"><a href="#数据库唯一索引，防止新增脏数据" class="headerlink" title="数据库唯一索引，防止新增脏数据"></a>数据库唯一索引，防止新增脏数据</h3><p>  <strong>比如：</strong> 新建用户的时候将手机号码设置为唯一索引，那么即使你重试，也只会新建一个用户，不会因为重试导致当前用户注册了两个用户</p>
<p>  <strong>要点：</strong> 唯一索引或唯一组合索引来防止新增数据存在脏数据 当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）  </p>
<h3 id="token机制，防止页面重复提交"><a href="#token机制，防止页面重复提交" class="headerlink" title="token机制，防止页面重复提交"></a>token机制，防止页面重复提交</h3><ul>
<li><p>业务要求：页面的数据只能被点击提交一次  </p>
</li>
<li><p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交  </p>
</li>
<li><p>解决办法：集群环境：采用<code>token</code>加<code>redis</code>（<code>redis</code>单线程的，处理需要排队） </p>
</li>
<li><p>处理流程：  </p>
<ul>
<li>数据提交前要向服务的申请<code>token</code>，<code>token</code>放到<code>redis</code>或<code>内存</code>，<code>token</code>有效时间 </li>
<li>提交后后台校验<code>token</code>，同时删除<code>token</code>，生成新的<code>token</code>返回</li>
</ul>
</li>
</ul>
<p>  <strong>token特点：</strong> 要申请，一次有效性，可以限流<br>  <strong>注意：</strong> <code>redis</code>要用删除操作来判断<code>token</code>，删除成功代表<code>token</code>校验通过，如果用<code>select</code> + <code>delete</code>来校验<code>token</code>，存在并发问题，不建议使用</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>  获取数据的时候加锁获取 </p>
  <pre class="line-numbers language-none"><code class="language-none">select * from table_xxx where id&#x3D;&#39;xxx&#39; for update; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  <strong>注意：</strong> <code>id</code>字段一定是主键或者唯一索引，不然是锁表，会死人的 </p>
<p>  悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用  </p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>  乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 </p>
<p>  乐观锁的实现方式多种多样可以通过<code>version</code>或者<code>其他状态</code>条件： </p>
<ol>
<li><p>通过版本号实现 </p>
  <pre class="line-numbers language-none"><code class="language-none">update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where version&#x3D;#version# <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>通过条件限制 </p>
  <pre class="line-numbers language-none"><code class="language-none">update table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where avai_amount-#subAmount# &gt;&#x3D; 0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<p>  <strong>要求：</strong> <code>quality-#subQuality# &gt;=</code> ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高  </p>
<p>  <strong>注意：</strong> 乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好 </p>
  <pre class="line-numbers language-none"><code class="language-none">update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where id&#x3D;#id# and version&#x3D;#version# 
update table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where id&#x3D;#id# and avai_amount-#subAmount# &gt;&#x3D; 0  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>  还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，</p>
<p>  这时候可以引入分布式锁，通过第三方的系统(<code>redis</code>或<code>zookeeper</code>)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，</p>
<p>  这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 </p>
<p>  <strong>要点：</strong>某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(<code>用户ID</code>+<code>后缀</code>等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p>
<h3 id="select-insert"><a href="#select-insert" class="headerlink" title="select + insert"></a>select + insert</h3><p>  并发不高的后台系统，或者一些任务<code>JOB</code>，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了  </p>
<p>  <strong>注意：</strong> 核心高并发流程不要用这种方法  </p>
<h3 id="对外提供接口的api如何保证幂等"><a href="#对外提供接口的api如何保证幂等" class="headerlink" title="对外提供接口的api如何保证幂等"></a>对外提供接口的api如何保证幂等</h3><p>  如银联提供的付款接口：需要接入商户提交付款请求时附带：<code>source</code>来源，<code>seq</code>序列号 </p>
<p>  <code>source</code> + <code>seq</code> 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) </p>
<blockquote>
<p><strong>重点：</strong><br>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，<br>这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；<br>没有处理过，进行相应处理，返回结果。<br>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。  </p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>幂等与你是不是分布式高并发没有关系。关键是你的操作是不是幂等的。</p>
<ul>
<li>一个幂等的操作典型如：把编号为<code>5</code>的记录的<code>A字段</code>设置为<code>0</code>这种操作不管执行多少次都是幂等的。</li>
<li>一个非幂等的操作典型如：把编号为<code>5</code>的记录的<code>A字段</code>增加<code>1</code>这种操作显然就不是幂等的。</li>
</ul>
</li>
<li><p>要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。</p>
</li>
<li><p>譬如说需求是：当用户点击赞同时，将答案的赞同数量<code>+1</code>。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。</p>
</li>
<li><p>总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是<code>钱</code>的系统，</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Micro</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>幂等性机制</tag>
        <tag>幂等性解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 之 使用 Prometheus 和 Grafana 监控 MySQL 性能</title>
    <url>//post/mysql-prometheus-grafana-build.html</url>
    <content><![CDATA[<blockquote>
<p>请注意，这只是一个简单搭建教程，具体应用还需要根据实际情况来调整。</p>
</blockquote>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8</td>
</tr>
<tr>
<td>Prometheus</td>
<td>2.41.0</td>
</tr>
<tr>
<td>Grafana</td>
<td>9.3.2</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="1-Prometheus-安装与配置"><a href="#1-Prometheus-安装与配置" class="headerlink" title="1. Prometheus 安装与配置"></a>1. Prometheus 安装与配置</h2><h3 id="Prometheus-下载"><a href="#Prometheus-下载" class="headerlink" title="Prometheus 下载"></a>Prometheus 下载</h3><h4 id="Prometheus-的官方网站"><a href="#Prometheus-的官方网站" class="headerlink" title="Prometheus 的官方网站"></a>Prometheus 的官方网站</h4><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;prometheus.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Prometheus-安装"><a href="#Prometheus-安装" class="headerlink" title="Prometheus 安装"></a>Prometheus 安装</h3><h4 id="Prometheus-安装的命令行语句"><a href="#Prometheus-安装的命令行语句" class="headerlink" title="Prometheus 安装的命令行语句"></a>Prometheus 安装的命令行语句</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~
<span class="token function">mkdir</span> prometheus <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> prometheus
wegt https://github.com/prometheus/prometheus/releases/download/v2.41.0/prometheus-2.41.0.linux-arm64.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> prometheus-2.41.0.linux-arm64.tar.gz
./prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="2-Grafana-安装与配置"><a href="#2-Grafana-安装与配置" class="headerlink" title="2. Grafana 安装与配置"></a>2. Grafana 安装与配置</h2><h3 id="Grafana-下载"><a href="#Grafana-下载" class="headerlink" title="Grafana 下载"></a>Grafana 下载</h3><h4 id="Grafana-的官方网站"><a href="#Grafana-的官方网站" class="headerlink" title="Grafana 的官方网站"></a>Grafana 的官方网站</h4><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;grafana.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Grafana-安装"><a href="#Grafana-安装" class="headerlink" title="Grafana 安装"></a>Grafana 安装</h3><h4 id="Grafana-安装的命令行语句"><a href="#Grafana-安装的命令行语句" class="headerlink" title="Grafana 安装的命令行语句"></a>Grafana 安装的命令行语句</h4><pre class="line-numbers language-none"><code class="language-none">docker pull grafana&#x2F;grafana-oss:9.3.2-ubuntu@sha256:e76c86b351aadc13a748ac05937110a69d659b426ca59e0d824a325170ca75fd
docker run -d --net host --name&#x3D;grafana -e &quot;GF_INSTALL_PLUGINS&#x3D;grafana-clock-panel,grafana-simple-json-datasource&quot; -p 3000:3000 77a68ddee903<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="3-mysql-exporter-安装与配置"><a href="#3-mysql-exporter-安装与配置" class="headerlink" title="3. mysql_exporter 安装与配置"></a>3. mysql_exporter 安装与配置</h2><h3 id="mysql-exporter-下载"><a href="#mysql-exporter-下载" class="headerlink" title="mysql_exporter 下载"></a>mysql_exporter 下载</h3><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;mysqld_exporter&#x2F;releases&#x2F;download&#x2F;v0.14.0&#x2F;mysqld_exporter-0.14.0.linux-arm64.tar.gz
tar -zxvf mysqld_exporter-0.14.0.linux-arm64.tar.gz
cd mysqld_exporter-0.14.0.linux-arm64
vim .my.cnf

[client]
host&#x3D;127.0.0.1
port&#x3D;3306
user&#x3D;mysqld_exporter
password&#x3D;mysqld_exporter

.&#x2F;mysqld_exporter --config.my-cnf&#x3D;&#x2F;root&#x2F;prometheus&#x2F;mysql_exporter&#x2F;mysqld_exporter-0.14.0.linux-arm64&#x2F;.my.cnf

vi &#x2F;root&#x2F;prometheus&#x2F;prometheus-2.41.0.linux-arm64&#x2F;prometheus.yml

- job_name: &#39;mysqld-node&#39;
    static_configs:
    - targets: [&#39;192.168.1.235:9104&#39;]
      labels:
        instance: mysqld-node1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Grafana-配置监控面板"><a href="#Grafana-配置监控面板" class="headerlink" title="Grafana 配置监控面板"></a>Grafana 配置监控面板</h3><h4 id="Grafana-中创建-mysql-exporter-监控面板"><a href="#Grafana-中创建-mysql-exporter-监控面板" class="headerlink" title="Grafana 中创建 mysql_exporter 监控面板"></a>Grafana 中创建 mysql_exporter 监控面板</h4><p><strong>导入mysqld_exporter仪表板 ID 7362 ,修改名称 加载</strong></p>
<hr>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>排名前 8 位的容器仓库</title>
    <url>//post/container-rank.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>排名</th>
<th>仓库</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Docker Hub</td>
</tr>
<tr>
<td>2</td>
<td>Amazon ECR</td>
</tr>
<tr>
<td>3</td>
<td>Harbor</td>
</tr>
<tr>
<td>4</td>
<td>Azure Container Registry</td>
</tr>
<tr>
<td>5</td>
<td>GitHub Container Registry</td>
</tr>
<tr>
<td>6</td>
<td>Google Container Registry</td>
</tr>
<tr>
<td>7</td>
<td>JFrog Container Registry</td>
</tr>
<tr>
<td>8</td>
<td>Red Hat Quay</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>容器registry 经常对它们的存储库对应物感到困惑，即使它们服务于不同的目的。</p>
<p>容器存储库是容器化应用程序映像的存储。如今，大多数镜像存储库都专注于“OCI”格式，基于 Docker 普及并向所有人开放的容器格式。</p>
<p>事实上，“OCI 映像”和“Docker 映像”在registry 提供者的营销中经常可以互换使用。</p>
<blockquote>
<p>OCI 代表开放容器倡议。该倡议是一种容器结构，旨在充当行业标准格式。技术、开发和云服务领域的大多数主要参与者都支持该计划并支持 OCI格式。在 <a href="https://opencontainers.org/">Open Container Initiative</a> 网站上阅读有关它的更多信息。</p>
</blockquote>
<p>因此，容器registry 既充当容器存储库的集合，又充当您管理和部署映像的可搜索目录。</p>
<p>市场上有许多容器注册选项，为不同类型、规模和需求的客户提供服务。让我们看看我们的前 8 名以及他们为什么会吸引人。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>鉴于 Docker 发明了用于容器交付的标准 OCI 格式，以及所有主要操作系统的采用， <a href="https://hub.docker.com/">Docker Hub</a>也是镜像管理的标准registry 是有道理的。如果您正在开发中，那么您很可能已经使用过 Docker Hub，尤其是如果您曾经遵循我们的技术指南或博客之一。</p>
<p>尽管此列表中的所有registry 服务都可以帮助您管理 Docker 的格式，但 Docker Hub 作为registry 仍然值得在这里占有一席之地。尤其是因为它提供了一个巨大的公共registry ，您可以使用它来部署来自大小供应商的应用程序，还可以交付您自己的应用程序。</p>
<h2 id="Amazon-ECR"><a href="#Amazon-ECR" class="headerlink" title="Amazon ECR"></a>Amazon ECR</h2><p>如果您已经在使用 Amazon Web Services (AWS) 来托管应用程序， <a href="https://aws.amazon.com/ecr/">Amazon 的 Elastic Container Registry (ECR)将非常有用</a>，因为它具有集成和团队管理选项。</p>
<p>Amazon 的 ECR 已融入其所有容器托管服务，因此您可以轻松管理镜像并将其推送到：</p>
<ul>
<li>弹性容器服务 (ECS)</li>
<li>弹性 Kubernetes 服务 (EKS)</li>
<li>AWS Lambda</li>
</ul>
<p>（当然，前提是你能理解所有这些相似的首字母缩略词。）</p>
<p>与 Docker Hub 一样，他们的公共注册中心和市场也物有所值，允许部署许多产品、免费软件和开源项目。您永远不会缺少可以构建的现有环境</p>
<h2 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h2><p> <a href="https://goharbor.io/">Harbor</a>是一个开源registry ，您几乎可以在任何地方安装，但特别适合 Kubernetes。</p>
<p>在某些服务将其注册中心与自己的服务紧密联系在一起的情况下，Harbor 的自由度使其成为一种多功能选择。它与大多数云服务和持续集成和持续交付 (CI&#x2F;CD) 平台兼容，也是一个很好的本地解决方案。</p>
<h2 id="Azure-Container-Registry"><a href="#Azure-Container-Registry" class="headerlink" title="Azure Container Registry"></a>Azure Container Registry</h2><p>在提供与 AWS 类似的服务的同时，微软的 <a href="https://azure.microsoft.com/en-au/products/container-registry/">Azure 容器registry (ACR)</a>还拥有对 Docker 和 OCI 映像以及 Helm 图表的支持。</p>
<p>然而，Azure 最大的卖点是它的registry 异地复制。这确保每个人都可以以他们习惯的速度，无论他们身在何处，都能以相同的速度访问镜像。</p>
<h2 id="GitHub-Container-Registry"><a href="#GitHub-Container-Registry" class="headerlink" title="GitHub Container Registry"></a>GitHub Container Registry</h2><p>鉴于 GitHub 的影响力，并且它已经可供所有用户使用， <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry">GitHub 的 Container Registry</a> （称为GitHub Packages的更大功能的一部分）是最平易近人的选择之一。</p>
<p>考虑使用 GitHub Packages 进行容器管理的好处包括：</p>
<ul>
<li>简化的用户管理 - 您的大多数用户已经拥有帐户</li>
<li>用于推送、发布和部署镜像的 GitHub Actions 集成</li>
<li>相对于其他服务的成本</li>
</ul>
<h2 id="Google-Container-Registry"><a href="#Google-Container-Registry" class="headerlink" title="Google Container Registry"></a>Google Container Registry</h2><p>由于其他服务将承诺重点放在对部分潜在客户很重要的某些功能上， <a href="https://cloud.google.com/container-registry/">谷歌云的容器registry (GCR)</a>是一个可靠的多面手。它可以从容器registry 中完成您想要的一切，并且做得非常好。</p>
<p>与云服务中的其他大牌一样，您可能会被锁定在 GCR 中，具体取决于您使用的 Google Cloud 产品。例如，Google Cloud Run 将仅使用存储在 GCR 中的镜像，因此在选择registry 服务时请记住这一点。</p>
<p>它不像 AWS 或 Azure 那样拥有丰富的功能，但 Google Cloud 的 GCR 是云提供商“三大巨头”之一提供的物有所值的产品。</p>
<h2 id="JFrog-Container-Registry"><a href="#JFrog-Container-Registry" class="headerlink" title="JFrog Container Registry"></a>JFrog Container Registry</h2><p>基于另一个 JFrog 产品 <code>Artifactory</code>， <a href="https://jfrog.com/container-registry/">JFrog Container Registry</a>支持 Docker 镜像和<code>Helm Charts</code>。JFrog Container Registry 还提供了存储任何包类型的选项，这要归功于其通用存储库。</p>
<p>JFrog 具有云和自托管选项（如果您愿意，也可以混合），并承诺具有出色的可扩展性。</p>
<h2 id="Red-Hat-Quay"><a href="#Red-Hat-Quay" class="headerlink" title="Red Hat Quay"></a>Red Hat Quay</h2><p>与其他选项不同， <a href="https://www.redhat.com/en/technologies/cloud-computing/quay">Red Hat Quay</a>仅提供私有容器registry 。这使其成为特别适合企业级客户的选择。</p>
<p>与云提供商无关，Quay 可以轻松连接到 DevOps 管道两端的系统。与 Azure 一样，Quay 也包括地理位置选项，有趣的是，它支持 BitTorrent 进行容器分发。</p>
<p>红帽还在其 Kubernetes 平台 OpenShift 中包含一个精简的registry 解决方案。然而，他们确实向较大的团队和组织推荐 Quay。</p>
<p>翻译来源：<br> <a href="https://octopus.com/blog/top-8-container-registries">https://octopus.com/blog/top-8-container-registries</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes容器</tag>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title>github action 之 Go开源项目配置(lint test build)</title>
    <url>//post/github-actions-go.html</url>
    <content><![CDATA[<p><strong>参考自<a href="https://github.com/gin-gonic/gin">gin</a>的github开源项目工作流</strong></p>
<h3 id="golangci-lint静态代码检查"><a href="#golangci-lint静态代码检查" class="headerlink" title="golangci-lint静态代码检查"></a>golangci-lint静态代码检查</h3><span id="more"></span>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 工作流的名称</span>
<span class="token key atrule">name</span><span class="token punctuation">:</span> Go workflow
<span class="token comment"># 工作流运行条件</span>
<span class="token key atrule">on</span><span class="token punctuation">:</span>
  <span class="token comment"># push时触发</span>
  <span class="token key atrule">push</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token comment"># pr时触发</span>
  <span class="token key atrule">pull_request</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token comment"># 定时触发 分 时 天 月 周几</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">cron</span><span class="token punctuation">:</span> <span class="token string">'25 7 * * 1'</span> 
<span class="token comment"># 权限</span>
<span class="token key atrule">permissions</span><span class="token punctuation">:</span>
  <span class="token key atrule">contents</span><span class="token punctuation">:</span> read
<span class="token comment"># 任务列表</span>
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>  
  <span class="token comment"># 任务名称 lint</span>
  <span class="token key atrule">lint</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> Lint
      <span class="token comment"># 运行环境</span>
      <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
      <span class="token comment"># 运行操作</span>
      <span class="token key atrule">steps</span><span class="token punctuation">:</span>
        <span class="token comment"># 单独操作名称</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go
          <span class="token comment"># 使用现成action设置go语言</span>
          <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3
          <span class="token comment"># action 的参数 </span>
          <span class="token key atrule">with</span><span class="token punctuation">:</span>
            <span class="token comment"># 矩阵语法 可根据不同版本去创建</span>
            <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token comment"># 检出代码</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout repository
          <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3

        <span class="token comment"># golangci-lint action </span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> golangci<span class="token punctuation">-</span>lint
          <span class="token key atrule">uses</span><span class="token punctuation">:</span> golangci/golangci<span class="token punctuation">-</span>lint<span class="token punctuation">-</span>action@v3
          <span class="token key atrule">with</span><span class="token punctuation">:</span>
            <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token string">'--verbose'</span>
            <span class="token key atrule">version</span><span class="token punctuation">:</span> v1.51.2
      <span class="token comment"># 矩阵配置 例如 不同的os go</span>
      <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
        <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
          <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.17'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置单元测试并上传结果到codecov"><a href="#配置单元测试并上传结果到codecov" class="headerlink" title="配置单元测试并上传结果到codecov"></a>配置单元测试并上传结果到codecov</h3><p><strong><a href="codecov.io">codecov</a></strong></p>
<p><strong>利用makefile管理项目 其中直接使用make test进行项目的单元测试</strong></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Go workflow
<span class="token key atrule">on</span><span class="token punctuation">:</span>
  <span class="token key atrule">push</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token key atrule">pull_request</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">cron</span><span class="token punctuation">:</span> <span class="token string">'25 7 * * 1'</span> 
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>  
  <span class="token key atrule">lint</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> Lint
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout repository
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> golangci<span class="token punctuation">-</span>lint
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> golangci/golangci<span class="token punctuation">-</span>lint<span class="token punctuation">-</span>action@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token string">'--verbose'</span>
          <span class="token key atrule">version</span><span class="token punctuation">:</span> v1.51.2
    <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
      <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
        <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.17'</span><span class="token punctuation">]</span>
  <span class="token key atrule">test</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> Test $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> @ Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment"># 执行顺序 需要在lint之后</span>
    <span class="token key atrule">needs</span><span class="token punctuation">:</span> lint
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github.ref <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">ref</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github.ref <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Cache
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/cache@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">key</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> runner.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">-</span>go<span class="token punctuation">-</span>$<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> hashFiles('<span class="token important">**/go.sum')</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
            $&#123;&#123; matrix.go-build &#125;&#125;
            ~/go/pkg/mod</span>
          <span class="token key atrule">restore-keys</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
            $&#123;&#123; runner.os &#125;&#125;-go-</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Run Tests
        <span class="token key atrule">run</span><span class="token punctuation">:</span> make test
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Upload coverage to Codecov
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> codecov/codecov<span class="token punctuation">-</span>action@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">files</span><span class="token punctuation">:</span> _output/coverage.out
          <span class="token key atrule">flags</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>go<span class="token punctuation">-</span>$<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
      <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
        <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.18'</span> <span class="token punctuation">,</span> <span class="token string">'1.19'</span> <span class="token punctuation">,</span> <span class="token string">'1.20'</span><span class="token punctuation">]</span>
        <span class="token key atrule">os</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>ubuntu<span class="token punctuation">-</span>latest <span class="token punctuation">,</span> macos<span class="token punctuation">-</span>latest<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="在工作流中进行-make-build-构建"><a href="#在工作流中进行-make-build-构建" class="headerlink" title="在工作流中进行 make build 构建"></a>在工作流中进行 make build 构建</h3><p><strong>利用upload-artifact action将make build产生的二进制文件做成 <code>工作件</code>(可以在外部action详情中下载build的文件)</strong></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Go workflow
<span class="token key atrule">on</span><span class="token punctuation">:</span>
  <span class="token key atrule">push</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token key atrule">pull_request</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"main"</span> <span class="token punctuation">]</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">cron</span><span class="token punctuation">:</span> <span class="token string">'25 7 * * 1'</span> 
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>  
  <span class="token key atrule">lint</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> Lint
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout repository
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> golangci<span class="token punctuation">-</span>lint
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> golangci/golangci<span class="token punctuation">-</span>lint<span class="token punctuation">-</span>action@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token string">'--verbose'</span>
          <span class="token key atrule">version</span><span class="token punctuation">:</span> v1.51.2
    <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
      <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
        <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.17'</span><span class="token punctuation">]</span>
  <span class="token key atrule">test</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> Test $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> @ Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment"># 执行顺序 需要在lint之后</span>
    <span class="token key atrule">needs</span><span class="token punctuation">:</span> lint
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github.ref <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">ref</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github.ref <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Cache
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/cache@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">key</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> runner.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">-</span>go<span class="token punctuation">-</span>$<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> hashFiles('<span class="token important">**/go.sum')</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
            $&#123;&#123; matrix.go-build &#125;&#125;
            ~/go/pkg/mod</span>
          <span class="token key atrule">restore-keys</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
            $&#123;&#123; runner.os &#125;&#125;-go-</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Run Tests
        <span class="token key atrule">run</span><span class="token punctuation">:</span> make test
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Upload coverage to Codecov
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> codecov/codecov<span class="token punctuation">-</span>action@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">files</span><span class="token punctuation">:</span> _output/coverage.out
          <span class="token key atrule">flags</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>go<span class="token punctuation">-</span>$<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
      <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
        <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.18'</span> <span class="token punctuation">,</span> <span class="token string">'1.19'</span> <span class="token punctuation">,</span> <span class="token string">'1.20'</span><span class="token punctuation">]</span>
        <span class="token key atrule">os</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>ubuntu<span class="token punctuation">-</span>latest <span class="token punctuation">,</span> macos<span class="token punctuation">-</span>latest<span class="token punctuation">]</span>
  <span class="token key atrule">build</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> Build
    <span class="token key atrule">needs</span><span class="token punctuation">:</span> test
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout code
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Go $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3.5.0
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.go <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Build
        <span class="token key atrule">run</span><span class="token punctuation">:</span> make build
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Rename
        <span class="token key atrule">run</span><span class="token punctuation">:</span> mv _output/mini  _output/mini<span class="token punctuation">-</span>$<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> matrix.os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Archive production artifacts
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/upload<span class="token punctuation">-</span>artifact@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">name</span><span class="token punctuation">:</span> build<span class="token punctuation">-</span>file
          <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
            _output/mini-$&#123;&#123; matrix.os &#125;&#125;</span>
    <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
      <span class="token key atrule">matrix</span><span class="token punctuation">:</span>
        <span class="token key atrule">go</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'1.20'</span><span class="token punctuation">]</span>
        <span class="token key atrule">include</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">go-build</span><span class="token punctuation">:</span> ~/.cache/go<span class="token punctuation">-</span>build
            <span class="token key atrule">os</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
          <span class="token punctuation">-</span> <span class="token key atrule">go-build</span><span class="token punctuation">:</span> ~/Library/Caches/go<span class="token punctuation">-</span>build
            <span class="token key atrule">os</span><span class="token punctuation">:</span> macos<span class="token punctuation">-</span>latest
        <span class="token key atrule">os</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>ubuntu<span class="token punctuation">-</span>latest <span class="token punctuation">,</span> macos<span class="token punctuation">-</span>latest<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<hr>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>actions</tag>
        <tag>workflows</tag>
      </tags>
  </entry>
  <entry>
    <title>git 命令行操作</title>
    <url>//post/git-on-bash.html</url>
    <content><![CDATA[<p>Git 的命令行操作</p>
<span id="more"></span>

<p>Git命令索引：<a href="https://www.worldhello.net/gotgit/90-app/010-git-commands-index.html#a-1-git">https://www.worldhello.net/gotgit/90-app/010-git-commands-index.html#a-1-git</a></p>
<h2 id="git-reflog-显示当前分支的最近几次提交"><a href="#git-reflog-显示当前分支的最近几次提交" class="headerlink" title="git reflog 显示当前分支的最近几次提交"></a>git reflog 显示当前分支的最近几次提交</h2><p>包括已经被删除的 <code>commit</code> 记录和 <code>reset</code> 的操作<br>例如执行 <code>git reset --hard HEAD~1</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的<code>commitid</code>，用<code>git reflog</code>则可以看到被删除的<code>commitid</code>，我们就可以恢复到被删除的那个版本</p>
<h2 id="git-log-查询版本的历史"><a href="#git-log-查询版本的历史" class="headerlink" title="git log 查询版本的历史"></a>git log 查询版本的历史</h2><ol>
<li><p>查看提交记录</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示commit历史，以及每次commit发生变更的文件</span>
<span class="token function">git</span> log <span class="token parameter variable">--stat</span>

<span class="token comment"># 最近5次提交</span>
<span class="token function">git</span> log <span class="token parameter variable">-5</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit

<span class="token comment"># 搜索提交历史，根据关键词</span>
<span class="token function">git</span> log <span class="token parameter variable">-S</span> <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span>

<span class="token comment"># 显示某个文件的版本历史，包括文件改名</span>
<span class="token function">git</span> log <span class="token parameter variable">--follow</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span>
<span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span>

<span class="token comment"># 显示指定文件相关的每一次diff</span>
<span class="token function">git</span> log <span class="token parameter variable">-p</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span>

<span class="token comment"># 显示所有提交过的用户，按提交次数排序</span>
<span class="token function">git</span> shortlog <span class="token parameter variable">-sn</span>

<span class="token comment"># 显示指定文件是什么人在什么时间修改过</span>
<span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span>

<span class="token comment"># 显示今天你写了多少行代码</span>
$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--shortstat</span> <span class="token string">"@&#123;0 day ago&#125;"</span>

<span class="token comment"># 查看log点线图</span>
<span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--oneline</span>

<span class="token comment">#  // 符号解释:</span>
<span class="token comment">#   * 表示一个commit， 注意不要管*在哪一条主线上</span>
<span class="token comment">#   | 表示分支前进</span>
<span class="token comment">#   / 表示分叉</span>
<span class="token comment">#   \ 表示合入</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>设置别名查看某个人的提交<code>log</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.lm  <span class="token string">"log --no-merges --color --date=format:'%Y-%m-%d %H:%M:%S' --author='提交者的名字！' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> lm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>设置别名查看某个人的提交的<code>详细log</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.lms  <span class="token string">"log --no-merges --color --stat --date=format:'%Y-%m-%d %H:%M:%S' --author='提交者的名字！' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> lms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>设置别名查看所有的提交<code>log</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.ls <span class="token string">"log --no-merges --color --graph --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>设置别名查看所有的提交<code>详细log</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.lss <span class="token string">"log --no-merges --color --stat --graph --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>查看最新一条提交</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span>  alias.last  <span class="token string">"log -1 HEAD"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="git-stash-存储更改"><a href="#git-stash-存储更改" class="headerlink" title="git stash 存储更改"></a>git stash 存储更改</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 保存</span>
<span class="token function">git</span> stash
<span class="token comment"># 获取所有</span>
<span class="token function">git</span> stash list
<span class="token comment"># 如果您想查看最近存储的内容</span>
<span class="token function">git</span> stash show
<span class="token comment"># 如果您想查看指定存储的内容</span>
<span class="token function">git</span> stash show stash@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span>
<span class="token comment"># 取出更改但希望保留您的存储更改 (git stash list 列表中还存在)</span>
<span class="token function">git</span> stash apply
<span class="token comment"># 取出更改但希望不希望保留</span>
<span class="token function">git</span> stash pop
<span class="token comment"># 删除</span>
<span class="token function">git</span> stash drop stash@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p><code>rebase</code>与<code>merge</code>的差异：</p>
<p><code>rebase</code> 会把你当前分支的 <code>commit</code> 放到公共分支的最后面,所以叫<code>变基</code>。就好像你从公共分支又重新拉出来这个分支一样。<br><code>merge</code> 会把公共分支和你当前的 <code>commit</code> 合并在一起，形成一个新的 <code>commit</code> 提交。并且 <code>coomit</code> 提交记录会产生分叉.</p>
<p>以 <code>master</code> 分支为基础,拉出一个分支进行开发需求 <code>dev</code> 。<br>此时 <code>master</code> 分支提交记录为 <code>a</code>、<code>b</code>。<br>你在 <code>dev</code> 分支分别 <code>commit</code> 了2次记录为 <code>e</code>、<code>f</code> ,有其他同事在 <code>master</code> 分支提交了两次记录为 <code>c</code>、<code>d</code> 这个时候你要合并 <code>master</code> 分支代码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 合并master分支代码</span>
<span class="token function">git</span> rebase master
<span class="token comment"># 查看log点线图</span>
<span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--oneline</span>
<span class="token comment">#  // 符号解释:</span>
<span class="token comment">#   * 表示一个commit， 注意不要管*在哪一条主线上</span>
<span class="token comment">#   | 表示分支前进</span>
<span class="token comment">#   / 表示分叉</span>
<span class="token comment">#   \ 表示合入</span>
<span class="token comment"># 首先，我们发现目前 dev 分支上面的提交记录为 abcdef 并没有像 merge 一样产生新的提交记录</span>
<span class="token comment"># 其次 rebase master 分支到 dev 分支, dev 分支的历史记录会添加在 master 分支的后面。</span>
<span class="token comment"># 历史记录成一条线,非常整洁,最后并没有像使 merge 一样提交记录产生分叉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>场景一：</strong>  经典场景,优化本地提交记录,使其减少分叉。</p>
</blockquote>
<blockquote>
<p><strong>场景二：</strong>  连续性冲突 （简单来讲就是。远程分支 master 对文件a进行了1次 commit ，而别的分支dev对文件A进行了3次commit，但是本地分支dev提交的n次 commit都与master分支的1次commit有冲突）</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 git rebase 解决冲突</span>

<span class="token comment"># 更新本地存储的远程仓库的分支引用</span>
<span class="token function">git</span> fetch
<span class="token comment"># 拉去远程分支master中的代码与当前分支合并且变基</span>
<span class="token function">git</span> rebase origin/master
<span class="token comment"># 此时我们会产生第一次冲突,为当前dev分支版本v2中的a页面与远程分支master中的a页面冲突。解决后,根据提示进行</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token comment"># 继续进行合并</span>
<span class="token function">git</span> rebase <span class="token builtin class-name">continue</span>
<span class="token comment"># 此时我们会产生第二次冲突,为当前dev分支版本v3中的a页面与远程分支master中的a页面冲突。解决后,根据提示进行</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token comment"># 继续进行合并</span>
<span class="token function">git</span> rebase <span class="token builtin class-name">continue</span>
<span class="token comment"># 此时我们会产生第三次冲突,为当前dev分支版本v4中的a页面与远程分支master中的a页面冲突。解决后,根据提示进行</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token comment"># 继续进行合并</span>
<span class="token function">git</span> rebase <span class="token builtin class-name">continue</span>
<span class="token comment"># 至此我们使用 rebase 变基完成 可以根据产品需求push到远程dev分支</span>
<span class="token comment"># 查看log点线图</span>
<span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--oneline</span>


<span class="token comment"># 结论</span>
<span class="token comment"># 不会因为像使用 merge 时合代码时遇到冲突产生新的提交记录</span>
<span class="token comment"># 用 merge 只需要解决一次冲突即,简单粗暴,而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。</span>
<span class="token comment"># 使用 rebase 提交记录不会分叉,一条线干净整洁</span>
<span class="token comment"># 冲突解决完之后，使用 git add 来标记冲突已解决，最后执行 git rebase --continue 继续。</span>
<span class="token comment"># 如果中间遇到某个补丁不需要应用，可以用下面命令忽略：git rebase --skip</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>场景三：</strong>  你开发的一个需求产品反复更改,导致你的<code>commit</code>记录多次重复功能点；在日常开发中,难免有重复的<code>commit</code>提交记录.这时候我们想优化一下提交记录该如何做呢</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># i(interactive)交互，HEAD~x 代表要合并到距离HEAD最近的几个历史提交,如 HEAD～3就是历史的前3个提交.</span>
<span class="token function">git</span> rebase <span class="token parameter variable">-i</span> HEAD~x
<span class="token comment"># p 使用提交</span>
<span class="token comment"># s 使用提交，但挤压进上一个提交</span>
<span class="token comment"># 使用 p s即可 合并了冗余的提交,并产生了一条新的提交记录</span>

<span class="token comment"># 查看log点线图</span>
<span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--oneline</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="git-revert-撤销提交的内容"><a href="#git-revert-撤销提交的内容" class="headerlink" title="git revert 撤销提交的内容"></a>git revert 撤销提交的内容</h2><ol>
<li><p>直接撤销,并进入编辑器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert 3c0fd77<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">:qa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>退回到上一个版本，将 1 操作的撤销还原</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset <span class="token parameter variable">--hard</span>  HEAD~1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>直接撤销,不进入编辑器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert 3c0fd77 --no-edit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>直接撤销,不进入编辑器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert 3c0fd77 --no-edit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>直接撤销,不添加<code>commit</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert 3c0fd77 --no-commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>直接撤销多次提交,不进入编辑器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert 3c0fd77 9dbb942 --no-edit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="git-tag-打标签"><a href="#git-tag-打标签" class="headerlink" title="git tag 打标签"></a>git tag 打标签</h2><ol>
<li><p>创建轻量的标签tag(快速创建tag)</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>创建标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>对某个<code>commit</code>创建标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.0.1 cc16905 <span class="token parameter variable">-m</span> <span class="token string">"version 0.0.1, tag info"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>对某个<code>commit</code>创建标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.0.1 cc16905 <span class="token parameter variable">-m</span> <span class="token string">"version 0.0.1, tag info"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>查看某个tag信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> show v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>查看所有tag信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag
<span class="token function">git</span> tag <span class="token parameter variable">--column</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>查看所有tag信息 带有注释的</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">-n</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>推送某一tag到远程仓库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>一次推送多个标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin <span class="token parameter variable">--tags</span>

<span class="token function">git</span> push <span class="token parameter variable">--tags</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>删除本地标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">-d</span> v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>删除远程标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin :refs/tags/v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>检出标签</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout v0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>根据标签回退<br><strong>查看要回退的标签信息，取 <code>commit hash</code>，版本回退将主干分支回退到某个版本</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> show v0.0.1
<span class="token function">git</span> reset <span class="token parameter variable">--hard</span> cc16905<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>比较两个标签的差异</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">diff</span> v0.0.1<span class="token punctuation">..</span>v0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="git-add-提交"><a href="#git-add-提交" class="headerlink" title="git add 提交"></a>git add 提交</h2><ol>
<li><p>提交所有文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-A</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>提交当前目录，以及所有子目录文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>提交的交互模式</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-i</span>
<span class="token comment"># 1. status – 显示有变化的路径</span>
<span class="token comment"># 2. update - 将工作树状态添加到暂存的更改集中</span>
<span class="token comment"># 3. revert – 将分阶段的更改集恢复到 HEAD 版本</span>
<span class="token comment"># 4. add untracked - 将未跟踪文件的内容添加到暂存的更改集中</span>
<span class="token comment"># 5. patch – 选择帅哥并有选择地更新</span>
<span class="token comment"># 6. diff – 查看 HEAD 和索引之间的差异</span>
<span class="token comment"># 7. quit – 退出 Git add 交互模式</span>
<span class="token comment"># 8. help – 将帮助菜单打印到屏幕上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>撤消 git add</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 索引中删除单个暂存文件</span>
<span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> <span class="token operator">&lt;</span>filename<span class="token operator">></span>

<span class="token comment"># 同时删除索引中暂存的所有文件，将 &lt;directory-name> 替换为存储库的目录名称</span>
<span class="token function">git</span> reset HEAD -- <span class="token operator">&lt;</span>directory-name<span class="token operator">></span>

<span class="token comment"># 从正在工作的目录中的暂存中删除所有文件</span>
<span class="token function">git</span> reset HEAD – <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>更多操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加指定文件到暂存区</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.

<span class="token comment"># 添加指定目录到暂存区，包括子目录</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token punctuation">[</span>dir<span class="token punctuation">]</span>

<span class="token comment"># 添加每个变化前，都会要求确认</span>
<span class="token comment"># 对于同一个文件的多处变化，可以实现分次提交</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-p</span>

<span class="token comment"># 删除工作区文件，并且将这次删除放入暂存区</span>
<span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.

<span class="token comment"># 停止追踪指定文件，但该文件会保留在工作区</span>
<span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span>

<span class="token comment"># 改名文件，并且将这个改名放入暂存区</span>
<span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="git-fetch-获取"><a href="#git-fetch-获取" class="headerlink" title="git fetch 获取"></a>git fetch 获取</h2><p>它执行两个不同的任务。首先，<code>git fetch</code> 从特定远程分支下载<code>所有提交</code>，在本地更新远程跟踪分支。同时，<code>Git</code> 更新一个名为 <code>FETCH_HEAD</code> 的特殊文件，该文件跟踪下载的更新来自何处以及涉及哪些提交 <code>SHA</code></p>
<ol>
<li><p>从所有可能的远程获取本地未存在更改的任何分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看哪些 Git 远程可用于存储库</span>
<span class="token function">git</span> remote <span class="token parameter variable">-v</span>

<span class="token function">git</span> fetch –all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>要定位特定远程上的特定分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span>
<span class="token function">git</span> fetch origin <span class="token operator">&lt;</span>branch<span class="token operator">></span>
<span class="token comment"># 在本地合并所有更改</span>
<span class="token function">git</span> merge FETCH_HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>远程同步的更多操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载远程仓库的所有变动</span>
<span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span>

<span class="token comment"># 显示所有远程仓库</span>
<span class="token function">git</span> remote <span class="token parameter variable">-v</span>

<span class="token comment"># 显示某个远程仓库的信息</span>
<span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span>

<span class="token comment"># 增加一个新的远程仓库，并命名</span>
<span class="token function">git</span> remote <span class="token function">add</span> <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span>

<span class="token comment"># 取回远程仓库的变化，并与本地分支合并</span>
<span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>

<span class="token comment"># 上传本地指定分支到远程仓库</span>
<span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>

<span class="token comment"># 强行推送当前分支到远程仓库，即使有冲突</span>
<span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token parameter variable">--force</span>

<span class="token comment"># 推送所有分支到远程仓库</span>
<span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="git-diff-获取提交之间的差异"><a href="#git-diff-获取提交之间的差异" class="headerlink" title="git diff 获取提交之间的差异"></a>git diff 获取提交之间的差异</h2><p>检查每个文件的差异时，<code>添加</code>的文本行通常以<code>绿色</code>突出显示或用<code>+</code>号表示。同样，<code>删除</code>的文本行通常以<code>红色</code>突出显示或带有<code>–</code>符号</p>
<ol>
<li><p>未暂存时查看更改差异</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">diff</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>暂存后查看更改差异</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--staged</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

</li>
<li><p>两个不同版本查看差异</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag <span class="token parameter variable">--column</span>
<span class="token function">git</span> <span class="token function">diff</span> v1.0.1<span class="token punctuation">..</span>v1.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>两个不同指针建间查看差异</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log <span class="token parameter variable">--oneline</span>
<span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token punctuation">..</span>9557d80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="git-reset-回退"><a href="#git-reset-回退" class="headerlink" title="git reset 回退"></a>git reset 回退</h2><ol>
<li><p>–soft</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 用于版本的回退，只进行对commit操作的回退，不影响工作区的文件,撤回之后所有内容全部放进暂存区</span>
<span class="token comment"># 当发现之前的提交有错误的代码，推荐使用soft进行处理，这样会把错误的提交日志进行废弃，意思就是通过git log就查看不到那一次错误的提交日志。</span>
<span class="token function">git</span> reset  <span class="token parameter variable">--soft</span> eaa7b017f106cbdf426d2e46dbc1a8b186a95303<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>–mixed 默认模式</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将指定 commit id 撤回之后所有内容全部放进工作区中</span>
<span class="token function">git</span> reset  <span class="token parameter variable">--mixed</span> eaa7b017f106cbdf426d2e46dbc1a8b186a95303
<span class="token function">git</span> reset  eaa7b017f106cbdf426d2e46dbc1a8b186a95303
<span class="token comment"># 可查看回撤到工作区的代码</span>
<span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>–hard</p>
</li>
</ol>
<p><code>git checkout .</code>： 用于撤销当前目录下所有文件的修改，将工作区恢复到最近一次提交时的状态。<br>它只影响当前目录及其子目录下的文件，不会影响暂存区和提交历史。暂存区中的更改仍然保留，需要使用其他命令来撤销暂存区的更改。</p>
<p><code>git reset --hard</code>： 用于将工作区和暂存区同时重置到指定的提交。<br>它可以丢弃所有未提交的更改，包括已添加到暂存区但未提交的更改。这个命令会清除暂存区中的所有更改，并将HEAD指针移动到指定的提交，同时更新工作区。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将指定 commit id 撤回并清空工作目录及暂存区所有修改。</span>
<span class="token comment"># 撤回代码</span>
<span class="token function">git</span> reset <span class="token parameter variable">--hard</span> eaa7b017f106cbdf426d2e46dbc1a8b186a95303
<span class="token comment"># 可查看是否回退到了指定的 commit id</span>
<span class="token function">git</span> log
<span class="token comment"># 可查本地修改代码都清空了</span>
<span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="git-config-配置"><a href="#git-config-配置" class="headerlink" title="git config 配置"></a>git config 配置</h2><p>配置官方文档：<a href="https://git-scm.com/docs/git-config">https://git-scm.com/docs/git-config</a></p>
<ol>
<li><p>配置系统</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 要在终端中查看 Git 配置系统设置的完整列表</span>
<span class="token function">git</span> config <span class="token parameter variable">--system</span> <span class="token parameter variable">--list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>配置全局</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 要在终端中查看 Git 配置全局设置的完整列表</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>配置本地</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 要在终端中查看 Git 配置本地设置的完整列表</span>
<span class="token function">git</span> config <span class="token parameter variable">--local</span> <span class="token parameter variable">--list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>配置用户名</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 全局</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name"</span>
<span class="token comment"># 本地</span>
<span class="token function">git</span> config <span class="token parameter variable">--local</span> user.name <span class="token string">"Your Name"</span>
<span class="token comment"># 系统</span>
<span class="token function">git</span> config <span class="token parameter variable">--system</span> user.name <span class="token string">"Your Name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>电子邮件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 全局</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email youremail@example.com
<span class="token comment"># 本地</span>
<span class="token function">git</span> config <span class="token parameter variable">--local</span> user.email youremail@example.com
<span class="token comment"># 系统</span>
<span class="token function">git</span> config <span class="token parameter variable">--system</span> user.email youremail@example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将默认分支名称配置为 Main</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 全局</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> init.defaultBranch main
<span class="token comment"># 本地</span>
<span class="token function">git</span> config <span class="token parameter variable">--local</span> init.defaultBranch main
<span class="token comment"># 系统</span>
<span class="token function">git</span> config <span class="token parameter variable">--system</span> init.defaultBranch main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>命令行中显示所有 Git 配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示全局 本地 系统所有配置</span>
<span class="token function">git</span> config <span class="token parameter variable">--list</span> --show-origin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="git-bisect-快速查找存储库历史记录中的特定提交"><a href="#git-bisect-快速查找存储库历史记录中的特定提交" class="headerlink" title="git bisect 快速查找存储库历史记录中的特定提交"></a>git bisect 快速查找存储库历史记录中的特定提交</h2><p>用来查找哪一次代码提交引入了错误</p>
<p>发现代码库中引入<code>错误</code>或<code>问题</code>的位置</p>
<p>它的原理很简单，就是将代码提交的历史，按照两分法不断缩小定位。</p>
<p>所谓”两分法”，就是将代码历史一分为二，确定问题出在前半部分，还是后半部分，不断执行这个过程，直到范围缩小到某一次代码提交</p>
<ol>
<li><p>git bisect start</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># "终点"是最近的提交，"起点"是更久以前的提交。它们之间的这段历史，就是差错的范围</span>
<span class="token function">git</span> bisect start <span class="token punctuation">[</span>终点<span class="token punctuation">]</span> <span class="token punctuation">[</span>起点<span class="token punctuation">]</span>
<span class="token function">git</span> bisect start HEAD 4d83cf
<span class="token comment"># 执行上面的命令以后，代码库就会切换到这段范围正当中的那一次提交，假设是第51次提交</span>
<span class="token comment"># 现在查看代码没有问题。使用 git bisect good 命令，标识本次提交（第51次）没有问题</span>
<span class="token comment"># 既然第51次提交没有问题，就意味着错误是在代码历史的后半段引入的。执行上面 git bisect good 命令，Git 就自动切换到后半段的中点（第76次提交）</span>
<span class="token comment"># 查看代码有问题。使用git bisect bad命令，标识本次提交（第76）有问题</span>
<span class="token comment"># 执行 git bisect bad 以后，Git 就自动切换到第51次到第76次的中点（第63次提交）</span>
<span class="token comment"># 接下来，不断重复这个过程，直到成功找到出问题的那一次提交为止。这时，Git 会给出如下的提示</span>
<span class="token comment"># b47892 is the first bad commit</span>
<span class="token comment"># 既然找到那个有问题的提交，就可以检查代码，确定具体是什么错误。</span>
<span class="token comment"># 然后，使用git bisect reset命令，退出查错，回到最近一次的代码提交。</span>

<span class="token comment"># 现在就可以开始修复错误了。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>git bisect good</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> bisect good<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>git bisect bad</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> bisect bad<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>git bisect reset</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> bisect reset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="git-LFS-快速查找存储库历史记录中的特定提交"><a href="#git-LFS-快速查找存储库历史记录中的特定提交" class="headerlink" title="git LFS 快速查找存储库历史记录中的特定提交"></a>git LFS 快速查找存储库历史记录中的特定提交</h2><p><code>Git LFS</code>（大文件存储）在 <code>Git</code> 存储库中存储<code>图像</code>、<code>视频</code>、<code>音频</code>和<code>二进制文件</code>，而不会减慢它们的速度。</p>
<p><code>Git LFS</code> 是一个 <code>Git</code> 扩展，是许多开发人员在处理<code>二进制文件</code>时用来<code>节省空间</code>的工具。</p>
<p><strong>好处：</strong></p>
<p>当使用包含<code>音频</code>、<code>视频</code>或<code>图像文件</code>（也称为二进制文件）的<code>存储库</code>时，对这些<code>文件</code>所做的<code>任何更改</code>都不会像跟踪<code>非二进制文件</code>那样通过 <code>Git</code> 进行跟踪。</p>
<p>虽然 <code>Git</code> 在跟踪文本文件中的更改集方面做得很好，但对<code>二进制文件</code>所做的更改会作为文件的<code>附加副本</code>进行跟踪。</p>
<p>想象一下，您正在使用存储库上占用 <code>100MB</code> 的二进制映像，并且您对该文件进行了更改。<code>Git</code> 将跟踪同样占用 <code>100MB</code> 空间的文件上的更改，并将继续对所做的每个更改执行此操作。</p>
<p>如果您想做一些快速数学计算……对二进制 <code>100MB</code> 文件进行四次文件更改将导致总共使用 <code>500MB</code>（<code>100MB</code> 原始文件 + <code>100MB</code> 更改文件 + <code>100MB</code> 更改文件 + <code>100MB</code> 更改文件 + <code>100MB</code> 更改文件 &#x3D; <code>500MB</code>）。</p>
<p>由于这些更改也会推送到您的远端服务器，因此您的远端服务器也会变大，从而<code>降低</code>您使用存储库进行<code>克隆</code>、<code>推送</code>、<code>拉取</code>或<code>执行其他操作</code>的速度</p>
<p><strong>使用 Git LFS 节省时间</strong></p>
<p>使用 <code>Git LFS</code> 时，您的提交将指向<code>轻量级引用对象</code>，而不是指向<code>二进制文件</code>（您实际上是将原始二进制文件推送到 <code>LFS</code> 存储库）。</p>
<p>现在，当您克隆<code> LFS 存储库</code>或<code>签出 LFS 存储库</code>中的分支时，您只需从 <code>Git LFS 服务器</code>拉取所需的<code>二进制文件</code>版本，从而节省空间和时间。</p>
<p><strong>使用</strong></p>
<ol>
<li><p>安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> git-lfs
<span class="token function">git</span> lfs <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>为现有<code>存储库</code>初始化 <code>Git LFS</code>，并指定需要应用程序跟踪的<code>文件类型</code></p>
</li>
</ol>
<p>过滤大文件，从这里开始需要做的所有添加到该项目的 <code>jpeg</code> 文件将 <code>jpeg</code>自动变成<code>参考文件</code>，在这种情况下，本地存储的<code>实际文件</code>将被推送到 <code>github</code> 的 <code>lfs</code> 服务，因为这是一个基于 <code>github</code> 的项目</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> lfs track <span class="token string">"*.jpeg"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>




<h2 id="高级-Git-CLI-技巧：Git-Clean、Git-Reflog、Git-GC、Git-Alias-等"><a href="#高级-Git-CLI-技巧：Git-Clean、Git-Reflog、Git-GC、Git-Alias-等" class="headerlink" title="高级 Git CLI 技巧：Git Clean、Git Reflog、Git GC、Git Alias 等"></a>高级 Git CLI 技巧：Git Clean、Git Reflog、Git GC、Git Alias 等</h2><ol>
<li><p>访问比 Git 日志更多的存储库信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reflog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>加快存储库速度</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 清理不必要的文件并优化本地存储库</span>
<span class="token function">git</span> gc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>删除不需要的文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除那些，没有进行任何其他提交 或 做了一些测试而创建的测试文件</span>
<span class="token function">git</span> clean <span class="token parameter variable">-i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>在存储库文件中查找特定字符串</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">grep</span> www
<span class="token comment"># 字符串出現在哪一行</span>
<span class="token function">git</span> <span class="token function">grep</span> <span class="token parameter variable">-n</span> www
<span class="token comment"># 字符串出現的次数</span>
<span class="token function">git</span> <span class="token function">grep</span> <span class="token parameter variable">-c</span> www
<span class="token comment"># 仅查找到出现字符串的文件</span>
<span class="token function">git</span> <span class="token function">grep</span> --name-only www
<span class="token comment"># 在指定的提交commit中查找字符串 或 能标识指定commit提交就行 如tag</span>
<span class="token function">git</span> <span class="token function">grep</span> com 5027c63<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在合并和删除文件之前在本地保存工作Git Branch</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 打包不同的分支或commit</span>
<span class="token function">git</span> archive <span class="token parameter variable">--o</span> ./output.tar.gz master

<span class="token comment"># 导出变更文件</span>
<span class="token function">git</span> archive <span class="token parameter variable">-o</span> ./export.zip 479d554 <span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> <span class="token function">diff</span> --name-only a838d05 479d554<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>为更改添加其他上下文</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> notes list
<span class="token function">git</span> notes <span class="token function">add</span> <span class="token string">"this is note"</span> a838d05
<span class="token function">git</span> notes append <span class="token string">"this is note"</span> a838d05
<span class="token function">git</span> notes remove a838d05
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>配置 Git 以自动更正输入错误的 Git 命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> help.autocorrect <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>为 Git 命令创建快捷方式</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span>  alias.last  <span class="token string">"log -1 HEAD"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="git-worktree-工作树"><a href="#git-worktree-工作树" class="headerlink" title="git worktree 工作树"></a>git worktree 工作树</h2><p>使用场景</p>
<p>假设这样一个场景，你做完了一个功能，正在跑漫长的测试。</p>
<p>闲着也是闲着，修复下 <code>bug</code> 吧。</p>
<p>但是测试跑着，你不能随便动工作区的代码。</p>
<p>这时候应该怎么办？</p>
<p>在<code>git worktree</code>出现之前, <code>git</code>切换分支前后的<code>文件</code>都只存在在<code>当前文件夹</code>下;</p>
<p><code>git worktree</code> 出现之后, 我们可以将<code>分支</code>切换到<code>其他文件夹</code>下;</p>
<blockquote>
<p>比如你的项目有很多个版本分支, 在<code>git worktree</code>出现之前, 为了维护不同版本你就需要频繁切换版本, 如果项目还不小的话, 切换成本还是不小的;<br>以前端为例, 由于<code>node_modules</code>文件夹被忽略无法被跟着分支来回切换, 导致切换不同版本后还需要重新安装<code>npm</code>, 很麻烦<br>这时使用<code>git worktree</code>将分支检出到另外其他文件夹就可以避免这个问题.<br>将分支用<code>git worktree</code>检出到其他文件夹的好处很明显:<br>可以<code>同时``维护``多个分支代码</code>、可以<code>对比``不同分支</code>的<code>代码行为</code>等等</p>
</blockquote>
<ol>
<li><p>worktree 列表</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> worktree list
<span class="token function">git</span> worktree list  <span class="token parameter variable">--porcelain</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>增加一个新的 worktree，并指定了其关联的目录是 path ，关联的分支是 branch</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 假设我需要要接在 main 上工作，所以我要为 main 做一个 git worktree 条目</span>
<span class="token comment"># 可以这样添加 main，最好的做法是始终将其放在主存储库文件夹之外</span>
<span class="token comment"># 主存储库同层文件夹</span>
<span class="token comment"># 如果当前branch已经被关联到了一个 worktree，则这次 add 会被拒绝执行，可以通过增加 -f | --force 选项来强制执行</span>
<span class="token comment"># 可以使用 -b 基于新建分支并使这个新分支关联到这个新的 worktree 。如果已经存在，则这次 add 会被拒绝，可以使用 -B 代替这里的 -b 来强制执行</span>
<span class="token function">git</span> worktree <span class="token function">add</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>移除 worktree</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 已经完成了我们的工作，我们回到了我们上次停下来的地方</span>
<span class="token function">git</span> worktree remove <span class="token punctuation">[</span>path<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>全部 worktree 命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加worktree</span>
<span class="token function">git</span> worktree <span class="token function">add</span> <span class="token punctuation">[</span>-f<span class="token punctuation">]</span> <span class="token punctuation">[</span>--checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>new-branch<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token operator">&lt;</span>commit-ish<span class="token operator">></span>
<span class="token comment"># 列出所有worktree</span>
<span class="token function">git</span> worktree list <span class="token punctuation">[</span>--porcelain<span class="token punctuation">]</span>
<span class="token comment"># worktree上锁</span>
<span class="token function">git</span> worktree lock <span class="token punctuation">[</span>--reason <span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&lt;</span>worktree<span class="token operator">></span><span class="token punctuation">]</span>
<span class="token comment"># worktree解锁</span>
<span class="token function">git</span> worktree unlock <span class="token operator">&lt;</span>worktree<span class="token operator">></span>
<span class="token comment"># 移动worktree到其他目录</span>
<span class="token function">git</span> worktree move <span class="token operator">&lt;</span>worktree<span class="token operator">></span> <span class="token operator">&lt;</span>new-path<span class="token operator">></span>
<span class="token comment"># 清除那些检出目录已经被删除的worktree</span>
<span class="token function">git</span> worktree prune <span class="token parameter variable">-n</span> <span class="token parameter variable">--expire</span> <span class="token operator">&lt;</span>expire<span class="token operator">></span>
<span class="token comment"># 删除worktree, 同时删除检出目录</span>
<span class="token function">git</span> worktree remove <span class="token parameter variable">-f</span> <span class="token operator">&lt;</span>worktree<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p><code>git pull</code> <strong>&#x3D;</strong> <code> git fetch</code> <strong>+</strong> <code>git marge</code></p>
<p><code>git pull</code> 实际上是<code>两个</code>操作的组合：</p>
<p>当您从 <code>远程 git</code> 拉取时执行 <code>git fetch </code>，获取 <code>fetch</code> 和 获取合并 将<code>所有更改</code>从<code>远程</code>下载到<code>本地存储库</code>，然后 <code>git</code> 立即执行<code>合并</code>，然后将这些更改应用到<code>本地存储库</code></p>
<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p><code>git cherry-pick</code>命令的作用，就是将指定的提交（<code>commit</code>）应用于其他分支。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick <span class="token operator">&lt;</span>commitHash<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>上面命令就会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p>
<p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a - b - c - d   Master
     <span class="token punctuation">\</span>
       e - f - g Feature<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>现在将提交<code>f</code>应用到<code>master</code>分支。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 切换到 master 分支</span>
<span class="token function">git</span> checkout master
<span class="token comment"># Cherry pick 操作</span>
<span class="token function">git</span> cherry-pick f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的操作完成以后，代码库就变成了下面的样子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a - b - c - d - f   Master
     <span class="token punctuation">\</span>
       e - f - g Feature<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p>
<p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick feature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码表示将<code>feature</code>分支的最近一次提交，转移到当前分支。</p>
<ol>
<li>转移多个提交</li>
</ol>
<p>  <code>Cherry pick </code>支持一次转移多个提交。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick <span class="token operator">&lt;</span>HashA<span class="token operator">></span> <span class="token operator">&lt;</span>HashB<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  上面的命令将 <code>A</code> 和 <code>B</code> 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p>
<p>  如果想要转移一系列的连续提交，可以使用下面的简便语法。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick A<span class="token punctuation">..</span>B<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  上面的命令可以转移从 <code>A</code> 到 <code>B</code> 的所有提交。它们必须按照正确的顺序放置：提交 <code>A</code> 必须<code>早于</code>提交 <code>B</code>，否则命令将失败，但不会报错。</p>
<p>  注意，使用上面的命令，提交 <code>A</code> 将不会包含在 <code>Cherry pick</code> 中。如果要包含提交 <code>A</code>，可以使用下面的语法。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick A^<span class="token punctuation">..</span>B<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>




<ol start="2">
<li>配置项</li>
</ol>
<p>  <code>git cherry-pick</code>命令的常用配置项如下。</p>
<p>  <strong>（1）<code>-e</code>，<code>--edit</code></strong></p>
<p>  打开外部编辑器，编辑提交信息。</p>
<p>  <strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p>
<p>  只更新工作区和暂存区，不产生新的提交。</p>
<p>  <strong>（3）<code>-x</code></strong></p>
<p>  在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p>
<p>  <strong>（4）<code>-s</code>，<code>--signoff</code></strong></p>
<p>  在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p>  <strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p>
<p>  如果原始提交是一个合并节点，来自于两个分支的合并，那么 <code>Cherry pick</code> 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p>  <code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick <span class="token parameter variable">-m</span> <span class="token number">1</span> <span class="token operator">&lt;</span>commitHash<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  上面命令表示，<code>Cherry pick</code> 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p>
<p>  一般来说，<code>1</code>号父分支是接受变动的分支（<code>the branch being merged into</code>），<code>2</code>号父分支是作为变动来源的分支（<code>the branch being merged from</code>）。</p>
<ol start="3">
<li>代码冲突</li>
</ol>
<p>  如果操作过程中发生代码冲突，<code>Cherry pick </code>会停下来，让用户决定如何继续操作。</p>
<p>  <strong>（1）<code>--continue</code></strong></p>
<p>  用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 <code>Cherry pick</code> 过程继续执行。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick <span class="token parameter variable">--continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  <strong>（2）<code>--abort</code></strong></p>
<p>  发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p>  <strong>（3）<code>--quit</code></strong></p>
<p>  发生代码冲突后，退出 <code>Cherry pick</code>，但是不回到操作前的样子。</p>
<ol start="4">
<li>转移到另一个代码库</li>
</ol>
<p>  <code>Cherry pick</code> 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> target git://gitUrl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  上面命令添加了一个远程仓库<code>target</code>。</p>
<p>  然后，将远程代码抓取到本地。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  上面命令将远程代码仓库抓取到本地。</p>
<p>  接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log target/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  最后，使用<code>git cherry-pick</code>命令转移提交。</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cherry-pick <span class="token operator">&lt;</span>commitHash<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>




<h2 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h2><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做<code>两个</code>独立的项目，同时又想在一个项目中使用另一个。</p>
<p><code>Git</code> 通过<code>子模块</code>来解决这个问题。 <code>子模块</code>允许你将一个 <code>Git 仓库</code>作为另一个<code> Git 仓库</code>的<code>子目录</code>。 它能让你将<code>另一个仓库</code>克隆到自己的<code>项目</code>中，同时还保持<code>提交的独立</code>。</p>
<ol>
<li>添加子模块</li>
</ol>
<p>添加一个远程仓库项目 <code>https://github.com/iphysresearch/GWToolkit.git</code> 子模块到一个已有主仓库项目中。代码形式是 <code>git submodule add &lt;url&gt; &lt;repo_name&gt;</code>， 如下面的例子：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule <span class="token function">add</span> https://github.com/iphysresearch/GWToolkit.git GWToolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这时，你会看到一个名为 <code>GWToolkit</code> 的文件夹在你的主仓库目录中。</p>
<p>如果你是旧版 Git 的话，你会发现 <code>./GWToolkit</code> 目录中是空的，你还需要在执行一步「更新子模块」，才可以把远程仓库项目中的内容下载下来。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule update <span class="token parameter variable">--init</span> <span class="token parameter variable">--recursive</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果你不小心把路径写错了，可以用下面的代码来删掉，详细可查阅 <code>git help submodule</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> GWToolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>添加子模块后，若运行 <code>git status</code>，可以看到主仓库目录中会增加一个文件 <code>.gitmodules</code>，这个文件用来保存子模块的信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> status
位于分支 main
您的分支与上游分支 <span class="token string">'origin/main'</span> 一致。

要提交的变更：
  （使用 <span class="token string">"git restore --staged &lt;文件>..."</span> 以取消暂存）
新文件：   .gitmodules
新文件：   GWToolkit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，在 <code>.git/config</code> 中会多出一块关于子模块信息的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>submodule <span class="token string">"GWToolkit"</span><span class="token punctuation">]</span>
        url <span class="token operator">=</span> https://github.com/iphysresearch/GWToolkit.git
        active <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射。如果有多个<code>子模块</code>，该文件中就会有多条记录。</p>
<p>要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p>
<p>新生成的还有相关子模块的文件：<code>.git/modules/GWToolkit/</code>。</p>
<p>此时若把上述「<code>添加子模块</code>」的修改更新到主仓库的 <code>GitHub</code> 上去的话，会看到相应<code>子模块仓库的文件夹图标</code>会有些不同：</p>
<p><img src="https://vip2.loli.io/2021/08/28/ktpsTaGFljSKfOc.png"></p>
<p>此时还要留意的是，在终端 <code>Git</code> 命令操作下，位于主仓库目录中除了<code>子模块</code>外的任何子目录下进行的 <code>commit</code> 操作，都会记到主仓库下。只有在<code>子模块目录内</code>的任何 <code>commit</code> 操作，才会记到<code>子模块仓库</code>下。如下面的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/projects/<span class="token operator">&lt;</span>module<span class="token operator">></span>
<span class="token function">git</span> log <span class="token comment"># log shows commits from Project &lt;module></span>
<span class="token builtin class-name">cd</span> ~/projects/<span class="token operator">&lt;</span>module<span class="token operator">></span>/<span class="token operator">&lt;</span>sub_dir<span class="token operator">></span>
<span class="token function">git</span> log <span class="token comment"># still commits from Project &lt;module></span>
<span class="token builtin class-name">cd</span> ~/projects/<span class="token operator">&lt;</span>module<span class="token operator">></span>/<span class="token operator">&lt;</span>submodule<span class="token operator">></span>
<span class="token function">git</span> log <span class="token comment"># commits from &lt;submodule></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ol start="2">
<li>查看子模块</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule

13fe233bb134e25382693905cfb982fe58fa94c9 GWToolkit <span class="token punctuation">(</span>heads/main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<ol start="3">
<li>更新子模块</li>
</ol>
<p>更新项目内子模块到最新版本：</p>
<p>更新子模块为远程项目的最新版本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule update <span class="token parameter variable">--remote</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<ol start="4">
<li><code>Clone</code> 包含子模块的项目</li>
</ol>
<p>对于你的主仓库项目合作者来说，如果只是 <code>git clone</code> 去下载主仓库的内容，那么你会发现子模块仓库的文件夹内是空的！</p>
<p>此时，你可以像上面「添加子模块」中说到的使用 <code>git submodule update --init --recursive</code> 来递归的初始化并下载子模块仓库的内容。</p>
<p>也可以分初始化和更新子模块两步走的方式来下载子模块仓库的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule init<span class="token comment"># 初始化子模块</span>
<span class="token function">git</span> submodule update<span class="token comment"># 更新子模块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但是，如果你是第一次使用 <code>git clone</code> 下载主仓库的所有项目内容的话，我建议你可以使用如下的代码格式来把主仓库和其中子模块的所有内容，都<strong>一步到位</strong>的下载下来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">--recursive</span> <span class="token operator">&lt;</span>project url<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以后可以在子模块仓库目录下使用 <code>git pull origin main</code> 或者 <code>git push</code> 等来进行更新与合并等操作。</p>
<ol start="5">
<li>删除子模块</li>
</ol>
<p><strong>删除子模块比较麻烦，需要手动删除相关的文件，否则在添加子模块时有可能出现错误</strong> 同样以删除 <code>GWToolkit</code> 子模块仓库文件夹为例：</p>
<p>  (1) 删除子模块文件夹</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> GWToolkit
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> GWToolkit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  (2) 删除 <code>.gitmodules</code> 文件中相关子模块的信息，类似于：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>submodule <span class="token string">"GWToolkit"</span><span class="token punctuation">]</span>
        path <span class="token operator">=</span> GWToolkit
        url <span class="token operator">=</span> https://github.com/iphysresearch/GWToolkit.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  (3) 删除 <code>.git/config</code> 中相关子模块信息，类似于：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>submodule <span class="token string">"GWToolkit"</span><span class="token punctuation">]</span>
        url <span class="token operator">=</span> https://github.com/iphysresearch/GWToolkit.git
        active <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  (4) 删除 <code>.git</code> 文件夹中的相关子模块文件</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token parameter variable">-rf</span> .git/modules/GWToolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<ul>
<li>虽然 Git 提供的子模块功能已足够方便好用，但仍请在为主仓库项目添加子模块之前确保这是非常必要的。毕竟有很多编程语言（如 <a href="https://golang.org/">Go</a>）或其他依赖管理工具（如 Ruby’s <a href="http://guides.rubygems.org/">rubygems</a>, Node.js’ <a href="https://docs.npmjs.com/getting-started/what-is-npm">npm</a>, or Cocoa’s <a href="https://cocoapods.org/about">CocoaPods</a> and <a href="https://github.com/Carthage/Carthage">Carthage</a>）可以更好的 handle 类似的功能。</li>
<li>主仓库项目的合作者并不会<strong>自动地</strong>看到子模块仓库的更新通知的。所以，更新子模块后一定要记得提醒一下主仓库项目的合作者 <code>git submodule update</code>。</li>
</ul>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>github action 之 Go开源项目配置(tag release)</title>
    <url>//post/github-actions-go1.html</url>
    <content><![CDATA[<p><a href="https://goreleaser.com/">gorelease</a></p>
<p>在github工作流中利用gorelease来根据tag去发布项目</p>
<span id="more"></span>
<h2 id="本地配置gorelease"><a href="#本地配置gorelease" class="headerlink" title="本地配置gorelease"></a>本地配置gorelease</h2><h3 id="安装gorelease"><a href="#安装gorelease" class="headerlink" title="安装gorelease"></a>安装gorelease</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token function">install</span> github.com/goreleaser/goreleaser@latest <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="配置gorelease以发布文件"><a href="#配置gorelease以发布文件" class="headerlink" title="配置gorelease以发布文件"></a>配置gorelease以发布文件</h3><p>在项目根目录生成 <code>.goreleaser.yml</code> 配置文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">goreleaser init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>示例 <code>.goreleaser.yml</code> 文件(具体配置参考gorelease文档):</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">before</span><span class="token punctuation">:</span>
  <span class="token key atrule">hooks</span><span class="token punctuation">:</span>
    <span class="token comment"># You may remove this if you don't use go modules.</span>
    <span class="token punctuation">-</span> go mod tidy
    <span class="token comment"># you may remove this if you don't need go generate</span>
<span class="token comment">#    - go generate ./...</span>
<span class="token key atrule">builds</span><span class="token punctuation">:</span>
  <span class="token comment"># main.go 文件位置</span>
  <span class="token punctuation">-</span> <span class="token key atrule">main</span><span class="token punctuation">:</span> ./cmd
    <span class="token key atrule">ldflags</span><span class="token punctuation">:</span> <span class="token comment"># build构建时 ldflags 这里利用项目的version包进行注入</span>
      <span class="token punctuation">-</span> <span class="token punctuation">-</span>X github.com/gzwillyy/mini/pkg/version.GitVersion=<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.Version<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token punctuation">-</span>X github.com/gzwillyy/mini/pkg/version.GitCommit=<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.ShortCommit<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token punctuation">-</span>X github.com/gzwillyy/mini/pkg/version.GitTreeState=<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.Summary<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span> <span class="token punctuation">-</span>X github.com/gzwillyy/mini/pkg/version.BuildDate=<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.CommitDate<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> CGO_ENABLED=0
    <span class="token key atrule">goos</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> linux
      <span class="token punctuation">-</span> darwin

<span class="token key atrule">archives</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">format</span><span class="token punctuation">:</span> tar.gz
    <span class="token comment"># this name template makes the OS and Arch compatible with the results of uname.</span>
    <span class="token key atrule">name_template</span><span class="token punctuation">:</span> <span class="token punctuation">></span><span class="token punctuation">-</span>
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> .ProjectName <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>_
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">-</span> title .Os <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>_
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">-</span> if eq .Arch "amd64" <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>x86_64
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">-</span> else if eq .Arch "386" <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>i386
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">-</span> else <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> .Arch <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> end <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">-</span> if .Arm <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> .Arm <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> end <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment"># use zip for windows archives</span>
    <span class="token key atrule">format_overrides</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">goos</span><span class="token punctuation">:</span> windows
        <span class="token key atrule">format</span><span class="token punctuation">:</span> zip
<span class="token key atrule">checksum</span><span class="token punctuation">:</span>
  <span class="token key atrule">name_template</span><span class="token punctuation">:</span> <span class="token string">'checksums.txt'</span>
<span class="token key atrule">snapshot</span><span class="token punctuation">:</span>
  <span class="token key atrule">name_template</span><span class="token punctuation">:</span> <span class="token string">"&#123;&#123; incpatch .Version &#125;&#125;-next"</span>
<span class="token key atrule">changelog</span><span class="token punctuation">:</span>
  <span class="token key atrule">sort</span><span class="token punctuation">:</span> desc
  <span class="token key atrule">filters</span><span class="token punctuation">:</span>
    <span class="token key atrule">exclude</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'^docs:'</span>
      <span class="token punctuation">-</span> <span class="token string">'^test:'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="本地利用tag发布项目文件"><a href="#本地利用tag发布项目文件" class="headerlink" title="本地利用tag发布项目文件"></a>本地利用tag发布项目文件</h2><h3 id="创建tag"><a href="#创建tag" class="headerlink" title="创建tag"></a>创建tag</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 列出历史提交</span>
<span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
<span class="token comment"># 为指定提交创建tag</span>
<span class="token function">git</span> tag v0.6.0 <span class="token parameter variable">-m</span> <span class="token string">"v0.6.0 版本"</span>  4b9a14b8c0e7b305d258cd87658ba5e3d34fe480
<span class="token comment"># 当前最先提交创建tag</span>
<span class="token function">git</span> tag v0.6.0 <span class="token parameter variable">-m</span> <span class="token string">"v0.6.0 版本"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="本地发布文件"><a href="#本地发布文件" class="headerlink" title="本地发布文件"></a>本地发布文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">goreleaser release <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="自动化发布"><a href="#自动化发布" class="headerlink" title="自动化发布"></a>自动化发布</h2><h3 id="使用GitHub-Actions"><a href="#使用GitHub-Actions" class="headerlink" title="使用GitHub Actions"></a>使用GitHub Actions</h3><p>在代码目录创建workflows文件定义工作流程</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir -p .github&#x2F;workflows&#x2F;gorelease.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>示例<code>gorelease.yml</code>文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Go releaser
<span class="token key atrule">on</span><span class="token punctuation">:</span>
  <span class="token key atrule">push</span><span class="token punctuation">:</span>
    <span class="token key atrule">tags</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'*'</span>
<span class="token key atrule">permissions</span><span class="token punctuation">:</span>
  <span class="token key atrule">contents</span><span class="token punctuation">:</span> write
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>
  <span class="token key atrule">goreleaser</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> workflows at release
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">fetch-depth</span><span class="token punctuation">:</span> <span class="token number">0</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Set up Go
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3.5.0
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> <span class="token string">'1.20'</span>
      <span class="token punctuation">-</span> <span class="token key atrule">env</span><span class="token punctuation">:</span>
          <span class="token key atrule">GITHUB_TOKEN</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> secrets.GITHUB_TOKEN <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Run GoReleaser
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> goreleaser/goreleaser<span class="token punctuation">-</span>action@v4
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">args</span><span class="token punctuation">:</span> release <span class="token punctuation">-</span><span class="token punctuation">-</span>clean
          <span class="token comment"># either 'goreleaser' (default) or 'goreleaser-pro'</span>
          <span class="token key atrule">distribution</span><span class="token punctuation">:</span> goreleaser
          <span class="token key atrule">version</span><span class="token punctuation">:</span> latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="推送tag来运行自动化工作流程"><a href="#推送tag来运行自动化工作流程" class="headerlink" title="推送tag来运行自动化工作流程"></a>推送tag来运行自动化工作流程</h3><p>在本地设置好tag后,讲tag推送到github代码仓库</p>
<pre class="line-numbers language-none"><code class="language-none">git push origin --tags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="其他的action"><a href="#其他的action" class="headerlink" title="其他的action"></a>其他的action</h2><p>如github代码仓库中的 <code>Security</code> , 在其中配置  <code>Dependabot安全警报</code></p>
<p>如github代码仓库 <code>Actions</code> 里 <code>New workflow</code> 在里面选择需要的工作流</p>
<hr>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>actions</tag>
        <tag>workflows</tag>
        <tag>goreleaser</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions 简单使用</title>
    <url>//post/github-actions-learn.html</url>
    <content><![CDATA[<p><strong>github代码仓库创建<code>workflows-component</code>仓库</strong></p>
<span id="more"></span>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> workflows-component <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> workflows-component
<span class="token function">touch</span> README.md
<span class="token builtin class-name">echo</span> <span class="token string">"# workflows-component"</span> <span class="token operator">>></span> README.md
<span class="token function">git</span> init
<span class="token function">git</span> <span class="token function">add</span> README.md
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"first commit"</span>
<span class="token function">git</span> branch <span class="token parameter variable">-M</span> main
<span class="token function">git</span> remote <span class="token function">add</span> origin 远程仓库地址
<span class="token function">git</span> push <span class="token parameter variable">-u</span> origin main
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> .github/workflows <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> .github/workflows
<span class="token function">touch</span> learn-github-actions.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span>
<span class="token comment"># 将工作流中运行的所有作业组合在一起</span>
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>
  <span class="token comment"># 定义一个名为 的作业check-bats-version。子键将定义作业的属性</span>
  <span class="token key atrule">check-go-version</span><span class="token punctuation">:</span>
    <span class="token comment"># 配置作业以在最新版本的 Ubuntu Linux 运行器上运行。这意味着作业将在 GitHub 托管的新虚拟机上执行</span>
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token comment"># 将作业中运行的所有步骤组合在一起 。嵌套在该部分下的每个项目都是一个单独的操作或 shell 脚本</span>
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token comment"># 关键字uses指定此步骤将运行v3操作actions/checkout。这是一个将您的存储库签出到运行器上的操作，允许您针对您的代码运行脚本或其他操作（例如构建和测试工具）。</span>
      <span class="token comment"># 任何时候您的工作流将针对存储库的代码运行时，您都应该使用 checkout 操作。</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 签出存储库
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 设置Go环境
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>go@v3.5.0
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">go-version</span><span class="token punctuation">:</span> ^1.20.0
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 输出 Go Version
        <span class="token key atrule">run</span><span class="token punctuation">:</span> go version
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 运行 hello.go
        <span class="token key atrule">run</span><span class="token punctuation">:</span> go run hello.go
<span class="token comment"># 工作流的名称，因为它将出现在 GitHub 存储库的“操作”选项卡中</span>
<span class="token key atrule">name</span><span class="token punctuation">:</span> learn<span class="token punctuation">-</span>github<span class="token punctuation">-</span>actions
<span class="token comment"># 工作流触发条件</span>
<span class="token key atrule">'on'</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> push
<span class="token comment"># 从工作流生成的工作流运行的名称，它将显示在存储库的“操作”选项卡上的工作流运行列表中。此示例使用带有上下文的表达式github来显示触发工作流运行的参与者的用户名</span>
<span class="token key atrule">run-name</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github.actor <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> is learning GitHub Actions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>actions</tag>
      </tags>
  </entry>
  <entry>
    <title>github 使用 GPG 在本地对提交进行签名。</title>
    <url>//post/github-gpg-commit.html</url>
    <content><![CDATA[<p>github官方文档 : <a href="https://docs.github.com/zh/authentication/managing-commit-signature-verification/signing-commits">文档地址</a></p>
<h2 id="本地生成新的-GPG-密钥"><a href="#本地生成新的-GPG-密钥" class="headerlink" title="本地生成新的 GPG 密钥"></a>本地生成新的 GPG 密钥</h2><p>访问下载地址 <a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a> ，下载适合你的操作系统的版本。</p>
<p>一般高版本下的 git 会携带有 GPG 命令操作。如果没有，请自行安装</p>
<ol>
<li>打开 Git Bash</li>
<li>生成 GPG 密钥对，由于 GPG 有多个版本，因此您可能需要查询相关的<a href="https://en.wikipedia.org/wiki/Man_page">手册页</a>以找到适当的密钥生成命令。 密钥必须使用 RSA。</li>
</ol>
<p>当前使用版本高于 2.1.17，使用以下命令生成 GPG 密钥对</p>
<span id="more"></span>
<pre class="line-numbers language-none"><code class="language-none">gpg --full-generate-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li><p>在提示时，指定要生成的密钥类型，或按 <code>Enter</code> 键接受默认值。</p>
</li>
<li><p>在提示时，指定想要的密钥大小，或按 <code>Enter</code>键接受默认值。 密钥必须至少是 <code>4096</code>位（最大是4096位，输入最大的即可）。</p>
</li>
<li><p>输入密钥的有效时长。 按 <code>Enter</code>键将指定默认选择，表示该密钥不会过期。</p>
</li>
<li><p>验证您的选择是否正确。</p>
</li>
<li><p>输入您的用户 ID 信息。</p>
</li>
</ol>
<p>请保持和你的git账户一致的信息</p>
<ol>
<li>输入安全密码（后续启动提交签名认证时需要输入）</li>
<li>使用 <code>gpg --list-secret-keys --keyid-format=long</code>命令列出您拥有其公钥和私钥的长形式 GPG 密钥。 签名提交或标记需要私钥。</li>
</ol>
<p>注：Linux上的一些 GPG 安装可能需要使用 <code>gpg2 --list-keyid-form LONG</code>查看您现有密钥的列表。 在这种情况下，您还需要运行 <code>git config --global gpg.program gpg2</code>来配置 Git 使用 git gpg2。</p>
<ol>
<li>从 GPG 密钥列表中复制您想要使用的 GPG 密钥 ID 的长形式。 在此例中，GPG 密钥 ID 是 <code>3AA5C34371567BD2</code>：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ gpg --list-secret-keys --keyid-format&#x3D;long
&#x2F;Users&#x2F;hubot&#x2F;.gnupg&#x2F;secring.gpg
------------------------------------
sec   4096R&#x2F;3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot 
ssb   4096R&#x2F;42B317FD4BA89E7A 2016-03-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>粘贴下面的文本（替换为您要使用的 GPG 密钥 ID）。 在此例中，GPG 密钥 ID 是 <code>3AA5C34371567BD2</code>：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ gpg --armor --export 3AA5C34371567BD2
# Prints the GPG key ID, in ASCII armor format<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol>
<li>复制 GPG 密钥，从 —–BEGIN PGP PUBLIC KEY BLOCK—– 开始，到 —–END PGP PUBLIC KEY BLOCK—– 结束。</li>
<li>将 GPG 密钥添加到具体的 账户上即可。</li>
</ol>
<h2 id="启动-GPG-密钥验证"><a href="#启动-GPG-密钥验证" class="headerlink" title="启动 GPG 密钥验证"></a>启动 GPG 密钥验证</h2><ol>
<li>打开 Git Bash</li>
<li>使用 <code>gpg --list-secret-keys --keyid-format=long</code> 命令列出您拥有其公钥和私钥的长形式 GPG 密钥。 签名提交或标记需要私钥。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ gpg --list-secret-keys --keyid-format&#x3D;long<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li>从 GPG 密钥列表中复制您想要使用的 GPG 密钥 ID 的长形式。 在此例中，GPG 密钥 ID 是 <code>3AA5C34371567BD2</code>：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ gpg --list-secret-keys --keyid-format&#x3D;long
&#x2F;Users&#x2F;hubot&#x2F;.gnupg&#x2F;secring.gpg
------------------------------------
sec   4096R&#x2F;3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot 
ssb   4096R&#x2F;42B317FD4BA89E7A 2016-03-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>要在 Git 中设置 GPG 签名密钥，请粘贴下面的文本，替换您想要使用的 GPG 密钥 ID。 在此例中，GPG 密钥 ID 是 <code>3AA5C34371567BD2</code>：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">git config --global user.signingkey 3AA5C34371567BD2
git config --local user.signingkey 3AA5C34371567BD2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="对提交和标记签名"><a href="#对提交和标记签名" class="headerlink" title="对提交和标记签名"></a>对提交和标记签名</h2><h3 id="提交签名"><a href="#提交签名" class="headerlink" title="提交签名"></a>提交签名</h3><p><strong>提示：</strong></p>
<p>要将您的 Git 客户端配置为默认对本地仓库的提交签名，请在 Git 版本 2.0.0 及更高版本中，运行 git config commit.gpgsign true。 要在计算机上的任何本地仓库中默认对所有提交签名，请运行 git config –global commit.gpgsign true。</p>
<p>要存储 GPG 密钥密码，以便无需在每次对提交签名时输入该密码，我们建议使用以下工具：</p>
<ul>
<li>对于 Mac 用户，<a href="https://gpgtools.org/">GPG Suite</a> 允许您在 Mac OS 密钥链中存储 GPG 密钥密码。</li>
<li>对于 Windows 用户，<a href="https://www.gpg4win.org/">Gpg4win</a> 将与其他 Windows 工具集成。</li>
</ul>
<p>您也可以手动配置 <a href="http://linux.die.net/man/1/gpg-agent">gpg-agent</a> 以保存 GPG 密钥密码，但这不会与 Mac OS 密钥链（如 ssh 代理）集成，并且需要更多设置。</p>
<ol>
<li>当本地分支中的提交更改时，请将 S 标志添加到 git commit 命令：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ git commit -S -m &quot;your commit message&quot;
# Creates a signed commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol>
<li>如果您使用 GPG，则创建提交后，提供您生成 GPG 密钥时设置的密码。</li>
<li>在本地完成创建提交后，将其推送到 GitHub 上的远程仓库：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ git push
# Pushes your local commits to the remote repository<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>完成提交签名，对于签名状态可以去对应git程序上面查看。请注意，如果删除了已经添加到账户中的 GPG 密钥，可能导致原有的提交签名由 <code>Verified</code>变为 <code>Unverified</code>。</p>
<h3 id="标记签名"><a href="#标记签名" class="headerlink" title="标记签名"></a>标记签名</h3><ol>
<li>要对标记签名，请将 <code>-s</code> 添加到您的 <code>git tag</code> 命令。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ git tag -s mytag
# Creates a signed tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol>
<li>通过运行 <code>git tag -v [tag-name]</code> 验证您签名的标记。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ git tag -v mytag
# Verifies the signed tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="GPG-Keys-命令操作"><a href="#GPG-Keys-命令操作" class="headerlink" title="GPG Keys 命令操作"></a>GPG Keys 命令操作</h2><ol>
<li><p>列出所有<code>公钥key</code></p>
<pre class="line-numbers language-none"><code class="language-none">gpg -k
gpg --list-keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>列出所有<code>私钥(密钥)</code></p>
<pre class="line-numbers language-none"><code class="language-none">gpg -K
gpg --list-secret-keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<p>每个key都会有一个uid，不论是公开key还是私钥密钥</p>
<ol start="3">
<li><p>删除<code>公钥key</code></p>
<pre class="line-numbers language-none"><code class="language-none">gpg --delete-key [uid]
gpg --delete-keys 6C8A15CECD3DCC2741A7C590AB38BACE635A064C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>删除<code>私钥(密钥)</code></p>
<pre class="line-numbers language-none"><code class="language-none">gpg --delete-secret-key [uid]
gpg --delete-secret-key 6C8A15CECD3DCC2741A7C590AB38BACE635A064C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>导出<code>公钥key</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">gpg -a -o public-file.key --export 8AC0AB86C34ADC6ED110A5A9E6730F4374866065<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导出<code>私钥(密钥)</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">gpg -a -o private-file.key --export-secret-keys 8AC0AB86C34ADC6ED110A5A9E6730F4374866065<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导入<code>公钥key</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">gpg --import public-file.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导入<code>私钥(密钥)</code>：<br>导入报错 pinentry  , <code>sudo dnf install pinentry</code> 后重试</p>
<pre class="line-numbers language-none"><code class="language-none">gpg --import private-file.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改用户名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"gzwillyy"</span>
<span class="token comment"># 修改邮箱</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"gzwillyy@gmail.com"</span>
<span class="token comment"># 设置git，保存用户名和密码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper store
<span class="token comment"># 解决git中 'Filename too lang' 的错误</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.longpaths <span class="token boolean">true</span>
<span class="token comment"># 防止乱码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.quotepath off
<span class="token comment"># github限制最大克隆 需要安装 Git Large File Storage</span>
<span class="token function">git</span> lfs <span class="token function">install</span> --skip-repo
<span class="token comment"># 设置自动更正</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> help.autocorrect <span class="token number">15</span>

gpg --list-secret-keys --keyid-format<span class="token operator">=</span>long
<span class="token comment"># sec   rsa4096/3AA5C34371567BD2</span>
<span class="token comment"># Git 中设置 GPG 签名主键,替换要使用的 GPG 密钥ID： 3AA5C34371567BD2</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.signingkey 3AA5C34371567BD2
<span class="token comment"># 将 Git 配置为默认对所有提交进行签名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> gpg.program gpg
<span class="token function">git</span> config <span class="token parameter variable">--global</span> commit.gpgsign <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="GPG-提交错误"><a href="#GPG-提交错误" class="headerlink" title="GPG 提交错误"></a>GPG 提交错误</h2><p><code>gpg failed to sign the data fatal: failed to write commit object</code></p>
<ol>
<li>gpg –version</li>
<li>echo “test” | gpg –clearsign</li>
</ol>
<p><strong>如果显示：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gpg: signing failed: Inappropriate ioctl <span class="token keyword">for</span> device
gpg: <span class="token punctuation">[</span>stdin<span class="token punctuation">]</span>: clear-sign failed: Inappropriate ioctl <span class="token keyword">for</span> device<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="3">
<li><p>然后使用 <code>export GPG_TTY=$(tty)</code></p>
</li>
<li><p>然后再次尝试<code>echo &quot;test&quot; | gpg --clearsign</code> 获得 PGP 签名。</p>
</li>
<li><p>git config -l | grep gpg</p>
</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">gpg.program</span><span class="token operator">=</span>gpg
<span class="token assign-left variable">commit.gpgsign</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li>申请git commit -S -m “commitMsz”</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>commit</tag>
        <tag>GPG</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook M1 通过 parallels desktop 安装 linux centos8.4</title>
    <url>//post/mac-m1-centos8-4.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8.4</td>
</tr>
<tr>
<td>Parallels Desktop</td>
<td>18.1.1</td>
</tr>
</tbody></table>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Parallels Desktop</code> 虚拟机软件<br><code>CentOS-8.4.2105-aarch64-boot.iso</code> centos8.4镜像</p>
<h2 id="安装Parallels-Desktop"><a href="#安装Parallels-Desktop" class="headerlink" title="安装Parallels Desktop"></a>安装Parallels Desktop</h2><h3 id="破解Parallels-Desktop"><a href="#破解Parallels-Desktop" class="headerlink" title="破解Parallels Desktop"></a>破解Parallels Desktop</h3><p>开源破解软件： <a href="https://github.com/MikeWang000000/PD-Runner-Revived">https://github.com/MikeWang000000/PD-Runner-Revived</a></p>
<span id="more"></span>
<h2 id="准备Linux-CentOS-8-4"><a href="#准备Linux-CentOS-8-4" class="headerlink" title="准备Linux CentOS 8.4"></a>准备Linux CentOS 8.4</h2><p>Linux CentOS 镜像下载地址 : </p>
<ul>
<li><a href="http://mirrors.aliyun.com/centos/">阿里CentOS源</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/centos/">清华CentOS源</a></li>
<li><a href="http://mirror.nsc.liu.se/centos-store/">历史版本下载</a></li>
<li><a href="https://www.centos.org/download/">CentOS8官网下载</a></li>
<li><a href="http://mirror.nsc.liu.se/centos-store/8.4.2105/isos/aarch64/CentOS-8.4.2105-aarch64-dvd1.iso">本文使用镜像下载地址</a>: <a href="http://mirror.nsc.liu.se/centos-store/8.4.2105/isos/aarch64/CentOS-8.4.2105-aarch64-dvd1.iso">http://mirror.nsc.liu.se/centos-store/8.4.2105/isos/aarch64/CentOS-8.4.2105-aarch64-dvd1.iso</a></li>
</ul>
<h2 id="安装Linux-CentOS-8-4"><a href="#安装Linux-CentOS-8-4" class="headerlink" title="安装Linux CentOS 8.4"></a>安装Linux CentOS 8.4</h2><h3 id="Parallels-Desktop-选择镜像安装-Linux-CentOS-8-4"><a href="#Parallels-Desktop-选择镜像安装-Linux-CentOS-8-4" class="headerlink" title="Parallels Desktop 选择镜像安装 Linux CentOS 8.4"></a>Parallels Desktop 选择镜像安装 Linux CentOS 8.4</h3><ol>
<li>第一次输入<code>r</code>，刷新配置，可以看到有几个带感叹号⚠️的警告，接下来就一一设置</li>
<li><code>磁盘选择设置</code> 选数字 <code>5</code> 再按提示<code>c</code> <code>c</code> <code>c</code>，完成磁盘的选择</li>
<li><code>设置root密码</code> 选数字 <code>8</code> 再按提示6688…，完成密码设置, 弱密码 输入 <code>yes</code></li>
<li>最后输入 <code>b</code> 后 开始安装…</li>
<li>安装完成重启 ,若出现<code>license information(license not accepted)</code>，即说明需要同意许可信息， 输入<code>1</code>-<code>回车</code>-<code>2</code>-<code>回车</code>-<code>c</code>-<code>回车</code>-<code>c</code>-<code>回车</code>，即可解决。</li>
</ol>
<h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><h4 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h4><p><strong>ifcfg- 开头的就是我们要编辑的配置文件，每个人的文件名可能不同</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/sysconfig/network-scripts/
<span class="token function">ls</span>
<span class="token function">vi</span> ifcfg-enp0s5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p><strong>修改内容如下:</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet  <span class="token comment">#网卡类型</span>
<span class="token assign-left variable">PROXY_METHOD</span><span class="token operator">=</span>none
<span class="token assign-left variable">BROWSER_ONLY</span><span class="token operator">=</span>no
<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>static <span class="token comment"># 修改为静态IP dhcp为动态ip none为无</span>
<span class="token assign-left variable">DEFROUTE</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV4_FAILURE_FATAL</span><span class="token operator">=</span>no
<span class="token assign-left variable">IPV6INIT</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_AUTOCONF</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_DEFROUTE</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_FAILURE_FATAL</span><span class="token operator">=</span>no
<span class="token assign-left variable">NAME</span><span class="token operator">=</span>enp0s5
<span class="token assign-left variable">UUID</span><span class="token operator">=</span>cd9c7deb-5cf8-4474-abf2-b06cf1bafc07
<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>enp0s5 <span class="token comment"># 设备名</span>
<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes <span class="token comment"># ONBOOT=yes #开机自启</span>
<span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token number">10.211</span>.55.3 <span class="token comment"># IP地址</span>
<span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token number">10.211</span>.55.1 <span class="token comment"># 网关</span>
<span class="token assign-left variable">NETMASK</span><span class="token operator">=</span><span class="token number">255.255</span>.255.0 <span class="token comment"># 子网掩码</span>
<span class="token assign-left variable">DNS1</span><span class="token operator">=</span><span class="token number">10.211</span>.55.1 <span class="token comment"># DNS服务器1、2</span>
<span class="token assign-left variable">DNS2</span><span class="token operator">=</span><span class="token number">8.8</span>.8.8
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>保存退出后重启CentOS 或者 重启网络</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">shutdown</span> <span class="token parameter variable">-h</span> now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>查询<code>ip</code>地址 并验证网络</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> addr
<span class="token function">curl</span> www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>外部打开<code>iterm</code> <code>ping</code> <code>虚拟机</code></strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token number">10.211</span>.55.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>ssh</code>连接虚拟机</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> root@10.211.55.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>关闭虚拟机防火墙</strong><br>查看防火墙状态：<code>firewall-cmd --state</code>或<code>systemctl status firewalld.service</code><br>关闭：<code>systemctl stop firewalld.service</code><br>永久关闭： <code>systemctl disable firewalld.service</code></p>
<h2 id="在Linux-CentOS-8-4中安装必要的软件"><a href="#在Linux-CentOS-8-4中安装必要的软件" class="headerlink" title="在Linux CentOS 8.4中安装必要的软件"></a>在Linux CentOS 8.4中安装必要的软件</h2><h3 id="安装Parallels-Tools"><a href="#安装Parallels-Tools" class="headerlink" title="安装Parallels Tools"></a>安装Parallels Tools</h3><p><strong>首先在虚拟机的控制中心菜单中&gt;操作&gt;安装Parallels Tools</strong></p>
<p><strong>然后回到虚拟机里，执行挂载光盘:</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># mount /dev/cdrom /mnt</span>
mount: /mnt: WARNING: device write-protected, mounted read-only.
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># df -h /mnt/</span>
Filesystem      Size  Used Avail Use% Mounted on
/dev/sr0         60M   60M     <span class="token number">0</span> <span class="token number">100</span>% /mnt
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># cp -ra /mnt /opt/</span>
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># umount /mnt</span>
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>选择光盘</strong><br>parallels desktop 虚拟机界面上方菜单栏中选择镜像文件连接</p>
<p><strong>修改源文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/CentOS-* /opt/</span>
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># mv /opt/CentOS-Linux-Media.repo /etc/yum.repos.d/</span>
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># mkdir /media/CentOS/ -p</span>
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># mount /dev/cdrom /media/CentOS/</span>
mount: /media/CentOS: WARNING: device write-protected, mounted read-only.
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># df -h|grep /media/CentOS</span>
/dev/sr0                    <span class="token number">6</span>.8G  <span class="token number">6</span>.8G     <span class="token number">0</span> <span class="token number">100</span>% /media/CentOS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>上面的注意检查下，是这个6.8G的，之前的那个tool的要umount掉，然后再操作上面的iso加载，不行就多操作或者重启机器了<br>修改vim &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Linux-Media.repo文件如下，centos7的是一个，注意这里centos8已经拆分成两个了</p>
</blockquote>
<p><strong>CentOS-Linux-Media.repo 原始文件如下:</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># CentOS-Linux-Media.repo</span>
<span class="token comment">#</span>
<span class="token comment"># You can use this repo to install items directly off the installation media.</span>
<span class="token comment"># Verify your mount point matches one of the below file:// paths.</span>

<span class="token punctuation">[</span>media-baseos<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS Linux <span class="token variable">$releasever</span> - Media - BaseOS
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///media/CentOS/BaseOS
        file:///media/cdrom/BaseOS
        file:///media/cdrecorder/BaseOS
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial

<span class="token punctuation">[</span>media-appstream<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS Linux <span class="token variable">$releasever</span> - Media - AppStream
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///media/CentOS/AppStream
        file:///media/cdrom/AppStream
        file:///media/cdrecorder/AppStream
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>添加epel源 ,这个是因为dkms的包是在epel里面的，而tool是需要这个dkms的包的，所以添加源<br>而gcc的默认的版本已经足够高了，不需要之前centos7的那些处理</strong></p>
<p><strong>修改后整个文件&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Media.repo内容如下：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># CentOS-Linux-Media.repo</span>
<span class="token comment">#</span>
<span class="token comment"># You can use this repo to install items directly off the installation media.</span>
<span class="token comment"># Verify your mount point matches one of the below file:// paths.</span>

<span class="token punctuation">[</span>media-baseos<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS Linux <span class="token variable">$releasever</span> - Media - BaseOS
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///media/CentOS/BaseOS
<span class="token comment">#        file:///media/cdrom/BaseOS</span>
<span class="token comment">#        file:///media/cdrecorder/BaseOS</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment">#gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span>

<span class="token punctuation">[</span>media-appstream<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS Linux <span class="token variable">$releasever</span> - Media - AppStream
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///media/CentOS/AppStream
<span class="token comment">#        file:///media/cdrom/AppStream</span>
<span class="token comment">#        file:///media/cdrecorder/AppStream</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span>

<span class="token punctuation">[</span>epel<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>epel
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>https://mirrors.tuna.tsinghua.edu.cn/epel/8/Everything/aarch64/
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>更新yum缓存 yum makecache</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># yum makecache</span>
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
CentOS Linux <span class="token number">8</span> - Media - BaseOS                                                                                                           <span class="token number">317</span> MB/s <span class="token operator">|</span> <span class="token number">1.5</span> MB     00:00
CentOS Linux <span class="token number">8</span> - Media - AppStream                                                                                                        <span class="token number">561</span> MB/s <span class="token operator">|</span> <span class="token number">6.0</span> MB     00:00
epel                                                                                                                                      <span class="token number">7.2</span> MB/s <span class="token operator">|</span>  <span class="token number">11</span> MB     00:01
Metadata cache created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>开始安装 Parallels Tools</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># cd /opt/mnt/</span>
<span class="token punctuation">[</span>root@localdomain mnt<span class="token punctuation">]</span><span class="token comment"># ll</span>
total <span class="token number">536</span>
-r-xr-xr-x. <span class="token number">1</span> root root   <span class="token number">1043</span> Nov <span class="token number">24</span> <span class="token number">14</span>:24 <span class="token function">install</span>
-r-xr-xr-x. <span class="token number">1</span> root root <span class="token number">533104</span> Nov <span class="token number">24</span> <span class="token number">14</span>:25 install-gui
dr-xr-xr-x. <span class="token number">3</span> root root   <span class="token number">4096</span> Nov <span class="token number">24</span> <span class="token number">14</span>:25 installer
dr-xr-xr-x. <span class="token number">2</span> root root     <span class="token number">28</span> Nov <span class="token number">24</span> <span class="token number">14</span>:24 kmods
dr-xr-xr-x. <span class="token number">4</span> root root    <span class="token number">185</span> Nov <span class="token number">24</span> <span class="token number">14</span>:25 tools
-r--r--r--. <span class="token number">1</span> root root     <span class="token number">13</span> Nov <span class="token number">24</span> <span class="token number">14</span>:25 version
<span class="token punctuation">[</span>root@localdomain mnt<span class="token punctuation">]</span><span class="token comment"># ./install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>** <code>next</code> -&gt; <code>next</code> -&gt; <code>next</code> -&gt; <code>reboot</code>**</p>
<blockquote>
<p>检查是否真的安装好了，安装好了有共享文件夹功能，可以在linux里面直接访问Mac的文件<br>添加共享文件夹</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /media/psf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h3><p><strong>备份</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/yum.repos.d/CentOS-Linux-BaseOS.repo /etc/yum.repos.d/CentOS-Linux-BaseOS.repo.backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>下载新的 CentOS-Base.repo 到 &#x2F;etc&#x2F;yum.repos.d&#x2F;</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token parameter variable">-O</span> /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>清除文件 并 重建元数据缓存</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf clean all
dnf makecache
dnf update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置:</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'/mirrors.cloud.aliyuncs.com/d'</span> <span class="token parameter variable">-e</span> <span class="token string">'/mirrors.aliyuncs.com/d'</span> /etc/yum.repos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>yum makecache 出现报错</strong><br>报错：<code>Errors during downloading metadata for repository &#39;media-baseos&#39;: …</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment"># yum makecache</span>
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
CentOS-8 - Base - mirrors.aliyun.com                                                                                  <span class="token number">3.9</span> MB/s <span class="token operator">|</span> <span class="token number">2.9</span> MB     00:00
CentOS-8 - Extras - mirrors.aliyun.com                                                                                 <span class="token number">38</span> kB/s <span class="token operator">|</span>  <span class="token number">10</span> kB     00:00
CentOS-8 - AppStream - mirrors.aliyun.com                                                                             <span class="token number">1.2</span> MB/s <span class="token operator">|</span> <span class="token number">6.9</span> MB     00:05
CentOS Linux <span class="token number">8</span> - Media - BaseOS                                                                                       <span class="token number">0.0</span>  B/s <span class="token operator">|</span>   <span class="token number">0</span>  B     00:00
Errors during downloading metadata <span class="token keyword">for</span> repository <span class="token string">'media-baseos'</span><span class="token builtin class-name">:</span>
  - Curl error <span class="token punctuation">(</span><span class="token number">37</span><span class="token punctuation">)</span>: Couldn<span class="token string">'t read a file:// file for file:///media/CentOS/BaseOS/repodata/repomd.xml [Couldn'</span>t <span class="token function">open</span> <span class="token function">file</span> /media/CentOS/BaseOS/repodata/repomd.xml<span class="token punctuation">]</span>
Error: Failed to download metadata <span class="token keyword">for</span> repo <span class="token string">'media-baseos'</span><span class="token builtin class-name">:</span> Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried
<span class="token punctuation">[</span>root@localdomain ~<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>解决方法</strong></p>
<ul>
<li><code>挂载镜像：mount /dev/sr0 /media/CentOS/</code></li>
<li><code>重新生成缓存 yum makecache</code><pre class="line-numbers language-none"><code class="language-none">[root@localdomain yum.repos.d]# mount &#x2F;dev&#x2F;sr0 &#x2F;media&#x2F;CentOS&#x2F;
mount: &#x2F;media&#x2F;CentOS: WARNING: device write-protected, mounted read-only.
[root@localdomain yum.repos.d]# yum clean all
Failed to set locale, defaulting to C.UTF-8
Repository extras is listed more than once in the configuration
33 files removed
[root@localdomain yum.repos.d]# yum makecache
Failed to set locale, defaulting to C.UTF-8
Repository extras is listed more than once in the configuration
CentOS-8 - Base - mirrors.aliyun.com                                                                                  4.7 MB&#x2F;s | 2.9 MB     00:00
CentOS-8 - Extras - mirrors.aliyun.com                                                                                 33 kB&#x2F;s |  10 kB     00:00
CentOS-8 - AppStream - mirrors.aliyun.com                                                                             7.6 MB&#x2F;s | 6.9 MB     00:00
CentOS Linux 8 - AppStream                                                                                            4.6 MB&#x2F;s | 6.9 MB     00:01
CentOS Linux 8 - BaseOS                                                                                               2.5 MB&#x2F;s | 2.9 MB     00:01
CentOS Linux 8 - Media - BaseOS                                                                                       279 MB&#x2F;s | 1.5 MB     00:00
CentOS Linux 8 - Media - AppStream                                                                                    487 MB&#x2F;s | 6.0 MB     00:00
epel                                                                                                                  7.5 MB&#x2F;s |  11 MB     00:01
Metadata cache created.
[root@localdomain yum.repos.d]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h1 id="Vscode-SSH-Remote"><a href="#Vscode-SSH-Remote" class="headerlink" title="Vscode SSH Remote"></a>Vscode SSH Remote</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-R</span> <span class="token number">10.211</span>.55.4

<span class="token comment"># 删除ip记录后重新使用 vscode远程连接</span>
<span class="token function">vi</span> ~/.ssh/known_hosts
<span class="token function">vi</span> /Users/admin/.ssh/known_hosts
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Mac M1</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 的多架构支持</title>
    <url>//post/docker-arch-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h2 id="使用-buildx-构建多架构镜像"><a href="#使用-buildx-构建多架构镜像" class="headerlink" title="使用 buildx 构建多架构镜像"></a>使用 buildx 构建多架构镜像</h2><p>Windows 和 Mac的桌面版Docker自带buildx命令，但是Linux环境下的Docker需要自行安装buildx （<a href="https://github.com/docker/buildx%EF%BC%89">https://github.com/docker/buildx）</a></p>
<p><a href="https://docs.docker.com/buildx/working-with-buildx/">https://docs.docker.com/buildx/working-with-buildx/</a></p>
<p>本节课使用的源码 <a href="https://github.com/xiaopeng163/flask-redis">https://github.com/xiaopeng163/flask-redis</a></p>
<p>登录 dockerhub</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>进入源码目录（Dockerfile所在目录）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/xiaopeng163/flask-redis
<span class="token builtin class-name">cd</span> flask-redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>构建</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> login
Authenticating with existing credentials<span class="token punctuation">..</span>.
Login Succeeded
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> buildx build <span class="token parameter variable">--push</span> <span class="token parameter variable">--platform</span> linux/arm/v7,linux/arm64/v8,linux/amd64 <span class="token parameter variable">-t</span> xiaopeng163/flask-redis:latest <span class="token builtin class-name">.</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Building <span class="token number">0</span>.0s <span class="token punctuation">(</span><span class="token number">0</span>/0<span class="token punctuation">)</span>
error: multiple platforms feature is currently not supported <span class="token keyword">for</span> <span class="token function">docker</span> driver. Please switch to a different driver <span class="token punctuation">(</span>eg. <span class="token string">"docker buildx create --use"</span><span class="token punctuation">)</span>
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span>
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> buildx <span class="token function">ls</span>
NAME/NODE       DRIVER/ENDPOINT STATUS  PLATFORMS
desktop-linux   <span class="token function">docker</span>
desktop-linux desktop-linux   running linux/amd64, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
default *       <span class="token function">docker</span>
default       default         running linux/amd64, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> buildx create <span class="token parameter variable">--name</span> mybuilder <span class="token parameter variable">--use</span>
mybuilder
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> buildx <span class="token function">ls</span>
NAME/NODE       DRIVER/ENDPOINT                STATUS   PLATFORMS
mybuilder *     docker-container
mybuilder0    npipe:////./pipe/docker_engine inactive
desktop-linux   <span class="token function">docker</span>
desktop-linux desktop-linux                  running  linux/amd64, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
default         <span class="token function">docker</span>
default       default                        running  linux/amd64, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>flask-redis<span class="token operator">></span> <span class="token function">docker</span> buildx build <span class="token parameter variable">--push</span> <span class="token parameter variable">--platform</span> linux/arm/v7,linux/arm64/v8,linux/amd64 <span class="token parameter variable">-t</span> xiaopeng163/flask-redis:latest <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="使用-buildx-构建多架构镜像另外一个例子"><a href="#使用-buildx-构建多架构镜像另外一个例子" class="headerlink" title="使用 buildx 构建多架构镜像另外一个例子"></a>使用 buildx 构建多架构镜像另外一个例子</h2><h3 id="1-创建一个新的-builder"><a href="#1-创建一个新的-builder" class="headerlink" title="1. 创建一个新的 builder"></a>1. 创建一个新的 builder</h3><hr>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> login
<span class="token function">docker</span> buildx create <span class="token parameter variable">--name</span> mybuilder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<h3 id="2-准备好Dockerfile"><a href="#2-准备好Dockerfile" class="headerlink" title="2. 准备好Dockerfile"></a>2. 准备好Dockerfile</h3><p>其中 <code>TARGETARCH</code> 这个参数会随着 <code>buildx</code> 的不同 <code>platform</code> 自动变化。然后会根据不同的 <code>platform</code> 下载不同二进制文件 <code>terraform</code> 。</p>
<p>类似  <a href="https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope">https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope</a> 还有其他的一些自动变量可以参考链接。</p>
<p>关于 <code>ARG</code> 和 <code>ENV</code> 的区别和用法，请参考 <a href="https://dockertips.readthedocs.io/en/latest/dockerfile-guide/env_vs_arg.html">https://dockertips.readthedocs.io/en/latest/dockerfile-guide/env_vs_arg.html</a></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> alpine:3.16</span>

<span class="token instruction"><span class="token keyword">ARG</span> TARGETARCH=amd64 TERRAFORM_VERSION=<span class="token string">"1.2.9"</span></span>

<span class="token instruction"><span class="token keyword">RUN</span> apk update &amp;&amp; apk add --no-cache curl</span>

<span class="token instruction"><span class="token keyword">RUN</span> curl <span class="token operator">\</span>
    --location <span class="token operator">\</span>
    --output /tmp/terraform.zip <span class="token operator">\</span>
    https://releases.hashicorp.com/terraform/<span class="token variable">$&#123;TERRAFORM_VERSION&#125;</span>/terraform_<span class="token variable">$&#123;TERRAFORM_VERSION&#125;</span>_linux_<span class="token variable">$&#123;TARGETARCH&#125;</span>.zip <span class="token operator">\</span>
    &amp;&amp; unzip /tmp/terraform.zip -d /usr/local/bin <span class="token operator">\</span>
    &amp;&amp; rm -rf /tmp/terraform.zip</span>

<span class="token instruction"><span class="token keyword">CMD</span> []</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-构建镜像"><a href="#3-构建镜像" class="headerlink" title="3. 构建镜像"></a>3. 构建镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> buildx build <span class="token parameter variable">--push</span> <span class="token parameter variable">--platform</span> linux/arm64/v8,linux/amd64 <span class="token parameter variable">-t</span> xiaopeng163/terraform:1.2.9 <span class="token builtin class-name">.</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Building <span class="token number">27</span>.9s <span class="token punctuation">(</span><span class="token number">13</span>/13<span class="token punctuation">)</span> FINISHED
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>internal<span class="token punctuation">]</span> load build definition from Dockerfile                                                                                                                                                                          <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> transferring dockerfile: 460B                                                                                                                                                                                          <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>internal<span class="token punctuation">]</span> load .dockerignore                                                                                                                                                                                             <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> transferring context: 2B                                                                                                                                                                                               <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>linux/arm64 internal<span class="token punctuation">]</span> load metadata <span class="token keyword">for</span> docker.io/library/alpine:3.16                                                                                                                                                    <span class="token number">1</span>.2s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>linux/amd64 internal<span class="token punctuation">]</span> load metadata <span class="token keyword">for</span> docker.io/library/alpine:3.16                                                                                                                                                    <span class="token number">1</span>.1s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>auth<span class="token punctuation">]</span> library/alpine:pull token <span class="token keyword">for</span> registry-1.docker.io                                                                                                                                                                 <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>linux/arm64 <span class="token number">1</span>/3<span class="token punctuation">]</span> FROM docker.io/library/alpine:3.16@sha256:bc41182d7ef5ffc53a40b044e725193bc10142a1243f395ee852a8d9730fc2ad                                                                                              <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> resolve docker.io/library/alpine:3.16@sha256:bc41182d7ef5ffc53a40b044e725193bc10142a1243f395ee852a8d9730fc2ad                                                                                                          <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>linux/amd64 <span class="token number">1</span>/3<span class="token punctuation">]</span> FROM docker.io/library/alpine:3.16@sha256:bc41182d7ef5ffc53a40b044e725193bc10142a1243f395ee852a8d9730fc2ad                                                                                              <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> resolve docker.io/library/alpine:3.16@sha256:bc41182d7ef5ffc53a40b044e725193bc10142a1243f395ee852a8d9730fc2ad                                                                                                          <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> CACHED <span class="token punctuation">[</span>linux/arm64 <span class="token number">2</span>/3<span class="token punctuation">]</span> RUN apk update <span class="token operator">&amp;&amp;</span> apk <span class="token function">add</span> --no-cache <span class="token function">curl</span>                                                                                                                                                        <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> CACHED <span class="token punctuation">[</span>linux/arm64 <span class="token number">3</span>/3<span class="token punctuation">]</span> RUN <span class="token function">curl</span>     <span class="token parameter variable">--location</span>     <span class="token parameter variable">--output</span> /tmp/terraform.zip     https://releases.hashicorp.com/terraform/1.2.9/terraform_1.2.9_linux_arm64.zip     <span class="token operator">&amp;&amp;</span> <span class="token function">unzip</span> /tmp/terraform.zip <span class="token parameter variable">-d</span> /usr/local/bin     <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> CACHED <span class="token punctuation">[</span>linux/amd64 <span class="token number">2</span>/3<span class="token punctuation">]</span> RUN apk update <span class="token operator">&amp;&amp;</span> apk <span class="token function">add</span> --no-cache <span class="token function">curl</span>                                                                                                                                                        <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> CACHED <span class="token punctuation">[</span>linux/amd64 <span class="token number">3</span>/3<span class="token punctuation">]</span> RUN <span class="token function">curl</span>     <span class="token parameter variable">--location</span>     <span class="token parameter variable">--output</span> /tmp/terraform.zip     https://releases.hashicorp.com/terraform/1.2.9/terraform_1.2.9_linux_amd64.zip     <span class="token operator">&amp;&amp;</span> <span class="token function">unzip</span> /tmp/terraform.zip <span class="token parameter variable">-d</span> /usr/local/bin     <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> exporting to image                                                                                                                                                                                                       <span class="token number">26</span>.6s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting layers                                                                                                                                                                                                       <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting manifest sha256:14704a82f6f432f13057d06401c8bf704b85458e8531d2dda616774bbec27cce                                                                                                                             <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting config sha256:0592e737952d4a1bba5572696eee64f8aaa372127363f413c06641dfa099dac8                                                                                                                               <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting manifest sha256:469a68b5e84746d1415c931378d6078a54f5aabdedad599da281f4743bc1d504                                                                                                                             <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting config sha256:0b1fcf8214c11d7f696bce23d9800fed508e0526da7db0c640c079eb171a2b3b                                                                                                                               <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> exporting manifest list sha256:f137daace77c8b787d8a5cbf6b201605b62ac4b7455a56c38d5146a3fe7d55d0                                                                                                                        <span class="token number">0</span>.0s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> pushing layers                                                                                                                                                                                                        <span class="token number">25</span>.4s
<span class="token operator">=</span><span class="token operator">></span> <span class="token operator">=</span><span class="token operator">></span> pushing manifest <span class="token keyword">for</span> docker.io/xiaopeng163/terraform:1.2.9@sha256:f137daace77c8b787d8a5cbf6b201605b62ac4b7455a56c38d5146a3fe7d55d0                                                                                     <span class="token number">1</span>.2s
<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>auth<span class="token punctuation">]</span> xiaopeng163/terraform:pull,push token <span class="token keyword">for</span> registry-1.docker.io                                                                                                                                                     <span class="token number">0</span>.0s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>arch</tag>
        <tag>docker buildx</tag>
        <tag>image buildx</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 与 GitHub 实现 CICD</title>
    <url>//post/docker-cicd-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>



<h2 id="本章介绍"><a href="#本章介绍" class="headerlink" title="本章介绍"></a>本章介绍</h2><p>自动化构建和提交镜像</p>
<p><a href="https://github.com/xiaopeng163/docker.tips/blob/master/source/_static/docker-cicd/action1.PNG"><img src="https://github.com/xiaopeng163/docker.tips/raw/master/source/_static/docker-cicd/action1.PNG" alt="docker-cicd-1"></a></p>
<p>服务部署</p>
<p><a href="https://github.com/xiaopeng163/docker.tips/blob/master/source/_static/docker-cicd/action2.PNG"><img src="https://github.com/xiaopeng163/docker.tips/raw/master/source/_static/docker-cicd/action2.PNG" alt="docker-cicd-2"></a></p>
<p><code>github action</code> 的 <code>workflow</code> <code>docker-build.yml</code> 配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Docker image buildx and push
<span class="token key atrule">on</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>push<span class="token punctuation">]</span>
<span class="token key atrule">jobs</span><span class="token punctuation">:</span>
  <span class="token key atrule">Docker-Build-Push</span><span class="token punctuation">:</span>
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v2
      <span class="token punctuation">-</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Set up QEMU
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> docker/setup<span class="token punctuation">-</span>qemu<span class="token punctuation">-</span>action@v1
      <span class="token punctuation">-</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Set up Docker Buildx
        <span class="token key atrule">id</span><span class="token punctuation">:</span> buildx
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> docker/setup<span class="token punctuation">-</span>buildx<span class="token punctuation">-</span>action@v1
      <span class="token punctuation">-</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Login to DockerHub
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> docker/login<span class="token punctuation">-</span>action@v1 
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">username</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> secrets.DOCKERHUB_USERNAME <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
          <span class="token key atrule">password</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> secrets.DOCKERHUB_PASSWORD <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
      <span class="token punctuation">-</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> Build and push
        <span class="token key atrule">id</span><span class="token punctuation">:</span> docker_build
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> docker/build<span class="token punctuation">-</span>push<span class="token punctuation">-</span>action@v2
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">push</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
          <span class="token key atrule">platforms</span><span class="token punctuation">:</span> linux/amd64<span class="token punctuation">,</span>linux/arm64
          <span class="token key atrule">tags</span><span class="token punctuation">:</span> xiaopeng163/flask<span class="token punctuation">-</span>redis<span class="token punctuation">:</span>latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>GitHub Actions 文档 <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></p>
<p><code>课程源码</code></p>
<ul>
<li><a href="https://github.com/xiaopeng163/docker.tips">https://github.com/xiaopeng163/docker.tips</a></li>
<li><a href="https://github.com/xiaopeng163/flask-redis">https://github.com/xiaopeng163/flask-redis</a></li>
</ul>
<p><code>Ansible</code> 入门系列视频</p>
<ul>
<li>YouTube <a href="https://www.youtube.com/playlist?list=PLfQqWeOCIH4BDoRx8lpXXl4hqSD4GSDU5">https://www.youtube.com/playlist?list=PLfQqWeOCIH4BDoRx8lpXXl4hqSD4GSDU5</a></li>
<li>B站 <a href="https://space.bilibili.com/364122352/channel/detail?cid=125322">https://space.bilibili.com/364122352/channel/detail?cid=125322</a></li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>DockerHub</tag>
        <tag>GitHub</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Bridge 网络</title>
    <url>//post/docker-bridge-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>

<h2 id="网络基础知识回顾"><a href="#网络基础知识回顾" class="headerlink" title="网络基础知识回顾"></a>网络基础知识回顾</h2><p>IP、子网掩码、网关、DNS、端口号</p>
<p><a href="https://zhuanlan.zhihu.com/p/65226634">https://zhuanlan.zhihu.com/p/65226634</a></p>
<blockquote>
<p>面试常问的一个题目, 当你在浏览器中输入一个网址（比如 <code>www.baidu.com</code> ）并敲回车，这个过程后面都发生了什么</p>
</blockquote>
<h2 id="Internet如何工作的"><a href="#Internet如何工作的" class="headerlink" title="Internet如何工作的"></a>Internet如何工作的</h2><p><a href="https://www.hp.com/us-en/shop/tech-takes/how-does-the-internet-work">https://www.hp.com/us-en/shop/tech-takes/how-does-the-internet-work</a></p>
<p>从数据包的角度详细解析</p>
<p><a href="https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/">https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/</a></p>
<h2 id="网络常用命令"><a href="#网络常用命令" class="headerlink" title="网络常用命令"></a>网络常用命令</h2><h2 id="IP地址的查看"><a href="#IP地址的查看" class="headerlink" title="IP地址的查看"></a>IP地址的查看</h2><p><code>Windows</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>Linux</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span>

<span class="token function">ip</span> addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>或者</p>
<h2 id="网络连通性测试"><a href="#网络连通性测试" class="headerlink" title="网络连通性测试"></a>网络连通性测试</h2><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token operator">></span> <span class="token function">ping</span> <span class="token number">192.168</span>.178.1

Pinging <span class="token number">192.168</span>.178.1 with <span class="token number">32</span> bytes of data:
Reply from <span class="token number">192.168</span>.178.1: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">32</span> <span class="token assign-left variable">time</span><span class="token operator">=</span>2ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">64</span>
Reply from <span class="token number">192.168</span>.178.1: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">32</span> <span class="token assign-left variable">time</span><span class="token operator">=</span>3ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">64</span>
Reply from <span class="token number">192.168</span>.178.1: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">32</span> <span class="token assign-left variable">time</span><span class="token operator">=</span>3ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">64</span>
Reply from <span class="token number">192.168</span>.178.1: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">32</span> <span class="token assign-left variable">time</span><span class="token operator">=</span>3ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">64</span>

Ping statistics <span class="token keyword">for</span> <span class="token number">192.168</span>.178.1:
    Packets: Sent <span class="token operator">=</span> <span class="token number">4</span>, Received <span class="token operator">=</span> <span class="token number">4</span>, Lost <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>% loss<span class="token punctuation">)</span>,
Approximate round trip <span class="token builtin class-name">times</span> <span class="token keyword">in</span> milli-seconds:
    Minimum <span class="token operator">=</span> 2ms, Maximum <span class="token operator">=</span> 3ms, Average <span class="token operator">=</span> 2ms
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a>telnet命令</h3><p>测试端口的连通性</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  ~ telnet www.baidu.com <span class="token number">80</span>
Trying <span class="token number">104.193</span>.88.123<span class="token punctuation">..</span>.
Connected to www.wshifen.com.
Escape character is <span class="token string">'^]'</span><span class="token builtin class-name">.</span>

HTTP/1.1 <span class="token number">400</span> Bad Request

Connection closed by foreign host.
➜  ~
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>路径探测跟踪</p>
<p><code>Linux</code>下使用 <code>tracepath</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  ~ tracepath www.baidu.com
<span class="token number">1</span>?: <span class="token punctuation">[</span>LOCALHOST<span class="token punctuation">]</span>                      pmtu <span class="token number">1500</span>
<span class="token number">1</span>:  DESKTOP-FQ0EO8J                                       <span class="token number">0</span>.430ms
<span class="token number">1</span>:  DESKTOP-FQ0EO8J                                       <span class="token number">0</span>.188ms
<span class="token number">2</span>:  <span class="token number">192.168</span>.178.1                                         <span class="token number">3</span>.371ms
<span class="token number">3</span>:  no reply
<span class="token number">4</span>:  gv-rc0052-cr102-et91-251.core.as33915.net            <span class="token number">13</span>.970ms
<span class="token number">5</span>:  asd-tr0021-cr101-be156-10.core.as9143.net            <span class="token number">19</span>.190ms
<span class="token number">6</span>:  nl-ams04a-ri3-ae51-0.core.as9143.net                <span class="token number">213</span>.589ms
<span class="token number">7</span>:  <span class="token number">63.218</span>.65.33                                         <span class="token number">16</span>.887ms
<span class="token number">8</span>:  HundredGE0-6-0-0.br04.sjo01.pccwbtn.net             <span class="token number">176</span>.099ms asymm <span class="token number">10</span>
<span class="token number">9</span>:  HundredGE0-6-0-0.br04.sjo01.pccwbtn.net             <span class="token number">173</span>.399ms asymm <span class="token number">10</span>
<span class="token number">10</span>:  <span class="token number">63</span>-219-23-98.static.pccwglobal.net                  <span class="token number">177</span>.337ms asymm <span class="token number">11</span>
<span class="token number">11</span>:  <span class="token number">104.193</span>.88.13                                       <span class="token number">178</span>.197ms asymm <span class="token number">12</span>
<span class="token number">12</span>:  no reply
<span class="token number">13</span>:  no reply
<span class="token number">14</span>:  no reply
<span class="token number">15</span>:  no reply
<span class="token number">16</span>:  no reply
<span class="token number">17</span>:  no reply
<span class="token number">18</span>:  no reply
<span class="token number">19</span>:  no reply
<span class="token number">20</span>:  no reply
<span class="token number">21</span>:  no reply
<span class="token number">22</span>:  no reply
<span class="token number">23</span>:  no reply
<span class="token number">24</span>:  no reply
<span class="token number">25</span>:  no reply
<span class="token number">26</span>:  no reply
<span class="token number">27</span>:  no reply
<span class="token number">28</span>:  no reply
<span class="token number">29</span>:  no reply
<span class="token number">30</span>:  no reply
    Too many hops: pmtu <span class="token number">1500</span>
    Resume: pmtu <span class="token number">1500</span>
➜  ~
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Windows</code>下使用 <code>TRACERT.EXE</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token operator">></span> TRACERT.EXE www.baidu.com

Tracing route to www.wshifen.com <span class="token punctuation">[</span><span class="token number">104.193</span>.88.123<span class="token punctuation">]</span>
over a maximum of <span class="token number">30</span> hops:

<span class="token number">1</span>     <span class="token number">4</span> ms     <span class="token number">3</span> ms     <span class="token number">3</span> ms  <span class="token number">192.168</span>.178.1
<span class="token number">2</span>     *        *        *     Request timed out.
<span class="token number">3</span>    <span class="token number">21</span> ms    <span class="token number">18</span> ms    <span class="token number">19</span> ms  gv-rc0052-cr102-et91-251.core.as33915.net <span class="token punctuation">[</span><span class="token number">213.51</span>.197.37<span class="token punctuation">]</span>
<span class="token number">4</span>    <span class="token number">14</span> ms    <span class="token number">13</span> ms    <span class="token number">12</span> ms  asd-tr0021-cr101-be156-10.core.as9143.net <span class="token punctuation">[</span><span class="token number">213.51</span>.158.2<span class="token punctuation">]</span>
<span class="token number">5</span>    <span class="token number">23</span> ms    <span class="token number">19</span> ms    <span class="token number">14</span> ms  nl-ams04a-ri3-ae51-0.core.as9143.net <span class="token punctuation">[</span><span class="token number">213.51</span>.64.194<span class="token punctuation">]</span>
<span class="token number">6</span>    <span class="token number">15</span> ms    <span class="token number">14</span> ms    <span class="token number">13</span> ms  <span class="token number">63.218</span>.65.33
<span class="token number">7</span>   <span class="token number">172</span> ms   <span class="token number">169</span> ms   <span class="token number">167</span> ms  HundredGE0-6-0-0.br04.sjo01.pccwbtn.net <span class="token punctuation">[</span><span class="token number">63.223</span>.60.58<span class="token punctuation">]</span>
<span class="token number">8</span>   <span class="token number">167</span> ms   <span class="token number">168</span> ms   <span class="token number">168</span> ms  HundredGE0-6-0-0.br04.sjo01.pccwbtn.net <span class="token punctuation">[</span><span class="token number">63.223</span>.60.58<span class="token punctuation">]</span>
<span class="token number">9</span>   <span class="token number">168</span> ms   <span class="token number">173</span> ms   <span class="token number">167</span> ms  <span class="token number">63</span>-219-23-98.static.pccwglobal.net <span class="token punctuation">[</span><span class="token number">63.219</span>.23.98<span class="token punctuation">]</span>
<span class="token number">10</span>   <span class="token number">172</span> ms   <span class="token number">170</span> ms   <span class="token number">171</span> ms
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h2 id="Docker-Bridge-网络"><a href="#Docker-Bridge-网络" class="headerlink" title="Docker Bridge 网络"></a>Docker Bridge 网络</h2><p><img src="https://dockertips.readthedocs.io/en/latest/_images/two-container-network.png" alt="multi-host-volume"></p>
<h3 id="创建两个容器"><a href="#创建两个容器" class="headerlink" title="创建两个容器"></a>创建两个容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> box1 busybox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do sleep 3600; done"</span>
$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> box2 busybox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do sleep 3600; done"</span>
$ <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
4f3303c84e53   busybox   <span class="token string">"/bin/sh -c 'while t…"</span>   <span class="token number">49</span> minutes ago   Up <span class="token number">49</span> minutes             box2
03494b034694   busybox   <span class="token string">"/bin/sh -c 'while t…"</span>   <span class="token number">49</span> minutes ago   Up <span class="token number">49</span> minutes             box1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><p>两个容器都连接到了一个叫 <code>docker0</code> 的 <code>Linux bridge</code> 上</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> network <span class="token function">ls</span>

NETWORK ID     NAME      DRIVER    SCOPE
1847e179a316   bridge    bridge    <span class="token builtin class-name">local</span>
a647a4ad0b4f   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>
fbd81b56c009   none      null      <span class="token builtin class-name">local</span>
$ <span class="token function">docker</span> network inspect bridge
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"1847e179a316ee5219c951c2c21cf2c787d431d1ffb3ef621b8f0d1edd197b24"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-01T15:28:09.265408946Z"</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"EnableIPv6"</span><span class="token builtin class-name">:</span> false,
        <span class="token string">"IPAM"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,
            <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
            <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">&#123;</span>
                    <span class="token string">"Subnet"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.0/16"</span>,
                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"Internal"</span><span class="token builtin class-name">:</span> false,
        <span class="token string">"Attachable"</span><span class="token builtin class-name">:</span> false,
        <span class="token string">"Ingress"</span><span class="token builtin class-name">:</span> false,
        <span class="token string">"ConfigFrom"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Network"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"ConfigOnly"</span><span class="token builtin class-name">:</span> false,
        <span class="token string">"Containers"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"03494b034694982fa085cc4052b6c7b8b9c046f9d5f85f30e3a9e716fad20741"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"box1"</span>,
                <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"072160448becebb7c9c333dce9bbdf7601a92b1d3e7a5820b8b35976cf4fd6ff"</span>,
                <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,
                <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.2/16"</span>,
                <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>
            <span class="token punctuation">&#125;</span>,
            <span class="token string">"4f3303c84e5391ea37db664fd08683b01decdadae636aaa1bfd7bb9669cbd8de"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"box2"</span>,
                <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"4cf0f635d4273066acd3075ec775e6fa405034f94b88c1bcacdaae847612f2c5"</span>,
                <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,
                <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.3/16"</span>,
                <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token builtin class-name">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token builtin class-name">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token builtin class-name">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token builtin class-name">:</span> <span class="token string">"0.0.0.0"</span>,
            <span class="token string">"com.docker.network.bridge.name"</span><span class="token builtin class-name">:</span> <span class="token string">"docker0"</span>,
            <span class="token string">"com.docker.network.driver.mtu"</span><span class="token builtin class-name">:</span> <span class="token string">"1500"</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><code>brctl</code> 使用前需要安装, 对于<code>CentOS</code>, 可以通过 <code>sudo yum install -y bridge-utils</code> 安装. 对于<code>Ubuntu</code>, 可以通过 <code>sudo apt-get install -y bridge-utils</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brctl show
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0         <span class="token number">8000</span>.0242759468cf       no              veth8c9bb82<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<h3 id="容器对外通信"><a href="#容器对外通信" class="headerlink" title="容器对外通信"></a>容器对外通信</h3><p>查看路由</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ip</span> route
default via <span class="token number">10.0</span>.2.2 dev eth0 proto dhcp metric <span class="token number">100</span>
<span class="token number">10.0</span>.2.0/24 dev eth0 proto kernel scope <span class="token function">link</span> src <span class="token number">10.0</span>.2.15 metric <span class="token number">100</span>
<span class="token number">172.17</span>.0.0/16 dev docker0 proto kernel scope <span class="token function">link</span> src <span class="token number">172.17</span>.0.1
<span class="token number">192.168</span>.200.0/24 dev eth1 proto kernel scope <span class="token function">link</span> src <span class="token number">192.168</span>.200.10 metric <span class="token number">101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>iptable</code>  转发规则</p>
<p><code>iptable</code> 参考资料 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> iptables <span class="token parameter variable">--list</span> <span class="token parameter variable">-t</span> nat
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere            <span class="token operator">!</span>loopback/8           ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
MASQUERADE  all  --  <span class="token number">172.17</span>.0.0/16        anywhere

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
RETURN     all  --  anywhere             anywhere<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>创建容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> web <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 nginx
$ <span class="token function">docker</span> container inspect <span class="token parameter variable">--format</span> <span class="token string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> web
$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> client busybox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do sleep 3600; done"</span>
$ <span class="token function">docker</span> container inspect <span class="token parameter variable">--format</span> <span class="token string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> client
$ <span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> client <span class="token function">wget</span> http://172.17.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看 <code>iptables</code> 的<code>端口转发</code>规则</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvxL</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">10</span> packets, <span class="token number">1961</span> bytes<span class="token punctuation">)</span>
    pkts      bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">1</span>       <span class="token number">52</span> DOCKER     all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">9</span> packets, <span class="token number">1901</span> bytes<span class="token punctuation">)</span>
    pkts      bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">2</span> packets, <span class="token number">120</span> bytes<span class="token punctuation">)</span>
    pkts      bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">0</span>        <span class="token number">0</span> DOCKER     all  --  *      *       <span class="token number">0.0</span>.0.0/0           <span class="token operator">!</span><span class="token number">127.0</span>.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">4</span> packets, <span class="token number">232</span> bytes<span class="token punctuation">)</span>
    pkts      bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">3</span>      <span class="token number">202</span> MASQUERADE  all  --  *      <span class="token operator">!</span>docker0  <span class="token number">172.17</span>.0.0/16        <span class="token number">0.0</span>.0.0/0
    <span class="token number">0</span>        <span class="token number">0</span> MASQUERADE  tcp  --  *      *       <span class="token number">172.17</span>.0.2           <span class="token number">172.17</span>.0.2           tcp dpt:80

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
    pkts      bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">0</span>        <span class="token number">0</span> RETURN     all  --  docker0 *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0
    <span class="token number">1</span>       <span class="token number">52</span> DNAT       tcp  --  <span class="token operator">!</span>docker0 *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8080 to:172.17.0.2:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="创建和使用-bridge"><a href="#创建和使用-bridge" class="headerlink" title="创建和使用 bridge"></a>创建和使用 bridge</h2><p>创建 bridge</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge mybridge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看 <code>bridge</code> 信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network inspect mybridge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建容器时使用 <code>mybridge</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> box3 <span class="token parameter variable">--network</span> mybridge busybox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do sleep 3600; done"</span>

<span class="token function">docker</span> container <span class="token function">ls</span>

<span class="token comment"># 查看容器信息</span>
<span class="token function">docker</span> container inspect box3

<span class="token comment"># 查看 mybridge 下 的信息</span>
<span class="token function">docker</span> network inspect mybridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将容器连接到两个不同的 <code>bridge</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network <span class="token function">ls</span>

<span class="token comment"># docker network connect 网络名 容器名</span>
<span class="token function">docker</span> network connect bridge box3

<span class="token comment"># 查看容器信息</span>
<span class="token function">docker</span> container inspect box3

<span class="token comment"># 进入容器 ip a</span>
<span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> box <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>创建新的 <code>box4</code> 连接到 自定义的 <code>bridge</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> box4 <span class="token parameter variable">--network</span> mybridge busybox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do sleep 3600; done"</span>

<span class="token comment"># box3 于 box4 互相 ping</span>
<span class="token function">docker</span> container  <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> box4 <span class="token function">ping</span> <span class="token number">172.18</span>.0.2
<span class="token comment"># 可以使用容器名去 ping 类似 DNS</span>
<span class="token function">docker</span> container  <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> box4 <span class="token function">ping</span> box3

<span class="token comment"># 默认的 bridge 不支持使用容器名去互相 ping</span>
<span class="token comment"># 默认的 docker0 的 bridge 不提供 DNS 这样的功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在去使用 <code>docker</code> 时 ， 推荐创建自己的 <code>network</code>， 而不是使用默认的 <code>docker0 bridge</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network create <span class="token parameter variable">--help</span>

<span class="token comment"># --geteway</span>
<span class="token comment"># --subnet</span>
<span class="token comment"># 在创建network时 可以通过参数指定配置</span>

<span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge <span class="token parameter variable">--geteway</span> <span class="token number">170.200</span>.0.1 <span class="token parameter variable">--subnet</span> <span class="token number">172.200</span>.0.0/16 demo

<span class="token function">docker</span> network inspect demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Docker-Host-网络"><a href="#Docker-Host-网络" class="headerlink" title="Docker Host 网络"></a>Docker Host 网络</h2><h2 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h2><p><code>Linux</code> 的 <code>Namespace</code>（命名空间）技术是一种隔离技术，常用的 <code>Namespace</code> 有 <code>user namespace</code>, <code>process namespace</code>, <code>network namespace</code>等</p>
<p>在 <code>Docker</code> 容器中，不同的容器通过 <code>Network namespace</code> 进行了隔离，也就是不同的容器有各自的<code>IP</code>地址，<code>路由表</code>等，互不影响。</p>
<p><code>Note</code>：准备一台<code>Linux</code>机器，这一节会用到一个叫 <code>brtcl</code> 的命令，这个命令需要安装，如果是<code>Ubuntu</code>的系统，可以通过 <code>apt-get install bridge-utils</code> 安装；如果是<code>Centos</code>系统，可以通过 <code>sudo yum install bridge-utils</code> 来安装</p>
<p><img src="https://dockertips.readthedocs.io/en/latest/_images/network-namespace.png" alt="docker-volume"></p>
<h3 id="创建bridge"><a href="#创建bridge" class="headerlink" title="创建bridge"></a>创建bridge</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> brctl addbr mydocker0
<span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ brctl show
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
mydocker0               <span class="token number">8000.000000000000</span>       no
<span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="准备一个shell脚本"><a href="#准备一个shell脚本" class="headerlink" title="准备一个shell脚本"></a>准备一个shell脚本</h3><p>脚本名字叫 <code>add-ns-to-br.sh</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">bridge</span><span class="token operator">=</span><span class="token variable">$1</span>
<span class="token assign-left variable">namespace</span><span class="token operator">=</span><span class="token variable">$2</span>
<span class="token assign-left variable">addr</span><span class="token operator">=</span><span class="token variable">$3</span>

<span class="token assign-left variable">vethA</span><span class="token operator">=</span>veth-<span class="token variable">$namespace</span>
<span class="token assign-left variable">vethB</span><span class="token operator">=</span>eth00-<span class="token variable">$namespace</span>

<span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">add</span> <span class="token variable">$namespace</span>
<span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> <span class="token variable">$vethA</span> <span class="token builtin class-name">type</span> veth peer name <span class="token variable">$vethB</span>

<span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> <span class="token variable">$vethB</span> netns <span class="token variable">$namespace</span>
<span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$namespace</span> <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token variable">$addr</span> dev <span class="token variable">$vethB</span>
<span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$namespace</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> <span class="token variable">$vethB</span> up

<span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> <span class="token variable">$vethA</span> up

<span class="token function">sudo</span> brctl addif <span class="token variable">$bridge</span> <span class="token variable">$vethA</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sh</span> add-ns-to-br.sh mydocker0 ns1 <span class="token number">172.16</span>.1.1/16
<span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sh</span> add-ns-to-br.sh mydocker0 ns2 <span class="token number">172.16</span>.1.2/16
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>把<code>mydocker0</code>这个<code>bridge</code> <code>up</code>起来</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev mydocker0 up
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> ns1 <span class="token function">bash</span>
<span class="token punctuation">[</span>root@docker-host1 vagrant<span class="token punctuation">]</span><span class="token comment"># ip a</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
<span class="token number">5</span>: eth00@if6: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default qlen <span class="token number">1000</span>
    link/ether f2:59:19:34:73:70 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.16</span>.1.1/16 scope global eth00
    valid_lft forever preferred_lft forever
    inet6 fe80::f059:19ff:fe34:7370/64 scope <span class="token function">link</span>
    valid_lft forever preferred_lft forever
<span class="token punctuation">[</span>root@docker-host1 vagrant<span class="token punctuation">]</span><span class="token comment"># ping 172.16.1.2</span>
PING <span class="token number">172.16</span>.1.2 <span class="token punctuation">(</span><span class="token number">172.16</span>.1.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">172.16</span>.1.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.029</span> ms
<span class="token number">64</span> bytes from <span class="token number">172.16</span>.1.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.080</span> ms
^C
--- <span class="token number">172.16</span>.1.2 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 1000ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.029</span>/0.054/0.080/0.026 ms
<span class="token punctuation">[</span>root@docker-host1 vagrant<span class="token punctuation">]</span><span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="对外通信"><a href="#对外通信" class="headerlink" title="对外通信"></a>对外通信</h3><p><a href="https://www.karlrupp.net/en/computer/nat_tutorial">https://www.karlrupp.net/en/computer/nat_tutorial</a></p>
<h2 id="Python-Flask-Redis-练习"><a href="#Python-Flask-Redis-练习" class="headerlink" title="Python Flask + Redis 练习"></a>Python Flask + Redis 练习</h2><h3 id="程序准备"><a href="#程序准备" class="headerlink" title="程序准备"></a>程序准备</h3><p>准备一个<code>Python</code>文件，名字为 <code>app.py</code> 内容如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
<span class="token keyword">from</span> redis <span class="token keyword">import</span> Redis
<span class="token keyword">import</span> os
<span class="token keyword">import</span> socket

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'REDIS_HOST'</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    redis<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"Hello Container World! I have been seen </span><span class="token interpolation"><span class="token punctuation">&#123;</span>redis<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string"> times and my hostname is </span><span class="token interpolation"><span class="token punctuation">&#123;</span>socket<span class="token punctuation">.</span>gethostname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">.\n"</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>准备一个<code>Dockerfile</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask redis &amp;&amp; <span class="token operator">\</span>
    groupadd -r flask &amp;&amp; useradd -r -g flask flask &amp;&amp; <span class="token operator">\</span>
    mkdir /src &amp;&amp; <span class="token operator">\</span>
    chown -R flask:flask /src</span>

<span class="token instruction"><span class="token keyword">USER</span> flask</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>

<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py REDIS_HOST=redis</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h3><p>构建<code>flask</code>镜像，准备一个<code>redis</code>镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image pull redis
$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> flask-demo <span class="token builtin class-name">.</span>
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY   TAG          IMAGE ID       CREATED              SIZE
flask-demo   latest       4778411a24c5   About a minute ago   126MB
python       <span class="token number">3.9</span>.5-slim   c71955050276   <span class="token number">8</span> days ago           115MB
redis        latest       08502081bff6   <span class="token number">2</span> weeks ago          105MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="创建一个docker-bridge"><a href="#创建一个docker-bridge" class="headerlink" title="创建一个docker bridge"></a>创建一个docker bridge</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge demo-network
8005f4348c44ffe3cdcbbda165beea2b0cb520179d3745b24e8f9e05a3e6456d
$ <span class="token function">docker</span> network <span class="token function">ls</span>
NETWORK ID     NAME           DRIVER    SCOPE
2a464c0b8ec7   bridge         bridge    <span class="token builtin class-name">local</span>
8005f4348c44   demo-network   bridge    <span class="token builtin class-name">local</span>
80b63f711a37   <span class="token function">host</span>           <span class="token function">host</span>      <span class="token builtin class-name">local</span>
fae746a75be1   none           null      <span class="token builtin class-name">local</span>
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="创建redis-container"><a href="#创建redis-container" class="headerlink" title="创建redis container"></a>创建redis container</h3><p>创建一个叫 <code>redis-server</code> 的<code>container</code>，连到 <code>demo-network</code> 上</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-server <span class="token parameter variable">--network</span> demo-network redis
002800c265020310231d689e6fd35bc084a0fa015e8b0a3174aa2c5e29824c0e
$ <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS      NAMES
002800c26502   redis     <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">4</span> seconds ago   Up <span class="token number">3</span> seconds   <span class="token number">6379</span>/tcp   redis-server
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="创建flask-container"><a href="#创建flask-container" class="headerlink" title="创建flask container"></a>创建flask container</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> demo-network <span class="token parameter variable">--name</span> flask-demo <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_HOST</span><span class="token operator">=</span>redis-server <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 flask-demo
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>打开浏览器访问 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a></p>
<p>应该能看到类似下面的内容，每次刷新页面，计数加<code>1</code></p>
<p>Hello Container World! I have been seen 36 times and my hostname is 925ecb8d111a.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果把上面的步骤合并到一起，成为一个部署脚本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># prepare image</span>
<span class="token function">docker</span> image pull redis
<span class="token function">docker</span> image build <span class="token parameter variable">-t</span> flask-demo <span class="token builtin class-name">.</span>

<span class="token comment"># create network</span>
<span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge demo-network

<span class="token comment"># create container</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-server <span class="token parameter variable">--network</span> demo-network redis
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> demo-network <span class="token parameter variable">--name</span> flask-demo <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_HOST</span><span class="token operator">=</span>redis-server <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 flask-demo
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Bridge</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 命令行</title>
    <url>//post/docker-command-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<p>基于存储库<code>docker-test</code>，运行环境是在 <code>github</code> 的 <code>codespace</code> 中</p>
<span id="more"></span>


<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><blockquote>
<p><em><strong>docker 版本信息</strong></em></p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>输出：</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Client:
 Version:           <span class="token number">23.0</span>.7+azure-1
 API version:       <span class="token number">1.42</span>
 Go version:        go1.19.12
 Git commit:        92955ed461e91154ed722ed831e9f22ea93fd7e9
 Built:             Wed Aug <span class="token number">23</span> <span class="token number">12</span>:04:52 UTC <span class="token number">2023</span>
 OS/Arch:           linux/amd64
 Context:           default

Server:
 Engine:
  Version:          <span class="token number">23.0</span>.7+azure-1
  API version:      <span class="token number">1.42</span> <span class="token punctuation">(</span>minimum version <span class="token number">1.12</span><span class="token punctuation">)</span>
  Go version:       go1.19.12
  Git commit:       606a7a76949ec08cb26940037b1c71c0024c6b44
  Built:            Wed Sep  <span class="token number">6</span> 06:38:37 <span class="token number">2023</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="token boolean">false</span>
 containerd:
  Version:          <span class="token number">1.6</span>.24-2
  GitCommit:        61f9fd88f79f081d64d6fa3bb1a0dc71ec870523
 runc:
  Version:          <span class="token number">1.1</span>.9-1
  GitCommit:        ccaecfcbc907d70a7aa870a6650887b901b25b82
 docker-init:
  Version:          <span class="token number">0.19</span>.0
  GitCommit:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<blockquote>
<p><em><strong>docker 环境信息</strong></em></p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>输出：</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Client:
 Context:    default
 Debug Mode: <span class="token boolean">false</span>
 Plugins:
  buildx: Docker Buildx <span class="token punctuation">(</span>Docker Inc.<span class="token punctuation">)</span>
    Version:  <span class="token number">0.11</span>.2+azure-3
    Path:     /usr/libexec/docker/cli-plugins/docker-buildx
  compose: Docker Compose <span class="token punctuation">(</span>Docker Inc.<span class="token punctuation">)</span>
    Version:  <span class="token number">2.22</span>.0-1
    Path:     /usr/libexec/docker/cli-plugins/docker-compose

Server:
 Containers: <span class="token number">0</span>
  Running: <span class="token number">0</span>
  Paused: <span class="token number">0</span>
  Stopped: <span class="token number">0</span>
 Images: <span class="token number">0</span>
 Server Version: <span class="token number">23.0</span>.7+azure-1
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: <span class="token boolean">true</span>
  Using metacopy: <span class="token boolean">false</span>
  Native Overlay Diff: <span class="token boolean">false</span>
  userxattr: <span class="token boolean">false</span>
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: <span class="token number">2</span>
 Plugins:
  Volume: <span class="token builtin class-name">local</span>
  Network: bridge <span class="token function">host</span> ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file <span class="token builtin class-name">local</span> logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 61f9fd88f79f081d64d6fa3bb1a0dc71ec870523
 runc version: ccaecfcbc907d70a7aa870a6650887b901b25b82
 init version:
 Security Options:
  apparmor
  seccomp
   Profile: <span class="token builtin class-name">builtin</span>
  cgroupns
 Kernel Version: <span class="token number">6.2</span>.0-1015-azure
 Operating System: Ubuntu <span class="token number">20.04</span>.6 LTS <span class="token punctuation">(</span>containerized<span class="token punctuation">)</span>
 OSType: linux
 Architecture: x86_64
 CPUs: <span class="token number">2</span>
 Total Memory: <span class="token number">7</span>.744GiB
 Name: codespaces-4da6ac
 ID: 7d145c8f-4865-4a57-adfb-ce2e04573a75
 Docker Root Dir: /var/lib/docker
 Debug Mode: <span class="token boolean">false</span>
 Username: codespacesdev
 Registry: https://index.docker.io/v1/
 Experimental: <span class="token boolean">false</span>
 Insecure Registries:
  <span class="token number">127.0</span>.0.0/8
 Live Restore Enabled: <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<blockquote>
<p><em><strong>docker 命令用法</strong></em></p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>输出：</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
Usage:  <span class="token function">docker</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> COMMAND

A self-sufficient runtime <span class="token keyword">for</span> containers

Common Commands:
  run         Create and run a new container from an image
  <span class="token builtin class-name">exec</span>        Execute a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a running container
  <span class="token function">ps</span>          List containers
  build       Build an image from a Dockerfile
  pull        Download an image from a registry
  push        Upload an image to a registry
  images      List images
  login       Log <span class="token keyword">in</span> to a registry
  <span class="token builtin class-name">logout</span>      Log out from a registry
  search      Search Docker Hub <span class="token keyword">for</span> images
  version     Show the Docker version information
  info        Display system-wide information

Management Commands:
  builder     Manage builds
  buildx*     Docker Buildx <span class="token punctuation">(</span>Docker Inc., <span class="token number">0.11</span>.2+azure-3<span class="token punctuation">)</span>
  compose*    Docker Compose <span class="token punctuation">(</span>Docker Inc., <span class="token number">2.22</span>.0-1<span class="token punctuation">)</span>
  container   Manage containers
  context     Manage contexts
  image       Manage images
  manifest    Manage Docker image manifests and manifest lists
  network     Manage networks
  plugin      Manage plugins
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Swarm Commands:
  swarm       Manage Swarm

Commands:
  attach      Attach <span class="token builtin class-name">local</span> standard input, output, and error streams to a running container
  commit      Create a new image from a container<span class="token string">'s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container'</span>s filesystem
  events      Get real <span class="token function">time</span> events from the server
  <span class="token builtin class-name">export</span>      Export a container<span class="token string">'s filesystem as a tar archive
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes

Global Options:
      --config string      Location of client config files (default "/home/codespace/.docker")
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket to connect to
  -l, --log-level string   Set the logging level ("debug", "info", "warn", "error", "fatal") (default "info")
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default "/home/codespace/.docker/ca.pem")
      --tlscert string     Path to TLS certificate file (default "/home/codespace/.docker/cert.pem")
      --tlskey string      Path to TLS key file (default "/home/codespace/.docker/key.pem")
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Run '</span><span class="token function">docker</span> COMMAND --help' <span class="token keyword">for</span> <span class="token function">more</span> information on a command.

For <span class="token function">more</span> <span class="token builtin class-name">help</span> on how to use Docker, <span class="token function">head</span> to https://docs.docker.com/go/guides/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<blockquote>
<p><em><strong>docker 命令帮助查看</strong></em></p>
</blockquote>
<p>Management Commands</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>输出：</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
Usage:  <span class="token function">docker</span> container COMMAND

Manage containers

Commands:
  attach      Attach <span class="token builtin class-name">local</span> standard input, output, and error streams to a running container
  commit      Create a new image from a container<span class="token string">'s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container'</span>s filesystem
  <span class="token builtin class-name">exec</span>        Execute a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a running container
  <span class="token builtin class-name">export</span>      Export a container<span class="token string">'s filesystem as a tar archive
  inspect     Display detailed information on one or more containers
  kill        Kill one or more running containers
  logs        Fetch the logs of a container
  ls          List containers
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  prune       Remove all stopped containers
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  run         Create and run a new container from an image
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes

Run '</span><span class="token function">docker</span> container COMMAND --help' <span class="token keyword">for</span> <span class="token function">more</span> information on a command.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h2 id="批量操作命令"><a href="#批量操作命令" class="headerlink" title="批量操作命令"></a>批量操作命令</h2><p><em><strong>列出所有 container的 ID</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p><em><strong>批量停止运行所有 container</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container stop <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>批量删除所有 container</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>强制删除运行中的 container</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span> <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>运行停止后自动删除的 container</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span>  <span class="token operator">&lt;</span>Image ID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>清除所有停止的 container</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> system prune <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>清除所有未使用的 Image镜像</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image prune <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="容器-attached-和-detached-运行模式"><a href="#容器-attached-和-detached-运行模式" class="headerlink" title="容器 attached 和 detached 运行模式"></a>容器 attached 和 detached 运行模式</h2><p><code>attached</code> 模式在前台运行，ctrl + c 会终止运行，信号传递到容器内部<br><code>detached</code> 模式在后台运行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># attached</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 nginx

<span class="token comment"># detached</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 nginx

<span class="token comment"># 重新 attach 到容器</span>
<span class="token function">docker</span> container attach <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>

<span class="token comment"># 或者查看日志</span>
<span class="token function">docker</span> container logs <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>
<span class="token comment"># 动态跟踪日志</span>
<span class="token function">docker</span> container logs <span class="token operator">&lt;</span>Container ID<span class="token operator">></span> <span class="token parameter variable">-f</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="容器-交互式模式-it"><a href="#容器-交互式模式-it" class="headerlink" title="容器 交互式模式 -it"></a>容器 交互式模式 -it</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 交互式创建运行容器并进入 ubuntu 容器 shell 中</span>
<span class="token comment"># exit 退出 shell 脚本环境， 容器会停止运行</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> ubuntu <span class="token function">sh</span>

<span class="token comment"># 已经运行的容器通过命令进入交互式模式</span>
<span class="token comment"># exit 退出 shell 脚本环境， 容器不会停止运行</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>Container ID<span class="token operator">></span> <span class="token function">sh</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<hr>
<p><em><strong>交互式运行 busybox</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-it</span> busybox <span class="token function">sh</span>
<span class="token comment"># container 的ip地址</span>
<span class="token function">ip</span> a
<span class="token comment"># ping</span>
<span class="token function">ping</span> www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Busybox</code> 是一个精简的 <code>Linux</code> 工具集合，你可以使用它进行<code>文件操作</code>、查看<code>网络配置</code>、<code>测试网络连通性</code>等。它提供了许多常用的<code>命令</code>和<code>工具</code>，包括<code>文件操作</code>、<code>文本处理</code>、<code>网络工具</code>等等。</p>
<p><code>Busybox</code> 镜像的主要用途是在 <code>Docker</code> 容器中提供一个轻量级的基础环境。</p>
<p>它可以用作其他 <code>Docker</code> 镜像的<code>基础镜像</code>，也可以作为临时容器用于<code>调试</code>和<code>测试</code>。</p>
<p>由于 <code>Busybox</code> 镜像非常小巧，仅包含最基本的工具和命令，因此它可以帮助减小容器的大小和资源占用，并提高容器的启动速度。</p>
<p>它适用于那些只需要基本功能的应用场景，或者在构建<code>定制化</code>的<code>容器镜像</code>时作为<code>基础层</code>使用。</p>
<p><em><strong>查看容器中运行的进程</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">docker</span> container <span class="token function">top</span> <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>

<span class="token comment"># 结果</span>
<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMD
root                <span class="token number">4057</span>                <span class="token number">4038</span>                <span class="token number">0</span>                   05:47               ?                   00:00:00            nginx: master process nginx <span class="token parameter variable">-g</span> daemon off<span class="token punctuation">;</span>
systemd+            <span class="token number">4151</span>                <span class="token number">4057</span>                <span class="token number">0</span>                   05:47               ?                   00:00:00            nginx: worker process
systemd+            <span class="token number">4152</span>                <span class="token number">4057</span>                <span class="token number">0</span>                   05:47               ?                   00:00:00            nginx: worker process


<span class="token comment"># 宿主机系统中查看进程</span>
<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> nginx
<span class="token comment"># 容器即进程</span>

<span class="token comment"># 结果</span>
root        <span class="token number">4057</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">11392</span>  <span class="token number">7040</span> ?        Ss   05:47   <span class="token number">0</span>:00 nginx: master process nginx <span class="token parameter variable">-g</span> daemon off<span class="token punctuation">;</span>
systemd+    <span class="token number">4151</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">11856</span>  <span class="token number">2908</span> ?        S    05:47   <span class="token number">0</span>:00 nginx: worker process
systemd+    <span class="token number">4152</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">11856</span>  <span class="token number">2908</span> ?        S    05:47   <span class="token number">0</span>:00 nginx: worker process
codespa+    <span class="token number">5920</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">8172</span>  <span class="token number">2304</span> pts/0    S+   05:52   <span class="token number">0</span>:00 <span class="token function">grep</span> <span class="token parameter variable">--color</span><span class="token operator">=</span>auto nginx

<span class="token comment"># 查看进程树关系</span>
pstree <span class="token parameter variable">-halps</span> <span class="token number">4151</span>

<span class="token comment"># 结果</span>
docker-init,1 -- /bin/sh <span class="token parameter variable">-c</span> <span class="token builtin class-name">echo</span> Container started<span class="token punctuation">\</span>012trap <span class="token string">"exit 0"</span> <span class="token number">15</span><span class="token punctuation">\</span>012/usr/local/share/ssh-init.sh<span class="token punctuation">\</span>012/usr/local/share/docker-init.sh<span class="token punctuation">\</span>012exec <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">\</span>012while <span class="token function">sleep</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token function">wait</span> <span class="token variable">$!</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">:</span><span class="token punctuation">;</span> <span class="token keyword">done</span> - /usr/local/share/docker-init.sh /usr/local/share/ssh-init.sh <span class="token function">sleep</span> infinity
  └─containerd-shim,4038 <span class="token parameter variable">-namespace</span> moby <span class="token parameter variable">-id</span> 3a6eb3f56e8b3a874edd663a07652e4d200a4a7a45cb822f27a12c2e3ac8a192 <span class="token parameter variable">-address</span> /var/run/docker/containerd/containerd.sock
      └─nginx,4057
          └─nginx,4151
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="镜像的创建-管理-发布"><a href="#镜像的创建-管理-发布" class="headerlink" title="镜像的创建 管理 发布"></a>镜像的创建 管理 发布</h2><ul>
<li><p>pull from <code>registry</code> (<code>online</code>) 从<code>registry</code>拉取</p>
<ul>
<li>public（公有）</li>
<li>private（私有）</li>
</ul>
</li>
<li><p><code>build</code> from <code>Dockerfile</code> (<code>online</code>) 从<code>Dockerfile</code>构建</p>
</li>
<li><p><code>load</code> from <code>file</code> (<code>offline</code>) 文件导入 （离线）</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">docker</span> image
<span class="token comment"># 结果</span>
Usage:  <span class="token function">docker</span> image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile
  <span class="token function">history</span>     Show the <span class="token function">history</span> of an image
  <span class="token function">import</span>      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or <span class="token function">more</span> images
  load        Load an image from a <span class="token function">tar</span> archive or STDIN
  <span class="token function">ls</span>          List images
  prune       Remove unused images
  pull        Download an image from a registry
  push        Upload an image to a registry
  <span class="token function">rm</span>          Remove one or <span class="token function">more</span> images
  save        Save one or <span class="token function">more</span> images to a <span class="token function">tar</span> archive <span class="token punctuation">(</span>streamed to STDOUT by default<span class="token punctuation">)</span>
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

Run <span class="token string">'docker image COMMAND --help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information on a command.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="镜像的拉取Pull-Image"><a href="#镜像的拉取Pull-Image" class="headerlink" title="镜像的拉取Pull Image"></a>镜像的拉取Pull Image</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拉取最新</span>
<span class="token function">docker</span> pull nginx
<span class="token function">docker</span> pull nginx:latest

<span class="token comment"># 指定版本</span>
<span class="token function">docker</span> pull nginx:1.20.0

<span class="token comment"># 从Quay上拉取镜像</span>
<span class="token function">docker</span> pull quay.io/bitnami/nginx

<span class="token comment"># 结果</span>
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      <span class="token punctuation">..</span>.
        <span class="token comment"># cpu 架构</span>
        <span class="token string">"Architecture"</span><span class="token builtin class-name">:</span> <span class="token string">"amd64"</span>,
        <span class="token comment"># 系统</span>
        <span class="token string">"Os"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,
      <span class="token punctuation">..</span>.
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="镜像的查看"><a href="#镜像的查看" class="headerlink" title="镜像的查看"></a>镜像的查看</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images
<span class="token function">docker</span> image <span class="token function">ls</span>
<span class="token comment"># 结果</span>
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    593aee2afb64   <span class="token number">30</span> hours ago   187MB
ubuntu       latest    e4c58958181a   <span class="token number">3</span> weeks ago    <span class="token number">77</span>.8MB
busybox      latest    a416a98b71e2   <span class="token number">3</span> months ago   <span class="token number">4</span>.26MB

<span class="token comment"># image 详细信息</span>
<span class="token function">docker</span> image inspect 593aee2afb64

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="镜像的删除"><a href="#镜像的删除" class="headerlink" title="镜像的删除"></a>镜像的删除</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">rm</span> 0922eabe1625
<span class="token comment"># 强制删除</span>
<span class="token function">docker</span> image <span class="token function">rm</span> 0922eabe1625 <span class="token parameter variable">-f</span>
<span class="token comment"># 结果</span>
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:2b7412e6465c3c7fc5bb21d3e6f1917c167358449fecac8176c6e496e5c1f05f
Deleted: sha256:e4c58958181a5925816faa528ce959e487632f4cfd192f8132f71b32df2744b4
Deleted: sha256:256d88da41857db513b95b50ba9a9b28491b58c954e25477d5dad8abb465430b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="镜像的导出和导入-offline"><a href="#镜像的导出和导入-offline" class="headerlink" title="镜像的导出和导入 (offline)"></a>镜像的导出和导入 (offline)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 导出</span>
<span class="token function">docker</span> image save nginx:latest <span class="token parameter variable">-o</span> nginx.image

<span class="token comment"># 导入</span>
<span class="token function">docker</span> image load <span class="token parameter variable">-i</span> ./nginx.image
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="Dockerfile-介绍"><a href="#Dockerfile-介绍" class="headerlink" title="Dockerfile 介绍"></a>Dockerfile 介绍</h3><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<ul>
<li><p><code>Dockerfile</code> 是用于构建<code>docker</code>镜像的文件</p>
</li>
<li><p><code>Dockerfile</code> 里包含了构建镜像所需的<code>“指令”</code></p>
</li>
<li><p><code>Dockerfile</code> 有其特定的语法规则</p>
</li>
</ul>
<h4 id="举例：执行一个Python程序"><a href="#举例：执行一个Python程序" class="headerlink" title="举例：执行一个Python程序"></a>举例：执行一个Python程序</h4><p>容器即进程，所以镜像就是一个运行这个进程所需要的环境。</p>
<p>假如我们要在一台<code>ubuntu 22.04</code>上运行下面这个 <code>hello.py</code> 的 <code>Python</code> 程序</p>
<p><code>hello.py</code>的文件内容：</p>
<p>第一步，准备<code>Python</code>环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
<span class="token assign-left variable">DEBIAN_FRONTEND</span><span class="token operator">=</span>noninteractive <span class="token function">apt-get</span> <span class="token function">install</span> --no-install-recommends <span class="token parameter variable">-y</span> python3.10 python3-pip python3.10-dev
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>第二步，运行 <code>hello.py</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 hello.py
hello <span class="token function">docker</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h4 id="一个Dockerfile的基本结构"><a href="#一个Dockerfile的基本结构" class="headerlink" title="一个Dockerfile的基本结构"></a>一个Dockerfile的基本结构</h4><p><code>Dockerfile</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:22.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3.10 python3-pip python3.10-dev</span>
<span class="token instruction"><span class="token keyword">ADD</span> hello.py /</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"python3"</span>, <span class="token string">"/hello.py"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="镜像的构建和分享"><a href="#镜像的构建和分享" class="headerlink" title="镜像的构建和分享"></a>镜像的构建和分享</h3><p>从 <code>Dockerfile</code> 构建镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># . 指定 dockerfile 文件位置</span>
<span class="token function">docker</span> image build <span class="token parameter variable">-t</span> hello:1.0.0 <span class="token builtin class-name">.</span>

<span class="token comment"># 运行s</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> hello:1.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将镜像 <code>push</code> 到 <code>dockerhub</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token comment"># 从新创建镜像</span>
<span class="token function">docker</span> image build <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>账户<span class="token operator">></span>/hello:1.0.0 <span class="token builtin class-name">.</span>

<span class="token comment"># 或者 使用 docker image tag 根据已经存在的 image 创建一个新的tag image</span>
<span class="token function">docker</span> image tag <span class="token operator">&lt;</span>Image ID<span class="token operator">></span>  <span class="token operator">&lt;</span>账户<span class="token operator">></span>/hello:1.0.1

<span class="token comment"># 登录</span>
<span class="token function">docker</span> login <span class="token operator">&lt;</span>地址<span class="token operator">></span> <span class="token parameter variable">-u</span> <span class="token operator">&lt;</span>账户<span class="token operator">></span> <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>密码<span class="token operator">></span>

<span class="token comment"># 推送到远程仓库</span>
<span class="token function">docker</span> image push <span class="token operator">&lt;</span>账户<span class="token operator">></span>/hello:1.0.1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="通过-commit-创建镜像"><a href="#通过-commit-创建镜像" class="headerlink" title="通过 commit 创建镜像"></a>通过 commit 创建镜像</h2><p>从 <code>Container</code> <code>commit</code> 一个 <code>Image</code> 镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 运行一个容器</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 nginx
<span class="token comment"># 进入容器内部</span>
<span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>Container ID<span class="token operator">></span> <span class="token function">sh</span>
<span class="token comment"># 编辑修改容器里内容</span>
<span class="token builtin class-name">cd</span> /usr/share/nginx/html
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;h1>hello&lt;h1>"</span> <span class="token operator">></span> index.html

<span class="token comment"># exit</span>
<span class="token comment"># 停止容器</span>
<span class="token function">docker</span> container stop <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>
<span class="token comment"># 启动容器 查看修改</span>
<span class="token function">docker</span> container start <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>

<span class="token comment"># 帮助命令</span>
<span class="token function">docker</span> container commit <span class="token parameter variable">--help</span>

<span class="token comment"># 创建镜像</span>
<span class="token function">docker</span> container commit <span class="token operator">&lt;</span>Container ID<span class="token operator">></span> <span class="token operator">&lt;</span>账户<span class="token operator">></span>/nginx:<span class="token operator">&lt;</span>Tag<span class="token operator">></span>

<span class="token comment"># 查看创建的镜像 Image</span>
<span class="token function">docker</span> images
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="关于-scratch-镜像"><a href="#关于-scratch-镜像" class="headerlink" title="关于 scratch 镜像"></a>关于 scratch 镜像</h2><p><code>Scratch</code> 是一个空的 <code>Docker</code> 镜像。</p>
<p>通过 <code>scratch</code> 来构建一个基础镜像。</p>
<p><code>hello.c</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include &lt;stdio.h></span>
int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    printf<span class="token punctuation">(</span><span class="token string">"hello docker<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译成一个二进制文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">--static</span> <span class="token parameter variable">-o</span> hello hello.c
./hello
hello <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>Dockerfile</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> scratch</span>
<span class="token instruction"><span class="token keyword">ADD</span> hello /</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"/hello"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>构建</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> hello <span class="token builtin class-name">.</span>
<span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
hello        latest    2936e77a9daa   <span class="token number">40</span> minutes ago   872kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-it</span> hello
hello <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>查看分层</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">history</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>








]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Image</tag>
        <tag>Docker Container</tag>
      </tags>
  </entry>
  <entry>
    <title>跟我一起写 makefile</title>
    <url>//post/with-me-makefile.html</url>
    <content><![CDATA[<p><code>github</code>文档地址: <a href="https://github.com/seisman/how-to-write-makefile">https://github.com/seisman/how-to-write-makefile</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>什么是 <code>makefile</code> ？或许很多 <code>Windows</code> 的程序员都不知道这个东西，因为那些 <code>Windows</code> 的集成开发环境（<code>integrated development environment，IDE</code>）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，<code>makefile</code> 还是要懂。这就好像现在有这么多的 <code>HTML</code> 编辑器，但如果你想成为一个专业人士，你还是要了解 <code>HTML</code> 的标签的含义。特别在 <code>Unix</code> 下的软件编译，你就不能不自己写 <code>makefile</code> 了，会不会写 <code>makefile</code>，从一个侧面说明了一个人是否具备完成大型工程的能力。</p>
<span id="more"></span>
<p>因为，<code>makefile</code> 关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，<code>makefile</code> 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>makefile</code> 就像一个 <code>Shell</code> 脚本一样，其中也可以执行操作系统的命令。</p>
<p><code>makefile</code> 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>make</code> 是一个命令工具，是一个解释 <code>makefile</code> 中指令的命令工具，一般来说，大多数的 <code>IDE</code> 都有这个命令，比如：<code>Delphi</code> 的 <code>make</code>，<code>Visual C++</code>的 <code>nmake</code>，<code>Linux</code> 下<code>GNU</code> 的 <code>make</code>。可见，<code>makefile</code> 都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写 <code>makefile</code> 的文章比较少，这是我想写这篇文章的原因。当然，不同产商的 <code>make</code> 各不相同，也有不同的语法，但其本质都是在 <code>文件依赖性</code> 上做文章，这里，我仅对 <code>GNU</code> 的 <code>make</code> 进行讲述，我的环境是 <code>RedHat Linux 8.0</code>，<code>make</code> 的版本是 <code>3.80</code>。毕竟，这个 <code>make</code> 是应用最为广泛的，也是用得最多的。而且其还是最遵循于 <code>IEEE 1003.2-1992</code> 标准的（<code>POSIX.2</code>）。</p>
<p>在这篇文档中，将以 <code>C/C++</code> 的源码作为基础，所以必然涉及一些关于 <code>C/C++</code> 的编译的知识。关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是 <code>UNIX</code> 下的 <code>GCC</code> 和 <code>CC</code>。</p>
<h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h2><p>在此，我想多说关于程序编译的一些规范和方法。一般来说，无论是 <code>C</code> 还是 <code>C++</code>，首先要把源文件编译成中间代码文件，在 <code>Windows</code> 下也就是 <code>.obj</code> 文件，<code>UNIX </code>下是 <code>.o </code>文件，即 <code>Object File</code>，这个动作叫做编译（<code>compile</code>）。然后再把大量的 <code>Object File</code> 合成执行文件，这个动作叫作链接（<code>link</code>）。编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在<code> C/C++</code> 文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（<code>.o</code> 文件或 <code>.obj</code> 文件）。</p>
<p>链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（<code>.o</code> 文件或 <code>.obj</code> 文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（<code>Object File</code>），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在 <code>Windows</code> 下这种包叫“<code>库文件</code>”（<code>Library File</code>），也就是 <code>.lib</code> 文件，在 <code>UNIX</code> 下，是<code>Archive File</code>，也就是 <code>.a</code> 文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 <code>ObjectFile</code>。而在链接程序时，链接器会在所有的 <code>Object File</code> 中找寻函数的实现，如果找不到，那到就会报链接错误码（<code>Linker Error</code>），在 <code>VC </code>下，这种错误一般是：<code>Link 2001 </code>错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的 <code>Object File</code>。</p>
<p>好，言归正传，<code>gnu</code> 的 <code>make</code> 有许多的内容，闲言少叙。</p>
<h1 id="makefile-介绍"><a href="#makefile-介绍" class="headerlink" title="makefile 介绍"></a>makefile 介绍</h1><p><code>make</code> 命令执行时，需要一个 <code>makefile</code> 文件，以告诉 <code>make</code> 命令需要怎么样的去编译和链接程序。<br>首先，我们用一个示例来说明 <code>makefile</code> 的书写规则，以便给大家一个感性认识。这个示例来源于 <code>gnu</code>的 <code>make</code> 使用手册，在这个示例中，我们的工程有 8 个 <code>c</code> 文件，和 3 个<code>头</code>文件，我们要写一个 <code>makefile</code>来告诉 make 命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有 <code>c</code> 文件都要编译并被链接。</li>
<li>如果这个工程的某几个 <code>c</code> 文件被修改，那么我们只编译被修改的 <code>c</code> 文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 <code>c</code> 文件，并链接目标程序。</li>
</ol>
<p>只要我们的 <code>makefile</code> 写得够好，所有的这一切，我们只用一个 <code>make</code> 命令就可以完成，<code>make</code> 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p>
<h2 id="makefile-的规则"><a href="#makefile-的规则" class="headerlink" title="makefile 的规则"></a>makefile 的规则</h2><p>在讲述这个 <code>makefile</code> 之前，还是让我们先来粗略地看一看 <code>makefile</code> 的规则。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target ...</span> <span class="token punctuation">:</span> prerequisites ...
  command
  ...
  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>target</code> ：</strong><br>可以是一个 <code>object file</code>（目标文件），也可以是一个执行文件，还可以是一个标签（<code>label</code>）。对于标签这种特性，在后续的<code>伪目标</code>章节中会有叙述。</p>
<p><strong><code>prerequisites</code> ：</strong><br>生成该 <code>target</code> 所依赖的文件和<code>/</code>或 <code>target</code></p>
<p><strong><code>command</code> ：</strong><br>该 <code>target</code> 要执行的命令（任意的 <code>shell</code> 命令）</p>
<p>这是一个文件的依赖关系，也就是说，target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说:</p>
<pre class="line-numbers language-none"><code class="language-none">prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>这就是 <code>makefile</code> 的规则，也就是 <code>makefile</code> 中最核心的内容。</p>
<p>说到底，<code>makefile</code> 的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是 <code>makefile</code> 的主线和核心，但要写好一个 <code>makefile</code> 还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。 内容还多着呢。:)</p>
<h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p>正如前面所说，如果一个工程有 3 个头文件和 8 个 c 文件，为了完成前面所述的那三个规则，我们的 <code>makefile</code> 应该是下面的这个样子的。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h
    cc -c main.c
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> kbd.c defs.h command.h
    cc -c kbd.c
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> command.c defs.h command.h
    cc -c command.c
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> display.c defs.h buffer.h
    cc -c display.c
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> insert.c defs.h buffer.h
    cc -c insert.c
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> search.c defs.h buffer.h
    cc -c search.c
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> files.c defs.h buffer.h command.h
    cc -c files.c
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> utils.c defs.h
    cc -c utils.c
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>反斜杠(<code>\ </code>)是换行符的意思。这样比较便于 <code>makefile</code> 的阅读。我们可以把这个内容保存在名字为 <code>makefile</code> 或 <code>Makefile</code> 的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件 <code>edit</code>。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就可以了。</p>
<p>在这个 <code>makefile</code> 中，目标文件(<code>target</code>)包含:执行文件 <code>edit</code> 和中间目标文件(<code>*.o</code> )，依赖文件 (<code>prerequisites</code>)就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code>文件又是执行文件 <code>edit</code> 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，<em><strong>一定要以一个 <code>Tab</code> 键作为开头</strong></em>。记住，<code>make</code> 并不管命令是怎么工作的，他只管执行所定义的命令。</p>
<p><em><strong><code>make</code>会比较<code>targets</code>文件和<code>prerequisites</code>文件的修改日期，如果<code>prerequisites</code>文件的日期要比<code>targets</code>文件的日期要新，或者<code>target</code>不存在的话，那么，<code>make</code>就会执行后续定义的命令。</strong></em></p>
<p>这里要说明一点的是，<code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像 <code>c </code>语言中的 <code>label</code> 一 样，其冒号后什么也没有，那么，<code>make</code> 就不会自动去找它的依赖性，也就不会自动执行其后所定义的命 令。要执行其后的命令，就要在 <code>make</code> 命令后明显得指出这个 <code>label</code> 的名字。这样的方法非常有用，我们 可以在一个 <code>makefile</code> 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h2 id="make-是如何工作的"><a href="#make-是如何工作的" class="headerlink" title="make 是如何工作的"></a>make 是如何工作的</h2><p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，</p>
<ol>
<li>make 会在当前目录下找名字叫 <code>Makefile</code> 或 <code>makefile</code> 的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件(<code>target</code>)，在上面的例子中，他会找到 <code>edit</code> 这个文 件，并把这个文件作为最终的目标文件。</li>
<li>如果 <code>edit</code> 文件不存在，或是 <code>edit</code> 所依赖的后面的 <code>.o </code>文件的文件修改时间要比 <code>edit</code> 这个文件新， 那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li>
<li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么 <code>make</code> 会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如 果找到则再根据那一个规则生成 <code>.o</code> 文件。(这有点像一个堆栈的过程)</li>
<li>当然，你的 <code>C</code> 文件和 <code>H</code> 文件是存在的啦，于是 <code>make</code> 会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成 <code>make</code> 的终极任务，也就是执行文件 <code>edit</code> 了。</li>
</ol>
<p>这就是整个 <code>make</code> 的依赖性，<code>make</code> 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 <code>make</code> 就会直接退出，并 报错，而对于所定义的命令的错误，或是编译不成功，<code>make </code>根本不理。<code>make</code> 只管文件的依赖性，即，如 果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像 <code>clean</code> 这种，没有被第一个目标文件直接或间接关联，那么它后面所定 义的命令将不会被自动执行，不过，我们可以显示要 <code>make</code> 执行。即命令——<code>make clean</code> ，以此来清除 所有的目标文件，以便重编译。<br>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 <code>file.c</code> ，那 么根据我们的依赖性，我们的目标 <code>file.o</code> 会被重编译(也就是在这个依性关系后面所定义的命令)，于 是 <code>file.o</code> 的文件也是最新的啦，于是 <code>file.o</code> 的文件修改时间要比 <code>edit</code> 要新，所以 <code>edit</code> 也会被重新 链接了(详见 <code>edit</code> 目标文件后定义的命令)。</p>
<p>而如果我们改变了 <code>command.h</code> ，那么，<code>kdb.o</code> 、<code>command.o</code> 和 <code>files.o</code> 都会被重编译，并且，<code>edit</code> 会被重链接。</p>
<h2 id="makefile-中使用变量"><a href="#makefile-中使用变量" class="headerlink" title="makefile 中使用变量"></a>makefile 中使用变量</h2><p>在上面的例子中，先让我们看看 edit 的规则:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>我们可以看到 <code>.o </code>文件的字符串被重复了两次，如果我们的工程需要加入一个新的 <code>.o </code>文件，那么我 们需要在两个地方加(应该是三个地方，还有一个地方<code>clean</code> 中)。当然，我们的 <code>makefile</code> 并不复杂，所 以在两个地方加也不累，但如果 <code>makefile</code> 变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而 导致编译失败。所以，为了 <code>makefile</code> 的易维护，在 <code>makefile</code> 中我们可以使用变量。<code>makefile</code> 的变量也就 是一个字符串，理解成 <code>C</code> 语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫 <code>objects</code> ，<code>OBJECTS</code>，<code>objs</code> ，<code>OBJS</code> ，<code>obj</code> 或是 <code>OBJ</code> ，反正不管什么 啦，只要能够表示 <code>obj</code> 文件就行了。我们在 makefile 一开始就这样定义:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>于是，我们就可以很方便地在我们的 makefile 中以 $(objects) 的方式来使用这个变量了，于是我 们的改良版 makefile 就变成下面这个样子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">
objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h
    cc -c main.c
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> kbd.c defs.h command.h
    cc -c kbd.c
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> command.c defs.h command.h
    cc -c command.c
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> display.c defs.h buffer.h
    cc -c display.c
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> insert.c defs.h buffer.h
    cc -c insert.c
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> search.c defs.h buffer.h
    cc -c search.c
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> files.c defs.h buffer.h command.h
    cc -c files.c
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> utils.c defs.h
    cc -c utils.c
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p>
<h2 id="让-make-自动推导"><a href="#让-make-自动推导" class="headerlink" title="让 make 自动推导"></a>让 make 自动推导</h2><p><code>GNU</code> 的 <code>make</code> 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的 <code>make</code> 会自动识别，并自己推导命令。</p>
<p>只要 <code>make</code> 看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果 <code>make</code> 找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的 <code>makefile</code> 再也不用写得这么复杂。我们的新 <code>makefile</code> 又出炉了。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
  cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> defs.h
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> defs.h command.h
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> defs.h command.h
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> defs.h buffer.h command.h
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> defs.h

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
  rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>这种方法，也就是 <code>make</code> 的 <code>隐晦规则</code> 。上面文件内容中，<code>.PHONY</code> 表示 <code>clean</code> 是个伪目标文件。</p>
<h2 id="另类风格的-makefiles"><a href="#另类风格的-makefiles" class="headerlink" title="另类风格的 makefiles"></a>另类风格的 makefiles</h2><p>既然我们的 <code>make</code> 可以自动推导命令，那么我看到那堆 <code>.o</code> 和 <code>.h</code> 的依赖就有点不爽，那么多的重复的 <code>.h</code> ，能不能把其收拢起来，好吧，没有问题，这个对于 <code>make</code> 来说很容易，谁叫它提供了自动推导命令和文件的功能呢?来看看最新风格的 <code>makefile</code> 吧。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token target symbol"><span class="token variable">$</span>(objects)</span> <span class="token punctuation">:</span> defs.h

<span class="token target symbol">kbd.o command.o files.o</span> <span class="token punctuation">:</span> command.h
<span class="token target symbol">display.o insert.o search.o files.o</span> <span class="token punctuation">:</span> buffer.h

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种风格，让我们的 <code>makefile</code> 变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多， 要加入几个新的 <code>.o</code> 文件，那就理不清楚了。</p>
<h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个 <code>Makefile</code> 中都应该写一个清空目标文件(<code>.o</code> 和执行文件)的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”(呵呵，还记得我的《编程修养》吗)。一般的风格都是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>更为稳健的做法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>前面说过，<code>.PHONY</code> 表示 <code>clean</code> 是一个“<code>伪目标</code>”。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也 许某些文件出现问题，但不要管，继续做后面的事。当然，<code>clean </code>的规则不要放在文件的开头，不然，这就会变成 <code>make</code> 的默认目标，相信谁也不愿意这样。不成文的规矩是——“<code>clean 从来都是放在文件的最后</code>”。</p>
<p>上面就是一个 <code>makefile</code> 的概貌，也是 <code>makefile</code> 的基础，下面还有很多 <code>makefile</code> 的相关细节，准备好 了吗?准备好了就来。</p>
<h2 id="Makefile-里有什么"><a href="#Makefile-里有什么" class="headerlink" title="Makefile 里有什么?"></a>Makefile 里有什么?</h2><p><code>Makefile</code> 里主要包含了五个东西:显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li><p><code>显式规则</code>。显式规则说明了如何生成一个或多个目标文件。这是由 <code>Makefile</code> 的书写者明显指出要 生成的文件、文件的依赖文件和生成的命令。</p>
</li>
<li><p><code>隐晦规则</code>。由于我们的 <code>make</code> 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 <code>Make-file</code>，这是由 <code>make</code> 所支持的。</p>
</li>
<li><p><code>变量的定义</code>。在 <code>Makefile</code> 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 <code>C</code> 语言中的宏，当 <code>Makefile</code> 被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
</li>
<li><p><code>文件指示</code>。其包括了三个部分，一个是在一个 <code>Makefile</code> 中引用另一个 <code>Makefile</code>，就像 <code>C</code> 语言中的 <code>include</code> 一样;另一个是指根据某些情况指定 <code>Makefile</code> 中的有效部分，就像 <code>C</code> 语言中的预编译 <code>#if</code> 一样;还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p>
</li>
<li><p><code>注释</code>。<code>Makefile</code> 中只有行注释，和 <code>UNIX</code> 的 <code>Shell</code> 脚本一样，其注释是用 <code>#</code> 字符，这个就像 <code>C/C++</code> 中的 &#x2F;&#x2F; 一样。如果你要在你的 <code>Makefile</code> 中使用 <code>#</code> 字符，可以用反斜杠进行转义，如:<code>\#</code> 。</p>
</li>
</ol>
<p>最后，还值得一提的是，在 <code>Makefile</code> 中的命令，必须要以 <code>Tab</code> 键开始</p>
<h2 id="Makefile-的文件名"><a href="#Makefile-的文件名" class="headerlink" title="Makefile 的文件名"></a>Makefile 的文件名</h2><p>默认的情况下，<code>make</code> 命令会在当前目录下按顺序找寻文件名为“<code>GNUmakefile</code>”、“<code>makefile</code>”、“<code>Make-file</code>”的文件，找到了解释这个文件。在这三个文件名中，最好使用“<code>Makefile</code>”这个文件名，因为，这 个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“<code>GNUmakefile</code>”，这个文件是 <code>GNU</code> 的 <code>make</code> 识别的。有另外一些 <code>make</code> 只对全小写的“<code>makefile</code>”文件名敏感，但是基本上来说，大多数的 <code>make</code> 都支持“<code>makefile</code>”和“<code>Makefile</code>”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写 <code>Makefile</code>，比如:“<code>Make.Linux</code>”，“<code>Make.Solaris</code>”，“<code>Make.AIX</code>” 等，如果要指定特定的 <code>Makefile</code>，你可以使用 <code>make</code> 的 <code>-f</code> 和 <code>--file</code> 参数，如:<code>make -f Make.Linux</code> 或 <code>make --file Make.AIX</code> 。</p>
<h2 id="引用其它的-Makefile"><a href="#引用其它的-Makefile" class="headerlink" title="引用其它的 Makefile"></a>引用其它的 Makefile</h2><p>在 <code>Makefile</code> 使用 <code>include</code> 关键字可以把别的 <code>Makefile</code> 包含进来，这很像 <code>C</code> 语言的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code> 的语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> &lt;filename><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>filename</code> 可以是当前操作系统 Shell 的文件模式(可以包含路径和通配符)。</p>
<p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。<code>include</code> 和 <code>&lt;filename&gt;</code> 可以用一个或多个空格隔开。举个例子，你有这样几个 <code>Makefile:a.mk</code> 、<code>b.mk</code> 、<code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code> ，其包含了 <code>e.mk</code> 和 <code>f.mk</code> ，那么，下面的语句:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> foo.make *.mk <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>make</code> 命令开始时，会找寻 <code>include</code> 所指出的其它 <code>Makefile</code>，并把其内容安置在当前的位置。就好像 <code>C/C++</code> 的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，<code>make</code> 会在当前目录下首先寻找，如果当前目录下没有找到，那么，<code>make</code> 还会在下面的几个目录下找:</p>
<ol>
<li><p>如果 <code>make</code> 执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么 <code>make</code> 就会在这个参数所指定的目录下去寻找。</p>
</li>
<li><p>如果目录<code>&lt;prefix&gt;/include</code>(一般是: <code>/usr/local/bin</code> 或 <code>/usr/include</code> )存在的话，<code>make</code>也会去找。</p>
</li>
</ol>
<p>如果有文件没有找到的话，<code>make</code> 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 <code>makefile</code> 的读取，<code>make</code>会再重试这些没有找到，或是不能读取的文件，如果还是不行，<code>make</code> 才会出现一条致命信息。如果你想让 <code>make</code> 不理那些无法读取的文件，而继续执行，你可以在 <code>include</code> 前加一个减号 “<code>-</code>”。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">-include</span> &lt;filename><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其表示，无论 <code>include</code> 过程中出现什么错误，都不要报错继续执行。和其它版本 <code>make</code> 兼容的相关命令是 <code>sinclude</code>，其作用和这一个是一样的。</p>
<h2 id="环境变量-MAKEFILES"><a href="#环境变量-MAKEFILES" class="headerlink" title="环境变量 MAKEFILES"></a>环境变量 MAKEFILES</h2><p>如果你的当前环境中定义了环境变量 <code>MAKEFILES</code> ，那么，<code>make</code> 会把这个变量中的值做一个类似于 <code>include</code> 的动作。这个变量中的值是其它的 <code>Makefile</code>，用空格分隔。只是，它和 <code>include</code> 不同的是，从这个环境变量中引入的 <code>Makefile</code> 的“<code>目标</code>”不会起作用，如果环境变量中定义的文件发现错误，<code>make</code> 也 会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 <code>make</code> 时，所有的 <code>Makefile</code> 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也 许有时候你的 <code>Makefile</code> 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h2 id="make-的工作方式"><a href="#make-的工作方式" class="headerlink" title="make 的工作方式"></a>make 的工作方式</h2><p><code>GNU</code> 的 <code>make</code> 工作时的执行步骤如下:(想来其它的 <code>make</code> 也是类似)</p>
<ol>
<li>读入所有的 <code>Makefile</code></li>
<li>读入被 <code>include</code> 的其它 <code>Makefile</code>。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p><code>1-5</code> 步为第一个阶段，<code>6-7</code> 为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，<code>make</code> 会 把其展开在使用的位置。但 <code>make</code> 并不会完全马上展开，<code>make</code> 使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对 <code>make</code> 更为熟悉。有了这个基础， 后续部分也就容易看懂了。</p>
<h1 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在 <code>Makefile</code> 中，规则的顺序是很重要的，因为，<code>Makefile</code> 中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 <code>make</code> 知道你的最终目标是什么。一般来说，定义在 <code>Makefile</code> 中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。<code>make</code> 所完成的也就是这个目标。</p>
<h2 id="规则举例"><a href="#规则举例" class="headerlink" title="规则举例"></a>规则举例</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo.o</span><span class="token punctuation">:</span> foo.c defs.h  <span class="token comment"># foo模块</span>
    cc -c -g foo.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>看到这个例子，各位应该不是很陌生了，前面也已说过，<code>foo.o</code> 是我们的目标，<code>foo.c</code> 和 <code>defs.h</code> 是 目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code> (以 <code>Tab</code> 键开头)。这个规则告诉我们两件事:</p>
<ol>
<li>文件的依赖关系，<code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code> 和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code>文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。</li>
<li>生成或更新 <code>foo.o</code> 文件，就是那个 <code>cc</code> 命令。它说明了如何生成 <code>foo.o</code> 这个文件。(当然，<code>foo.c</code> 文 件 <code>include</code> 了 <code>defs.h</code> 文件)</li>
</ol>
<h2 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">targets</span> <span class="token punctuation">:</span> prerequisites
    command
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>或是这样:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">targets</span> <span class="token punctuation">:</span> prerequisites <span class="token punctuation">;</span> command
    command
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>targets</code> 是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也 有可能是多个文件。<br><code>command</code> 是命令行，如果其不与“<code>target:prerequisites</code>”在一行，那么，必须以 <code>Tab</code> 键开头，如果 和 <code>prerequisites</code> 在一行，那么可以用分号做为分隔。(见上)<br><code>prerequisites</code> 也就是目标所依赖的文件(或依赖目标)。如果其中的某个文件要比目标文件要新，那 么，目标就被认为是“<code>过时的</code>”，被认为是需要重生成的。这个在前面已经讲过了。<br>如果命令太长，你可以使用反斜杠(<code>\ </code>)作为换行符。<code>make</code> 对一行上有多少个字符没有限制。规则 告诉 <code>make</code> 两件事，文件的依赖关系和如何生成目标文件。<br>一般来说，<code>make</code> 会以 <code>UNIX</code> 的标准 <code>Shell</code>，也就是 <code>/bin/sh</code> 来执行命令。</p>
<h2 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make 支持三个通配符:<br><code>*</code> ，<code>?</code> 和 <code>~</code> 。这是和 <code>Unix</code> 的 <code>B-Shell</code> 是相同的。<br>波浪号(<code>~</code> )字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code> ，这就表示当前用户的 <code>$HOME</code> 目 录下的 <code>test</code> 目录。而 <code>~hchen/test</code> 则表示用户 <code>hchen</code> 的宿主目录下的 <code>test</code> 目录。(这些都是 <code>Unix</code> 下的 小知识了，<code>make</code> 也支持)而在 <code>Windows</code> 或是 <code>MS-DOS</code> 下，用户没有宿主目录，那么波浪号所指的目录 则根据环境变量“<code>HOME</code>”而定。<br>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为 <code>c</code> 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如: <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。</p>
<p>  例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm -f *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其实在这个 <code>clean:</code> 后面可以加上你想做的一些事情，如果你想看到在编译完后看看 <code>main.c</code> 的源代码，你可以在加上 <code>cat</code> 这个命令，例子如下:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    cat main.c
    rm -f *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其结果你试一下就知道的。上面这个例子我不不多说了，这是操作系统 <code>Shell</code> 所支持的通配符。这是在命令中的通配符。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">print</span><span class="token punctuation">:</span> *.c
    lpr -p <span class="token variable">$?</span>
    touch print<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面这个例子说明了通配符也可以在我们的规则中，目标 <code>print</code> 依赖于所有的 <code>.c</code> 文件。其中的 <code>$?</code> 是一个自动化变量，我会在后面给你讲述。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> *.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面这个例子，表示了通配符同样可以用在变量中。并不是说 <code>*.o</code> 会展开，不 <code>!objects</code> 的值就是 <code>*.o</code> 。<code>Makefile</code> 中的变量其实就是 <code>C/C++</code> 中的宏。如果你要让通配符在变量中展开，也就是让 <code>objects</code> 的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>另给一个变量使用通配符的例子:</p>
<ol>
<li>列出一确定文件夹中的所有.c文件。</li>
</ol>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="2">
<li>列出 <code>(1)</code> 中所有文件对应的 <code>.o</code> 文件，在 <code>(3)</code> 中我们可以看到它是由 <code>make</code> 自动编译出的:</li>
</ol>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>由 <code>(1)</code> <code>(2)</code> 两步，可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件</li>
</ol>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token target symbol">foo</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这种用法由关键字“<code>wildcard</code>”，“<code>patsubst</code>”指出，关于 <code>Makefile</code> 的关键字，我们将在后面讨论。</p>
<h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当 <code>make</code> 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 <code>make</code>，让 <code>make</code> 在自动去找。</p>
<p><code>Makefile</code> 文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，<code>make</code> 只会在当 前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，<code>make</code> 就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的定义指定两个目录，“<code>src</code>”和“<code>../headers</code>”，<code>make</code> 会按照这个顺序进行搜索。目录由“<code>冒号</code>”分隔。(当然，当前目录永远是最高优先搜索的地方)</p>
<p>另一个设置文件搜索路径的方法是使用 <code>make</code> 的“<code>vpath</code>”关键字(注意，它是全小写的)，这不是变量，这是一个 <code>make</code> 的关键字，这和上面提到的那个 <code>VPATH</code> 变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">vpath</span> &lt;pattern> &lt;directories>
    为符合模式 &lt;pattern> 的文件指定搜索目录 &lt;directories>。
<span class="token keyword">vpath</span> &lt;pattern>
    清除符合模式 &lt;pattern> 的文件的搜索目录。
<span class="token keyword">vpath</span>
    清除所有已被设置好了的文件搜索目录。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><code>vpath</code> 使用方法中的 <code>&lt;pattern&gt;</code> 需要包含 <code>%</code> 字符。<code>%</code> 的意思是匹配零或若干字符，(需引用 <code>%</code> ，使用 <code>\</code> )例如，<code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<code>&lt;pattern&gt;</code> 指定了要搜索的文件集，而 <code>&lt;directories&gt;</code> 则 指定了 <code>&lt;pattern&gt;</code> 的文件集的搜索的目录。例如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">vpath</span> %.h ../headers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>该语句表示，要求 <code>make</code> 在“<code>../headers</code>”目录下搜索所有以 <code>.h</code> 结尾的文件。(如果某文件在当前目 录没有找到的话)</p>
<p>我们可以连续地使用 <code>vpath</code> 语句，以指定不同搜索策略。如果连续的 <code>vpath</code> 语句中出现了相同的 <code>&lt;pattern&gt;</code> ，或是被重复了的 <code>&lt;pattern&gt;</code>，那么，<code>make</code> 会按照 <code>vpath</code> 语句的先后顺序来执行搜索。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">vpath</span> %.c foo
<span class="token keyword">vpath</span> %   blish
<span class="token keyword">vpath</span> %.c bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其表示 <code>.c</code> 结尾的文件，先在“<code>foo</code>”目录，然后是“<code>blish</code>”，最后是“<code>bar</code>”目录。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">vpath %.c foo</span><span class="token punctuation">:</span>bar
<span class="token keyword">vpath</span> %   blish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而上面的语句则表示 <code>.c</code>结尾的文件，先在“<code>foo</code>”目录，然后是“<code>bar</code>”目录，最后才是“<code>blish</code>”目录。</p>
<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>最早先的一个例子中，我们提到过一个“<code>clean</code>”的目标，这是一个“<code>伪目标</code>”，</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm *.o temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>正像我们前面例子中的“<code>clean</code>”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“<code>目标</code>”以备完整地重编译而用。(以“<code>make clean</code>”来使用该目标)</p>
<p>因为，我们并不生成“<code>clean</code>”这个文件。“<code>伪目标</code>”并不是一个文件，只是一个标签，由于“<code>伪目标</code>” 不是文件，所以 <code>make</code> 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“<code>目标</code>”才能让其生效。当然，“<code>伪目标</code>”的取名不能和文件名重名，不然其就失去了“<code>伪目标</code>”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“<code>.PHONY</code>”来显式地指明一个目标是“<code>伪目标</code>”，向 <code>make</code> 说明，不管是否有这个文件，这个目标就是“<code>伪目标</code>”。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>只要有这个声明，不管是否有“<code>clean</code>”文件，要运行“<code>clean</code>”这个目标，只有“<code>make clean</code>”这样。 于是整个过程可以这样写:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm *.o temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为 “<code>默认目标</code>”，只要将其放在第一个。一个示例就是，如果你的 <code>Makefile</code> 需要一口气生成若干个可执行文件，但你只想简单地敲一个 <code>make</code> 完事，并且，所有的目标文件都写在一个 <code>Makefile</code> 中，那么你可以使用“<code>伪目标</code>”这个特性:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span> <span class="token punctuation">:</span> prog1 prog2 prog3

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> all
<span class="token target symbol">prog1</span> <span class="token punctuation">:</span> prog1.o utils.o
    cc -o prog1 prog1.o utils.o
<span class="token target symbol">prog2</span> <span class="token punctuation">:</span> prog2.o
    cc -o prog2 prog2.o
<span class="token target symbol">prog3</span> <span class="token punctuation">:</span> prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们知道，<code>Makefile</code> 中的第一个目标会被作为其默认目标。我们声明了一个“<code>all</code>”的伪目标，其依赖 于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“<code>all</code>”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“<code>all</code>”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。<code>.PHONY : all</code> 声明了“<code>all</code>”这个目标为“<code>伪目标</code>”。(注:这里的显式“<code>.PHONY : all</code>”不写的话一般情况也可以正确的执行，这样 <code>make</code> 可通过隐式规则推导出，“<code>all</code>”是 一个伪目标，执行 <code>make</code> 不会生成“<code>all</code>”文件，而执行后面的多个目标。建议:显式写出是一个好习惯。)</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。<br>看下面的例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> cleanall cleanobj cleandiff

<span class="token target symbol">cleanall</span> <span class="token punctuation">:</span> cleanobj cleandiff
    rm program

<span class="token target symbol">cleanobj</span> <span class="token punctuation">:</span>
    rm *.o

<span class="token target symbol">cleandiff</span> <span class="token punctuation">:</span>
    rm *.diff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>“<code>make cleanall</code>”将清除所有要被清除的文件。“<code>cleanobj</code>”和“<code>cleandiff</code>”这两个伪目标有点像“<code>子程序</code>”的意思。我们可以输入“<code>make cleanall</code>”和“<code>make cleanobj</code>”和“<code>make cleandiff</code>”命令来达到清除不同种类文件的目的。</p>
<h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p><code>Makefile</code> 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@ </code>(关于自动化变量，将在后面讲述)，这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">bigoutput littleoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> output,,<span class="token variable">$@</span><span class="token punctuation">)</span> > <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上述规则等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">bigoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -big > bigoutput
<span class="token target symbol">littleoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -little > littleoutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，<code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个 <code>Makefile</code> 的函数，函数名为 <code>subst</code>，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，<code>$@</code> 表示目标的集合，就像一个数组，<code>$@</code> 依次取出目标，并执于命令。</p>
<h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">&lt;targets ...></span> <span class="token punctuation">:</span> &lt;target-pattern> <span class="token punctuation">:</span> &lt;prereq-patterns ...>
    &lt;commands>
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>targets</code> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。<br><code>target-pattern</code> 是指明了 <code>targets</code> 的模式，也就是的目标集模式。<br><code>prereq-patterns</code> 是目标的依赖模式，它对 <code>target-pattern</code> 形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 <code>&lt;target- pattern&gt;</code> 定义成 <code>%.o</code> ，意思是我们的<code> &lt;target&gt;</code>; 集合中都是以 <code>.o </code>结尾的，而如果我们的 <code>&lt;prereq- patterns&gt;</code> 定义成 <code>%.c</code> ，意思是对 <code>&lt;target-pattern&gt;</code> 所形成的目标集进行二次定义，其计算方法是，取 <code>&lt;target-pattern&gt;</code> 模式<br>中的 <code>% </code>(也就是去掉了 <code>.o</code> 这个结尾)，并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p>
<p>所以，我们的“<code>目标模式</code>”或是“<code>依赖模式</code>”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么 你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。</p>
<p>看一个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o

<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，指明了我们的目标从 <code>$object</code> 中获取，<code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o</code> <code>bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o </code>的 <code>%</code> ，也就是 <code>foo</code> <code>bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c</code> <code>bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量，<code>$&lt;</code> 表示第一个依赖文件，<code>$@</code> 表示目标集(也就是“<code>foo.o</code> <code>bar.o</code>”)。于是，上面的规则展开后等价 于下面的规则:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c -o foo.o
<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c -o bar.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的“<code>静态模式规则</code>”就可以写完一堆 规则，实在是太有效率了。“<code>静态模式规则</code>”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">files <span class="token operator">=</span> foo.elc bar.o lose.o

<span class="token target symbol"><span class="token variable">$</span>(filter %.o,<span class="token variable">$</span>(files))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>

<span class="token target symbol"><span class="token variable">$</span>(filter %.elc,<span class="token variable">$</span>(files))</span><span class="token punctuation">:</span> %.elc<span class="token punctuation">:</span> %.el
    emacs -f batch-byte-compile <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>$(filter %.o,$(files))</code> 表示调用 <code>Makefile</code> 的 <code>filter</code> 函数，过滤“<code>$files</code>”集，只要其中模式为“<code>%.o</code>”的 内容。其它的内容，我就不用多说了吧。这个例子展示了 <code>Makefile</code> 中更大的弹性。</p>
<h2 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h2><p>在 <code>Makefile</code> 中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的 <code>main.c</code> 中有一句 <code>#include &quot;defs.h&quot;</code> ，那么我们的依赖关系应该是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是，如果是一个比较大型的工程，你必需清楚哪些 <code>C</code> 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 <code>Makefile</code>，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 <code>C/C++</code> 编译的一个功能。大多数的 <code>C/C++</code> 编译器都支持一个“<code>-M</code>”的 选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cc -M main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其输出是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编 译器自动生成了。需要提醒一句的是，如果你使用 <code>GNU</code> 的 <code>C/C++ </code>编译器，你得用 <code>-MM </code>参数，不然，<code>-M</code> 参数会把一些标准库的头文件也包含进来。</p>
<p><code>gcc -M main.c</code> 的输出是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c defs.h /usr/<span class="token keyword">include</span>/stdio.h /usr/<span class="token keyword">include</span>/features.h \
    /usr/<span class="token keyword">include</span>/sys/cdefs.h /usr/<span class="token keyword">include</span>/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="token keyword">include</span>/stddef.h \
    /usr/<span class="token keyword">include</span>/bits/types.h /usr/<span class="token keyword">include</span>/bits/pthreadtypes.h \
    /usr/<span class="token keyword">include</span>/bits/sched.h /usr/<span class="token keyword">include</span>/libio.h \
    /usr/<span class="token keyword">include</span>/_G_config.h /usr/<span class="token keyword">include</span>/wchar.h \
    /usr/<span class="token keyword">include</span>/bits/wchar.h /usr/<span class="token keyword">include</span>/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="token keyword">include</span>/stdarg.h \
    /usr/<span class="token keyword">include</span>/bits/stdio_lim.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>gcc -MM main.c</code> 的输出则是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那么，编译器的这个功能如何与我们的 <code>Makefile</code> 联系在一起呢。因为这样一来，我们的 <code>Makefile</code> 也 要根据这些源文件重新生成，让 <code>Makefile</code> 自已依赖于源文件?这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。<code>GNU</code> 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的 <code>Makefile</code> 文件，<code>.d</code> 文件中就存放对应 <code>.c</code> 文件 的依赖关系。</p>
<p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让 <code>make</code> 自动更新或生成 <code>.d</code> 文件，并把其 包含在我们的主 <code>Makefile</code> 中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.d</span><span class="token punctuation">:</span> %.c
    <span class="token operator">@</span>set -e<span class="token punctuation">;</span> rm -f <span class="token variable">$@;</span> \
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -M <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> > <span class="token variable">$@.$$$$;</span> \
    sed <span class="token string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="token variable">$@.$$$$</span> > <span class="token variable">$@;</span> \ rm -f <span class="token variable">$@.$$$$</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件，<code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件，<code>$@</code> 表示模式 <code>%.d</code> 文件， 如果有一个 <code>C</code> 文件是 <code>name.c</code>，那么 <code>%</code> 就是 <code>name</code> ，<code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能 是“<code>name.d.12345</code>”，第三行使用 <code>sed</code> 命令做了一个替换，关于 <code>sed</code> 命令的用法请参看相关的使用文档。 第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>转成:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o main.d</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 <code>.d</code> 文件中加入的 不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 <code>Makefile</code> 中。我们可以使用 <code>Makefile</code> 的“<code>include</code>”命令，来引入别的 <code>Makefile</code> 文件(前面讲过)，例如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">sources <span class="token operator">=</span> foo.c bar.c

<span class="token target symbol">include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上述语句中的 <code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code> ，关于这个“<code>替换</code>”的内容，在后面我会有更为详细的讲述。当然，你得注意次序， 因为 <code>include</code> 是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目标会成为默认目标。</p>
<h1 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h1><p>每条规则中的命令和操作系统 <code>Shell</code> 的命令行是一致的。<code>make</code> 会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以 <code>Tab</code> 键开头的，那么 <code>make</code> 会认为其是一个空命令。</p>
<p>我们在 <code>UNIX</code> 下可能会使用不同的 <code>Shell</code>，但是 <code>make</code> 的命令默认是被 <code>/bin/sh ——UNIX</code> 的标准 <code>Shell</code> 解释执行的。除非你特别指定一个其它的 <code>Shell</code>。<code>Makefile</code> 中，<code>#</code> 是注释符，很像 <code>C/C++</code> 中的 <code>//</code> ，其后的本行字符都被注释。</p>
<h2 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h2><p>通常，<code>make</code> 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，<br>这个命令将不被 <code>make</code> 显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token operator">@</span>echo 正在编译XXX模块......<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当 <code>make</code> 执行时，会输出“<code>正在编译 XXX 模块⋯⋯</code>”字串，但不会输出命令，如果没有“<code>@</code>”，那么，<code>make</code> 将输出:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">echo 正在编译XXX模块......
正在编译XXX模块......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果 <code>make</code> 执行时，带入 <code>make</code> 参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令， 这个功能很有利于我们调试我们的 <code>Makefile</code>，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而 <code>make</code> 参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，<code>make</code> 会一条一条的执行其后的命令。 需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比 如你的第一条命令是 <code>cd</code> 命令，你希望第二条命令得在 <code>cd</code> 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如:</p>
<p>示例一:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">exec</span><span class="token punctuation">:</span>
    cd /home/hchen
    pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>示例二:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">exec</span><span class="token punctuation">:</span>
    cd /home/hchen<span class="token punctuation">;</span> pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当我们执行 <code>make exec</code> 时，第一个例子中的 <code>cd</code> 没有作用，<code>pwd</code> 会打印出当前的 <code>Makefile</code> 目录，而 第二个例子中，<code>cd</code> 就起作用了，<code>pwd</code> 会打印出“<code>/home/hchen</code>”。</p>
<p><code>make</code> 一般是使用环境变量 <code>SHELL</code> 中所定义的系统 <code>Shell</code> 来执行命令，默认情况下使用 <code>UNIX</code> 的标 准 <code>Shell——/bin/sh</code> 来执行命令。但在 <code>MS-DOS</code> 下有点特殊，因为 <code>MS-DOS</code> 下没有 <code>SHELL</code> 环境变量， 当然你也可以指定。如果你指定了 <code>UNIX</code> 风格的目录形式，首先，<code>make</code> 会在 <code>SHELL</code> 所指定的路径中找 寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在 <code>PATH</code> 环境 变量中所定义的所有路径中寻找。<code>MS-DOS</code> 中，如果你定义的命令解释器没有找到，其会给你的命令解 释器加上诸如 <code>.exe</code> 、<code>.com</code> 、<code>.bat</code> 、<code>.sh</code> 等后缀。</p>
<h2 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h2><p>每当命令运行完后，<code>make</code> 会检测每个命令的返回码，如果命令返回成功，那么 <code>make</code> 会执行下一条 命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错 了(命令退出码非零)，那么 <code>make</code> 就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如 <code>mkdir</code> 命令，我们一定需要建立一个目录，如果 目录不存在，那么 <code>mkdir</code> 就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用 <code>mkdir</code> 的意思就是一定要有这样的一个目录，于是我们就不希望 <code>mkdir</code> 出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在 <code>Makefile</code> 的命令行前加一个减号 <code>-</code> (在 <code>Tab</code> 键之 后)，标记为不管命令出不出错都认为是成功的。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    -rm -f *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>还有一个全局的办法是，给 <code>make</code> 加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，<code>Makefile</code> 中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。 这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的 <code>make</code> 的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<h2 id="嵌套执行-make"><a href="#嵌套执行-make" class="headerlink" title="嵌套执行 make"></a>嵌套执行 make</h2><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在 每个目录中都书写一个该目录的 <code>Makefile</code>，这有利于让我们的 <code>Makefile</code> 变得更加地简洁，而不至于把所 有的东西全部写在一个 <code>Makefile</code> 中，这样会很难维护我们的 <code>Makefile</code>，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫 <code>subdir</code>，这个目录下有个 <code>Makefile</code> 文件，来指明了这个目录下文件的编译规则。那么我们总控的 <code>Makefile</code> 可以这样书写:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>定义 <code>$(MAKE)</code> 宏变量的意思是，也许我们的 <code>make</code> 需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“<code>subdir</code>”目录，然后执行 <code>make</code> 命令。<br>我们把这个 <code>Makefile</code> 叫做“<code>总控 Makefile</code>”，<code>总控 Makefile</code> 的变量可以传递到下级的 <code>Makefile</code> 中 (如果你显示的声明)，但是不会覆盖下层的 <code>Makefile</code> 中所定义的变量，除非指定了 <code>-e</code> 参数。<br>如果你要传递变量到下级 <code>Makefile</code> 中，那么你可以使用这样的声明:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> &lt;variable ...><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果你不想让某些变量传递到下级 <code>Makefile</code> 中，那么你可以这样声明:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">unexport</span> &lt;variable ...><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如:<br>示例一:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> variable <span class="token operator">=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">=</span> value
<span class="token keyword">export</span> variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> variable <span class="token operator">:=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">:=</span> value
<span class="token keyword">export</span> variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>示例二:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> variable <span class="token operator">+=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">+=</span> value
<span class="token keyword">export</span> variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>如果你要传递所有的变量，那么，只要一个 export 就行了。后面什么也不用跟，表示传递所有的变量。<br>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否 <code>export</code>， 其总是要传递到下层 <code>Makefile</code> 中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了 <code>make</code> 的参数信息，如果我们执行“<code>总控 Makefile</code>”时有 <code>make</code> 参数或是在上层 <code>Makefile</code> 中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会 是这些参数，并会传递到下层 <code>Makefile</code> 中，这是一个系统级的环境变量。<br>但是 <code>make</code> 命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> (有关 <code>Makefile</code> 参数 的细节将在后面说明)，如果你不想往下层传递参数，那么，你可以这样来:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> MAKEFLAGS<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>如果你定义了环境变量 <code>MAKEFLAGS</code> ，那么你得确信其中的选项是大家都会用到的，如果其中有 <code>-t</code> , <code>-n</code> 和 <code>-q</code> 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“<code>嵌套执行</code>”中比较有用的参数，<code>-w</code> 或是 <code>--print-directory</code> 会在 <code>make</code> 的过程中输出 一些信息，让你看到目前的工作目录。比如，如果我们的下级 <code>make</code> 目录是“<code>/home/hchen/gnu/make</code>”， 如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看到:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">make</span><span class="token punctuation">:</span> Entering directory `/home/hchen/gnu/make'.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>而在完成下层 <code>make</code> 后离开目录时，我们会看到:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">make</span><span class="token punctuation">:</span> Leaving directory `/home/hchen/gnu/make'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>当你使用 <code>-C</code> 参数来指定 <code>make</code> 下层 <code>Makefile</code> 时，<code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> (<code>--slient</code> )或是 <code>--no-print-directory</code> ，那么，<code>-w</code> 总是失效的。</p>
<h2 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h2><p>如果 <code>Makefile</code> 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">define</span> run-yacc
yacc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">firstword</span> <span class="token variable">$^</span><span class="token punctuation">)</span>
mv y.tab.c <span class="token variable">$@</span>
<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>这里，“<code>run-yacc</code>”是这个命令包的名字，其不要和 <code>Makefile</code> 中的变量重名。在 <code>define</code> 和 <code>endef</code> 中 的两行就是命令序列。这个命令包中的第一个命令是运行 <code>Yacc</code> 程序，因为 <code>Yacc</code> 程序总是生成“<code>y.tab.c</code>” 的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo.c</span> <span class="token punctuation">:</span> foo.y
    <span class="token variable">$</span><span class="token punctuation">(</span>run-yacc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“<code>run- yacc</code>”中的 <code>$^</code> 就是 <code>foo.y</code> ，<code>$@</code> 就是 <code>foo.c</code>(有关这种以 <code>$</code> 开头的特殊变量，我们会在后面介绍)，<code>make</code> 在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>在 Makefile 中的定义的变量，就像是 <code>C/C++</code> 语言中的宏一样，他代表了一个文本字串，在 <code>Makefile</code> 中执行的时候其会自动原模原样地展开在所使用的地方。其与 <code>C/C++</code> 所不同的是，你可以在 <code>Makefile</code> 中改变其值。在 <code>Makefile</code> 中，变量可以使用在“<code>目标</code>”，“<code>依赖目标</code>”，“<code>命令</code>”或是 <code>Makefile</code> 的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线(可以是数字开头)，但不应该含有 : 、# 、&#x3D; 或是空 字符(空格、回车等)。变量是大小写敏感的，“<code>foo</code>”、“<code>Foo</code>”和“<code>FOO</code>”是三个不同的变量名。传统的 <code>Makefile</code> 的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如:<code>MakeFlags</code>。这样可以 避免和系统的变量冲突，而发生意外的事情。</p>
<p>有一些变量是很奇怪字串，如 <code>$&lt;</code> 、<code>$@</code> 等，这些是自动化变量，我会在后面介绍。</p>
<h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code> 来表示。</p>
<p>变量可以使用在许多地方，如规则中的“<code>目标</code>”、“<code>依赖</code>”、“<code>命令</code>”以及新的变量中。先看一个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> program.o foo.o utils.o

<span class="token target symbol">program</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o program <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>(objects)</span> <span class="token punctuation">:</span> defs.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>变量会在使用它的地方精确地展开，就像 <code>C/C++</code> 中的宏一样，例如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">=</span> c
<span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> -<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> prog.<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>展开后得到:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.c
    cc -c prog.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>当然，千万不要在你的 <code>Makefile</code> 中这样干，这里只是举个例子来表明 <code>Makefile</code> 中的变量在使用处展开的真实样子。可见其就是一个“<code>替代</code>”的原理。</p>
<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量 加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在 <code>Makefile</code> 中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用 <code>=</code> 号，在 <code>=</code> 左侧是变量，右侧是变量的值，右侧变量的值可以 定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义 的值。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
bar <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>ugh<span class="token punctuation">)</span>
ugh <span class="token operator">=</span> Huh?

<span class="token target symbol">all</span><span class="token punctuation">:</span>
    echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们执行“<code>make all</code>”将会打出变量 <code>$(foo)</code> 的值是 <code>Huh</code>? (<code>$(foo)</code> 的值是 <code>$(bar)</code> ，<code>$(bar)</code> 的值 是 <code>$(ugh)</code> ，<code>$(ugh)</code> 的值是 <code>Huh</code>? )可见，变量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>include_dirs<span class="token punctuation">)</span> -O
include_dirs <span class="token operator">=</span> -Ifoo -Ibar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>当 <code>CFLAGS</code> 在命令中被展开时，会是 <code>-Ifoo</code> <code>-Ibar</code> <code>-O</code> 。但这种形式也有不好的地方，那就是递归定 义，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">A <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>
B <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这会让 <code>make</code> 陷入无限的变量展开过程中去，当然，我们的 <code>make</code> 是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的 <code>make</code> 运行时非常慢，更糟糕的是， 他会使用得两个 <code>make</code> 的函数“<code>wildcard</code>”和“<code>shell</code>”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用 <code>make</code> 中的另一种用变量来定义变量的方法。这种方法使用的是 <code>:=</code> 操作符，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x <span class="token operator">:=</span> foo
y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
bar x <span class="token operator">:=</span> later<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">y <span class="token operator">:=</span> foo bar
x <span class="token operator">:=</span> later<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> bar
x <span class="token operator">:=</span> foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>那么，<code>y</code> 的值是“<code>bar</code>”，而不是“<code>foo bar</code>”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了 make 的函数、条件表达式和一个系统变量“<code>MAKELEVEL</code>”的使用:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>0,<span class="token variable">$</span><span class="token punctuation">&#123;</span>MAKELEVEL<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
cur-dir <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>
whoami <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> whoami<span class="token punctuation">)</span>
host-type <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> arch<span class="token punctuation">)</span>
MAKE <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>MAKE<span class="token punctuation">&#125;</span> host-type<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>host-type<span class="token punctuation">&#125;</span> whoami<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>关于条件表达式和函数，我们在后面再说，对于系统变量“<code>MAKELEVEL</code>”，其意思是，如果我们的 <code>make</code> 有一个嵌套执行的动作(参见前面的“嵌套使用 <code>make</code>”)，那么，这个变量会记录了我们的当前 <code>Makefile</code> 的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是 一个空格，那么我们可以这样来:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">nullstring <span class="token operator">:=</span>
space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># end of the line</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p><code>nullstring</code> 是一个 <code>Empty</code> 变量，其中什么也没有，而我们的 <code>space</code> 的值是一个空格。因为在操作符 的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 <code>Empty</code> 变量来标明变量的值开始了， 而后面采用“<code>#</code>”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意 这里关于“<code>#</code>”的使用，注释符“<code>#</code>”的这种特性值得我们注意，如果我们这样定义一个变量:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">dir <span class="token operator">:=</span> /foo/bar <span class="token comment"># directory to put the frobs in</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p><code>dir</code> 这个变量的值是“<code>/foo/bar</code>”，后面还跟了 <code>4</code> 个空格，如果我们这样使用这个变量来指定别的目录——“<code>$(dir)/file</code>”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是 <code>?=</code> ，先看示例:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">FOO <span class="token operator">?=</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其含义是，如果 <code>FOO</code> 没有被定义过，那么变量 <code>FOO</code> 的值就是“<code>bar</code>”，如果 <code>FOO</code> 先前被定义过，<br>那么这条语将什么也不做，其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> FOO<span class="token punctuation">)</span>, undefined<span class="token punctuation">)</span>
    FOO <span class="token operator">=</span> bar
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。<br>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> ，其意思是，把变量 “<code>var</code>”中所有以“<code>a</code>”字串“结尾”的“<code>a</code>”替换成“<code>b</code>”字串。这里的“<code>结尾</code>”意思是“<code>空格</code>”或是“<code>结束符</code>”。 还是看一个示例吧:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> a.o b.o c.o
bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这个示例中，我们先定义了一个 <code>$(foo)</code> 变量，而第二行的意思是把 <code>$(foo)</code> 中所有以 <code>.o</code> 字串“结 尾”全部替换成 <code>.c</code> ，所以我们的 <code>$(bar)</code> 的值就是“<code>a.c</code> <code>b.c</code> <code>c.c</code>”。</p>
<p>另外一种变量替换的技术是以“<code>静态模式</code>”(参见前面章节)定义的，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> a.o b.o c.o
bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>%.o<span class="token operator">=</span>%.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个 <code>%</code> 字符，这个例子同样让 <code>$(bar)</code> 变 量的值为“<code>a.c</code> <code>b.c</code> <code>c.c</code>”。<br>第二种高级用法是——“<code>把变量的值再当成变量</code>”。先看一个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x<span class="token operator">=</span>y
y<span class="token operator">=</span>z
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>在这个例子中，<code>$(x)</code> 的值是“<code>y</code>”，所以 <code>$($(x))</code> 就是 <code>$(y)</code>，于是 <code>$(a)</code> 的值就是“<code>z</code>”。(注意，是 “<code>x=y</code>”，而不是“<code>x=$(y)</code>”)<br>   我们还可以使用更多的层次:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x<span class="token operator">=</span>y
y<span class="token operator">=</span>z
z<span class="token operator">=</span>u
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的 <code>$(a)</code> 的值是“<code>u</code>”，相关的推导留给读者自己去做吧。 让我们再复杂一点，使用上“<code>在变量定义中使用变量</code>”的第一个方式，来看一个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> y<span class="token operator">=</span>z
z <span class="token operator">=</span> Hello
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里的 <code>$($(x))</code> 被替换成了 <code>$($(y))</code> ，因为 <code>$(y)</code> 值是“<code>z</code>”，所以，最终结果是: <code>a:=$(z)</code> ，也就 是“<code>Hello</code>”。</p>
<p>再复杂一点，我们再加上函数:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x <span class="token operator">=</span> variable1 variable2 <span class="token operator">:=</span> Hello
y <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> 1,2,<span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> z<span class="token operator">=</span>y
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这个例子中，<code>$($($(z)))</code> 扩展为 <code>$($(y))</code> ，而其再次被扩展为 <code>$($(subst 1,2,$(x)))</code> 。<code>$(x)</code> 的 值是“<code>variable1</code>”，<code>subst</code> 函数把“<code>variable1</code>”中的所有“<code>1</code>”字串替换成“<code>2</code>”字串，于是，“<code>variable1</code>”变 成“<code>variable2</code>”，再取其值，所以，最终，<code>$(a)</code> 的值就是 <code>$(variable2)</code> 的值——“<code>Hello</code>”。</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">first_second <span class="token operator">=</span> Hello
a <span class="token operator">=</span> first
b <span class="token operator">=</span> second
all <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$a_$b</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>这里的 <code>$a_$b</code> 组成了“<code>first_second</code>”，于是，<code>$(all)</code> 的值就是“<code>Hello</code>”。</p>
<p>再来看看结合第一种技术的例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a_objects <span class="token operator">:=</span> a.o b.o c.o
1_objects <span class="token operator">:=</span> 1.o 2.o 3.o

sources <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>_objects<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个例子中，如果 <code>$(a1)</code> 的值是“<code>a</code>”的话，那么，<code>$(sources)</code> 的值就是“<code>a.c</code> <code>b.c</code> <code>c.c</code>”;如果 <code>$(a1)</code> 的值是“<code>1</code>”，那么 <code>$(sources)</code> 的值是“<code>1.c</code> <code>2.c</code> <code>3.c</code>”。</p>
<p>再来看一个这种技术和“<code>函数</code>”与“<code>条件语句</code>”一同使用的例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> do_sort
  func <span class="token operator">:=</span> sort
<span class="token keyword">else</span>
  func <span class="token operator">:=</span> strip
<span class="token keyword">endif</span>

bar <span class="token operator">:=</span> a d b g q c

foo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个示例中，如果定义了“<code>do_sort</code>”，那么: <code>foo := $(sort a d b g q c)</code> ，于是 <code>$(foo)</code> 的值就 是“<code>a b c d g q</code>”，而如果没有定义“<code>do_sort</code>”，那么: <code>foo := $(strip a d b g q c)</code> ，调用的就是 <code>strip</code> 函数。</p>
<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">dir <span class="token operator">=</span> foo
<span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_sources <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> <span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>/*.c<span class="token punctuation">)</span>
<span class="token keyword">define</span> <span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_print
lpr <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_sources<span class="token punctuation">)</span>
<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个例子中定义了三个变量:“<code>dir</code>”，“<code>foo_sources</code>”和“<code>foo_print</code>”。</p>
<h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>我们可以使用 <code>+=</code> 操作符给变量追加值，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o foo.o bar.o utils.o
objects <span class="token operator">+=</span> another.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>于是，我们的 <code>$(objects)</code> 值变成:“<code>main.o</code> <code>foo.o</code> <code>bar.o</code> <code>utils.o</code> <code>another.o</code>”(<code>another.o</code> 被追加进去了)<br>使用 <code>+=</code> 操作符，可以模拟为下面的这种例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o foo.o bar.o utils.o
objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> another.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所不同的是，用 <code>+=</code> 更为简洁。</p>
<p>如果变量之前没有定义过，那么，<code>+=</code> 会自动变成 <code>=</code> ，如果前面有变量定义，那么 <code>+=</code> 会继承于前次<br>操作的赋值符。如果前一次的是 <code>:=</code> ，那么 <code>+=</code> 会以 <code>:=</code> 作为其赋值符，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">:=</span> value
variable <span class="token operator">+=</span> more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">:=</span> value
variable <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span> more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但如果是这种情况:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">variable <span class="token operator">=</span> value
variable <span class="token operator">+=</span> more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于前次的赋值符是 <code>=</code> ，所以 <code>+=</code> 也会以 <code>=</code> 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以 <code>make</code> 会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h2 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h2><p>如果有变量是通常 <code>make</code> 的命令行参数设置的，那么 <code>Makefile</code> 中对这个变量的赋值会被忽略。如果你想在 <code>Makefile</code> 中设置这类参数的值，那么，你可以使用“<code>override</code>”指示符。其语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">=</span> &lt;value><span class="token punctuation">;</span>
<span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">:=</span> &lt;value><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然，你还可以追加:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">+=</span> &lt;more text><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于多行的变量定义，我们用 <code>define</code> 指示符，在 <code>define</code> 指示符前，也同样可以使用 <code>override</code> 指示符， 如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">override</span> <span class="token keyword">define</span> foo
bar
<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<h2 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h2><p>还有一种设置变量值的方法是使用 define 关键字。使用 define 关键字设置变量的值可以有换行，这有利于定义一系列的命令(前面我们讲过“命令包”的技术就是利用这个关键字)。</p>
<p><code>define</code> 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 <code>endef</code> 关键字结束。其工作方式和“<code>=</code>”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以 <code>[Tab]</code> 键开头，所以如果你用 <code>define</code> 定义的命令变量中没有以 <code>Tab</code> 键开头，那么 <code>make</code> 就不会把其认为是命令。</p>
<p>下面的这个示例展示了 <code>define</code> 的用法:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">define</span> two-lines
echo foo
echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>make</code> 运行时的系统环境变量可以在 <code>make</code> 开始运行时被载入到 <code>Makefile</code> 文件中，但是如果 <code>Makefile</code> 中已定义了这个变量，或是这个变量由 <code>make</code> 命令行带入，那么系统的环境变量的值将被覆盖。(如果 <code>make</code> 指定了“<code>-e</code>”参数，那么，系统环境变量将覆盖 <code>Makefile</code> 中定义的变量)</p>
<p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的 <code>Makefile</code> 中使用 这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果 <code>Makefile</code> 中定义了 <code>CFLAGS</code>，那么 则会使用 <code>Makefile</code> 中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很 像“<code>全局变量</code>”和“<code>局部变量</code>”的特性。</p>
<p>当 <code>make</code> 嵌套调用时(参见前面的“嵌套调用”章节)，上层 <code>Makefile</code> 中定义的变量会以系统环境变 量的方式传递到下层的 <code>Makefile</code> 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义 在文件中的变量，如果要向下层 <code>Makefile</code> 传递，则需要使用 <code>export</code> 关键字来声明。(参见前面章节)</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的 <code>Makefile</code> 时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h2 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h2><p>前面我们所讲的在 <code>Makefile</code> 中定义的变量都是“<code>全局变量</code>”，在整个文件，我们都可以访问这些变量。当然，“<code>自动化变量</code>”除外，如 <code>$&lt;</code> 等这种类量的自动化变量就属于“<code>规则型变量</code>”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“<code>Target-specific Variable</code>”，它可以 和“<code>全局变量</code>”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">&lt;target ...></span> <span class="token punctuation">:</span> &lt;variable-assignment><span class="token punctuation">;</span>
<span class="token target symbol">&lt;target ...></span> <span class="token punctuation">:</span> overide &lt;variable-assignment><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p><code>&lt;variable-assignment&gt;</code>; 可以是前面讲过的各种赋值表达式，如 <code>=</code> 、<code>:=</code> 、<code>+=</code> 或是 <code>?=</code> 。第二个语法 是针对于 <code>make</code> 命令行带入的变量，或是系统环境变量。<br>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">prog</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g

<span class="token target symbol">prog</span> <span class="token punctuation">:</span> prog.o foo.o bar.o
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o

<span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.c

<span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c

<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，不管全局的<code> $(CFLAGS)</code> 的值是什么，在 <code>prog</code> 目标，以及其所引发的所有规则中 (<code>prog.o</code> <code>foo.o</code> <code>bar.o</code> 的规则)，<code>$(CFLAGS)</code> 的值都是 <code>-g</code></p>
<h2 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h2><p>在 <code>GNU</code> 的 <code>make</code> 中，还支持模式变量(<code>Pattern-specific Variable</code>)，通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“<code>模式</code>”，可以把变量定义 在符合这种模式的所有目标上。</p>
<p>我们知道，<code>make</code>的“<code>模式</code>”一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code>结 尾的目标定义目标变量:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同样，模式变量的语法和“目标变量”一样:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">&lt;pattern ...>;</span> <span class="token punctuation">:</span> &lt;variable-assignment><span class="token punctuation">;</span>
<span class="token target symbol">&lt;pattern ...>;</span> <span class="token punctuation">:</span> <span class="token keyword">override</span> &lt;variable-assignment><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>override</code> 同样是针对于系统环境传入的变量，或是 <code>make</code> 命令行指定的变量。</p>
<h1 id="使用条件判断"><a href="#使用条件判断" class="headerlink" title="使用条件判断"></a>使用条件判断</h1><p>使用条件判断，可以让 <code>make</code> 根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的例子，判断 <code>$(CC)</code> 变量是否 <code>gcc</code> ，如果是的话，则使用 <code>GNU</code> 函数编译目标。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">
libs_for_gcc <span class="token operator">=</span> -lgnu
normal_libs <span class="token operator">=</span>

<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>,gcc<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span>
<span class="token keyword">endif</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可见，在上面示例的这个规则中，目标 <code>foo</code> 可以根据变量 <code>$(CC)</code> 值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字:<code>ifeq</code> 、<code>else</code> 和 <code>endif</code> 。<code>ifeq</code> 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。<code>else</code> 表示条件 表达式为假的情况。<code>endif</code> 表示一个条件语句的结束，任何一个条件表达式都应该以 <code>endif</code> 结束。</p>
<p>当我们的变量 <code>$(CC)</code> 值是 <code>gcc</code> 时，目标 <code>foo</code> 的规则是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而当我们的变量 <code>$(CC)</code> 值不是 <code>gcc</code> 时(比如 <code>cc</code> )，目标 <code>foo</code> 的规则是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然，我们还可以把上面的那个例子写得更简洁一些:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">libs_for_gcc <span class="token operator">=</span> -lgnu
normal_libs <span class="token operator">=</span>

<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>,gcc<span class="token punctuation">)</span>
    libs<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span>
<span class="token keyword">else</span>
    libs<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span>
<span class="token keyword">endif</span>

<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>条件表达式的语法为:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">&lt;conditional-directive>
&lt;text-if-true>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>以及:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">&lt;conditional-directive>
&lt;text-if-true>
<span class="token keyword">else</span>
&lt;text-if-false>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，如 <code>ifeq</code> 。这个关键字有四个。</p>
<p>第一个是我们前面所见过的 <code>ifeq</code></p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>&lt;arg1>, &lt;arg2><span class="token punctuation">)</span>
<span class="token keyword">ifeq</span> <span class="token string">'&lt;arg1>'</span> <span class="token string">'&lt;arg2>'</span>
<span class="token keyword">ifeq</span> <span class="token string">"&lt;arg1>"</span> <span class="token string">"&lt;arg2>"</span>
<span class="token keyword">ifeq</span> <span class="token string">"&lt;arg1>"</span> <span class="token string">'&lt;arg2>'</span>
<span class="token keyword">ifeq</span> <span class="token string">'&lt;arg1>'</span> <span class="token string">"&lt;arg2>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同。当然，参数中我们还可以使用 <code>make</code> 的函数。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>,<span class="token punctuation">)</span>
&lt;text-if-empty>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>这个示例中使用了 <code>strip</code> 函数，如果这个函数的返回值是空(<code>Empty</code>)，那么 <code>&lt;text-if-empty&gt;</code> 就 生效。</p>
<p>第二个条件关键字是 <code>ifneq</code> 。语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>&lt;arg1>, &lt;arg2><span class="token punctuation">)</span>
<span class="token keyword">ifneq</span> <span class="token string">'&lt;arg1>'</span> <span class="token string">'&lt;arg2>'</span>
<span class="token keyword">ifneq</span> <span class="token string">"&lt;arg1>"</span> <span class="token string">"&lt;arg2>"</span>
<span class="token keyword">ifneq</span> <span class="token string">"&lt;arg1>"</span> <span class="token string">'&lt;arg2>'</span>
<span class="token keyword">ifneq</span> <span class="token string">'&lt;arg1>'</span> <span class="token string">"&lt;arg2>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真。和 <code>ifeq</code> 类似。</p>
<p>第三个条件关键字是 <code>ifdef</code> 。语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> &lt;variable-name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真。否则，表达式为假。当然，<code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值。注意，<code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前 位置。还是来看两个例子:</p>
<p>示例一:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">=</span>
foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
<span class="token keyword">ifdef</span> foo
    frobozz <span class="token operator">=</span> yes
<span class="token keyword">else</span>
    frobozz <span class="token operator">=</span> no
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例二:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">=</span>
<span class="token keyword">ifdef</span> foo
    frobozz <span class="token operator">=</span> yes
<span class="token keyword">else</span>
    frobozz <span class="token operator">=</span> no
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个例子中，<code>$(frobozz)</code> 值是 <code>yes</code> ，第二个则是 <code>no</code>。</p>
<p>第四个条件关键字是 <code>ifndef</code> 。其语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifndef</span> &lt;variable-name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个我就不多说了，和 <code>ifdef</code> 是相反的意思。</p>
<p>在 <code>&lt;conditional-directive&gt;</code> 这一行上，多余的空格是被允许的，但是不能以 <code>Tab</code> 键作为开始(不 然就被认为是命令)。而注释符 # 同样也是安全的。<code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了。</p>
<p>特别注意的是，<code>make</code> 是在读取 <code>Makefile</code> 时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量(如 <code>$@</code> 等)放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且为了避免混乱，<code>make</code> 不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>在 <code>Makefile</code> 中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。<code>make</code> 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使 用。</p>
<h2 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h2><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>&lt;function> &lt;arguments><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">&#123;</span>&lt;function> &lt;arguments><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里，<code>&lt;function&gt;</code> 就是函数名，<code>make</code> 支持的函数不多。<code>&lt;arguments&gt;</code> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“<code>空格</code>”分隔。函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是<code>?</code>函数中的参数可以使用变量，为了风格的统一，函数和变量的括号 最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b, $&#123;x&#125;)</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<p>还是来看一个示例:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">comma<span class="token operator">:=</span> ,
empty<span class="token operator">:=</span>
space<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>
foo<span class="token operator">:=</span> a b c
bar<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，<code>$(comma)</code> 的值是一个逗号。<code>$(space)</code> 使用了 <code>$(empty)</code> 定义了一个空格，<code>$(foo)</code> 的值是 <code>a</code> <code>b</code> <code>c</code> ，<code>$(bar)</code> 的定义用，调用了函数 <code>subst</code> ，这是一个替换函数，这个函数有三个参数，第 一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是 把 <code>$(foo)</code> 中的空格替换成逗号，所以 <code>$(bar)</code> 的值是 <code>a</code>,<code>b</code>,<code>c</code> 。</p>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><h3 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> &lt;from>,&lt;to>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 字符串替换函数</li>
<li><code>功能</code>: 把字串<code>&lt;text&gt;</code>中的<code>&lt;from&gt;</code>字符串替换成<code>&lt;to&gt;</code>。</li>
<li><code>返回</code>: 函数返回被替换过后的字符串。</li>
<li><code>示例</code>:  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ee,EE,feet on the street<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
  把 <code>feet</code> <code>on</code> <code>the</code> <code>street</code> 中的 <code>ee</code> 替换成 <code>EE</code> ，返回结果是 <code>fEEt</code> <code>on</code> <code>the</code> <code>strEEt</code> 。</li>
</ul>
<h3 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> &lt;pattern>,&lt;replacement>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p><code>名称</code>: 模式字符串替换函数。</p>
</li>
<li><p><code>功能</code>: 查找<code>&lt;text&gt;</code>中的单词(单词以“<code>空格</code>”、“<code>Tab</code>”或“<code>回车</code>”“<code>换行</code>”分隔)是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里，<code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code> ， 表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么，<code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。(可以用 <code>\</code> 来转义，以 <code>\%</code>来表示真实含义的 <code>%</code> 字符)</p>
</li>
<li><p><code>返回</code>: 函数返回被替换过后的字符串。</p>
</li>
<li><p><code>示例</code>:</p>
  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,x.c.c bar.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  把字串 <code>x.c.c</code> <code>bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o</code> <code>bar.o</code></p>
</li>
<li><p><code>备注</code>: 这和我们前面“<code>变量章节</code>”说过的相关知识有点相似。如 <code>$(var:&lt;pattern&gt;=&lt;replacement&gt;; )</code> 相当于 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code> ， 而 <code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code> 则相当于 <code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code> 。<br>  例如有:</p>
  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o baz.o，<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  那么，$(objects:.o&#x3D;.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</p>
</li>
</ul>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> &lt;string><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 去空格函数。</li>
<li><code>功能</code>: 去掉<code>&lt;string&gt;</code>字串中开头和结尾的空字符。</li>
<li><code>返回</code>: 返回被去掉空格的字符串值。</li>
<li><code>示例</code>:  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> a b c <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
  把字串去掉开头和结尾的空格，结果是 <code>a</code> <code>b</code> <code>c</code>。</li>
</ul>
<h3 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> &lt;find>,&lt;in><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>:查找字符串函数</li>
<li><code>功能</code>:在字串<code>&lt;in&gt;</code>中查找<code>&lt;find&gt;</code>字串。</li>
<li><code>返回</code>:如果找到，那么返回<code>&lt;find&gt;</code>，否则返回空字符串。</li>
<li><code>示例</code>:  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> a,a b c<span class="token punctuation">)</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> a,b c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
  第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> &lt;pattern...>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 过滤函数</li>
<li><code>功能</code>: 以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，保留符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。</li>
<li><code>返回</code>: 返回符合模式<code>&lt;pattern&gt;</code>的字串。</li>
<li><code>示例</code>:  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">sources <span class="token operator">:=</span> foo.c bar.c baz.s ugh.h
<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>
    cc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> %.c %.s,<span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span> -o foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
  <code>$(filter %.c %.s,$(sources))</code> 返回的值是 <code>foo.c</code> <code>bar.c</code> <code>baz.s</code> 。</li>
</ul>
<h3 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter-out</span> &lt;pattern...>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 反过滤函数</li>
<li><code>功能</code>: 以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，去除符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。</li>
<li><code>返回</code>: 返回不符合模式<code>&lt;pattern&gt;</code>的字串。</li>
<li><code>示例</code>:  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects<span class="token operator">=</span>main1.o foo.o main2.o bar.o
mains<span class="token operator">=</span>main1.o main2.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
  <code>$(filter-out $(mains)</code>,<code>$(objects))</code> 返回值是 <code>foo.o</code> <code>bar.o</code> 。</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">sort</span> &lt;list><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 排序函数</li>
<li><code>功能</code>: 给字符串<code>&lt;list&gt;</code>中的单词排序(升序)。</li>
<li><code>返回</code>: 返回排序后的字符串。</li>
<li><code>示例</code>: <code>$(sortfoobarlose)</code> 返回 <code>barfoolose</code>。</li>
<li><code>备注</code>: <code>sort</code>函数会去掉<code>&lt;list&gt;</code>中相同的单词。</li>
</ul>
<h3 id="word"><a href="#word" class="headerlink" title="word"></a>word</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> &lt;n>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 取单词函数</li>
<li><code>功能</code>: 取字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词。(从一开始)</li>
<li><code>返回</code>: 返回字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词。如果<code>&lt;n&gt;</code>比<code>&lt;text&gt;</code>中的单词数要大，那么返回空字符串。</li>
<li><code>示例</code>: <code>$(word2,foobarbaz)</code> 返回值是 <code>bar</code>。</li>
</ul>
<h3 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wordlist</span> &lt;ss>,&lt;e>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 取单词串函数</li>
<li><code>功能</code>: 从字符串<code>&lt;text&gt;</code>中取从<code>&lt;ss&gt;</code>开始到<code>&lt;e&gt;</code>的单词串。<code>&lt;ss&gt;</code>和<code>&lt;e&gt;</code>是一个数字。</li>
<li><code>返回</code>: 返回字符串<code>&lt;text&gt;</code>中从<code>&lt;ss&gt;</code>到<code>&lt;e&gt;</code>的单词字串。如果<code>&lt;ss&gt;</code>比<code>&lt;text&gt;</code>中的单词数要大， 那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数，那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的 单词串。</li>
<li><code>示例</code>: <code>$(wordlist2,3,foobarbaz)</code> 返回值是 <code>barbaz</code></li>
</ul>
<h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">words</span> &lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 单词个数统计函数</li>
<li><code>功能</code>: 统计<code>&lt;text&gt;</code>中字符串中的单词个数。</li>
<li><code>返回</code>: 返回<code>&lt;text&gt;</code>中的单词数。</li>
<li><code>示例</code>: <code>$(words,foobarbaz)</code>返回值是<code>3</code>。</li>
<li><code>备注</code>: 如果我们要取 <code>&lt;text&gt;</code> 中最后的一个单词，我们可以这样: <code>$(word $(words &lt;text&gt;), &lt;text&gt;)</code> 。</li>
</ul>
<h3 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">firstword</span> &lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>名称</code>: 首单词函数——<code>firstword</code>。</li>
<li><code>功能</code>: 取字符串<code>&lt;text&gt;</code>中的第一个单词。</li>
<li><code>返回</code>: 返回字符串<code>&lt;text&gt;</code>的第一个单词。</li>
<li><code>示例</code>: <code>$(firstwordfoobar)</code>返回值是<code>foo</code>。</li>
<li><code>备注</code>: 这个函数可以用word函数来实现: <code>$(word1,&lt;text&gt;)</code>。</li>
</ul>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实 中应用的例子。我们知道，<code>make</code> 使用 <code>VPATH</code> 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code> ，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">override</span> CFLAGS <span class="token operator">+=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %,-I%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token punctuation">:</span>, ,<span class="token variable">$</span><span class="token punctuation">(</span>VPATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code> ，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是 <code>cc</code> 或 <code>gcc</code> 搜索头文件路径的参数。</p>
<h2 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> &lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 取目录函数——<code>dir</code>。</li>
<li><code>功能</code>: 从文件名序列<code>&lt;names&gt;</code>中取出目录部分。目录部分是指最后一个反斜杠(<code>/</code>)之前的部分。 如果没有反斜杠，那么返回 <code>./ </code>。</li>
<li><code>返回</code>: 返回文件名序列<code>&lt;names&gt;</code>的目录部分。</li>
<li><code>示例</code>: <code>$(dirsrc/foo.chacks)</code> 返回值是 <code>src/./</code>。</li>
</ul>
<h3 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> &lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 取文件函数——<code>notdir</code>。</li>
<li><code>功能</code>: 从文件名序列<code>&lt;names&gt;</code>中取出非目录部分。非目录部分是指最後一个反斜杠(<code>/</code>)之后的部分。</li>
<li><code>返回</code>: 返回文件名序列<code>&lt;names&gt;</code>的非目录部分。</li>
<li><code>示例</code>: <code>$(notdirsrc/foo.chacks)</code>返回值是<code>foo.chacks</code>。</li>
</ul>
<h3 id="suﬀix"><a href="#suﬀix" class="headerlink" title="suﬀix"></a>suﬀix</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">suffix</span> &lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 取後缀函数——<code>suﬀix</code>。</li>
<li><code>功能</code>: 从文件名序列<code>&lt;names&gt;</code>中取出各个文件名的后缀。</li>
<li><code>返回</code>: 返回文件名序列<code>&lt;names&gt;</code>的后缀序列，如果文件没有后缀，则返回空字串。</li>
<li><code>示例</code>: <code>$(suffixsrc/foo.csrc-1.0/bar.chacks)</code> 返回值是 <code>.c.c</code>。</li>
</ul>
<h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">basename</span> &lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 取前缀函数——<code>basename</code>。</li>
<li><code>功能</code>: 从文件名序列<code>&lt;names&gt;</code>中取出各个文件名的前缀部分。</li>
<li><code>返回</code>: 返回文件名序列<code>&lt;names&gt;</code>的前缀序列，如果文件没有前缀，则返回空字串。</li>
<li><code>示例</code>: <code>$(basenamesrc/foo.csrc-1.0/bar.chacks)</code> 返回值是 <code>src/foosrc-1.0/barhacks</code>。</li>
</ul>
<h3 id="addsuﬀix"><a href="#addsuﬀix" class="headerlink" title="addsuﬀix"></a>addsuﬀix</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">addsuffix</span> &lt;suffix>,&lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 加后缀函数——<code>addsuﬀix</code>。</li>
<li><code>功能</code>: 把后缀<code>&lt;suffix&gt;</code>加到<code>&lt;names&gt;</code>中的每个单词后面。</li>
<li><code>返回</code>: 返回加过后缀的文件名序列。</li>
<li><code>示例</code>: <code>$(addsuffix.c,foobar)</code> 返回值是 <code>foo.cbar.c</code>。</li>
</ul>
<h3 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>addprefix &lt;prefix>,&lt;names...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 加前缀函数——<code>addprefix</code>。</li>
<li><code>功能</code>: 把前缀<code>&lt;prefix&gt;</code>加到<code>&lt;names&gt;</code>中的每个单词前面。</li>
<li><code>返回</code>: 返回加过前缀的文件名序列。</li>
<li><code>示例</code>: <code>$(addprefixsrc/,foobar)</code> 返回值是 <code>src/foosrc/bar</code>。</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">join</span> &lt;list1>,&lt;list2><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>名称</code>: 连接函数——<code>join</code>。</li>
<li><code>功能</code>: 把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么，<code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么，<code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</li>
<li><code>返回</code>: 返回连接过后的字符串。</li>
<li><code>示例</code>: <code>$(joinaaabbb,111222333)</code> 返回值是 <code>aaa111</code> <code>bbb222</code> <code>333</code>。</li>
</ul>
<h2 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h2><p><code>foreach</code> 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，<code>Makefile</code> 中的 <code>foreach</code> 函数几乎是仿照于 <code>Unix</code> 标准 <code>Shell(/bin/sh)</code> 中的 <code>for</code> 语句，或是 <code>C-Shell(/bin/csh)</code> 中的 <code>foreach</code> 语句 而构建的。它的语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> &lt;var>,&lt;list>,&lt;text><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code>所指定的变量中，然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中，<code>&lt;text&gt;</code> 的所返回的每个 字符串会以空格分隔，最后当整个循环结束时，<code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串(以空格分隔)将会是 <code>foreach</code> 函数的返回值。</p>
<p>所以，<code>&lt;var&gt;</code> 最好是一个变量名，<code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会使用 <code>&lt;var&gt;</code> 这个 参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">names <span class="token operator">:=</span> a b c d

files <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> n,<span class="token variable">$</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，<code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中，<code>$(n).o</code> 每次根据 <code>$(n)</code> 计算出 一个值，这些值以空格分隔，最后作为 <code>foreach</code> 函数的返回，所以，<code>$(files)</code> 的值是 <code>a.o</code> <code>b.o</code> <code>c.o</code> <code>d.o</code> 。</p>
<p>注意，<code>foreach</code> 中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，<code>foreach</code> 函数执行完后，参数 <code>&lt;var&gt;</code> 的变量 将不在作用，其作用域只在 <code>foreach</code> 函数当中。</p>
<h2 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h2><p><code>if</code> 函数很像 <code>GNU</code> 的 <code>make</code> 所支持的条件语句——<code>ifeq</code>(参见前面所述的章节)，<code>if</code> 函数的语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> &lt;condition>,&lt;then-part><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或是</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> &lt;condition>,&lt;then-part>,&lt;<span class="token keyword">else</span>-part><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可见，<code>if</code> 函数可以包含“<code>else</code>”部分，或是不含。即 <code>if</code> 函数的参数可以是两个，也可以是三个。 <code>&lt;condition&gt;</code> 参数是 <code>if</code> 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<code>&lt;then-part&gt;</code> 会被计算，否则 <code>&lt;else-part&gt;</code> 会被计算。</p>
<p>而 <code>if</code> 函数的返回值是，如果 <code>&lt;condition&gt;</code> 为真(非空字符串)，那个 <code>&lt;then-part&gt;</code> 会是整个函数 的返回值，如果 <code>&lt;condition&gt;</code> 为假(空字符串)，那么 <code>&lt;else-part&gt;</code> 会是整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code> 没有被定义，那么，整个函数返回空字串。</p>
<p>所以，<code>&lt;then-part&gt;</code> 和 <code>&lt;else-part&gt;</code> 只会有一个被计算。</p>
<h2 id="call-函数"><a href="#call-函数" class="headerlink" title="call 函数"></a>call 函数</h2><p><code>call</code> 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以 <code>call</code> 函数来向这个表达式传递参数。其语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> &lt;expression>,&lt;parm1>,&lt;parm2>,...,&lt;parmn><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当 <code>make</code> 执行这个函数时，<code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、<code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、<code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 <code>call</code> 函数的返回值。例如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">reverse <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span>

foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> reverse,a,b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>那么，<code>foo</code> 的值就是 <code>a</code> <code>b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">reverse <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>

foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> reverse,a,b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>此时的 <code>foo</code> 的值就是 <code>b</code> <code>a</code> 。</p>
<p>需要注意: 在向 <code>call</code> 函数传递参数时要尤其注意空格的使用。<code>call</code> 函数在处理参数时，第 <code>2</code> 个及其 之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 <code>call</code> 函数提供参数时，最安全 的做法是去除所有多余的空格。</p>
<h2 id="origin-函数"><a href="#origin-函数" class="headerlink" title="origin 函数"></a>origin 函数</h2><p><code>origin</code> 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的?其语法是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> &lt;variable><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意，<code>&lt;variable&gt; </code>是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code>中使用 <code>$</code> 字符。<code>Origin</code> 函数会以其返回值来告诉你这个变量的“<code>出生情况</code>”，下面，是 <code>origin</code> 函数的返回值:</p>
<p><code>undefined</code> : 如果<code> &lt;variable&gt;</code> 从来没有定义过，<code>origin</code> 函数返回这个值 <code>undefined</code><br><code>default</code> : 如果 <code>&lt;variable&gt;</code> 是一个默认的定义，比如“<code>CC</code>”这个变量，这种变量我们将在后面讲述。<br><code>environment</code> : 如果 <code>&lt;variable&gt;</code> 是一个环境变量，并且当 <code>Makefile</code> 被执行时，<code>-e </code>参数没有被打开。<br><code>file</code> : 如果 <code>&lt;variable&gt;</code> 这个变量被定义在 <code>Makefile</code> 中。<br><code>command line</code> : 如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。<br><code>override</code> : 如果<code> &lt;variable&gt;</code> 是被 <code>override</code> 指示符重新定义的。<br><code>automatic</code> : 如果 <code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<p>这些信息对于我们编写 <code>Makefile</code> 是非常有用的，例如，假设我们有一个 <code>Makefile</code> 其包了一个定义文件 <code>Make.def</code>，在 <code>Make.def</code> 中定义了一个变量“<code>bletch</code>”，而我们的环境中也有一个环境变量“<code>bletch</code>”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于 <code>Make.def</code> 或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的 <code>Makefile</code> 中，我们可以这样写:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> bletch
    <span class="token keyword">ifeq</span> <span class="token string">"$(origin bletch)"</span> <span class="token string">"environment"</span>
        bletch <span class="token operator">=</span> barf, gag, etc.
    <span class="token keyword">endif</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然，你也许会说，使用 <code>override</code> 关键字不就可以重新定义环境中的变量了吗?为什么需要使用这样的步骤?是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code> 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><p><code>shell</code> 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统 <code>Shell</code> 的命令。它和反引号“<code>‘</code>” 是相同的功能。这就是说，<code>shell</code> 函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操 作系统命令以及字符串处理命令 <code>awk</code>，<code>sed</code> 等等命令来生成一个变量，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">contents <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> cat foo<span class="token punctuation">)</span>
files <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> echo *.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>注意，这个函数会新生成一个 <code>Shell</code> 程序来执行命令，所以你要注意其运行性能，如果你的 <code>Makefile</code> 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 <code>Makefile</code> 的隐晦的规则可能会让你的 <code>shell</code> 函数执行的次数比你想像的多得多。</p>
<h2 id="控制-make-的函数"><a href="#控制-make-的函数" class="headerlink" title="控制 make 的函数"></a>控制 make 的函数</h2><p><code>make</code> 提供了一些函数来控制 <code>make</code> 的运行。通常，你需要检测一些运行 <code>Makefile</code> 时的运行时信息，并且根据这些信息来决定，你是让 <code>make</code> 继续执行，还是停止。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> &lt;text ...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>产生一个致命的错误，<code>&lt;text ...&gt;</code> 是错误信息。注意，<code>error</code> 函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如:</p>
<p>示例一:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> ERROR_001
    <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> error is <span class="token variable">$</span><span class="token punctuation">(</span>ERROR_001<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>示例二:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">ERR <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> found an error!<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> err


<span class="token target symbol">err</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>ERR<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例一会在变量 <code>ERROR_001</code> 定义了后执行时产生 <code>error</code> 调用，而示例二则在目录 <code>err</code> 被执行时才 发生 <code>error</code> 调用。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">warning</span> &lt;text ...><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个函数很像 <code>error</code> 函数，只是它并不会让 <code>make</code> 退出，只是输出一段警告信息，而 <code>make</code> 继续执行。</p>
<h1 id="make-的运行"><a href="#make-的运行" class="headerlink" title="make 的运行"></a>make 的运行</h1><p>一般来说，最简单的就是直接在命令行下输入 <code>make</code> 命令，<code>make</code> 命令会找当前目录的 <code>makefile</code> 来执行，一切都是自动的。但也有时你也许只想让 <code>make</code> 重编译某些文件，而不是整个工程，而又有的时候你 有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用 <code>make</code> 命令 的。</p>
<h2 id="make-的退出码"><a href="#make-的退出码" class="headerlink" title="make 的退出码"></a>make 的退出码</h2><p>make 命令执行后有三个退出码:</p>
<p><code>0</code> : 表示成功执行<br><code>1</code> : 如果 make 运行时出现任何错误，其返回 <code>1</code><br><code>2</code> : 如果你使用了 <code>make</code> 的“<code>-q</code>”选项，并且 <code>make</code> 使得一些目标不需要更新，那么返回 <code>2</code>。 <code>Make</code> 的相关参数我们会在后续章节中讲述。</p>
<h2 id="指定-Makefile"><a href="#指定-Makefile" class="headerlink" title="指定 Makefile"></a>指定 Makefile</h2><p>前面我们说过，<code>GNU make</code> 找寻默认的 <code>Makefile</code> 的规则是在当前目录下依次找三个文件——“<code>GNU-makefile</code>”、“<code>makefile</code>”和“<code>Makefile</code>”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给 <code>make</code> 命令指定一个特殊名字的 <code>Makefile</code>。要达到这个功能，我们要使用 <code>make</code> 的 <code>-f</code> 或是 <code>--file</code>参数(<code>--makefile</code> 参数也行)。例如，我们有个 <code>makefile</code> 的名字是“<code>hchen.mk</code>”，那么，我们可以这样来让 <code>make</code> 来执行这个文件:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">make –f hchen.mk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果在 <code>make</code> 的命令行是，你不只一次地使用了 <code>-f</code> 参数，那么，所有指定的 <code>makefile</code> 将会被连在一起传递给 <code>make</code> 执行。</p>
<h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><p>一般来说，<code>make</code> 的最终目标是 <code>makefile</code> 中的第一个目标，而其它目标一般是由这个目标连带出来 的。这是 <code>make</code> 的默认行为。当然，一般来说，你的 <code>makefile</code> 中的第一个目标是由许多个目标组成，你可以指示 <code>make</code>，让其完成你所指定的目标。要达到这一目的很简单，需在 <code>make</code> 命令后直接跟目标的名 字就可以完成(如前面提到的“<code>make clean</code>”形式)</p>
<p>任何在 makefile 中的目标都可以被指定成终极目标，但是除了以 <code>-</code> 打头，或是包含了 <code>=</code>的目标，因 为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为 <code>make</code> 的终极目标，也就是说，只要 <code>make</code> 可以找到其隐含规则推导规则，那么这个隐含目标同样可以被 指定成终极目标。</p>
<p>有一个 <code>make</code> 的环境变量叫 <code>MAKECMDGOALS</code> ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">sources <span class="token operator">=</span> foo.c bar.c
<span class="token keyword">ifneq</span> <span class="token punctuation">(</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAKECMDGOALS<span class="token punctuation">)</span>,clean<span class="token punctuation">)</span>
<span class="token target symbol">    include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>基于上面的这个例子，只要我们输入的命令不是“<code>make clean</code>”，那么 <code>makefile</code> 会自动包含“<code>foo.d</code>” 和“<code>bar.d</code>”这两个 <code>makefile</code>。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all
<span class="token target symbol">all</span><span class="token punctuation">:</span> prog1 prog2 prog3 prog4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>从这个例子中，我们可以看到，这个 <code>makefile</code> 中有四个需要编译的程序——“<code>prog1</code>”“，<code>prog2</code>”，“<code>prog3</code>” 和“<code>prog4</code>”，我们可以使用“<code>make all</code>”命令来编译所有的目标(如果把 <code>all</code> 置成第一个目标，那么只需 执行“<code>make</code>”)，我们也可以使用“<code>make prog2</code>”来单独编译目标“<code>prog2</code>”。</p>
<p>即然 <code>make</code> 可以指定所有 <code>makefile</code> 中的目标，那么也包括“<code>伪目标</code>”，于是我们可以根据这种性质来让我们的 <code>makefile</code> 根据指定的不同的目标来完成不同的事。在 <code>Unix</code> 世界中，软件发布时，特别是 <code>GNU</code> 这种开源软件的发布时，其 <code>makefile</code> 都包含了编译、安装、打包等功能。我们可以参照这种规则来书写 我们的 <code>makefile</code> 中的目标。</p>
<ul>
<li><code>all</code> : 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li><code>clean</code> : 这个伪目标功能是删除所有被 <code>make</code> 创建的文件。</li>
<li><code>install</code> : 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li><code>print</code> : 这个伪目标的功能是例出改变过的源文件。</li>
<li><code>tar</code> : 这个伪目标功能是把源程序打包备份。也就是一个 <code>tar</code> 文件。</li>
<li><code>dist</code> : 这个伪目标功能是创建一个压缩文件，一般是把 <code>tar</code> 文件压成 <code>Z</code> 文件。或是 <code>gz</code> 文件。</li>
<li><code>TAGS</code> : 这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li><code>check</code> 和 <code>test</code> : 这两个伪目标一般用来测试 <code>makefile</code> 的流程</li>
</ul>
<p>当然一个项目的 <code>makefile</code> 中也不一定要书写这样的目标，这些东西都是 <code>GNU</code> 的东西，但是我想， <code>GNU</code> 搞出这些东西一定有其可取之处(等你的 <code>UNIX</code> 下的程序文件一多时你就会发现这些功能很有用了)，这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些， 规范的好处就是——不用解释，大家都明白。而且如果你的 <code>makefile</code> 中有这些功能，一是很实用，二是 可以显得你的 <code>makefile</code> 很专业(不是那种初学者的作品)。</p>
<h2 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h2><p>有时候，我们不想让我们的 <code>makefile</code> 中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用 <code>make</code> 命令的下述参数:</p>
<p><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code> : 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来， 但不执行，这些参数对于我们调试 <code>makefile</code> 很有用处。</p>
<p><code>-t</code>,<code>--touch</code> : 这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，<code>make</code> 假装编译目标， 但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<p><code>-q</code>, <code>--question</code> : 这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<p><code>-W &lt;file&gt;</code>, <code>--what-if=&lt;file&gt;</code>, <code>--assume-new=&lt;file&gt;</code>, <code>--new-file=&lt;file&gt;</code> : 这个参数需要指定一个文件。一般是是源文件(或依赖文件)，<code>Make</code> 会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“<code>-n</code>”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合 <code>-p</code> 和 <code>-v</code> 来输出 <code>makefile</code> 被执行时的信息(这个将在后面讲述)。</p>
<h2 id="make-的参数"><a href="#make-的参数" class="headerlink" title="make 的参数"></a>make 的参数</h2><p>下面列举了所有 <code>GNU make 3.80</code> 版的参数定义。其它版本和产商的 <code>make</code> 大同小异，不过其它产商的 <code>make</code> 的具体参数还是请参考各自的产品文档。</p>
<p><code>-b</code>, <code>-m</code> : 这两个参数的作用是忽略和其它版本 <code>make</code> 的兼容性。</p>
<p><code>-B</code>, <code>--always-make</code> : 认为所有的目标都需要更新(重编译)。</p>
<p><code>-C &lt;dir&gt;</code>, <code>--directory=&lt;dir&gt;</code> : 指定读取 <code>makefile</code> 的目录。如果有多个“<code>-C</code>”参数，<code>make</code> 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如:“<code>make -C ~hchen/test -C prog</code>”等价于“<code>make -C ~hchen/test/prog</code>”。</p>
<p><code>-debug[=&lt;options&gt;]</code> : 输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试 信息。下面是 <code>&lt;options&gt;</code> 的取值:<br>• <code>a</code> : 也就是 <code>all</code>，输出所有的调试信息。(会非常的多)<br>• <code>b</code> : 也就是 <code>basic</code>，只输出简单的调试信息。即输出不需要重编译的目标。<br>• <code>v</code> : 也就是 <code>verbose</code>，在 b 选项的级别之上。输出的信息包括哪个 <code>makefile</code> 被解析，不需要被 重编译的依赖文件(或是依赖目标)等。<br>• <code>i</code> : 也就是 <code>implicit</code>，输出所有的隐含规则。<br>• <code>j</code> : 也就是 <code>jobs</code>，输出执行规则中命令的详细信息，如命令的 <code>PID</code>、<code>返回码</code>等。<br>• <code>m</code> : 也就是<code> makefile</code>，输出 <code>make</code> 读取 <code>makefile</code>，更新 <code>makefile</code>，执行 <code>makefile</code> 的信息。</p>
<p><code>-d</code> : 相当于“<code>–debug=a</code>”。</p>
<p><code>-e</code>, <code>--environment-overrides</code> : 指明环境变量的值覆盖 makefile 中定义的变量的值</p>
<p><code>-f=&lt;file&gt;</code>, <code>--file=&lt;file&gt;</code>, <code>--makefile=&lt;file&gt;</code> : 指定需要执行的 <code>makefile</code>。</p>
<p><code>-h</code>, <code>--help</code> : 显示帮助信息。</p>
<p><code>-i</code> , <code>--ignore-errors</code> : 在执行时忽略所有的错误。</p>
<p><code>-I &lt;dir&gt;</code>, <code>--include-dir=&lt;dir&gt;</code> : 指定一个被包含 <code>makefile</code> 的搜索目标。可以使用多个“<code>-I</code>”参数来指定多个目录。</p>
<p><code>-j [&lt;jobsnum&gt;]</code>, <code>--jobs[=&lt;jobsnum&gt;]</code> : 指同时运行命令的个数。如果没有这个参数，<code>make</code> 运行命令时能运行多少就运行多少。如果有一 个以上的“<code>-j</code>”参数，那么仅最后一个“<code>-j</code>”才是有效的。(注意这个参数在 <code>MS-DOS</code> 中是无用的)</p>
<p><code>-k</code>, <code>--keep-going</code> : 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p><code>-l &lt;load&gt;</code>,<code> --load-average[=&lt;load&gt;]</code>, <code>-max-load[=&lt;load&gt;]</code> : 指定 <code>make</code> 运行命令的负载。</p>
<p><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code> : 仅输出执行过程中的命令序列，但并不执行。</p>
<p><code>-o &lt;file&gt;</code>, <code>--old-file=&lt;file&gt;</code>, <code>--assume-old=&lt;file&gt;</code> : 不重新生成的指定的 <code>&lt;file&gt;</code>，即使这个目标的依赖文件新于它。</p>
<p><code>-p</code>, <code>--print-data-base</code> : 输出 <code>makefile</code> 中的所有数据，包括所有的规则和变量。这个参数会让一个简单的 <code>makefile</code> 都会输 出一堆信息。如果你只是想输出信息而不想执行 <code>makefile</code>，你可以使用“<code>make -qp</code>”命令。如果你 想查看执行 <code>makefile</code> 前的预设变量和规则，你可以使用“<code>make –p –f /dev/null</code>”。这个参数输出的信息会包含着你的 <code>makefile</code> 文件的文件名和行号，所以，用这个参数来调试你的 <code>makefile</code> 会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<p><code>-q</code>, <code>--question</code> : 不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是 <code>0</code> 则说明要更新，如果是 <code>2</code> 则说明有错误发生。</p>
<p><code>-r</code>, <code>--no-builtin-rules</code> : 禁止 <code>make</code> 使用任何隐含规则。</p>
<p><code>-R</code>, <code>--no-builtin-variabes</code> :  禁止 <code>make</code> 使用任何作用于变量上的隐含规则。</p>
<p><code>-s</code>, <code>--silent</code>, <code>--quiet</code> : 在命令运行时不输出命令的输出。</p>
<p><code>-S</code>, <code>--no-keep-going</code>, <code>--stop</code> :  取消“<code>-k</code>”选项的作用。因为有些时候，<code>make</code> 的选项是从环境变量“<code>MAKEFLAGS</code>”中继承下来 的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<p><code>-t</code>, <code>--touch</code> : 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p><code>-v</code>, <code>--version</code> : 输出 <code>make</code> 程序的版本、版权等关于 <code>make</code> 的信息。</p>
<p><code>-w</code>, <code>--print-directory</code> : 输出运行 <code>makefile</code> 之前和之后的信息。这个参数对于跟踪嵌套式调用 <code>make</code> 时很有用。</p>
<p><code>--no-print-directory</code> : 禁止“<code>-w</code>”选项。</p>
<p><code>-W &lt;file&gt;</code>, <code>--what-if=&lt;file&gt;</code>, <code>--new-file=&lt;file&gt;</code>, <code>--assume-file=&lt;file&gt;</code> :  假定目标<code> &lt;file&gt;</code>; 需要更新，如果和“<code>-n</code>”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“<code>-n</code>”那么就像运行 <code>UNIX</code> 的“<code>touch</code>”命令一样，使得 <code>&lt;file&gt;</code>; 的修改时间为当前时间。</p>
<p><code>--warn-undefined-variables</code> : 只要 <code>make</code> 发现有未定义的变量，那么就输出警告信息。</p>
<h1 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h1><p>在我们使用 <code>Makefile</code> 时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译 <code>C/C++</code> 的源程序为中间目标文件(<code>Unix</code> 下是 <code>.o </code>文件，<code>Windows</code> 下是 <code>.obj</code> 文件)。本章讲述的就是一 些在 <code>Makefile</code> 中的“<code>隐含的</code>”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“<code>隐含规则</code>”也就是一种惯例，<code>make</code> 会按照这种“<code>惯例</code>”心照不喧地来运行，那怕我们的 <code>Makefile</code> 中没有书写这样的规则。例如，把 <code>.c</code> 文件编译成 <code>.o</code> 文件这一规则，你根本就不用写出来，<code>make</code> 会自动推导出这种规则，并生成我们需要的 <code>.o</code> 文件。</p>
<p>“<code>隐含规则</code>”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量 <code>CFLAGS</code> 可以控制编译时的编译器参数。</p>
<p>我们还可以通过“<code>模式规则</code>”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多 的限制。使用“<code>模式规则</code>”会显得更智能和清楚，但“后缀规则”可以用来保证我们 <code>Makefile</code> 的兼容性。 我们了解了“<code>隐含规则</code>”，可以让其为我们更好的服务，也会让我们知道一些“<code>约定俗成</code>”了的东西，而 不至于使得我们在运行 <code>Makefile</code> 时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“<code>隐含规则</code>”也会给我们造成不小的麻烦。只有了解了它，我们才能更 好地使用它。</p>
<h2 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，<code>make</code> 会试图去自动推导产生这个目标的规则和命令，如果 <code>make</code> 可以自动推导生成这个目标的规则和命令，那 么这个行为就是隐含规则的自动推导。当然，隐含规则是 <code>make</code> 事先约定好的一些东西。例如，我们有下 面的一个 <code>Makefile</code>:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo</span> <span class="token punctuation">:</span> foo.o bar.o
    cc –o foo foo.o bar.o <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>我们可以注意到，这个 <code>Makefile</code> 中并没有写下如何生成 <code>foo.o</code> 和 <code>bar.o</code> 这两目标的规则和命令。因为 <code>make</code> 的“<code>隐含规则</code>”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p><code>make</code> 会在自己的“<code>隐含规则</code>”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，<code>make</code> 调用的隐含规则是，把 <code>.o</code> 的目标的依赖文件置成 <code>.c</code> ，并使用 <code>C</code> 的编译命令 <code>cc –c $(CFLAGS) foo.c </code>来生成 <code>foo.o</code> 的目标。也就是说，我们完全没有必要写下下面的两条规则:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    cc –c foo.c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span>
<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    cc –c bar.c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为，这已经是“<code>约定</code>”好了的事了，<code>make</code> 和我们约定好了用 <code>C</code> 编译器 c<code>c</code> 生成 <code>.o</code> 文件的规则， 这就是隐含规则。</p>
<p>当然，如果我们为 <code>.o</code> 文件书写了自己的规则，那么 <code>make</code> 就不会自动推导并调用隐含规则，它会按 照我们写好的规则忠实地执行。</p>
<p>还有，在 <code>make</code> 的“<code>隐含规则库</code>”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使 用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，<code>make</code> 也不会管。如下面这条规则(没有命令):</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>依赖文件 <code>foo.p</code> (<code>Pascal</code> 程序的源文件)有可能变得没有意义。如果目录下存在了 <code>foo.c</code> 文件，那 么我们的隐含规则一样会生效，并会通过 <code>foo.c</code> 调用 <code>C</code> 的编译器生成 <code>foo.o</code> 文件。因为，在隐含规则 中，<code>Pascal</code> 的规则出现在 <code>C</code> 的规则之后，所以，<code>make</code> 找到可以生成 <code>foo.o</code> 的 <code>C</code>的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“<code>依赖规则</code>”，而不写命令。</p>
<h2 id="隐含规则一览"><a href="#隐含规则一览" class="headerlink" title="隐含规则一览"></a>隐含规则一览</h2><p>这里我们将讲述所有预先设置(也就是 <code>make</code> 内建)的隐含规则，如果我们不明确地写下规则， 那么，<code>make</code> 就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用 <code>make</code> 的参数 <code>-r</code> 或 <code>--no-builtin-rules</code> 选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了 <code>-r</code> 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了 “<code>后缀规则</code>”来定义的，所以，只要隐含规则中有“<code>后缀列表</code>”(也就一系统定义在目标 <code>.SUFFIXES</code> 的依赖目标)，那么隐含规则就会生效。默认的后缀列表是:<code>.out</code>, <code>.a</code>, <code>.ln</code>, <code>.o</code>, <code>.c</code>, <code>.cc</code>, <code>.C</code>, <code>.p</code>, <code>.f</code>, <code>.F</code>, <code>.r</code>, <code>.y</code>, <code>.l</code>, <code>.s</code>,<code>.S</code>, <code>.mod</code>, <code>.sym</code>, <code>.def</code>, <code>.h</code>, <code>.info</code>, <code>.dvi</code>, <code>.tex</code>, <code>.texinfo</code>, <code>.texi</code>, <code>.txinfo</code>, <code>.w</code>, <code>.ch</code> <code>.web</code>, <code>.sh</code>, <code>.elc</code>, <code>.el</code>。具体的细节， 我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol>
<li>编译 <code>C</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.c</code> ，并且其生成命令是 <code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code></p>
<ol start="2">
<li>编译 <code>C++</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.cc</code> 或是 <code>&lt;n&gt;.C</code> ，并且其生成命令是 <code>$(CXX) –c $(CPPFLAGS) $(CXXFLAGS)</code> 。(建议使用 <code>.cc</code> 作为 <code>C++</code> 源文件的后缀，而不是 <code>.C</code> )</p>
<ol start="3">
<li>编译 <code>Pascal</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.p</code> ，并且其生成命令是 <code>$(PC) –c $(PFLAGS)</code> 。</p>
<ol start="4">
<li>编译 <code>Fortran/Ratfor</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 或 <code>&lt;n&gt;.f </code>，并且其生成命令是:</p>
<ul>
<li><code>.f $(FC) –c $(FFLAGS)</code></li>
<li><code>.F $(FC) –c $(FFLAGS) $(CPPFLAGS)</code></li>
<li><code>.f $(FC) –c $(FFLAGS) $(RFLAGS)</code></li>
</ul>
<ol start="5">
<li>预处理 <code>Fortran/Ratfor</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.f</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 。这个规则只是转换 <code>Ratfor</code> 或有预处理的 <code>Fortran</code> 程序到一个标准的 <code>Fortran</code> 程序。其使用的命令是:</p>
<ul>
<li><code>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)</code></li>
<li><code>.r $(FC) –F $(FFLAGS) $(RFLAGS)</code></li>
</ul>
<ol start="6">
<li>编译 <code>Modula-2</code> 程序的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.sym</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.def</code> ，并且其生成命令是:<code>$(M2C) $(M2FLAGS) $(DEFFLAGS)</code> 。<code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.mod</code> ，并且其生成命令是:<code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code> 。</p>
<ol start="7">
<li>汇编和汇编预处理的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.s</code> ，默认使用编译器 <code>as</code> ，并且其生成命令是:<code>$ (AS) $(ASFLAGS)</code> 。<code>&lt;n&gt;.s</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.S</code> ，默认使用 <code>C</code> 预编译器 <code>cpp</code> ，并且其生成命令是: <code>$(AS) $(ASFLAGS)</code> 。</p>
<ol start="8">
<li>链接 <code>Object</code> 文件的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;</code> 目标依赖于 <code>&lt;n&gt;.o</code> ，通过运行 <code>C</code> 的编译器来运行链接程序生成(一般是 <code>ld</code> )，其生成命令 是:<code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code> 。这个规则对于只有一个源文件的工程有效，同时也对多个 <code>Object</code> 文件(由不同的源文件生成)的也有效。例如如下规则:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">x</span> <span class="token punctuation">:</span> y.o z.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>并且 <code>x.c</code> 、<code>y.c</code> 和 <code>z.c</code> 都存在时，隐含规则将执行如下命令:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有一个源文件(如上例中的 <code>x.c</code>)和你的目标名字(如上例中的 <code>x</code>)相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<ol start="9">
<li><code>Yacc C</code> 程序时的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.y </code>(<code>Yacc</code> 生成的文件)，其生成命令是:<code>$(YACC) $(YFALGS)</code>。(“<code>Yacc</code>”是一个语法分析器，关于其细节请查看相关资料)</p>
<ol start="10">
<li>Lex C 程序时的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.l</code>(<code>Lex</code> 生成的文件)，其生成命令是:<code>$(LEX) $(LFALGS)</code> 。(关于“<code>Lex</code>”的细节请查看相关资料)</p>
<ol start="11">
<li>Lex Ratfor 程序时的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.r</code> 的依赖文件被自动推导为 <code>n.l</code> (<code>Lex</code> 生成的文件)，其生成命令是:<code>$(LEX) $(LFALGS)</code> 。</p>
<ol start="12">
<li>从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则。</li>
</ol>
<p><code>&lt;n&gt;.ln</code>(<code>lint</code> 生成的文件)的依赖文件被自动推导为 <code>n.c</code> ，其生成命令是:<code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code> 。对于 <code>&lt;n&gt;.y</code> 和 <code>&lt;n&gt;.l</code> 也是同样的规则。</p>
<h2 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的 <code>makefile</code> 中改变这 些变量的值，或是在 <code>make</code> 的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用 <code>make</code> 的 <code>-R</code> 或 <code>--no–builtin-variables</code> 参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译 <code>C </code>程序的隐含规则的命令是 <code>$(CC) –c $(CFLAGS) $(CPPFLAGS)</code> 。 <code>Make</code> 默认的编译命令是 <code>cc</code> ，如果你把变量 <code>$(CC)</code> 重定义成 <code>gcc</code> ，把变量 <code>$(CFLAGS)</code> 重定义成 <code>-g</code> ，那么，隐含规则中的命令全部会以 <code>gcc –c -g $(CPPFLAGS)</code> 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种:一种是命令相关的，如 <code>CC</code> ;一种是参数相的关，如 <code>CFLAGS</code> 。下面是所有隐含规则中会用到的变量:</p>
<h3 id="关于命令的变量。"><a href="#关于命令的变量。" class="headerlink" title="关于命令的变量。"></a>关于命令的变量。</h3><ul>
<li><code>AR</code> : 函数库打包程序。默认命令是 <code>ar</code></li>
<li><code>AS</code> : 汇编语言编译程序。默认命令是 <code>as</code></li>
<li><code>CC</code> : <code>C</code> 语言编译程序。默认命令是 <code>cc</code></li>
<li><code>CXX</code> : <code>C++</code> 语言编译程序。默认命令是 <code>g++</code></li>
<li><code>CO</code> : 从 <code>RCS</code> 文件中扩展文件程序。默认命令是 <code>co</code></li>
<li><code>CPP</code> : <code>C</code> 程序的预处理器(输出是标准输出设备)。默认命令是 <code>$(CC) –E * FC : Fortran</code> 和 <code>Ratfor</code> 的编译器和预处理程序。默认命令是 <code>f77</code></li>
<li><code>GET</code> : 从 <code>SCCS</code> 文件中扩展文件的程序。默认命令是 <code>get</code></li>
<li><code>LEX</code> : <code>Lex</code> 方法分析器程序(针对于 <code>C</code> 或 <code>Ratfor</code>)。默认命令是 <code>lex</code></li>
<li><code>PC</code> : <code>Pascal</code> 语言编译程序。默认命令是 <code>pc</code></li>
<li><code>YACC</code> : <code>Yacc</code> 文法分析器(针对于 <code>C</code> 程序)。默认命令是 <code>yacc</code></li>
<li><code>YACCR</code> : <code>Yacc</code> 文法分析器(针对于 <code>Ratfor</code> 程序)。默认命令是 <code>yacc –r</code></li>
<li><code>MAKEINFO</code> : 转换 <code>Texinfo</code> 源文件(<code>.texi</code>)到 <code>Info</code> 文件程序。默认命令是 <code>makeinfo</code></li>
<li><code>TEX</code> : 从 <code>TeX</code> 源文件创建 <code>TeX DVI</code> 文件的程序。默认命令是 <code>tex</code></li>
<li><code>TEXI2DVI</code> : 从 <code>Texinfo</code> 源文件创建军 <code>TeX DVI</code> 文件的程序。默认命令是 <code>texi2dvi</code></li>
<li><code>WEAVE</code> : 转换 <code>Web</code> 到 <code>TeX</code> 的程序。默认命令是 <code>weave</code></li>
<li><code>CWEAVE</code> : 转换 <code>C Web</code> 到 <code>TeX</code> 的程序。默认命令是 <code>cweave</code></li>
<li><code>TANGLE</code> : 转换 <code>Web</code> 到 <code>Pascal</code> 语言的程序。默认命令是 <code>tangle</code></li>
<li><code>CTANGLE</code> : 转换 <code>C Web</code> 到 <code>C</code>。默认命令是 <code>ctangle</code></li>
<li><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></li>
</ul>
<h3 id="关于命令参数的变量"><a href="#关于命令参数的变量" class="headerlink" title="关于命令参数的变量"></a>关于命令参数的变量</h3><p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<ul>
<li><code>ARFLAGS</code> : 函数库打包程序 <code>AR</code> 命令的参数。默认值是 <code>rv</code></li>
<li><code>ASFLAGS</code> : 汇编语言编译器参数。(当明显地调用 <code>.s</code> 或 <code>.S</code> 文件时)</li>
<li><code>CFLAGS</code> : <code>C</code> 语言编译器参数。</li>
<li><code>CXXFLAGS</code> : <code>C++</code> 语言编译器参数。</li>
<li><code>COFLAGS</code> : <code>RCS</code> 命令参数。</li>
<li><code>CPPFLAGS</code> : <code>C</code> 预处理器参数。(<code>C</code> 和 <code>Fortran</code> 编译器也会用到)。</li>
<li><code>FFLAGS</code> : <code>Fortran</code> 语言编译器参数。</li>
<li><code>GFLAGS</code> : <code>SCCS</code> “<code>get</code>”程序参数。</li>
<li><code>LDFLAGS</code> : 链接器参数。(如:<code>ld</code> )</li>
<li><code>LFLAGS</code> : <code>Lex</code> 文法分析器参数。</li>
<li><code>PFLAGS</code> : <code>Pascal</code> 语言编译器参数。</li>
<li><code>RFLAGS</code> : <code>Ratfor</code> 程序的 <code>Fortran</code> 编译器参数。</li>
<li><code>YFLAGS</code> : <code>Yacc</code> 文法分析器参数。</li>
</ul>
<h2 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 <code>.o</code> 的文件生成，可能会是先被 <code>Yacc</code> 的 [<code>.y</code>] 文件先成 <code>.c</code> ，然后再被 <code>C</code> 的编译器生成。我们把这一系列的隐含规则叫做“<code>隐含规则链”</code>。</p>
<p>在上面的例子中，如果文件 <code>.c</code> 存在，那么就直接调用 <code>C</code> 的编译器的隐含规则，如果没有 <code>.c </code>文件， 但有一个 <code>.y</code> 文件，那么 <code>Yacc</code> 的隐含规则会被调用，生成 <code>.c</code> 文件，然后，再调用 <code>C</code> 编译的隐含规则最 终由 <code>.c</code> 生成 <code>.o</code> 文件，达到目标。</p>
<p>我们把这种 <code>.c</code> 的文件(或是目标)，叫做中间目标。不管怎么样，<code>make</code> 会努力自动推导生成目标的 一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成?怎么我的 <code>makefile</code> 发疯了?</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同:第一个不同是除非中间的目标 不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生 的中间目标文件会被以 <code>rm -f</code> 删除。</p>
<p>通常，一个被 <code>makefile</code> 指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明 一个文件或是目标是中介目标，你可以使用伪目标 <code>.INTERMEDIATE</code> 来强制声明。(如:<code>.INTERMEDIATE : mid</code> )</p>
<p>你也可以阻止 <code>make</code> 自动删除中间目标，要做到这一点，你可以使用伪目标 <code>.SECONDARY</code> 来强制声明 (如:<code>.SECONDARY : sec</code> )。你还可以把你的目标，以模式的方式来指定(如:<code>%.o</code> )成伪目标 <code>.PRECIOUS</code> 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“<code>隐含规则链</code>”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在 <code>make</code> 自动推导 时出现无限递归的情况。</p>
<p><code>Make</code> 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 <code>foo.c</code> 生成目标程序 <code>foo</code> ，按道理，<code>make</code> 会编译生成中间文件 <code>foo.o</code> ，然后链接成 <code>foo</code> ，但在实际情况下，这一动作可以被一条 <code>cc</code> 的命令完成(<code>cc –o foo foo.c</code> )，于是优化过的规则就不会生成中间文件。</p>
<h2 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h2><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目 标的定义需要有 <code>%</code> 字符。<code>%</code> 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 <code>%</code> ，只是依 赖目标中的 <code>%</code> 的取值，取决于其目标。</p>
<p>有一点需要注意的是，<code>%</code> 的展开发生在变量和函数的展开之后，变量和函数的展开发生在 <code>make</code> 载 入 <code>Makefile</code> 时，而模式规则中的 <code>%</code> 则发生在运行时。</p>
<h3 id="模式规则介绍"><a href="#模式规则介绍" class="headerlink" title="模式规则介绍"></a>模式规则介绍</h3><p>模式规则中，至少在规则的目标定义中要包含 <code>%</code> ，否则，就是一般的规则。目标中的 <code>%</code> 定义表示对 文件名的匹配，<code>%</code> 表示长度任意的非空字符串。例如:<code>%.c</code> 表示以 <code>.c</code> 结尾的文件名(文件名的长度至少为 <code>3</code>)，而 <code>s.%.c </code>则表示以 <code>s.</code> 开头，<code>.c</code> 结尾的文件名(文件名的长度至少为 <code>5</code>)。</p>
<p>如果 <code>%</code> 定义在目标中，那么，依赖中的 <code>%</code> 的值决定了目标中的 <code>%</code> 的值，也就是说，依赖中的模式的 <code>%</code> 决定了目标中 <code>%</code> 的样子。例如有一个模式规则如下:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c <span class="token punctuation">;</span> &lt;command ......><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其含义是，指出了怎么从所有的 <code>.c</code> 文件生成相应的 <code>.o</code> 文件的规则。如果要生成的目标是 <code>a.o</code> <code>b.o</code> ，那么 <code>%c</code> 就是 <code>a.c</code> <code>b.c</code> 。</p>
<p>一旦依赖目标中的 <code>%</code> 模式被确定，那么，<code>make</code> 会被要求去匹配当前目录下所有的文件名，一旦找到，<code>make</code> 就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，<code>make</code> 就会产生所有的模式目标，此时，<code>make</code> 关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h3 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h3><p>下面这个例子表示了, 把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>其中，<code>$@</code> 表示所有的目标的挨个值，<code>$&lt;</code> 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“<code>自动化变量</code>”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.tab.c %.tab.h</span><span class="token punctuation">:</span> %.y
    bison -d <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这条规则告诉 <code>make</code> 把所有的 <code>.y</code> 文件都以 <code>bison -d &lt;n&gt;.y </code>执行，然后生成 <code>&lt;n&gt;.tab.c</code> 和 <code>&lt;n&gt;. tab.h </code>文件。(其中，<code>&lt;n&gt;</code> 表示一个任意字符串)。如果我们的执行程序 <code>foo</code> 依赖于文件 <code>parse.tab.o </code>和 <code>scan.o</code> ，并且文件 <code>scan.o</code> 依赖于文件 <code>parse.tab.h</code> ，如果 <code>parse.y</code> 文件被更新了，那么根据上述的 规则，<code>bison -d parse.y</code> 就会被执行一次，于是，<code>parse.tab.o</code> 和 <code>scan.o</code> 的依赖文件就齐了。(假设， <code>parse.tab.o</code> 由 <code>parse.tab.c</code> 生成，和 <code>scan.o</code> 由 <code>scan.c</code> 生成，而 <code>foo</code> 由 <code>parse.tab.o </code>和 <code>scan.o</code> 链接生成，而且 <code>foo</code> 和其 <code>.o</code> 文件的依赖关系也写好，那么，所有的目标都会得到满足)</p>
<h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标?因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对 它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取 出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明:</p>
<ul>
<li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<code>$@</code> 就是匹配于目标中模 式定义的集合。</li>
<li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a</code>(<code>bar.o</code>) ，那么，<code>$%</code> 就是 <code>bar.o </code>，<code>$@</code> 就是<code> foo.a</code> 。如果目标不是函数库文件(<code>Unix</code> 下是 <code>.a</code> ，<code>Windows</code> 下是 <code>.lib</code> )，那么，其值为空。</li>
<li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式(即 <code>%</code> )定义的，那么 <code>$&lt;</code> 将是符合模 式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么，<code>$*</code> 的值就是 <code>dir/foo</code> 。这个变量对于构造有关联的文件名是比较有效。如果目标 中没有模式的定义，那么 <code>$* </code>也就不能被推导出，但是，如果目标文件的后缀是 <code>make</code> 所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如:如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是 <code>make</code> 所能识别的后缀名， 所以，<code>$*</code> 的值就是 <code>foo</code> 。这个特性是 <code>GNU make</code> 的，很有可能不兼容于其它版本的 <code>make</code>，所以， 你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是 <code>make</code> 所不能 识别的，那么 <code>$*</code> 就是空值。</li>
</ul>
<p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code> 在显式规则中很有用，例如，假设有一个函数库文件叫 <code>lib</code> ，其由其它几个 <code>object</code> 文件更新。那么把 <code>object</code> 文件打包的比较有效率的 <code>Makefile</code> 规则是:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">lib</span> <span class="token punctuation">:</span> foo.o bar.o lose.o win.o
    ar r lib <span class="token variable">$?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在上述所列出来的自动量变量中。四个变量(<code>$@</code> 、<code>$&lt;</code> 、<code>$%</code> 、<code>$*</code> )在扩展时只会有一个文件，而另 三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的 文件名，只需要搭配上 <code>D</code> 或 <code>F</code> 字样。这是 <code>GNU make</code> 中老版本的特性，在新版本中，我们使用函数 <code>dir</code> 或 <code>notdir</code> 就可以做到了。<code>D</code> 的含义就是 <code>Directory</code>，就是目录，<code>F</code> 的含义就是 <code>File</code>，就是文件。</p>
<p>下面是对于上面的七个变量分别加上 <code>D</code> 或是 <code>F</code> 的含义:</p>
<p><code>$(@D)</code> : 表示 <code>$@</code> 的目录部分(不以斜杠作为结尾)，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而 如果 <code>$@</code> 中没有包含斜杠的话，其值就是 . (当前目录)。<br><code>$(@F)</code> : 表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是 <code>foo.o</code> ，$(@F) 相当于函数 $(notdir $@) 。<br><code>$(*D)</code>, <code>$(*F)</code> : 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code> 返回 <code>dir</code> ， 而 <code>$(*F)</code> 返回 <code>foo</code><br><code>$(%D)</code>, <code>$(%F)</code> : 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code>archive</code>(<code>member</code>) 形式的目标中 的 <code>member</code> 中包含了不同的目录很有用。<br><code>$(&lt;D)</code>, <code>$(&lt;F)</code> : 分别表示依赖文件的目录部分和文件部分。<br><code>$(^D)</code>, <code>$(^F)</code> : 分别表示所有依赖文件的目录部分和文件部分。(无相同的)<br><code>$(+D)</code>, <code>$(+F)</code> : 分别表示所有依赖文件的目录部分和文件部分。(可以有相同的)<br><code>$(?D)</code>, <code>$(?F)</code> : 分别表示被更新的依赖文件的目录部分和文件部分。</p>
<p>最后想提醒一下的是，对于 <code>$&lt;</code> ，为了避免产生不必要的麻烦，我们最好给 <code>$</code> 后面的那个特定字符都加上圆括号，比如，<code>$(&lt;)</code> 就要比 <code>$&lt;</code> 要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“<code>显式规则</code>”和“<code>静态模式规则</code>”(参见前面“书写规则”一章)。其在隐含规则中并没有意义。</p>
<h3 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的 <code>%</code> ，或是没有前后缀，直接就是一个 <code>% </code>。因为 <code>%</code> 代表一个或多个字符，所以在定义好了的模式中，我们把 <code>%</code> 所匹配的内容叫做“<code>茎</code>”，例如 <code>%.c</code> 所匹配 的文件“<code>test.c</code>”中“<code>test</code>”就是“<code>茎</code>”。因为在目标和依赖目标中同时有 <code>%</code> 时，依赖目标的“<code>茎</code>”会传给 目标，当做目标中的“<code>茎</code>”。</p>
<p>当一个模式匹配包含有斜杠(实际也不经常包含)的文件时，那么在进行模式匹配时，目录部分会首 先被移开，然后进行匹配，成功后，再把目录加回去。在进行“<code>茎</code>”的传递时，我们需要知道这个步骤。 例如有一个模式 <code>e%t</code> ，文件 <code>src/eat</code> 匹配于该模式，于是 <code>src/a</code> 就是其“<code>茎</code>”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 <code>c%r</code> ，那么，目标就是 <code>src/car</code> 。(“<code>茎</code>”被传递)</p>
<h3 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h3><p>你可以重载内建的隐含规则(或是定义一个全新的)，例如你可以重新构造和内建隐含规则不同的命令，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -D<span class="token variable">$</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h2 id="老式风格的“后缀规则”"><a href="#老式风格的“后缀规则”" class="headerlink" title="老式风格的“后缀规则”"></a>老式风格的“后缀规则”</h2><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规 则更强更清晰。为了和老版本的 <code>Makefile</code> 兼容，<code>GNU make</code> 同样兼容于这些东西。后缀规则有两种方式:“<code>双后缀</code>”和“<code>单后缀</code>”。</p>
<p>双后缀规则定义了一对后缀:目标文件的后缀和依赖目标(源文件)的后缀。如 <code>.c.o</code> 相当于 <code>%o : %c</code> 。单后缀规则只定义一个后缀，也就是源文件的后缀。<br>如 <code>.c</code> 相当于 <code>% : %.c</code> 。</p>
<p>后缀规则中所定义的后缀应该是 <code>make</code> 所认识的，如果一个后缀是 <code>make</code> 所认识的，那么这个规则 就是单后缀规则，而如果两个连在一起的后缀都被 <code>make</code> 所认识，那就是双后缀规则。例如:<code>.c</code> 和 <code>.o</code> 都 是 <code>make</code> 所知道。因而，如果你定义了一个规则是 <code>.c.o</code> 那么其就是双后缀规则，意义就是 <code>.c</code> 是源文件 的后缀，<code>.o</code> 是目标文件的后缀。如下示例:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.c.o</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.c.o</span><span class="token punctuation">:</span> foo.h
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这个例子，就是说，文件 <code>.c.o</code> 依赖于文件 <code>foo.h</code> ，而不是我们想要的这样:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.o</span><span class="token punctuation">:</span> %.c foo.h
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。<br>而要让 <code>make</code> 知道一些特定的后缀，我们可以使用伪目标 <code>.SUFFIXES</code> 来定义或是删除，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> .hack .win<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>把后缀 .hack 和 .win 加入后缀列表中的末尾。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> <span class="token comment"># 删除默认的后缀</span>
<span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> .c .o .h <span class="token comment"># 定义自己的后缀</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>先清除默认后缀，后定义自己的后缀列表。</p>
<p><code>make</code> 的参数 <code>-r</code> 或 <code>-no-builtin-rules</code> 也会使用得默认的后缀列表为空。而变量 <code>SUFFIXE</code> 被用来定义默认的后缀列表，你可以用 <code>.SUFFIXES</code> 来改变后缀列表，但请不要改变变量 <code>SUFFIXE</code> 的值。</p>
<h2 id="隐含规则搜索算法"><a href="#隐含规则搜索算法" class="headerlink" title="隐含规则搜索算法"></a>隐含规则搜索算法</h2><p>比如我们有一个目标叫 <code>T</code>。下面是搜索目标 <code>T</code> 的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在 <code>Makefile</code> 被载入内存时，会被转换成模式规则。如果目标是 <code>archive</code>(<code>member</code>) 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标 <code>T</code>，如果没有找到的话，那么进入第二次，第二次会把 <code>member</code> 当作 <code>T</code> 来搜索。</p>
<ol>
<li><p>把 <code>T</code> 的目录部分分离出来。叫 <code>D</code>，而剩余部分叫 <code>N</code>。(如:如果 <code>T</code> 是 <code>src/foo.o</code> ，那么，<code>D</code> 就是 <code>src/</code> ，<code>N</code> 就是 <code>foo.o</code> )</p>
</li>
<li><p>创建所有匹配于 <code>T</code> 或是 <code>N</code> 的模式规则列表。</p>
</li>
<li><p>如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p>
</li>
<li><p>移除列表中没有命令的规则。</p>
</li>
<li><p>对于第一个在列表中的模式规则:</p>
<ol>
<li>推导其“<code>茎</code>”<code>S</code>，<code>S</code> 应该是 <code>T</code> 或是 <code>N</code> 匹配于模式中 <code>%</code> 非空的部分。</li>
<li>计算依赖文件。把依赖文件中的<code>%</code>都替换成“<code>茎</code>”<code>S</code>。如果目标模式中没有包含斜框字符，而把 <code>D</code> 加在第一个依赖文件的开头。</li>
<li>测试是否所有的依赖文件都存在或是理当存在。(如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”)</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
</ol>
</li>
<li><p>如果经过第 <code>5</code> 步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模 式规则:</p>
<ol>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>
<li>计算依赖文件。(同第 <code>5</code> 步)</li>
<li>测试所有的依赖文件是否存在或是理当存在。</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退 出该算法。</li>
<li>如果没有隐含规则可以使用，查看 <code>.DEFAULT</code> 规则，如果有，采用，把 <code>.DEFAULT</code> 的命令给 <code>T</code> 使用。</li>
</ol>
</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h1 id="使用-make-更新函数库文件"><a href="#使用-make-更新函数库文件" class="headerlink" title="使用 make 更新函数库文件"></a>使用 make 更新函数库文件</h1><p>函数库文件也就是对 <code>Object</code> 文件(程序编译的中间文件)的打包文件。在 <code>Unix</code> 下，一般是由命令 <code>ar</code> 来完成打包工作。</p>
<h2 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h2><p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">archive<span class="token punctuation">(</span>member<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 <code>ar</code> 命令来服务 的。如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">foolib(hack.o)</span> <span class="token punctuation">:</span> hack.o
    ar cr foolib hack.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果要指定多个 <code>member</code>，那就以空格分开，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foolib<span class="token punctuation">(</span>hack.o kludge.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其等价于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foolib<span class="token punctuation">(</span>hack.o<span class="token punctuation">)</span> foolib<span class="token punctuation">(</span>kludge.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>你还可以使用 Shell 的文件通配符来定义，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foolib<span class="token punctuation">(</span>*.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="函数库成员的隐含规则"><a href="#函数库成员的隐含规则" class="headerlink" title="函数库成员的隐含规则"></a>函数库成员的隐含规则</h2><p>当 <code>make</code> 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 <code>a</code>(<code>m</code>) 形式的，其会把目 标变成 (<code>m</code>) 。于是，如果我们的成员是<code> %.o</code> 的模式定义，并且如果我们使用 <code>make foo.a(bar.o)</code> 的形式调用 <code>Makefile</code> 时，隐含规则会去找 <code>bar.o</code> 的规则，如果没有定义 <code>bar.o</code> 的规则，那么内建隐含规则生效，<code>make</code> 会去找 <code>bar.c</code> 文件来生成 <code>bar.o</code> ，如果找得到的话，<code>make</code> 执行的命令大致如下:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>还有一个变量要注意的是 <code>$%</code> ，这是专属函数库文件的自动化变量，有关其说明请参见“<code>自动化变量</code>”一节。</p>
<h2 id="函数库文件的后缀规则"><a href="#函数库文件的后缀规则" class="headerlink" title="函数库文件的后缀规则"></a>函数库文件的后缀规则</h2><p>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.c.a</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> r <span class="token variable">$@</span> <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$*.o</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其等效于:</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">(%.o)</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> r <span class="token variable">$@</span> <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$*.o</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在进行函数库打包文件生成时，请小心使用 <code>make</code> 的并行机制(<code>-j</code> 参数)。如果多个 <code>ar</code> 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在 <code>make</code> 未来的版本中， 应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用 <code>-j</code> 参数。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker VS Podman</title>
    <url>//post/docker-podman-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>

<h2 id="Podman-介绍"><a href="#Podman-介绍" class="headerlink" title="Podman 介绍"></a>Podman 介绍</h2><h3 id="What-is-Podman"><a href="#What-is-Podman" class="headerlink" title="What is Podman?"></a>What is Podman?</h3><p><code>Podman</code> 是一个基于 <code>Linux</code> 系统的 <code>daemon-less</code> 的容器引擎。 可以用来开发，管理和运行 <code>OCI</code> 标准的容器. <code>podman</code>可以运行在<code>root</code>或者<code>非root</code>用户模式。</p>
<p><code>Podman</code> 是 <code>Red Hat</code> 在<code>2018</code>年推出的，源代码开放。</p>
<p>官方网站 <a href="https://podman.io/">https://podman.io/</a></p>
<p>OCI <a href="https://opencontainers.org/">https://opencontainers.org/</a></p>
<h3 id="和-docker-的区别"><a href="#和-docker-的区别" class="headerlink" title="和 docker 的区别"></a>和 docker 的区别</h3><ul>
<li>最主要的区别是 <code>podman</code> 是 <code>Daemonless</code> 的，而 <code>Docker</code> 在执行任务的时候，必须依赖于后台的 <code>docker daemon</code></li>
<li><code>podman</code> 不需要使用 <code>root用户</code> 或者 <code>root权限</code>，所以更安全。</li>
<li><code>podman</code> 可以创建<code>pod</code>，<code>pod</code>的概念和<code>Kubernetes</code> 里定义的<code>pod</code>类似</li>
<li><code>podman</code> 运行把<code>镜像</code>和<code>容器</code>存储在不同的地方，但是<code>docker</code>必须存储在<code>docker engineer</code>所在的本地</li>
<li><code>podman</code> 是传统的 <code>fork-exec</code> 模式，而 <code>docker</code> 是 <code>client-server</code> 架构</li>
</ul>
<h2 id="Podman-的安装"><a href="#Podman-的安装" class="headerlink" title="Podman 的安装"></a>Podman 的安装</h2><p><a href="https://podman.io/docs/installation">https://podman.io/docs/installation</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 搜索镜像</span>
<span class="token function">podman</span> search nginx

<span class="token comment"># 拉取镜像</span>
<span class="token function">podman</span> image pull docker.io/library/nginx

<span class="token comment"># 列举镜像</span>
<span class="token function">podman</span> image <span class="token function">ls</span>

<span class="token comment"># 创建容器</span>
<span class="token function">podman</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 docker.io/library/nginx

<span class="token comment"># 查看容器</span>
<span class="token function">podman</span> container <span class="token function">ls</span>

<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080

<span class="token comment"># 停止容器</span>
<span class="token function">podman</span> container stop aa6

<span class="token comment"># 删除</span>
<span class="token function">podman</span> container <span class="token function">rm</span> aa6

<span class="token function">sudo</span> adduser demo
<span class="token function">su</span> demo
<span class="token function">podman</span> image <span class="token function">ls</span>
<span class="token function">su</span> <span class="token parameter variable">-l</span> demo
<span class="token function">podman</span> image <span class="token function">ls</span>

<span class="token comment"># podman 不同的用户 容器与镜像 是相互隔离的</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Podman-创建-pod"><a href="#Podman-创建-pod" class="headerlink" title="Podman 创建 pod"></a>Podman 创建 pod</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">podman</span> pod <span class="token parameter variable">--help</span>

<span class="token comment"># 创建pod</span>
<span class="token function">podman</span> pod create <span class="token parameter variable">--name</span> demo

<span class="token comment"># 查看pod</span>
<span class="token function">podman</span> pod <span class="token function">ps</span>

<span class="token comment"># 查看pod</span>
<span class="token function">podman</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">--pod</span>

<span class="token comment"># 删除pod</span>
<span class="token function">podman</span> pod <span class="token function">rm</span> aas4

<span class="token comment"># 在pod里创建container</span>
<span class="token function">podman</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> test1 <span class="token parameter variable">--pod</span> demo dicker.io/library/busybox <span class="token function">ping</span> <span class="token number">8.8</span>.8.8
<span class="token function">podman</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> test2 <span class="token parameter variable">--pod</span> demo dicker.io/library/busybox <span class="token function">ping</span> <span class="token number">8.8</span>.8.8


<span class="token comment"># 进入 test1 test2  网络地址相同 里面的软件可以本地调用</span>
<span class="token function">podman</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> test1 <span class="token function">sh</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="Docker-的非-root-模式"><a href="#Docker-的非-root-模式" class="headerlink" title="Docker 的非 root 模式"></a>Docker 的非 root 模式</h2><p>文档 <a href="https://docs.docker.com/engine/security/rootless/">https://docs.docker.com/engine/security/rootless/</a></p>
<p><code>rootless</code> 在使用之前需要</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">DOCKER_HOST</span><span class="token operator">=</span>unix:///run/user/1000/docker.sock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Composer</tag>
        <tag>Swarm</tag>
        <tag>Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器安全</title>
    <url>//post/docker-security-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h1 id="容器安全"><a href="#容器安全" class="headerlink" title="容器安全"></a>容器安全</h1><p><a href="https://github.com/xiaopeng163/docker.tips/blob/master/source/_static/docker-security/summary.PNG"><img src="https://github.com/xiaopeng163/docker.tips/raw/master/source/_static/docker-security/summary.PNG" alt="docker-security"></a></p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>代码层面的漏洞</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><ul>
<li>选择官方认证的基础镜像</li>
<li>镜像的漏洞扫描</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li>容器的漏洞扫描</li>
<li>容器的实时监控</li>
</ul>
<h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><ul>
<li>Linux Kernel </li>
<li>Kernel namespaces</li>
<li>Control groups</li>
</ul>
<p><a href="https://www.cvedetails.com/vulnerability-list/vendor_id-33/product_id-47/year-2021/Linux-Linux-Kernel.html">https://www.cvedetails.com/vulnerability-list/vendor_id-33/product_id-47/year-2021/Linux-Linux-Kernel.html</a></p>
<p>dockerd的rootless模式</p>
<h1 id="Docker-配置扫描"><a href="#Docker-配置扫描" class="headerlink" title="Docker 配置扫描"></a>Docker 配置扫描</h1><p>Demo project:</p>
<p><a href="https://github.com/xiaopeng163/flask-redis">https://github.com/xiaopeng163/flask-redis</a></p>
<p>Docker Bench for Security</p>
<p><a href="https://github.com/docker/docker-bench-security">https://github.com/docker/docker-bench-security</a></p>
<h1 id="代码和镜像扫描"><a href="#代码和镜像扫描" class="headerlink" title="代码和镜像扫描"></a>代码和镜像扫描</h1><p>CVE  <a href="https://cve.mitre.org/">https://cve.mitre.org/</a></p>
<p>代码扫描 <a href="https://snyk.io/">https://snyk.io/</a></p>
<p>镜像扫描 <a href="https://github.com/aquasecurity/trivy#os-packages">https://github.com/aquasecurity/trivy#os-packages</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>DockerHub</tag>
        <tag>Docker Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Composer</title>
    <url>//post/docker-compose-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h1><p>中文参考规范 <a href="https://www.kancloud.cn/yiyanan/docker-compose/2240704">https://www.kancloud.cn/yiyanan/docker-compose/2240704</a></p>
<p>构建规范 <a href="https://docs.docker.com/compose/compose-file/build/">https://docs.docker.com/compose/compose-file/build/</a></p>
<p>部署规范 <a href="https://docs.docker.com/compose/compose-file/deploy/">https://docs.docker.com/compose/compose-file/deploy/</a></p>
<p>开发规范 <a href="https://docs.docker.com/compose/compose-file/develop/">https://docs.docker.com/compose/compose-file/develop/</a></p>
<h2 id="docker-compose-介绍"><a href="#docker-compose-介绍" class="headerlink" title="docker compose 介绍"></a>docker compose 介绍</h2><p><img src="https://dockertips.readthedocs.io/en/latest/_images/docker-compose-intro.PNG" alt="docker-compose-intro"></p>
<h2 id="docker-compose-的安装"><a href="#docker-compose-的安装" class="headerlink" title="docker compose 的安装"></a>docker compose 的安装</h2><p><code>Windows</code> 和 <code>Mac</code> 在默认安装了<code>docker desktop</code>以后，<code>docker-compose</code>随之自动安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>docker.tips<span class="token operator">></span> <span class="token function">docker-compose</span> <span class="token parameter variable">--version</span>
<span class="token function">docker-compose</span> version <span class="token number">1.29</span>.2, build 5becea4c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>Linux</code> 用户需要自行安装</p>
<p>最新版本号可以在这里查询 <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token string">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">)</span></span>"</span> <span class="token parameter variable">-o</span> /usr/local/bin/docker-compose
<span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose
<span class="token function">docker-compose</span> <span class="token parameter variable">--version</span>
<span class="token function">docker-compose</span> version <span class="token number">1.29</span>.2, build 5becea4c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>熟悉 <code>python</code> 的朋友，可以使用<code>pip</code>去安装<code>docker-Compose</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token function">docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="docker-compose-镜像构建，拉取，启动"><a href="#docker-compose-镜像构建，拉取，启动" class="headerlink" title="docker compose 镜像构建，拉取，启动"></a>docker compose 镜像构建，拉取，启动</h2><p>下载源码，进入源码目录</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拉取</span>
<span class="token function">docker-compose</span> pull
<span class="token comment"># 构建</span>
<span class="token function">docker-compose</span> build
<span class="token comment"># 启动</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
<span class="token comment"># 修改镜像文件时 需要build的重新build， 创建修改过的 services</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span> <span class="token parameter variable">--build</span>
<span class="token comment"># 需要build的重新build， 从 docker-conpose 移除的服务，增加删除 service</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span> <span class="token parameter variable">--build</span> --remove-orphans



<span class="token comment"># 当前容器服务信息</span>
<span class="token function">docker-compose</span> <span class="token function">ps</span>

<span class="token comment"># 查看日志</span>
<span class="token function">docker-compose</span> logs

<span class="token comment"># 动态查看日志</span>
<span class="token function">docker-compose</span> logs <span class="token parameter variable">-f</span>



<span class="token comment"># 停止</span>
<span class="token function">docker-compose</span> stop

<span class="token comment"># 清理后台停止的 container 不会清理掉未使用的网络 network</span>
<span class="token function">docker-compose</span> <span class="token function">rm</span>

<span class="token comment"># 清理未使用的 容器 网络</span>
<span class="token function">docker</span> system prune <span class="token parameter variable">-a</span> <span class="token parameter variable">-f</span>


<span class="token comment"># 重启容器</span>
<span class="token function">docker-compose</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 <code>-p</code> 指定创建容器 网络等 <code>前缀</code>, 缺点： <code>停止</code> <code>删除</code> 等操作时，也要使用 <code>-p</code> 指定，否则运行不会成功</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> myproject up <span class="token parameter variable">-d</span>
<span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> myproject stop
<span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> myproject <span class="token function">rm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="docker-compose-yml-文件-中-services-下-container-name-my-flask-指定创建的容器名称"><a href="#docker-compose-yml-文件-中-services-下-container-name-my-flask-指定创建的容器名称" class="headerlink" title="docker-compose.yml 文件 中 services 下 container_name: my_flask 指定创建的容器名称"></a><code>docker-compose.yml</code> 文件 中 <code>services</code> 下 <code>container_name: my_flask</code> 指定创建的<code>容器名称</code><br><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">flask-demo</span><span class="token punctuation">:</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> my_flask
    <span class="token key atrule">image</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>latest
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> REDIS_HOST=redis<span class="token punctuation">-</span>server
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 8080<span class="token punctuation">:</span><span class="token number">5000</span>

  <span class="token key atrule">redis-server</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">demo-network</span><span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><p><code>docker-compose</code> 从 <code>Dockerfile</code> 中构建镜像<br><code>docker-compose.yml</code> 文件 中 <code>services</code> 下 <code>build:</code> 参数指定文件位置如：<code>build: ./flask</code> 指定 <code>Dockerfile</code> 文件位置</p>
<p><code>build:</code> 下的参数 <code>context: </code> 指定 <code>Dockerfile</code> 的位置</p>
<p><code>build:</code> 下的参数 <code>dockerfile: </code> 指定 <code>Dockerfile</code> 的名称 如： <code>Dockerfile.dev</code></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">flask-demo</span><span class="token punctuation">:</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> my_flask
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./flask
    <span class="token key atrule">image</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>latest
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> REDIS_HOST=redis<span class="token punctuation">-</span>server
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 8080<span class="token punctuation">:</span><span class="token number">5000</span>

  <span class="token key atrule">redis-server</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">demo-network</span><span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="docker-compose-配置文件的结构和版本"><a href="#docker-compose-配置文件的结构和版本" class="headerlink" title="docker compose 配置文件的结构和版本"></a>docker compose 配置文件的结构和版本</h2><p><code>docker compose</code> 文件的语法说明 <a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<h3 id="基本语法结构"><a href="#基本语法结构" class="headerlink" title="基本语法结构"></a>基本语法结构</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token comment"># 容器</span>
  <span class="token key atrule">servicename</span><span class="token punctuation">:</span> <span class="token comment"># 服务名字，这个名字也是内部 bridge网络可以使用的 DNS name</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token comment"># 镜像的名字</span>
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token comment"># 可选，如果设置，则会覆盖默认镜像里的 CMD命令</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于 docker run里的 --env</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于docker run里的 -v</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于 docker run里的 --network</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于 docker run里的 -p</span>
  <span class="token key atrule">servicename2</span><span class="token punctuation">:</span>

<span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于 docker volume create</span>

<span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 可选，相当于 docker network create</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以 <code>Python Flask</code> + <code>Redis</code> 练习：为例子，改造成一个 <code>docker-compose</code> 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image pull redis
<span class="token function">docker</span> image build <span class="token parameter variable">-t</span> flask-demo <span class="token builtin class-name">.</span>

<span class="token comment"># create network</span>
<span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge demo-network

<span class="token comment"># create container</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-server <span class="token parameter variable">--network</span> demo-network redis
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> demo-network <span class="token parameter variable">--name</span> flask-demo <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_HOST</span><span class="token operator">=</span>redis-server <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 flask-demo
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>docker-compose.yml</code> 文件如下</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">flask-demo</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>latest
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> REDIS_HOST=redis<span class="token punctuation">-</span>server
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 8080<span class="token punctuation">:</span><span class="token number">5000</span>

  <span class="token key atrule">redis-server</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> demo<span class="token punctuation">-</span>network

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">demo-network</span><span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="docker-compose-语法版本"><a href="#docker-compose-语法版本" class="headerlink" title="docker-compose 语法版本"></a>docker-compose 语法版本</h3><p>向后兼容</p>
<p><a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<h2 id="docker-compose-网络"><a href="#docker-compose-网络" class="headerlink" title="docker compose 网络"></a>docker compose 网络</h2><p>准备一个 docker-compose 文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">box1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"

  <span class="token key atrule">box2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>拉取镜像，启动容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> pull
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>查看网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network <span class="token function">ls</span>
<span class="token function">docker</span> network inspect compose-network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>进入容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> compose_box1_1 <span class="token function">sh</span>
<span class="token comment"># 通过容器名称 ping</span>
<span class="token function">ping</span> compose_box2_1
<span class="token comment"># 通过 service 名称 ping</span>
<span class="token function">ping</span> box1
<span class="token function">ping</span> box2
<span class="token comment"># 这几个名称 docker本身和docker-compose 都已经将其注册到了 DNS 服务器中了</span>

<span class="token comment"># 查看 DNS server 信息</span>
<span class="token function">dig</span> box2

<span class="token comment"># 宿主机上 ping box1 是不通的， 用的 DNS 服务不是一个</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p>准备一个 docker-compose 文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">box1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mynetwork1

  <span class="token key atrule">box2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mynetwork1
      <span class="token punctuation">-</span> mynetwork2
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">mynetwork1</span><span class="token punctuation">:</span>
  <span class="token key atrule">mynetwork2</span><span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>拉取镜像，启动容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> pull
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network <span class="token function">ls</span>

<span class="token comment"># 单机情况下 `docker-compose` 创建的 `network` ，`default driver` 是 `bridge`</span>
<span class="token function">docker</span> network inspect compose_mynetwork1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p>network 其他配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">box1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mynetwork1

  <span class="token key atrule">box2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> xiaopeng163/net<span class="token punctuation">-</span>box<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> /bin/sh <span class="token punctuation">-</span>c "while true; do sleep 3600; done"
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mynetwork1
      <span class="token punctuation">-</span> mynetwork2
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">mynetwork1</span><span class="token punctuation">:</span>
    <span class="token key atrule">ipam</span><span class="token punctuation">:</span>
      <span class="token key atrule">driver</span><span class="token punctuation">:</span> default
      <span class="token key atrule">config</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">subnet</span><span class="token punctuation">:</span> 172.28.0.0/16
  <span class="token key atrule">mynetwork2</span><span class="token punctuation">:</span>
    <span class="token key atrule">ipam</span><span class="token punctuation">:</span>
      <span class="token key atrule">driver</span><span class="token punctuation">:</span> default
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="docker-compose-水平扩展"><a href="#docker-compose-水平扩展" class="headerlink" title="docker compose 水平扩展"></a>docker compose 水平扩展</h2><p>本节课的源码下载 <a href="https://dockertips.readthedocs.io/en/latest/_downloads/d08ec3fdb5d57a37e2ee3915bbee687f/compose-scale-example-1.zip"><code>本节源码</code></a></p>
<h3 id="环境清理"><a href="#环境清理" class="headerlink" title="环境清理"></a>环境清理</h3><p>删除所有容器和镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span>
<span class="token function">docker</span> system prune <span class="token parameter variable">-a</span> <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>下载源码，进入源码目录</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> pull
<span class="token function">docker-compose</span> build
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>

Creating network <span class="token string">"compose-scale-example_default"</span> with the default driver
Creating compose-scale-example_flask_1        <span class="token punctuation">..</span>. <span class="token keyword">done</span>
Creating compose-scale-example_client_1       <span class="token punctuation">..</span>. <span class="token keyword">done</span>
Creating compose-scale-example_redis-server_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>

<span class="token function">docker-compose</span> <span class="token function">ps</span>

                Name                              Command               State    Ports
----------------------------------------------------------------------------------------
compose-scale-example_client_1         <span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">sleep</span> <span class="token punctuation">..</span>.   Up
compose-scale-example_flask_1          flask run <span class="token parameter variable">-h</span> <span class="token number">0.0</span>.0.0             Up      <span class="token number">5000</span>/tcp
compose-scale-example_redis-server_1   docker-entrypoint.sh redis <span class="token punctuation">..</span>.   Up      <span class="token number">6379</span>/tcp
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="水平扩展-scale"><a href="#水平扩展-scale" class="headerlink" title="水平扩展 scale"></a>水平扩展 scale</h3><p>快速的增加 <code>service</code> 的数量，并为<code>service</code>做一个简单的负载均衡</p>
<p>在 <code>Docker Compose</code> 中，”<code>scale</code>“ 是一个用于水平扩展（<code>Horizontal Scaling</code>）的命令。它可以让你在 <code>Docker Compose</code> 项目中<code>复制</code>和<code>运行多个</code>服务实例。</p>
<p><code>水平扩展</code>是一种应对<code>高负载</code>和<code>提高系统性能</code>的常用方法。通过将应用程序的负载分散到多个实例中，可以增加系统的处理能力和容量，从而提高整体性能和可用性。</p>
<p>使用 <code>Docker Compose</code> 的 <code>scale</code> 命令，你可以根据需要<code>增加</code>或<code>减少</code>服务的实例数量。例如，如果你的应用程序需要处理<code>更多的请求</code>，你可以使用 <code>scale</code> 命令<code>增加</code>实例的<code>数量</code>来分担<code>负载</code>。反之，如果负载减少，你可以减少实例的数量以节省资源。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span> <span class="token parameter variable">--scale</span> <span class="token assign-left variable">flask</span><span class="token operator">=</span><span class="token number">3</span>

compose-scale-example_client_1 is up-to-date
compose-scale-example_redis-server_1 is up-to-date
Creating compose-scale-example_flask_2 <span class="token punctuation">..</span>. <span class="token keyword">done</span>
Creating compose-scale-example_flask_3 <span class="token punctuation">..</span>. <span class="token keyword">done</span>

<span class="token comment"># 当前容器服务信息</span>
<span class="token function">docker-compose</span> <span class="token function">ps</span>


                Name                              Command               State    Ports
----------------------------------------------------------------------------------------
compose-scale-example_client_1         <span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">sleep</span> <span class="token punctuation">..</span>.   Up
compose-scale-example_flask_1          flask run <span class="token parameter variable">-h</span> <span class="token number">0.0</span>.0.0             Up      <span class="token number">5000</span>/tcp
compose-scale-example_flask_2          flask run <span class="token parameter variable">-h</span> <span class="token number">0.0</span>.0.0             Up      <span class="token number">5000</span>/tcp
compose-scale-example_flask_3          flask run <span class="token parameter variable">-h</span> <span class="token number">0.0</span>.0.0             Up      <span class="token number">5000</span>/tcp
compose-scale-example_redis-server_1   docker-entrypoint.sh redis <span class="token punctuation">..</span>.   Up      <span class="token number">6379</span>/tcp


<span class="token comment"># 进入 flask 容器 ping flask</span>
<span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 83a <span class="token function">sh</span>
<span class="token comment"># 每次 ping 返回的 ip 是不同的  docker compose 会做一个简单的负载均衡</span>
<span class="token function">ping</span> flask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动 Docker Compose 项目</span>
ocker-compose up <span class="token parameter variable">-d</span>

<span class="token comment"># 将名为 "service_name" 的服务扩展到 5 个实例</span>
<span class="token function">docker-compose</span> scale <span class="token assign-left variable">service_name</span><span class="token operator">=</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="添加-nginx"><a href="#添加-nginx" class="headerlink" title="添加 nginx"></a>添加 nginx</h3><p>源码下载 <a href="https://dockertips.readthedocs.io/en/latest/_downloads/15ef8ef4c424aefda9ce24c71698051d/compose-scale-example-2.zip"><code>源码更新</code></a></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Docker Compose</code> 的水平扩展（<code>scale</code>）功能在很多实战场景中非常有用。下面是一些常见的应用场景：</p>
<p><code>负载均衡</code>：通过水平扩展容器实例，可以实现负载均衡，将流量分布到多个实例上。你可以使用<code>反向代理</code>（如 <code>Nginx</code>）或者<code>容器编排工具</code>（如 <code>Docker Swarm</code> 或 <code>Kubernetes</code>）将请求均匀地分发到不同的容器实例上，以提高应用程序的可用性和性能。</p>
<p><code>高可用性</code>：通过水平扩展容器实例，可以增加应用程序的冗余性，确保在某个容器实例发生故障时仍然有其他实例可以继续提供服务。当一个实例不可用时，负载将自动转移到其他可用的实例上，从而确保服务的连续性。</p>
<p><code>大规模数据处理</code>：对于需要处理大量数据的应用程序，水平扩展可以提高处理速度和吞吐量。你可以将数据分片并分发到多个容器实例上进行并行处理，从而加快处理时间并减少整体任务的完成时间。</p>
<p><code>弹性扩展</code>：当面临高负载或峰值流量时，使用水平扩展可以快速增加容器实例的数量，以应对突发的需求。一旦负载减少，可以通过减少实例数量来节省资源。</p>
<p><code>A/B 测试</code>：使用 <code>Docker Compose</code> 的水平扩展功能，你可以创建多个容器实例，并将<code>不同版本</code>或<code>配置</code>的应用程序部署到这些实例上。这样，你可以同时运行<code>多个版本</code>，并将一部分流量路由到<code>新版本</code>上进行测试，以评估其性能和功能，从而帮助你做出更明智的决策。</p>
<p>这些场景只是 <code>Docker Compose</code> 水平扩展的示例之一。根据你的具体需求，你可以根据需要扩展和管理容器实例，以获得更好的性能、可用性和弹性。</p>
<h2 id="docker-compose-环境变量"><a href="#docker-compose-环境变量" class="headerlink" title="docker compose 环境变量"></a>docker compose 环境变量</h2><p>本节课的最终源码下载 <a href="https://dockertips.readthedocs.io/en/latest/_downloads/9cfad3ad3a1ae08652fc2a8de13231f9/compose-env.zip"><code>本节源码</code></a></p>
<p>参考文档：<a href="https://docs.docker.com/compose/environment-variables/">https://docs.docker.com/compose/environment-variables/</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看配置</span>
<span class="token function">docker-compose</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>docker-compose.yml</code> 支持 <code>环境变量</code> 使用 ， 同目录下 <code>.env</code> 中配置</p>
<p>自己指定 <code>环境变量</code> 文件名称 <code>.env</code> 变成 <code>myenv</code> 时，查看配置： <code>docker-compose --env-file ./myenv config</code> ，启动：<code>docker-compose --env-file ./myenv up -d</code></p>
<hr>
<p>引用自：<a href="https://www.cnblogs.com/sparkdev/p/9826520.html">https://www.cnblogs.com/sparkdev/p/9826520.html</a></p>
<p>在项目中，往往需要在 <code>docker-compose.yml</code> 文件中使用<code>环境变量</code>来控制不同的<code>条件</code>和<code>使用场景</code>。本文集中介绍 <code>docker compose</code> 引用<code>环境变量</code>的方式。<br>说明：本文的演示环境为 <code>ubuntu 16.04</code>。</p>
<h3 id="Compose-CLI-与环境变量"><a href="#Compose-CLI-与环境变量" class="headerlink" title="Compose CLI 与环境变量"></a>Compose CLI 与环境变量</h3><p><code>Compose CLI</code>(<code>compose command-line</code> 即 <code>docker-compose</code> 程序)能够识别名称为 <code>COMPOSE_PROJECT_NAME</code> 和 <code>COMPOSE_FILE</code> 等<code>环境变量</code>(具体支持的<code>环境变量</code>请参考<a href="https://docs.docker.com/compose/reference/envvars/">这里</a>)。比如我们可以通过这两个<code>环境变量</code>为 <code>docker-compose</code> 指定 <code>project 的名称</code>和 <code>配置文件</code> ：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">COMPOSE_PROJECT_NAME</span><span class="token operator">=</span>TestVar
<span class="token builtin class-name">export</span> <span class="token assign-left variable">COMPOSE_FILE</span><span class="token operator">=~</span>/projects/composecounter/docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193147161-635372632.png"></p>
<p>然后启动应用，显示的 <code>project</code> 名称都是我们在环境变量中指定的：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193239211-1124545580.png"></p>
<p>如果设置了环境变量的同时又指定了<code>命令行选项</code>，那么会应用<code>命令行选项</code>的设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> nickproject up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193320881-483163814.png"></p>
<h3 id="在-compose-file-中引用环境变量"><a href="#在-compose-file-中引用环境变量" class="headerlink" title="在 compose file 中引用环境变量"></a>在 compose file 中引用环境变量</h3><p>我们还可以在<code>compose file</code>中直接引用<code>环境变量</code>，比如下面的 <code>demo</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
  <span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token key atrule">web</span><span class="token punctuation">:</span>
      <span class="token key atrule">image</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>IMAGETAG<span class="token punctuation">&#125;</span>
      <span class="token key atrule">ports</span><span class="token punctuation">:</span>
       <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
      <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>我们通过环境变量 <code>$&#123;IMAGETAG&#125;</code> 指定了 <code>web</code> 的<code>镜像</code>，下面通过 <code>export</code> 的方式来为 <code>compose</code> 配置文件中的<code>环境变量传值</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193436149-979839196.png"></p>
<p><strong>注意</strong>，如果<code>对应的环境变量</code>没有<code>被设置</code>，那么 <code>compose</code> 就会把它替换为一个<code>空字符串</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193516245-1665429749.png"></p>
<p>碰到这种情况，我们可以在 <code>compose</code> 的配置文件中为<code>该变量</code>设置一个<code>默认值</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>IMAGETAG<span class="token punctuation">:</span><span class="token punctuation">-</span>defaultwebimage<span class="token punctuation">&#125;</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>这样，如果没有设置 <code>IMAGETAG</code> 变量，就会应用 <code>defaultwebimage</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193612306-971233538.png"></p>
<p>除了这种方式，我们还可以通过后面将介绍的 <code>.env</code> 文件来为<code>环境变量</code>设置<code>默认值</code>。</p>
<h3 id="把环境变量传递给容器"><a href="#把环境变量传递给容器" class="headerlink" title="把环境变量传递给容器"></a>把环境变量传递给容器</h3><p>先来看一下在 <code>compose file</code> 中如何为<code>容器</code>设置<code>环境变量</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">web</span><span class="token punctuation">:</span>
  <span class="token key atrule">environment</span><span class="token punctuation">:</span>
    <span class="token key atrule">DEBUG</span><span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>compose file</code> 中的 <code>environment</code> 节点用来为<code>容器</code>设置<code>环境变量</code>，上面的写法等同于：</p>
<p>要把当前 <code>shell</code> <code>环境变量</code>的值<code>传递</code>给<code>容器</code>的<code>环境变量</code>也很简单，去掉上面代码中的<code>赋值部分</code>就可以了：</p>
<p>这种情况下，如果没有在当前的 <code>shell</code> 中导出<code>环境变量</code> <code>DEBUG</code>，<code>compose file</code> 中会把它解释为 <code>null</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193714885-1722118683.png"></p>
<p>在试试<code>导出环境变量</code> <code>DEBUG</code> 的情况：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021193832687-990288802.png"></p>
<p>这才是我们设计的正确的使用场景！</p>
<h3 id="使用文件为容器设置多个环境变量"><a href="#使用文件为容器设置多个环境变量" class="headerlink" title="使用文件为容器设置多个环境变量"></a>使用文件为容器设置多个环境变量</h3><p>如果觉得通过 <code>environment</code> 为<code>容器</code>设置<code>环境变量</code>不够过瘾，我们还可以像 <code>docker -run</code> 的 -<code>-env-file</code> 参数一样通过<code>文件</code>为<code>容器</code>设置环境变量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">web</span><span class="token punctuation">:</span>
  <span class="token key atrule">env_file</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> web<span class="token punctuation">-</span>variables.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，<code>web-variables.env</code> 文件的路径是相对于 <code>docker-compose.yml</code> 文件的<code>相对路径</code>。上面的代码效果与下面的代码相同：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run --env-file<span class="token operator">=</span>web-variables.env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>web-variables.env</code> 文件中可以定义<code>一个</code>或<code>多个</code>环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># define web container env</span>
<span class="token assign-left variable">APPNAME</span><span class="token operator">=</span>helloworld
<span class="token assign-left variable">AUTHOR</span><span class="token operator">=</span>Nick Li
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>检查下结果：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021194210315-791060157.png"></p>
<p>原来 <code>compose</code> 把 <code>env_file</code> 的设置翻译成了 <code>environment</code>！</p>
<h3 id="env-文件"><a href="#env-文件" class="headerlink" title=".env 文件"></a>.env 文件</h3><p>当我们在 <code>docker-compose.yml</code> 文件中<code>引用</code>了<code>大量</code>的<code>环境变量</code>时，对每个<code>环境变量</code>都设<code>置默认值</code>将是繁琐的，并且也会影响 <code>docker-compose.yml</code> 简洁程度。此时我们可以通过 <code>.env</code> 文件来为 <code>docker-compose.yml</code> 文件引用的<code>所有环境变量</code>设置<code>默认值</code>！<br>修改 docker-compose.yml 文件的内容如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>IMAGETAG<span class="token punctuation">&#125;</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">APPNAME</span><span class="token punctuation">:</span>
      <span class="token key atrule">AUTHOR</span><span class="token punctuation">:</span>
      <span class="token key atrule">VERSION</span><span class="token punctuation">:</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>然后在<code>相同的目录</code>下创建 <code>.env</code> 文件，编辑其内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># define env var default value.</span>
<span class="token assign-left variable">IMAGETAG</span><span class="token operator">=</span>defaultwebimage
<span class="token assign-left variable">APPNAME</span><span class="token operator">=</span>default app name
<span class="token assign-left variable">AUTHOR</span><span class="token operator">=</span>default author name
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span>default version is <span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>检查下结果，此时所有的环境变量都显示为 <code>.env</code> 文件中<code>定义</code>的<code>默认值</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021194335736-1906362609.png"></p>
<h3 id="配置不同场景下的环境变量"><a href="#配置不同场景下的环境变量" class="headerlink" title="配置不同场景下的环境变量"></a>配置不同场景下的环境变量</h3><p>从前面的部分中我们可以看到，<code>docker compose</code> 提供了足够的<code>灵活性</code>来让我们设置 <code>docker-compose.yml</code> 文件中<code>引用的环境变量</code>，它们的<code>优先级</code>如下：</p>
<ol>
<li>Compose file</li>
<li><strong>Shell environment variables</strong></li>
<li>Environment file</li>
<li>Dockerfile</li>
<li>Variable is not defined</li>
</ol>
<p><strong>首先</strong>，在 <code>docker-compose.yml</code> 文件中<code>直接设置</code>的值<code>优先级是最高的</code>。<br><strong>然后</strong>是在当前 <code>shell</code> 中 <code>export</code> 的<code>环境变量</code>值。<br><strong>接下来</strong>是在<code>环境变量文件</code>中定义的值。<br><strong>再接下来</strong>是在 <code>Dockerfile</code> 中定义的值。<br><strong>最后</strong>还没有找到相关的环境变量就认为该<code>环境变量没有被定义</code>。</p>
<p>根据上面的优先级定义，我们可以把<code>不同场景</code>下的<code>环境变量</code>定义在不同的 <code>shell 脚本</code> 中并导出，然后在执行 <code>docker-compose</code> 命令前先执行 <code>source</code> 命令把 <code>shell 脚本</code>中定义的环境变量<code>导出</code>到 <code>当前的 shell</code> 中。通过这样的方式可以<code>减少维护环境变量</code>的地方</p>
<p>下面的例子中我们分别在 <code>docker-compose.yml</code> 文件<code>所在的目录</code>创建 <code>test.sh</code> 和 <code>prod.sh</code></p>
<p><code>test.sh</code> 的内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># define env var default value.</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">IMAGETAG</span><span class="token operator">=</span>web:v1
<span class="token builtin class-name">export</span> <span class="token assign-left variable">APPNAME</span><span class="token operator">=</span>HelloWorld
<span class="token builtin class-name">export</span> <span class="token assign-left variable">AUTHOR</span><span class="token operator">=</span>Nick Li
<span class="token builtin class-name">export</span> <span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>prod.sh</code> 的内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># define env var default value.</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">IMAGETAG</span><span class="token operator">=</span>webpord:v1
<span class="token builtin class-name">export</span> <span class="token assign-left variable">APPNAME</span><span class="token operator">=</span>HelloWorldProd
<span class="token builtin class-name">export</span> <span class="token assign-left variable">AUTHOR</span><span class="token operator">=</span>Nick Li
<span class="token builtin class-name">export</span> <span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token number">1</span>.0LTS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>测试环境</code>下，执行下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> test.sh
<span class="token function">docker-compose</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021194545225-651179018.png"></p>
<p>此时 <code>docker-compose.yml</code> 中的<code>环境变量</code>应用的都是<code>测试环境</code>相关的设置。</p>
<p>而在<code>生产环境</code>下，执行下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> prod.sh
<span class="token function">docker-compose</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181021194641722-1807047502.png"></p>
<p>此时 <code>docker-compose.yml</code> 中的<code>环境变量</code>应用的都是<code>生产环境</code>相关的设置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>docker compose </code>对环境变量的使用提供了非常丰富支持和灵活的使用方式。希望通过本文的总结可以帮助大家理清相关的用法，并能够以简洁的方式为不同的使用场景提供支持。</p>
<p><strong>参考：</strong><br><a href="https://docs.docker.com/compose/reference/envvars/">Compose CLI environment variables</a></p>
<p><a href="https://docs.docker.com/compose/environment-variables/">Environment variables in Compose</a></p>
<p><a href="https://docs.docker.com/compose/compose-file/#variable-substitution">Compose file variable substitution</a></p>
<p><a href="https://docs.docker.com/compose/env-file/">Declare default environment variables in file</a></p>
<h2 id="docker-compose-服务依赖和健康检查"><a href="#docker-compose-服务依赖和健康检查" class="headerlink" title="docker compose 服务依赖和健康检查"></a>docker compose 服务依赖和健康检查</h2><p><code>Dockerfile healthcheck</code> <a href="https://docs.docker.com/engine/reference/builder/#healthcheck">https://docs.docker.com/engine/reference/builder/#healthcheck</a></p>
<p><code>docker compose</code> <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck">https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck</a></p>
<p>健康检查是容器运行状态的高级检查，主要是检查容器所运行的进程是否能正常的对外提供“服务”，比如一个数据库容器，我们不光 需要这个容器是<code>up</code>的状态，我们还要求这个容器的<code>数据库进程</code>能够正常对外提供服务，这就是所谓的<code>健康检查</code>。</p>
<h3 id="容器的健康检查"><a href="#容器的健康检查" class="headerlink" title="容器的健康检查"></a>容器的健康检查</h3><p>容器本身有一个健康检查的功能，但是需要在<code>Dockerfile</code>里定义，或者在执行<code>docker container run</code> 的时候，通过下面的一些参数指定</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--health-cmd string              Command to run to check health
--health-interval duration       Time between running the check
                                <span class="token punctuation">(</span>ms<span class="token operator">|</span>s<span class="token operator">|</span>m<span class="token operator">|</span>h<span class="token punctuation">)</span> <span class="token punctuation">(</span>default 0s<span class="token punctuation">)</span>
--health-retries int             Consecutive failures needed to
                                report unhealthy
--health-start-period duration   Start period <span class="token keyword">for</span> the container to
                                initialize before starting
                                health-retries countdown
                                <span class="token punctuation">(</span>ms<span class="token operator">|</span>s<span class="token operator">|</span>m<span class="token operator">|</span>h<span class="token punctuation">)</span> <span class="token punctuation">(</span>default 0s<span class="token punctuation">)</span>
--health-timeout duration        Maximum <span class="token function">time</span> to allow one check to
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h3><p>我们以下面的这个<code>flask</code>容器为例，相关的代码如下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token punctuation">\</span>compose-env<span class="token punctuation">\</span>flask<span class="token operator">></span> <span class="token function">dir</span>


    目录: C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token punctuation">\</span>compose-env<span class="token punctuation">\</span>flask


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         <span class="token number">2021</span>/7/13     <span class="token number">15</span>:52            <span class="token number">448</span> app.py
-a----         <span class="token number">2021</span>/7/14      <span class="token number">0</span>:32            <span class="token number">471</span> Dockerfile


PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token punctuation">\</span>compose-env<span class="token punctuation">\</span>flask<span class="token operator">></span> <span class="token function">more</span> .<span class="token punctuation">\</span>app.py
from flask <span class="token function">import</span> Flask
from redis <span class="token function">import</span> StrictRedis
<span class="token function">import</span> os
<span class="token function">import</span> socket

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
redis <span class="token operator">=</span> StrictRedis<span class="token punctuation">(</span>host<span class="token operator">=</span>os.environ.get<span class="token punctuation">(</span><span class="token string">'REDIS_HOST'</span>, <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>,
                    <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">6379</span>, <span class="token assign-left variable">password</span><span class="token operator">=</span>os.environ.get<span class="token punctuation">(</span><span class="token string">'REDIS_PASS'</span><span class="token punctuation">))</span>


@app.route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
def hello<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    redis.incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>
    <span class="token builtin class-name">return</span> f<span class="token string">"Hello Container World! I have been seen &#123;redis.get('hits').decode('utf-8')&#125; times and my hostname is &#123;socket.gethostname()&#125;.<span class="token entity" title="\n">\n</span>"</span>

PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token punctuation">\</span>compose-env<span class="token punctuation">\</span>flask<span class="token operator">></span> <span class="token function">more</span> .<span class="token punctuation">\</span>Dockerfile
FROM python:3.9.5-slim

RUN pip <span class="token function">install</span> flask redis <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
    <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
    <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">curl</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
    <span class="token function">groupadd</span> <span class="token parameter variable">-r</span> flask <span class="token operator">&amp;&amp;</span> <span class="token function">useradd</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-g</span> flask flask <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
    <span class="token function">mkdir</span> /src <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
    <span class="token function">chown</span> <span class="token parameter variable">-R</span> flask:flask /src

<span class="token environment constant">USER</span> flask

COPY app.py /src/app.py

WORKDIR /src

ENV <span class="token assign-left variable">FLASK_APP</span><span class="token operator">=</span>app.py <span class="token assign-left variable">REDIS_HOST</span><span class="token operator">=</span>redis

EXPOSE <span class="token number">5000</span>

HEALTHCHECK <span class="token parameter variable">--interval</span><span class="token operator">=</span>30s <span class="token parameter variable">--timeout</span><span class="token operator">=</span>3s <span class="token punctuation">\</span>
    CMD <span class="token function">curl</span> <span class="token parameter variable">-f</span> http://localhost:5000/ <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>

CMD <span class="token punctuation">[</span><span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面<code>Dockerfile</code>里的 <code>HEALTHCHECK</code> 就是定义了一个健康检查。 会每隔<code>30</code>秒检查一次，如果失败就会退出，退出代码是<code>1</code></p>
<h3 id="构建镜像和创建容器"><a href="#构建镜像和创建容器" class="headerlink" title="构建镜像和创建容器"></a>构建镜像和创建容器</h3><p>构建镜像，创建一个<code>bridge</code>网络，然后启动容器连到<code>bridge</code>网络</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image build <span class="token parameter variable">-t</span> flask-demo <span class="token builtin class-name">.</span>
<span class="token function">docker</span> network create mybridge
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> mybridge <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_PASS</span><span class="token operator">=</span>abc123 flask-demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>查看容器状态</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ls</span>

CONTAINER ID   IMAGE        COMMAND                  CREATED       STATUS                            PORTS      NAMES
059c12486019   flask-demo   <span class="token string">"flask run -h 0.0.0.0"</span>   <span class="token number">4</span> hours ago   Up <span class="token number">8</span> seconds <span class="token punctuation">(</span>health: starting<span class="token punctuation">)</span>   <span class="token number">5000</span>/tcp   dazzling_tereshkova<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以通过<code>docker container inspect 059</code> 查看详情， 其中有有关 <code>health</code> 的</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"Health"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
<span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"starting"</span>,
<span class="token string">"FailingStreak"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,
<span class="token string">"Log"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Start"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-14T19:04:46.4054004Z"</span>,
        <span class="token string">"End"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-14T19:04:49.4055393Z"</span>,
        <span class="token string">"ExitCode"</span><span class="token builtin class-name">:</span> -1,
        <span class="token string">"Output"</span><span class="token builtin class-name">:</span> <span class="token string">"Health check exceeded timeout (3s)"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>经过<code>3</code>次检查，一直是不通的，然后<code>health</code>的状态会从<code>starting</code>变为 <code>unhealthy</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ls</span>

CONTAINER ID   IMAGE        COMMAND                  CREATED       STATUS                     PORTS      NAMES
059c12486019   flask-demo   <span class="token string">"flask run -h 0.0.0.0"</span>   <span class="token number">4</span> hours ago   Up <span class="token number">2</span> minutes <span class="token punctuation">(</span>unhealthy<span class="token punctuation">)</span>   <span class="token number">5000</span>/tcp   dazzling_tereshkova
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h3><p>启动 <code>redis</code> ，连到 <code>mybridge</code> 上，<code>name=redis</code>， 注意<code>密码</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> mybridge <span class="token parameter variable">--name</span> redis redis:latest redis-server <span class="token parameter variable">--requirepass</span> abc123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>经过几秒钟，我们的<code>flask</code> 变成了<code>healthy</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ls</span>

CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                   PORTS      NAMES
bc4e826ee938   redis:latest   <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">18</span> seconds ago   Up <span class="token number">16</span> seconds            <span class="token number">6379</span>/tcp   redis
059c12486019   flask-demo     <span class="token string">"flask run -h 0.0.0.0"</span>   <span class="token number">4</span> hours ago      Up <span class="token number">6</span> minutes <span class="token punctuation">(</span>healthy<span class="token punctuation">)</span>   <span class="token number">5000</span>/tcp   dazzling_tereshkova
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="docker-compose-健康检查"><a href="#docker-compose-健康检查" class="headerlink" title="docker-compose 健康检查"></a>docker-compose 健康检查</h3><p><code>docker-compose.yaml</code> 文件， <code>healthcheck</code> 是 <code>docker-compose</code> 的容器健康检查项</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">flask</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./flask
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token key atrule">image</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>latest
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> REDIS_HOST=redis<span class="token punctuation">-</span>server
      <span class="token punctuation">-</span> REDIS_PASS=$<span class="token punctuation">&#123;</span>REDIS_PASSWORD<span class="token punctuation">&#125;</span>
    <span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>
      <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost:5000"</span><span class="token punctuation">]</span>
      <span class="token key atrule">interval</span><span class="token punctuation">:</span> 30s
      <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 3s
      <span class="token key atrule">retries</span><span class="token punctuation">:</span> <span class="token number">3</span>
      <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 40s
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> redis<span class="token punctuation">-</span>server
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> backend
      <span class="token punctuation">-</span> frontend

  <span class="token key atrule">redis-server</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>server <span class="token punctuation">-</span><span class="token punctuation">-</span>requirepass $<span class="token punctuation">&#123;</span>REDIS_PASSWORD<span class="token punctuation">&#125;</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> backend

  <span class="token key atrule">nginx</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>stable<span class="token punctuation">-</span>alpine
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 8000<span class="token punctuation">:</span><span class="token number">80</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token comment"># flask 是健康状态时 才去启动 nginx</span>
      <span class="token key atrule">flask</span><span class="token punctuation">:</span>
        <span class="token key atrule">condition</span><span class="token punctuation">:</span> service_healthy
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./nginx/nginx.conf<span class="token punctuation">:</span>/etc/nginx/conf.d/default.conf<span class="token punctuation">:</span>ro
      <span class="token punctuation">-</span> ./var/log/nginx<span class="token punctuation">:</span>/var/log/nginx
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frontend

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">backend</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构建镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从 dockerfile build  flask 镜像</span>
<span class="token function">docker-compose</span> build
<span class="token comment"># 拉取 nginx redis 镜像</span>
<span class="token function">docker-compose</span> pull
<span class="token comment"># 启动</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
<span class="token comment"># 查看</span>
<span class="token function">docker-compose</span> <span class="token function">ps</span>
<span class="token comment"># 修改 docker-compose.yaml 文件 改变配置，重新启动</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
<span class="token comment"># 停止</span>
<span class="token function">docker-compose</span> stop
<span class="token comment"># 删除</span>
<span class="token function">docker-compose</span> <span class="token function">rm</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码下载(<code>flask healthcheck</code>) <a href="https://dockertips.readthedocs.io/en/latest/_downloads/df3430ebd5e1f962f0c10136565257e1/compose-healthcheck-flask.zip"><code>本节源码</code></a></p>
<p>示例代码下载(<code>flask</code> + <code>redis healthcheck</code>) <a href="https://dockertips.readthedocs.io/en/latest/_downloads/529c888c2faf46a0906548ed7510d12b/compose-healthcheck-redis.zip"><code>本节源码</code></a></p>
<p>一个<code>healthcheck</code>不错的例子 <a href="https://gist.github.com/phuysmans/4f67a7fa1b0c6809a86f014694ac6c3a">https://gist.github.com/phuysmans/4f67a7fa1b0c6809a86f014694ac6c3a</a></p>
<h2 id="docker-compose-投票-app-练习"><a href="#docker-compose-投票-app-练习" class="headerlink" title="docker compose 投票 app 练习"></a>docker compose 投票 app 练习</h2><p>源码地址： <a href="https://github.com/dockersamples/example-voting-app">https://github.com/dockersamples/example-voting-app</a></p>
<p>另外这个<code>repo</code>大家也可以收藏一下 <a href="https://github.com/docker/awesome-compose">https://github.com/docker/awesome-compose</a> 里面非常多的 <code>docker-compose</code> <code>example</code></p>
<h2 id="Docker-Compose-进阶"><a href="#Docker-Compose-进阶" class="headerlink" title="Docker Compose 进阶"></a>Docker Compose 进阶</h2><p>引用自：<a href="https://www.cnblogs.com/sparkdev/p/9803554.html">https://www.cnblogs.com/sparkdev/p/9803554.html</a></p>
<h3 id="应用多个-compose-配置文件"><a href="#应用多个-compose-配置文件" class="headerlink" title="应用多个 compose 配置文件"></a>应用多个 compose 配置文件</h3><p><code>docker-compose</code> 命令默认使用的配置文件是当前目录中的 <code>docker-compose.yml</code> 文件，当然我们可以通过 <code>-f</code> 选项指定一个其它名称的配置文件，比如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-f</span> docker-compose-dev.yml up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>更酷的是我们可以添加多个 <code>-f</code> 选项，<code>docker-compose</code> 会自动合并它们，当然也会根据先后顺序把一些重复的配置项覆盖掉。 下面我们来演示一个常见的使用场景，先创建一个名称为 <code>docker-compose-base.yml</code> 的配置文件，其内容如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:latest"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后再创建名称为 <code>docker-compose-dev.yml </code>的配置文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面的命令会同时应用这两个配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-f</span> docker-compose-base.yml <span class="token parameter variable">-f</span> docker-compose-dev.yml config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>config</code> 命令不会执行真正的操作，而是显示 <code>docker-compose</code> 程序解析到的配置文件内容：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131032912-144319125.png"></p>
<p>很显然，我们指定的两个配置文件的内容被合并了。接下来我们再来看看配置文件覆盖的情况。新创建一个名为 <code>docker-compose-prod.yml</code> 的配置文件，编辑其内容如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"80:5000"</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>然后执行下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-f</span> docker-compose-base.yml <span class="token parameter variable">-f</span> docker-compose-prod.yml config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131118014-522763315.png"></p>
<p>这次 <code>docker-compose-prod.yml</code> 文件中的 <code>image</code> 设置覆盖了 <code>docker-compose-base.yml</code> 文件中的设置，并且映射的端口也改成了 <code>80:5000</code>。<br>就像 <code>demo</code> 中演示的那样，我们可以通过<code>多次</code>指定 <code>-f</code> 选项的方式配置不同的环境，并且共用一份基础的配置文件。</p>
<p>其实 <code>docker-compse</code> 还默认还支持一种<code>合并</code>、<code>覆盖</code>配置文件的写法，就是使用约定的文件名称<code> docker-compose.yml</code> 和 <code>docker-compose.override.yml</code>。下面我们把 <code>docker-compose-base.yml</code> 文件改名为 <code>docker-compose.yml</code>，把 <code>docker-compose-prod.yml</code> 文件改名为 <code>docker-compose.override.yml</code>，并直接执行<code>不带</code> <code>-f</code> 选项的命令：</p>
<p>结果和前面是一样的，<code>docker-compose </code>自动合并了配置文件 <code>docker-compose.yml </code>和<code> docker-compose.override.yml</code>。这种方式虽然省去了指定 <code>-f </code>选项的麻烦但其<code>缺点</code>也是很明显的，就是无法<code>指定更多不同的应用场景</code>。</p>
<h3 id="使用-network"><a href="#使用-network" class="headerlink" title="使用 network"></a>使用 network</h3><p><code>Docker</code> 提供的 <code>network</code> 功能能够对<code>容器</code>进行<code>网络上的隔离</code>，下面的 <code>demo</code> 中我们创建三个 <code>service</code> 和两个虚拟网络(注意，该 <code>demo</code> 主要是演示 <code>network</code> 的用法，所以笔者并没有配置 <code>proxy service</code> 中的 <code>nginx</code>)：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">proxy</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"80:80"</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frantnet
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frantnet
      <span class="token punctuation">-</span> endnet
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> endnet
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">frantnet</span><span class="token punctuation">:</span>
  endnet<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>其中：</p>
<p><code>proxy</code> 和 <code>webapp</code> 连接到网络 <code>frantnet</code> 上</p>
<p><code>webapp</code> 和 <code>redis</code> 连接在了 <code>endnet</code> 上(请使用《<a href="https://www.cnblogs.com/sparkdev/p/9753793.html">Docker Compose 简介</a>》一文中介绍的 <code>web</code> 应用和 <code>Dockerfile</code> 来创建<code> webapp service</code>)。请使用下面的命令来启动应用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> testnet <span class="token parameter variable">-f</span> docker-compose-net.yml up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131320811-1377033317.png"></p>
<p>从上图我们可以看到该命令一共创建了<code>两个</code> <code>network</code> 和 <code>三个</code> <code>容器</code>。然后我们检查一下这<code>三个容器</code>的<code>网络连接状态</code>。先从 <code>testnet_webapp_1</code> 中 <code>ping</code> 另外的两个容器：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131354662-416336694.png"></p>
<p>因为 <code>webapp</code> 服务同时连接到了 <code>frantnet</code> 和 <code>endnet</code> 两个网络中，所以它可以同时连接这两个网络中的其它容器(<code>proxy</code> 和 <code>redis</code>)。</p>
<p>接下来再看看容器 <code>proxy</code> 和 <code>redis</code> 是否可以直接连通，我们从容器 <code>testnet_redis_1</code> 中 <code>ping</code> <code>proxy</code>(注意，执行这个操作前需要在容器  <code>testnet_redis_1</code> 中通过 <code>apt-get update &amp;&amp; apt-get install iputils-ping</code> 命令安装 <code>ping</code> 命令)：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131431379-1023292312.png"></p>
<p>无法从容器 <code>testnet_redis_1</code> 中 <code>ping</code> 通 <code>proxy</code> 容器，这也就说明我们通过不同的虚拟网络实现了容器网络之间的隔离，从而在最大程度上去保护后端网络的安全。</p>
<h3 id="按顺序启动容器"><a href="#按顺序启动容器" class="headerlink" title="按顺序启动容器"></a>按顺序启动容器</h3><p>默认情况下 <code>compose</code> 启动容器的顺序是不确定的，但是有些场景下我们希望能够控制容器的启动顺序，比如应该让运行数据库的程序先启动。我们可以通过 <code>depends_on</code> 来解决有依赖关系的容器的启动顺序问题，看下面的 <code>demo</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">proxy</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"80:80"</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> webapp
      <span class="token punctuation">-</span> redis
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> redis
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>启动应用：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131603316-913957749.png"></p>
<p>无论我们执行多少次这样的启动操作，这三个容器的启动顺序都是不变的。如果不应用 <code>depends_on</code>，每次执行 <code>up</code> 命令容器的启动顺序可能都是不一样的。<br>需要注意的是 <code>depends_on</code> 只是<code>解决了</code>控制容器<code>启动顺序</code>的问题，如果一个容器的<code>启动时间</code>非常长，后面的容器并不会等待它<code>完成启动</code>。如果要解决这类问题(<code>等待容器完成启动并开始提供服务</code>)，需要使用 <code>wait-for-it</code> 等工具。</p>
<h3 id="配置数据卷-volume"><a href="#配置数据卷-volume" class="headerlink" title="配置数据卷(volume)"></a>配置数据卷(volume)</h3><p><code>数据卷</code>是处理容器中的<code>持久化数据</code>的主要方式，在 <code>compose</code> 中我们可以通过两种方式来指定数据卷：</p>
<ul>
<li>使用命名的数据卷</li>
<li>直接指定主机上的路径来创建数据卷</li>
</ul>
<p>下面的 <code>demo</code> 演示了这<code>两</code>种<code>数据卷</code>的配置方式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.2"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> volume
        <span class="token key atrule">source</span><span class="token punctuation">:</span> mydata
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /data
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> bind
        <span class="token key atrule">source</span><span class="token punctuation">:</span> ./nginx/logs
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /var/log/nginx
  <span class="token key atrule">jenkins</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> jenkins/jenkins<span class="token punctuation">:</span>lts
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> jenkins_home<span class="token punctuation">:</span>/var/jenkins_home
      <span class="token punctuation">-</span> mydata<span class="token punctuation">:</span>/data
<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">mydata</span><span class="token punctuation">:</span>
  jenkins_home<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>在这个例子中我们一共创建了<code>三</code>个数据卷，分别是<code>两个命名的数据卷</code> <code>jenkins_home</code> 和 <code>mydata</code>：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131740766-2091840960.png"></p>
<p>其中的 <code>jenkins_home</code> 数据卷是给 <code>jenkins</code> 保存数据的。</p>
<p>如果要在<code>多个容器</code>之间<code>共享数据卷</code>，就必须在<code>顶级</code>的 <code>volumes</code> 节点中<code>定义</code>这个数据卷，比如 <code>mydata</code> 数据卷，它被 <code>web</code> 和 <code>jenkins service</code> 共享了。</p>
<p>比如我们在 <code>web service</code> 中的 <code>mydata</code> 数据卷中创建一个名为 <code>hello</code> 的<code>文件</code>，该<code>文件</code>会同时出现在 <code>jenkins service</code> 中：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131815127-1126854547.png"></p>
<p>我们还创建了一个 <code>bind</code> 类型的 <code>volume</code> 在当前目录下的<code> nginx/logs</code> 目录下保存 <code>nginx</code> 的日志：</p>
<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017131845910-1606044961.png"></p>
<h3 id="配置日志驱动"><a href="#配置日志驱动" class="headerlink" title="配置日志驱动"></a>配置日志驱动</h3><p>我们还可以通过 <code>logging</code> 节点为 <code>service</code> 指定<code>日志驱动</code>及其<code>相关的选项</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
    <span class="token key atrule">logging</span><span class="token punctuation">:</span>
      <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"json-file"</span>
      <span class="token key atrule">options</span><span class="token punctuation">:</span>
        <span class="token key atrule">max-size</span><span class="token punctuation">:</span> <span class="token string">"200k"</span>
        <span class="token key atrule">max-file</span><span class="token punctuation">:</span> <span class="token string">"10"</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:latest"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>上面的代码指定日志驱动为 <code>json-file</code>，存储日志的最大文件 <code>size</code> 为 <code>200k</code>，最多存储 <code>10</code> 这样大的<code>文件</code>。</p>
<h3 id="在-compose-file-文件中应用模板"><a href="#在-compose-file-文件中应用模板" class="headerlink" title="在 compose file 文件中应用模板"></a>在 compose file 文件中应用模板</h3><p>从版本 <code>3.4</code> 开始，可以在 <code>compose file</code> 文件中使用 <code>extension fields</code>，其实我们可以简单的把它理解为<code>可以重用的代码模板</code>。</p>
<p><code>模板</code>的<code>定义</code>必须以 <code>x-</code> 开头，然后以 <code>&amp;</code> 开头的<code>字符串</code>为<code>模板命名</code>，之后就可以以 <code>*</code> 加上<code>模板的名称</code>引用模板：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.4'</span>
<span class="token key atrule">x-logging</span><span class="token punctuation">:</span>
  <span class="token important">&amp;default-logging</span>
  <span class="token key atrule">driver</span><span class="token punctuation">:</span> json<span class="token punctuation">-</span>file
  <span class="token key atrule">options</span><span class="token punctuation">:</span>
    <span class="token key atrule">max-size</span><span class="token punctuation">:</span> <span class="token string">"200k"</span>
    <span class="token key atrule">max-file</span><span class="token punctuation">:</span> <span class="token string">"10"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
    <span class="token key atrule">logging</span><span class="token punctuation">:</span> <span class="token important">*default-logging</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:latest"</span>
    <span class="token key atrule">logging</span><span class="token punctuation">:</span> <span class="token important">*default-logging</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>运行下面的命令看看模板替换的情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> <span class="token parameter variable">-p</span> template <span class="token parameter variable">-f</span> docker-compose-template.yml config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://img2018.cnblogs.com/blog/952033/201810/952033-20181017132006365-619863056.png"></p>
<p>上图显示所有对模板的引用都被替换成了模板的内容。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Docker compose</code> 是一件强有力的效率工具，本文只是介绍了一些常见的用法。如果你还想掌握更多内容，请参考 <code>compose file</code> 的官方文档。</p>
<p><strong>参考：</strong><br><a href="https://docs.docker.com/compose/compose-file/">Compose file version 3 reference</a></p>
<p><a href="https://medium.com/@basi/docker-compose-from-development-to-production-88000124a57c">Docker Compose from development to production</a></p>
<p><a href="https://docs.docker.com/compose/networking/">Networking in Compose</a></p>
<p><a href="https://docs.docker.com/compose/startup-order/">Control startup order in Compose</a></p>
<p><a href="https://www.oreilly.com/ideas/3-docker-compose-features-for-improving-team-development-workflow?mkt_tok=eyJpIjoiTnpNMU1tTXdaalUzTnpFMSIsInQiOiJFODk5T1Y0b0NvWFNBcE1xeFo1ZElCaUJYMzVab2hNY3Y5aWxxRTRiV201cHJmK090OWM4K2RSaHRnYlhNUzNHTk01aDF0bU83c2x6bUpEKzVFXC9LVHp3YWVLNXdoTDI0cThSWXZ6STVoaStVVU1GRzYwUmxwYXR4ZDlTK0dlT0tjd2VqTWtjUnZBRm5ZXC9qNE9oOFNkZz09In0=">3 Docker Compose features for improving team development workflow</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Volume 存储</title>
    <url>//post/docker-volume-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h1 id="Data-Volume-练习-MySQL"><a href="#Data-Volume-练习-MySQL" class="headerlink" title="Data Volume 练习 MySQL"></a>Data Volume 练习 MySQL</h1><p>使用 <code>MySQL</code> 官方镜像，<code>tag</code>版本<code>5.7</code></p>
<p><code>Dockerfile</code> 可以在这里查看 <a href="https://github.com/docker-library/mysql/tree/master/5.7">https://github.com/docker-library/mysql/tree/master/5.7</a></p>
<h2 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull mysql:5.7
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
mysql        <span class="token number">5.7</span>       2c9028880e58   <span class="token number">5</span> weeks ago    447MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>关于 <code>MySQL</code> 的镜像使用，可以参考 <code>dockerhub</code> <a href="https://hub.docker.com/_/mysql?tab=description&page=1&ordering=last_updated">https://hub.docker.com/_&#x2F;mysql?tab&#x3D;description&amp;page&#x3D;1&amp;ordering&#x3D;last_updated</a></p>
<p>关于 <code>Dockerfile</code> <code>Volume</code> 的定义，可以参考 <a href="https://github.com/docker-library/mysql/tree/master/5.7">https://github.com/docker-library/mysql/tree/master/5.7</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container run <span class="token parameter variable">--name</span> some-mysql <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>my-secret-pw <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> mysql-data:/var/lib/mysql mysql:5.7
02206eb369be08f660bf86b9d5be480e24bb6684c8a938627ebfbcfc0fd9e48e
$ <span class="token function">docker</span> volume <span class="token function">ls</span>
DRIVER    VOLUME NAME
<span class="token builtin class-name">local</span>     mysql-data
$ <span class="token function">docker</span> volume inspect mysql-data
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-06-21T23:55:23+02:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/mysql-data/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mysql-data"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数据库写入数据"><a href="#数据库写入数据" class="headerlink" title="数据库写入数据"></a>数据库写入数据</h2><p>进入 <code>MySQL</code> 的 <code>shell</code> ，密码是 <code>my-secret-pw</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 022 <span class="token function">sh</span>
<span class="token comment"># mysql -u root -p</span>
Enter password:
Welcome to the MySQL monitor.  Commands end with <span class="token punctuation">;</span> or <span class="token punctuation">\</span>g.
Your MySQL connection <span class="token function">id</span> is <span class="token number">2</span>
Server version: <span class="token number">5.7</span>.34 MySQL Community Server <span class="token punctuation">(</span>GPL<span class="token punctuation">)</span>

Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2000</span>, <span class="token number">2021</span>, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type <span class="token string">'help;'</span> or <span class="token string">'\h'</span> <span class="token keyword">for</span> help. Type <span class="token string">'\c'</span> to <span class="token function">clear</span> the current input statement.

mysql<span class="token operator">></span> show databases<span class="token punctuation">;</span>
+--------------------+
<span class="token operator">|</span> Database           <span class="token operator">|</span>
+--------------------+
<span class="token operator">|</span> information_schema <span class="token operator">|</span>
<span class="token operator">|</span> mysql              <span class="token operator">|</span>
<span class="token operator">|</span> performance_schema <span class="token operator">|</span>
<span class="token operator">|</span> sys                <span class="token operator">|</span>
+--------------------+
<span class="token number">4</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> create database demo<span class="token punctuation">;</span>
Query OK, <span class="token number">1</span> row affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> show databases<span class="token punctuation">;</span>
+--------------------+
<span class="token operator">|</span> Database           <span class="token operator">|</span>
+--------------------+
<span class="token operator">|</span> information_schema <span class="token operator">|</span>
<span class="token operator">|</span> demo               <span class="token operator">|</span>
<span class="token operator">|</span> mysql              <span class="token operator">|</span>
<span class="token operator">|</span> performance_schema <span class="token operator">|</span>
<span class="token operator">|</span> sys                <span class="token operator">|</span>
+--------------------+
<span class="token number">5</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token builtin class-name">exit</span>
Bye
<span class="token comment"># exit</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建了一个叫 <code>demo</code> 的数据库</p>
<p>查看 <code>data volume</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> volume inspect mysql-data
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-06-22T00:01:34+02:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/mysql-data/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mysql-data"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
$ <span class="token function">ls</span>  /var/lib/docker/volumes/mysql-data/_data
auto.cnf    client-cert.pem  ib_buffer_pool  ibdata1  performance_schema  server-cert.pem
ca-key.pem  client-key.pem   ib_logfile0     ibtmp1   private_key.pem     server-key.pem
ca.pem      demo             ib_logfile1     mysql    public_key.pem      sys
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="Bind-Mount"><a href="#Bind-Mount" class="headerlink" title="Bind Mount"></a>Bind Mount</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 data valume</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> cron-data:/app my-cron

<span class="token comment"># 使用本地当前目录映射到 容器的/app</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/app my-cron
<span class="token function">docker</span> volume <span class="token function">ls</span> <span class="token comment"># 不会有 volume 被创建</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Bind-Mount-练习之-Docker-开发环境"><a href="#Bind-Mount-练习之-Docker-开发环境" class="headerlink" title="Bind Mount 练习之 Docker 开发环境"></a>Bind Mount 练习之 Docker 开发环境</h2><p>假设当前本地机器 没有 <code>c</code> 的编译环境。 使用有 <code>gcc</code> 的容器，调试编译 <code>c</code> 文件</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动容器</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/root gzz:9.4
<span class="token builtin class-name">cd</span> /root
gcc <span class="token parameter variable">-o</span> hello hello.c
<span class="token function">ls</span>
./hello <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本地中也可以看到编译出的文件</p>
<h2 id="多个机器之间的容器共享数据"><a href="#多个机器之间的容器共享数据" class="headerlink" title="多个机器之间的容器共享数据"></a>多个机器之间的容器共享数据</h2><p>docker volume s3 plugin</p>
<p><img src="https://dockertips.readthedocs.io/en/latest/_images/volumes-shared-storage.png" alt="multi-host-volume"></p>
<p>官方参考链接 <a href="https://docs.docker.com/storage/volumes/#share-data-among-machines">https://docs.docker.com/storage/volumes/#share-data-among-machines</a></p>
<p><code>Docker</code> 的 <code>volume</code> 支持多种 <code>driver</code> 。默认创建的 <code>volume driver</code> 都是 <code>local</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> volume inspect vscode
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-06-23T21:33:57Z"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/vscode/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"vscode"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这一节我们看看一个叫 <code>sshfs</code> 的 <code>driver</code> ，如何让 <code>docker</code> 使用不在同一台机器上的文件系统做 <code>volume</code></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备#"></a>环境准备<a href="https://dockertips.readthedocs.io/en/latest/docker-volume/multi-host-share.html#id2" title="Permalink to this headline">#</a></h2><p>准备 <code>三</code> 台 <code>Linux</code> 机器，之间可以通过 <code>SSH</code> 相互通信。</p>
<table><colgroup><col> <col> <col> <col></colgroup><tbody><tr><td><p>hostname</p></td><td><p>ip</p></td><td><p>ssh username</p></td><td><p>ssh password</p></td></tr><tr><td><p>docker-host1</p></td><td><p>192.168.200.10</p></td><td><p>vagrant</p></td><td><p>vagrant</p></td></tr><tr><td><p>docker-host2</p></td><td><p>192.168.200.11</p></td><td><p>vagrant</p></td><td><p>vagrant</p></td></tr><tr><td><p>docker-host3</p></td><td><p>192.168.200.12</p></td><td><p>vagrant</p></td><td><p>vagrant</p></td></tr></tbody></table>

<h2 id="安装plugin"><a href="#安装plugin" class="headerlink" title="安装plugin"></a>安装plugin</h2><p>在其中两台机器上安装一个 <code>plugin</code> <code>vieux/sshfs</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> plugin <span class="token function">install</span> --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host2 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> plugin <span class="token function">install</span> --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="创建volume"><a href="#创建volume" class="headerlink" title="创建volume"></a>创建volume</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume create <span class="token parameter variable">--driver</span> vieux/sshfs <span class="token punctuation">\</span>
                          <span class="token parameter variable">-o</span> <span class="token assign-left variable">sshcmd</span><span class="token operator">=</span>vagrant@192.168.200.12:/home/vagrant <span class="token punctuation">\</span>
                          <span class="token parameter variable">-o</span> <span class="token assign-left variable">password</span><span class="token operator">=</span>vagrant <span class="token punctuation">\</span>
                          sshvolume
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume <span class="token function">ls</span>
DRIVER               VOLUME NAME
vieux/sshfs:latest   sshvolume
<span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume inspect sshvolume
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"0001-01-01T00:00:00Z"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"vieux/sshfs:latest"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/mnt/volumes/f59e848643f73d73a21b881486d55b33"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"sshvolume"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"password"</span><span class="token builtin class-name">:</span> <span class="token string">"vagrant"</span>,
            <span class="token string">"sshcmd"</span><span class="token builtin class-name">:</span> <span class="token string">"vagrant@192.168.200.12:/home/vagrant"</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="创建容器挂载Volume"><a href="#创建容器挂载Volume" class="headerlink" title="创建容器挂载Volume"></a>创建容器挂载Volume</h2><p>创建容器，挂载 <code>sshvolume</code> 到 <code>/app</code> 目录，然后进入容器的 <code>shell</code> ，在<code>/app</code>目录创建一个<code>test.txt</code>文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> sshvolume:/app busybox <span class="token function">sh</span>
Unable to <span class="token function">find</span> image <span class="token string">'busybox:latest'</span> locally
latest: Pulling from library/busybox
b71f96345d44: Pull complete
Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d
Status: Downloaded newer image <span class="token keyword">for</span> busybox:latest
/ <span class="token comment">#</span>
/ <span class="token comment"># ls</span>
app   bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ <span class="token comment"># cd /app</span>
/app <span class="token comment"># ls</span>
/app <span class="token comment"># echo "this is ssh volume"> test.txt</span>
/app <span class="token comment"># ls</span>
test.txt
/app <span class="token comment"># more test.txt</span>
this is <span class="token function">ssh</span> volume
/app <span class="token comment">#</span>
/app <span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个文件我们可以在 <code>docker-host3</code> 上看到</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>vagrant@docker-host3 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">pwd</span>
/home/vagrant
<span class="token punctuation">[</span>vagrant@docker-host3 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span>
test.txt
<span class="token punctuation">[</span>vagrant@docker-host3 ~<span class="token punctuation">]</span>$ <span class="token function">more</span> test.txt
this is <span class="token function">ssh</span> volume<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="Docker-使用-NFS"><a href="#Docker-使用-NFS" class="headerlink" title="Docker 使用 NFS"></a>Docker 使用 NFS</h1><p>简单来说， <code>Docker</code> 使用<code>NFS</code>存储有两种形式：</p>
<ul>
<li><p>方法一：在容器内部安装 <code>nfs-utils</code> ，就如同常规到 <code>NFS</code> 客户端一样，在容器内部直接通过<code>rpcbind</code>方式挂载NFS共享输出，这种方式需要每个容器独立运行<code>rpcbind</code>服务，并且要使用 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_systemd.html#docker-systemd">Docker systemd进程管理器</a> ，复杂且消耗较多资源。不过，优点是完全在容器内部控制，符合传统<code>SA</code>运维方式。</p>
</li>
<li><p>方法二：<code>Host</code>主机上创建<code>NFS</code>类型的<code>Docker Volume</code>，然后将<code>docker volume</code>映射到容器内部，这样容器就可以直接使用<code>Docker</code>共享卷，这种方式最为简洁优雅。</p>
</li>
<li><p>方法三：使用<code>Docker volume plugin</code>，例如 <a href="https://github.com/ContainX/docker-volume-netshare">ContainX&#x2F;docker-volume-netshare</a> 可以直接将<code>NFS共享卷</code>作为<code>容器卷</code>挂载(就不需要在<code>host</code>主机上去执行挂载<code>NFS</code>命令了)</p>
</li>
</ul>
<h2 id="方法一：在容器内部使用NFS"><a href="#方法一：在容器内部使用NFS" class="headerlink" title="方法一：在容器内部使用NFS"></a>方法一：在容器内部使用NFS</h2><p>要知道，容器并不是完整的虚拟机，天然就是瘦客户端并且有意削减了部分操作系统功能。</p>
<p>为了能够在容器中挂载<code>NFS</code>，我们需要同时运行多个服务，这样我们就需要有一个容器内部运行的 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/index.html#docker-init">Docker init进程管理器</a> 以便启动多个服务来支持NFS挂载。例如，我们可以选择 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_systemd.html#docker-systemd">Docker systemd进程管理器</a> 。</p>
<p>这里的案例假设我们已经构建了一个使用 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_systemd.html#docker-systemd">Docker systemd进程管理器</a> 的容器 <code>centos8-ssh</code> ，然后我们来实践NFS挂载部署。</p>
<p>备注</p>
<p>如果使用<code> NFSv4</code> ，就不需要安装 <code>nfs-utils</code> ，也不需要设置 <code>systemd</code></p>
<h3 id="NFS服务器"><a href="#NFS服务器" class="headerlink" title="NFS服务器"></a>NFS服务器</h3><p>我的测试 <code>NFS</code> 服务部署在运行 <code>Docker</code> 服务的物理主机上，该物理服务器是 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/linux/ubuntu_linux/index.html#ubuntu-linux">Ubuntu Linux</a> ，已完成 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/linux/ubuntu_linux/storage/ubuntu_nfs.html#ubuntu-nfs">Ubuntu NFS部署</a> ，共享目录设置如下:</p>
<ul>
<li><p>&#x2F;etc&#x2F;exportfs</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;data   *(rw,sync,no_root_squash,no_subtree_check)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>详细部署方法和解释见 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/linux/ubuntu_linux/storage/ubuntu_nfs.html#ubuntu-nfs">Ubuntu NFS部署</a></p>
<h3 id="NFS客户端"><a href="#NFS客户端" class="headerlink" title="NFS客户端"></a>NFS客户端</h3><ul>
<li><p>在容器内部安装 <code>nfs-utils</code></p>
</li>
<li><p>在容器内部配置 <code>/etc/fstab</code> 如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">172.17</span>.0.1:/data  /data  nfs  rw,soft,intr,vers<span class="token operator">=</span><span class="token number">3</span>,proto<span class="token operator">=</span>tcp,rsize<span class="token operator">=</span><span class="token number">32768</span>,wsize<span class="token operator">=</span><span class="token number">32768</span> <span class="token number">0</span> <span class="token number">0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>在容器内部执行挂载:</p>
</li>
</ul>
<p>报错:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount.nfs: Operation not permitted
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个问题和 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_systemd.html#docker-systemd">Docker systemd进程管理器</a> 相同，需要赋予运行容器 <code>CAP_SYS_ADMIN</code> 能力，所以需要重新创建运行容器，并传递参数 <code>--cap-add sys_admin</code></p>
<h3 id="mount-nfs-access-denied"><a href="#mount-nfs-access-denied" class="headerlink" title="mount.nfs: access denied"></a>mount.nfs: access denied</h3><ul>
<li><p>重新增加了 <code>CAP_SYS_ADMIN</code> 能力创建容器后，再次挂载NFS卷，提示错误:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount.nfs: access denied by server <span class="token keyword">while</span> mounting <span class="token number">172.17</span>.0.1:/data
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>但是，服务器端命名已经设置了 <code>/data            &lt;world&gt;</code> 输出给所有客户端，为何会拒绝？</p>
<p>使用 <code>-v</code> 参数挂载:</p>
<p>显示输出:</p>
<pre class="line-numbers language-none"><code class="language-none">mount.nfs: timeout set for Fri Jan 22 08:16:08 2021
mount.nfs: trying text-based options &#39;rw,soft,intr,vers&#x3D;3,proto&#x3D;tcp,rsize&#x3D;32768,wsize&#x3D;32768,addr&#x3D;172.17.0.1&#39;
mount.nfs: prog 100003, trying vers&#x3D;3, prot&#x3D;6
mount.nfs: trying 172.17.0.1 prog 100003 vers 3 prot TCP port 2049
mount.nfs: prog 100005, trying vers&#x3D;3, prot&#x3D;6
mount.nfs: trying 172.17.0.1 prog 100005 vers 3 prot TCP port 43999
mount.nfs: mount(2): Permission denied
mount.nfs: access denied by server while mounting 172.17.0.1:&#x2F;data
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>检查服务器的<code>rpc</code>输出:</li>
</ul>
<p>显示输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">program vers proto   port  <span class="token function">service</span>
 <span class="token number">100000</span>    <span class="token number">4</span>   tcp    <span class="token number">111</span>  portmapper
 <span class="token number">100000</span>    <span class="token number">3</span>   tcp    <span class="token number">111</span>  portmapper
 <span class="token number">100000</span>    <span class="token number">2</span>   tcp    <span class="token number">111</span>  portmapper
 <span class="token number">100000</span>    <span class="token number">4</span>   udp    <span class="token number">111</span>  portmapper
 <span class="token number">100000</span>    <span class="token number">3</span>   udp    <span class="token number">111</span>  portmapper
 <span class="token number">100000</span>    <span class="token number">2</span>   udp    <span class="token number">111</span>  portmapper
 <span class="token number">100005</span>    <span class="token number">1</span>   udp  <span class="token number">43059</span>  mountd
 <span class="token number">100005</span>    <span class="token number">1</span>   tcp  <span class="token number">46359</span>  mountd
 <span class="token number">100005</span>    <span class="token number">2</span>   udp  <span class="token number">37724</span>  mountd
 <span class="token number">100005</span>    <span class="token number">2</span>   tcp  <span class="token number">39809</span>  mountd
 <span class="token number">100005</span>    <span class="token number">3</span>   udp  <span class="token number">41232</span>  mountd
 <span class="token number">100005</span>    <span class="token number">3</span>   tcp  <span class="token number">43999</span>  mountd
 <span class="token number">100003</span>    <span class="token number">3</span>   tcp   <span class="token number">2049</span>  nfs
 <span class="token number">100003</span>    <span class="token number">4</span>   tcp   <span class="token number">2049</span>  nfs
 <span class="token number">100227</span>    <span class="token number">3</span>   tcp   <span class="token number">2049</span>  nfs_acl
 <span class="token number">100003</span>    <span class="token number">3</span>   udp   <span class="token number">2049</span>  nfs
 <span class="token number">100227</span>    <span class="token number">3</span>   udp   <span class="token number">2049</span>  nfs_acl
 <span class="token number">100021</span>    <span class="token number">1</span>   udp  <span class="token number">34464</span>  nlockmgr
 <span class="token number">100021</span>    <span class="token number">3</span>   udp  <span class="token number">34464</span>  nlockmgr
 <span class="token number">100021</span>    <span class="token number">4</span>   udp  <span class="token number">34464</span>  nlockmgr
 <span class="token number">100021</span>    <span class="token number">1</span>   tcp  <span class="token number">35037</span>  nlockmgr
 <span class="token number">100021</span>    <span class="token number">3</span>   tcp  <span class="token number">35037</span>  nlockmgr
 <span class="token number">100021</span>    <span class="token number">4</span>   tcp  <span class="token number">35037</span>  nlockmgr
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在容器内部检查服务器端输出的<code>NFS</code>共享:</li>
</ul>
<p>显示输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Export list <span class="token keyword">for</span> <span class="token number">172.17</span>.0.1:
/data *
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p>通过<code>tcpdump</code>抓包:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token parameter variable">-s0</span> <span class="token parameter variable">-i</span> eth0 <span class="token function">host</span> <span class="token number">172.17</span>.0.1 <span class="token parameter variable">-w</span> /tmp/client.pcap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>然后通过 <code>wireshark</code> 分析:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tshark <span class="token parameter variable">-tad</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-r</span> /tmp/client.pcap <span class="token parameter variable">-Y</span> <span class="token string">'frame.number == 500'</span> <span class="token parameter variable">-O</span> rpc <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/^Re/,$ !d'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>输出显示:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Running as user <span class="token string">"root"</span> and group <span class="token string">"root"</span><span class="token builtin class-name">.</span> This could be dangerous.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>tcpdump的分析 <code>nfs.status!=0</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tshark <span class="token parameter variable">-tad</span> <span class="token parameter variable">-nr</span> /tmp/client.pcap <span class="token parameter variable">-Y</span> nfs.status<span class="token operator">!=</span><span class="token number">0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同样显示输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Running as user <span class="token string">"root"</span> and group <span class="token string">"root"</span><span class="token builtin class-name">.</span> This could be dangerous.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在<code>NFS</code>服务器端检查输出:</li>
</ul>
<p>显示如下:</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;data        *(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid&#x3D;65534,anongid&#x3D;65534,sec&#x3D;sys,rw,secure,no_root_squash,no_all_squash)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>警告</p>
<p>暂时还没有解决容器内部直接<code>mount NFS</code>问题，待进一步排查</p>
<h2 id="方法二：Docker-NFS-volume-推荐"><a href="#方法二：Docker-NFS-volume-推荐" class="headerlink" title="方法二：Docker NFS volume(推荐)"></a>方法二：Docker NFS volume(推荐)</h2><p>采用<code>Docker NFS volume</code>的方式更为简单明了，实际上也就是先在<code>host</code>主机上挂<code>载NFS</code>卷，然后通过<code>卷映射方式</code>映射到容器内部。这种方式不需要给容器特殊的权限，也不需要运行systemd这样沉重的进程管理器，特别适合轻量级运行容器。当然，你也可以构建 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_tini.html#docker-tini">Docker tini进程管理器</a> 来运行一个轻量级的进程管理器，甚至使用 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/docker/init/docker_systemd.html#docker-systemd">Docker systemd进程管理器</a> 来构建复杂的 “富容器” 。</p>
<ul>
<li><p>在Host主机上挂载 <code>NFS</code> 卷，即编辑host主机 <code>/etc/fstab</code> 添加如下配置:</p>
<pre class="line-numbers language-none"><code class="language-none">172.17.0.1:&#x2F;data  &#x2F;container-data  nfs  rw,soft,intr,vers&#x3D;3,proto&#x3D;tcp,rsize&#x3D;32768,wsize&#x3D;32768 0 0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>然后<code>在host</code>主机上挂<code>载NFS</code>卷:</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir &#x2F;container-data
mount &#x2F;container-data
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>挂载以后在<code>host主</code>机上检查 <code>df -h</code> 可以看到NFS已经挂载:</p>
<pre class="line-numbers language-none"><code class="language-none">172.17.0.1:&#x2F;data  117G   12G  101G  11% &#x2F;container-data
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>现在我们启动一个容器并且映射这个挂载的NFS卷:</p>
<pre class="line-numbers language-none"><code class="language-none">docker run -itd -p 1222:22 --hostname centos8-nfs --name centos8-nfs \
  -v &#x2F;container-data:&#x2F;container-data centos:8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>使用 <code>docker ps | grep centos8-nfs</code> 检查可以看到:</p>
<pre class="line-numbers language-none"><code class="language-none">7a9e6663a988        centos:8                     &quot;&#x2F;bin&#x2F;bash&quot;              9 seconds ago       Up 7 seconds        0.0.0.0:1222-&gt;22&#x2F;tcp             centos8-nfs
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>然后我们进入这个 <code>centos8-nfs</code> 容器:</p>
<pre class="line-numbers language-none"><code class="language-none">docker exec -it centos8-nfs &#x2F;bin&#x2F;bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>在容器内部检查磁盘 <code>df -h</code> 可以看到:</p>
<pre class="line-numbers language-none"><code class="language-none">Filesystem        Size  Used Avail Use% Mounted on
...
172.17.0.1:&#x2F;data  117G   12G  101G  11% &#x2F;container-data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="方法三：使用Docker-volume-plugin"><a href="#方法三：使用Docker-volume-plugin" class="headerlink" title="方法三：使用Docker volume plugin"></a>方法三：使用Docker volume plugin</h2><p><a href="https://github.com/ContainX/docker-volume-netshare">ContainX&#x2F;docker-volume-netshare</a> 是一个Docker plugin，可以用来挂载NFS v3&#x2F;4, AWS EFS 或者 CIFS到容器内部。</p>
<p>备注</p>
<p>使用<code>netshare</code>插件部署安装比较麻烦，没有集成到发行版中，并且随着<code>Kubernetes</code>发展，较少采用<code>Docker volume plugin</code>方式。所以我没有具体实践这个方法，仅供参考。后续如果有实践需求，例如需要在简单的<code>Docker</code>环境挂载不同的<code>NFS/CIFS</code>等卷情况，我再实践。</p>
<ul>
<li><p>安装<code>netshare</code>插件:</p>
<pre class="line-numbers language-none"><code class="language-none">go get github.com&#x2F;ContainX&#x2F;docker-volume-netshare
go build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<p>也可以通过二进制安装，提供Ubuntu&#x2F;Debian安装包:</p>
<pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;github.com&#x2F;ContainX&#x2F;docker-volume-netshare&#x2F;releases&#x2F;download&#x2F;v0.36&#x2F;docker-volume-netshare_0.36_amd64.deb
sudo dpkg -i docker-volume-netshare_0.36_amd64.deb
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p>修改 <code>/etc/default/docker-volume-netshare</code> 启动参数</p>
</li>
<li><p>启动服务:</p>
<pre class="line-numbers language-none"><code class="language-none">service docker-volume-netshare start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>运行插件 - 可以添加到<code>systemd</code>或者在后台运行:</p>
<pre class="line-numbers language-none"><code class="language-none">sudo docker-volume-netshare nfs
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>启动容器:</p>
<pre class="line-numbers language-none"><code class="language-none">docker run -i -t --volume-driver&#x3D;nfs -v nfshost&#x2F;path:&#x2F;mount ubuntu &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://whyistheinternetbroken.wordpress.com/2015/05/12/techusing-nfs-with-docker-where-does-it-fit-in/">TECH::Using NFS with Docker – Where does it fit in?</a> - 原作者另外写了两篇有关使用NetApp FlexGroup volumes和加密NFS mount文章，可以进一步参考</p>
</li>
<li><p><a href="https://access.redhat.com/solutions/3773891">Mount failed with mount: mount.nfs: access denied by server while mounting error</a> Red Hat提供了非常好的debug方法，建议参考</p>
</li>
<li><p><a href="https://www.thegeekdiary.com/mount-nfs-access-denied-by-server-while-mounting-how-to-resolve/">“mount.nfs: access denied by server while mounting” – how to resolve</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/39922161/mounting-nfs-shares-inside-docker-container">Mounting nfs shares inside docker container</a> 提供了docker挂载NFS的多种方法概述</p>
</li>
<li><p><a href="https://github.com/ContainX/docker-volume-netshare">ContainX&#x2F;docker-volume-netshare</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Volume</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Dockerfile 完全指南</title>
    <url>//post/docker-dockerfile-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h1 id="基础镜像的选择-FROM"><a href="#基础镜像的选择-FROM" class="headerlink" title="基础镜像的选择 (FROM)"></a>基础镜像的选择 (FROM)</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul>
<li><code>官方镜像</code>优于非官方的镜像，如果没有官方镜像，则尽量选择 <code>Dockerfile</code> <code>开源</code>的</li>
<li>固定版本 <code>tag</code> 而不是每次都使用 <code>latest</code></li>
<li>尽量选择<code>体积小</code>的镜像</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">docker</span> image <span class="token function">ls</span>

REPOSITORY      TAG             IMAGE ID       CREATED          SIZE
bitnami/nginx   <span class="token number">1.18</span>.0          dfe237636dde   <span class="token number">28</span> minutes ago   <span class="token number">89</span>.3MB
nginx           <span class="token number">1.21</span>.0-alpine   a6eb2a334a9f   <span class="token number">2</span> days ago       <span class="token number">22</span>.6MB
nginx           <span class="token number">1.21</span>.0          d1a364dc548d   <span class="token number">2</span> days ago       133MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Build-一个-Nginx-镜像"><a href="#Build-一个-Nginx-镜像" class="headerlink" title="Build 一个 Nginx 镜像"></a>Build 一个 Nginx 镜像</h2><p>假如我们有一个 <code>index.html</code> 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>></span>Hello Docker<span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>准备一个 <code>Dockerfile</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> nginx:1.21.0-alpine</span>

<span class="token instruction"><span class="token keyword">ADD</span> index.html /usr/share/nginx/html/index.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过 <code>Dockerfile</code> 文件创建 <code>Image</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image build <span class="token parameter variable">-t</span> mysqnginx <span class="token builtin class-name">.</span>
<span class="token comment"># 运行</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 mysqnginx
<span class="token comment"># 查看</span>
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>基于 <code>Alpine Linux</code> 发行版构建的 <code>Docker</code> 镜像。<code>Alpine Linux</code> 是一个轻量级的 <code>Linux</code> 发行版，以其小巧、高效和安全而闻名。<br>使用 <code>Alpine</code> 版本的 <code>Docker</code> 镜像，你可以在 <code>Dockerfile</code> 中指定基础镜像为 <code>Alpine</code>，并在其中安装所需的软件包和依赖项</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># 基于 Alpine Linux 的 Dockerfile 示例</span>
<span class="token instruction"><span class="token keyword">FROM</span> alpine:latest</span>
<span class="token comment"># 安装所需的软件包</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk add --no-cache &lt;package1> &lt;package2> ...</span>
<span class="token comment"># 设置容器的工作目录</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token comment"># 复制应用程序文件到容器中</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>
<span class="token comment"># 定义容器启动时执行的命令</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"&lt;command>"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>使用 <code>Alpine</code> 版本的 <code>Dockerfile</code> 示例：</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># FROM nginx:alpine 指定了使用 nginx 官方镜像的 Alpine 版本作为基础镜像</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx:alpine</span>

<span class="token comment"># 通过 COPY 命令将自定义的 nginx.conf 文件复制到容器中的 /etc/nginx/nginx.conf 路径下</span>
<span class="token instruction"><span class="token keyword">COPY</span> nginx.conf /etc/nginx/nginx.conf</span>
<span class="token comment"># 将自定义的静态 HTML 文件复制到 /usr/share/nginx/html 路径下</span>
<span class="token instruction"><span class="token keyword">COPY</span> html /usr/share/nginx/html</span>

<span class="token comment"># EXPOSE 指令声明容器将会监听的端口，这里是 80 端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 80</span>

<span class="token comment"># 使用 CMD 定义容器启动时执行的命令</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"nginx"</span>, <span class="token string">"-g"</span>, <span class="token string">"daemon off;"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在构建完成后，你可以运行以下命令来构建镜像并启动容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-nginx <span class="token builtin class-name">.</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="延申阅读"><a href="#延申阅读" class="headerlink" title="延申阅读"></a>延申阅读</h2><ul>
<li><p><a href="https://pythonspeed.com/articles/base-image-python-docker-images/">https://pythonspeed.com/articles/base-image-python-docker-images/</a></p>
</li>
<li><p><a href="https://pythonspeed.com/articles/alpine-docker-python/">https://pythonspeed.com/articles/alpine-docker-python/</a></p>
</li>
</ul>
<h1 id="通过-RUN-执行指令"><a href="#通过-RUN-执行指令" class="headerlink" title="通过 RUN 执行指令"></a>通过 RUN 执行指令</h1><p><code>RUN</code> 主要用于在 <code>Image</code> 里<code>执行指令</code>，比如<code>安装软件</code>，<code>下载文件</code>等。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update
<span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">wget</span>
<span class="token function">wget</span> https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz
<span class="token function">tar</span> zxf ipinfo_2.0.1_linux_amd64.tar.gz
<span class="token function">mv</span> ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> ipinfo_2.0.1_linux_amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get install -y wget</span>
<span class="token instruction"><span class="token keyword">RUN</span> wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz</span>
<span class="token instruction"><span class="token keyword">RUN</span> tar zxf ipinfo_2.0.1_linux_amd64.tar.gz</span>
<span class="token instruction"><span class="token keyword">RUN</span> mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo</span>
<span class="token instruction"><span class="token keyword">RUN</span> rm -rf ipinfo_2.0.1_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>镜像的<code>大小</code>和<code>分层</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">ls</span>

<span class="token comment"># 大小</span>
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
ipinfo       latest    97bb429363fb   <span class="token number">4</span> minutes ago   138MB
ubuntu       <span class="token number">21.04</span>     478aa0080b60   <span class="token number">4</span> days ago      <span class="token number">74</span>.1MB

<span class="token function">docker</span> image <span class="token function">history</span> 97b

<span class="token comment"># 分层</span>
IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT
97bb429363fb   <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> ipinfo_2.0.1_linux_amd…   0B        buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">mv</span> ipinfo_2.0.1_linux_amd64 /…   <span class="token number">9</span>.36MB    buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">tar</span> zxf ipinfo_2.0.1_linux_am…   <span class="token number">9</span>.36MB    buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">wget</span> https://github.com/ipinf…   <span class="token number">4</span>.85MB    buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">wget</span> <span class="token comment"># bui…   7.58MB    buildkit.dockerfile.v0</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> minutes ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">apt-get</span> update <span class="token comment"># buildkit        33MB      buildkit.dockerfile.v0</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago      /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago      /bin/sh <span class="token parameter variable">-c</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /run/systemd <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'do…   7B
&lt;missing>      4 days ago      /bin/sh -c [ -z "$(apt-get indextargets)" ]     0B
&lt;missing>      4 days ago      /bin/sh -c set -xe   &amp;&amp; echo '</span><span class="token comment">#!/bin/sh' > /…   811B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago      /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop) ADD file:d6b6ba642344138dc…   74.1MB</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>每一行</code>的 <code>RUN</code> 命令都会产生一层<code>image layer</code>, 导致<code>镜像的臃肿</code>。</p>
<h2 id="改进版-Dockerfile"><a href="#改进版-Dockerfile" class="headerlink" title="改进版 Dockerfile"></a>改进版 Dockerfile</h2><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    apt-get install -y wget &amp;&amp; <span class="token operator">\</span>
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; <span class="token operator">\</span>
    rm -rf ipinfo_2.0.1_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">ls</span>
<span class="token comment"># 大小</span>
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
ipinfo-new   latest    fe551bc26b92   <span class="token number">5</span> seconds ago    124MB
ipinfo       latest    97bb429363fb   <span class="token number">16</span> minutes ago   138MB
ubuntu       <span class="token number">21.04</span>     478aa0080b60   <span class="token number">4</span> days ago       <span class="token number">74</span>.1MB

<span class="token function">docker</span> image <span class="token function">history</span> fe5

<span class="token comment"># 分层</span>
IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT
fe551bc26b92   <span class="token number">16</span> seconds ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span>     apt-get…   <span class="token number">49</span>.9MB    buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago       /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago       /bin/sh <span class="token parameter variable">-c</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /run/systemd <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'do…   7B
&lt;missing>      4 days ago       /bin/sh -c [ -z "$(apt-get indextargets)" ]     0B
&lt;missing>      4 days ago       /bin/sh -c set -xe   &amp;&amp; echo '</span><span class="token comment">#!/bin/sh' > /…   811B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">4</span> days ago       /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop) ADD file:d6b6ba642344138dc…   74.1MB</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="文件复制和目录操作-ADD-COPY-WORKDIR"><a href="#文件复制和目录操作-ADD-COPY-WORKDIR" class="headerlink" title="文件复制和目录操作 (ADD,COPY,WORKDIR)"></a>文件复制和目录操作 (ADD,COPY,WORKDIR)</h1><p>往镜像里复制文件有两种方式，<code>COPY</code> 和 <code>ADD</code> , 我们来看一下两者的不同。</p>
<h2 id="复制普通文件"><a href="#复制普通文件" class="headerlink" title="复制普通文件"></a>复制普通文件</h2><p><code>COPY</code> 和 <code>ADD</code> 都可以把 <code>local</code> 的一个文件<code>复制</code>到<code>镜像</code>里，如果目标<code>目录</code>不存在，则会<code>自动创建</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-alpine3.13</span>
<span class="token instruction"><span class="token keyword">COPY</span> hello.py /app/hello.py</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>比如把本地的 <code>hello.py</code> 复制到 <code>/app</code> 目录下。 <code>/app</code> 这个 <code>folder</code> 不存在，则会<code>自动创建</code></p>
<h2 id="复制压缩文件"><a href="#复制压缩文件" class="headerlink" title="复制压缩文件"></a>复制压缩文件</h2><p><code>ADD</code> 比 <code>COPY</code> 高级一点的地方就是，如果复制的是一个<code>gzip</code>等<code>压缩文件</code>时，<code>ADD</code>会帮助我们<code>自动</code>去<code>解压缩文件</code>。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-alpine3.13</span>
<span class="token instruction"><span class="token keyword">ADD</span> hello.tar.gz /app/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="切换目录-WORKDIR"><a href="#切换目录-WORKDIR" class="headerlink" title="切换目录 WORKDIR"></a>切换目录 WORKDIR</h2><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-alpine3.13</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> hello.py hello.py</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，<code>所有的文件复制</code>均使用 <code>COPY</code> 指令，仅在需要<code>自动解压缩</code>的场合使用 <code>ADD</code>。</p>
<h1 id="构建参数和环境变量-ARG-vs-ENV"><a href="#构建参数和环境变量-ARG-vs-ENV" class="headerlink" title="构建参数和环境变量 (ARG vs ENV)"></a>构建参数和环境变量 (ARG vs ENV)</h1><p><code>ARG</code> 和 <code>ENV</code> 是经常容易被<code>混淆</code>的两个 <code>Dockerfile</code> 的语法，都可以用来设置一个<code>“变量”</code>。 但实际上两者有很多的不同。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    apt-get install -y wget &amp;&amp; <span class="token operator">\</span>
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; <span class="token operator">\</span>
    rm -rf ipinfo_2.0.1_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENV</span> VERSION=2.0.1</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    apt-get install -y wget &amp;&amp; <span class="token operator">\</span>
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-<span class="token variable">$&#123;VERSION&#125;</span>/ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    tar zxf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    mv ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64 /usr/bin/ipinfo &amp;&amp; <span class="token operator">\</span>
    rm -rf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ARG</span> VERSION=2.0.1</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    apt-get install -y wget &amp;&amp; <span class="token operator">\</span>
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-<span class="token variable">$&#123;VERSION&#125;</span>/ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    tar zxf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    mv ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64 /usr/bin/ipinfo &amp;&amp; <span class="token operator">\</span>
    rm -rf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="https://dockertips.readthedocs.io/en/latest/_images/docker_environment_build_args.png" alt="docker-image"></p>
<p><code>ENV</code> 设置的变量可以在 <code>Image</code> 中保持，并在<code>容器中</code>的<code>环境变量</code>里<br><code>ARG</code> 可以在镜像 <code>build</code> 的时候动态修改 <code>value</code>, 通过 <code>--build-arg</code></p>
<p><code>ARG</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 构建</span>
<span class="token function">docker</span> image build <span class="token parameter variable">-f</span> .<span class="token punctuation">\</span>Dockerfile-arg <span class="token parameter variable">-t</span> ipinfo-arg-2.0.0 --build-arg <span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token number">2.0</span>.0 <span class="token builtin class-name">.</span>
<span class="token function">docker</span> image <span class="token function">ls</span>
<span class="token comment"># 运行</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> ipinfo-arg-2.0.0
<span class="token comment"># 查看版本</span>
root@b64285579756:/<span class="token comment"># ipinfo version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>ENV</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 构建</span>
<span class="token function">docker</span> image build <span class="token parameter variable">-f</span> .<span class="token punctuation">\</span>Dockerfile-env <span class="token parameter variable">-t</span> ipinfo-env <span class="token builtin class-name">.</span>
<span class="token function">docker</span> image <span class="token function">ls</span>
<span class="token comment"># 运行</span>
<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> ipinfo-env
<span class="token comment"># 查看版本</span>
root@b64285579756:/<span class="token comment"># ipinfo version</span>
<span class="token comment"># 查看环境变量</span>
root@b64285579756:/<span class="token comment"># env</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="容器启动命令-CMD"><a href="#容器启动命令-CMD" class="headerlink" title="容器启动命令 CMD"></a>容器启动命令 CMD</h1><p><code>CMD</code> 可以用来设置容器启动时默认会执行的命令。</p>
<ul>
<li><p>容器启动时默认执行的命令</p>
</li>
<li><p>如果 <code>docker container run</code>启动容器时指定了<code>其它命令</code>，如<code>docker container run -it ipinfo ipinfo</code>，则 <code>CMD</code> 命令会被<code>忽略</code></p>
</li>
<li><p>如果定义了多个<code>CMD</code>，只有最后一个会被执行。</p>
</li>
</ul>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENV</span> VERSION=2.0.1</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\</span>
    apt-get install -y wget &amp;&amp; <span class="token operator">\</span>
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-<span class="token variable">$&#123;VERSION&#125;</span>/ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    tar zxf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz &amp;&amp; <span class="token operator">\</span>
    mv ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64 /usr/bin/ipinfo &amp;&amp; <span class="token operator">\</span>
    rm -rf ipinfo_<span class="token variable">$&#123;VERSION&#125;</span>_linux_amd64.tar.gz</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">docker</span> image build <span class="token parameter variable">-t</span> ipinfo <span class="token builtin class-name">.</span>

<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> ipinfo


root@8cea7e5e8da8:/<span class="token comment">#</span>
root@8cea7e5e8da8:/<span class="token comment">#</span>
root@8cea7e5e8da8:/<span class="token comment">#</span>
root@8cea7e5e8da8:/<span class="token comment"># pwd</span>
/
root@8cea7e5e8da8:/<span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认进入到 <code>shell</code> 是因为在 <code>ubuntu</code> 的基础镜像里有定义 <code>CMD</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">docker</span> image <span class="token function">history</span> ipinfo


IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
db75bff5e3ad   <span class="token number">24</span> hours ago   RUN /bin/sh <span class="token parameter variable">-c</span> <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span>     apt-get…   50MB      buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">24</span> hours ago   ENV <span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token number">2.0</span>.1                               0B        buildkit.dockerfile.v0
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">7</span> days ago     /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">7</span> days ago     /bin/sh <span class="token parameter variable">-c</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /run/systemd <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'do…   7B
&lt;missing>      7 days ago     /bin/sh -c [ -z "$(apt-get indextargets)" ]     0B
&lt;missing>      7 days ago     /bin/sh -c set -xe   &amp;&amp; echo '</span><span class="token comment">#!/bin/sh' > /…   811B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">7</span> days ago     /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop) ADD file:d6b6ba642344138dc…   74.1MB</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="容器启动命令-ENTRYPOINT"><a href="#容器启动命令-ENTRYPOINT" class="headerlink" title="容器启动命令 ENTRYPOINT"></a>容器启动命令 ENTRYPOINT</h1><p><code>ENTRYPOINT</code> 也可以设置容器<code>启动时要执行</code>的命令，但是和<code>CMD</code>是有区别的。</p>
<ul>
<li><p><code>CMD</code> 设置的命令，可以在 <code>docker container run</code> 时<code>传入其它命令</code>，覆盖掉 <code>CMD</code> 的命令，但是 <code>ENTRYPOINT</code> 所<code>设置的命令</code>是<code>一定会被执行</code>的。</p>
</li>
<li><p><code>ENTRYPOINT</code> 和 <code>CMD</code> 可以<code>联合使用</code>，<code>ENTRYPOINT</code> 设置<code>执行的命令</code>，<code>CMD</code>传递<code>参数</code></p>
</li>
</ul>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"echo"</span>, <span class="token string">"hello docker"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>把上面的 <code>Dockerfile</code> <code>build</code> 成一个叫 <code>demo-cmd</code> 的镜象</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">ls</span>

REPOSITORY        TAG       IMAGE ID       CREATED      SIZE
demo-cmd          latest    5bb63bb9b365   <span class="token number">8</span> days ago   <span class="token number">74</span>.1MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"echo"</span>, <span class="token string">"hello docker"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>build</code> 成一个叫 <code>demo-entrypoint</code> 的镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image <span class="token function">ls</span>

REPOSITORY        TAG       IMAGE ID       CREATED      SIZE
demo-entrypoint   latest    b1693a62d67a   <span class="token number">8</span> days ago   <span class="token number">74</span>.1MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>CMD</code> 的镜像，如果执行<code>创建容器</code>，不指定<code>运行时的命令</code>，则会<code>默认执行</code> <code>CMD</code> 所定义的命令，打印出<code>hello docker</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> demo-cmd
hello <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但是如果我们 <code>docker container run</code> 的时候指定命令，则<code>该命令</code>会覆盖掉 <code>CMD</code> 的命令，如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> demo-cmd <span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span>

hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但是 <code>ENTRYPOINT</code> 的容器里 <code>ENTRYPOINT</code> 所定义的<code>命令</code>则<code>无法覆盖</code>，一定会执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> demo-entrypoint
hello <span class="token function">docker</span>

<span class="token function">docker</span> container run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> demo-entrypoint <span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span>
hello <span class="token function">docker</span> <span class="token builtin class-name">echo</span> hello world
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="Shell-格式和-Exec-格式"><a href="#Shell-格式和-Exec-格式" class="headerlink" title="Shell 格式和 Exec 格式"></a>Shell 格式和 Exec 格式</h1><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> echo <span class="token string">"hello docker"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Exec格式"><a href="#Exec格式" class="headerlink" title="Exec格式"></a>Exec格式</h2><p>以可执行命令的方式</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"echo"</span>, <span class="token string">"hello docker"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"echo"</span>, <span class="token string">"hello docker"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意 <code>shell</code> 脚本的问题</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENV</span> NAME=docker</span>
<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">"hello $NAME"</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>假如我们要把上面的 <code>CMD</code> 改成 <code>Exec</code> 格式，下面这样改是不行的, 大家可以试试。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENV</span> NAME=docker</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"echo"</span>, <span class="token string">"hello $NAME"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>它会打印出 <code>hello $NAME</code> , 而不是 <code>hello docker</code> ,那么需要怎么写呢？ 我们需要以 <code>shell</code> 脚本的方式去执行</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>
<span class="token instruction"><span class="token keyword">ENV</span> NAME=docker</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"sh"</span>, <span class="token string">"-c"</span>, <span class="token string">"echo hello $NAME"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h1 id="一起构建一个-Python-Flask-镜像"><a href="#一起构建一个-Python-Flask-镜像" class="headerlink" title="一起构建一个 Python Flask 镜像"></a>一起构建一个 Python Flask 镜像</h1><p><code>Python</code> 程序</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">'Hello, World!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Dockerfile</code> 文件</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>
<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="Dockerfile-技巧——合理使用缓存"><a href="#Dockerfile-技巧——合理使用缓存" class="headerlink" title="Dockerfile 技巧——合理使用缓存"></a>Dockerfile 技巧——合理使用缓存</h1><p>清空停止的 <code>container</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> system prune <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>Dockerfile</code> 文件</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>
<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>构建 <code>image</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> image build <span class="token parameter variable">-t</span> flask-demo <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如 修改 <code>app.py</code> 后，再次构建 <code>image</code> 过程中，如果 <code>dockerfile</code> 中某一层被修改 ， 这一层往后的命令 不会使用 <code>cache</code> 去构建 <code>Image</code></p>
<p>解决方法： 将容易改变的 放到后面。 不容易发生改变的放在前面，可以使用 <code>cache</code></p>
<p>新的 <code>Dockerfile</code> 文件</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>
<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="Dockerfile-技巧——合理使用-dockerignore"><a href="#Dockerfile-技巧——合理使用-dockerignore" class="headerlink" title="Dockerfile 技巧——合理使用 .dockerignore"></a>Dockerfile 技巧——合理使用 .dockerignore</h1><h2 id="什么是Docker-build-context"><a href="#什么是Docker-build-context" class="headerlink" title="什么是Docker build context"></a>什么是Docker build context</h2><p><code>Docker</code> 是 <code>client-server</code> 架构，理论上 <code>Client</code> 和 <code>Server</code> 可以不在一台机器上。</p>
<p>在构建 <code>docker</code> 镜像的时候，需要把所需要的文件由<code>CLI（client）</code>发给 <code>Server</code> ，<code>这些文件</code>实际上就是  <code>build context</code></p>
<p>举例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dockerfile-demo <span class="token function">more</span> Dockerfile
FROM python:3.9.5-slim

RUN pip <span class="token function">install</span> flask

WORKDIR /src
ENV <span class="token assign-left variable">FLASK_APP</span><span class="token operator">=</span>app.py

COPY app.py /src/app.py

EXPOSE <span class="token number">5000</span>

CMD <span class="token punctuation">[</span><span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span><span class="token punctuation">]</span>
$ dockerfile-demo <span class="token function">more</span> app.py
from flask <span class="token function">import</span> Flask

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>


@app.route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
def hello_world<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    <span class="token builtin class-name">return</span> <span class="token string">'Hello, world!'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构建的时候，第一行输出就是发送 <code>build context</code> 。<code>11.13 MB</code> （这里是 <code>Linux</code> 环境下的 <code>log</code>）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> demo <span class="token builtin class-name">.</span>

<span class="token comment"># 这一行</span>
Sending build context to Docker daemon  <span class="token number">11</span>.13MB

Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM python:3.9.5-slim
 ---<span class="token operator">></span> 609da079b03a
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> RUN pip <span class="token function">install</span> flask
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> 955ce495635e
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> WORKDIR /src
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> 1c2f968e9f9b
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> ENV <span class="token assign-left variable">FLASK_APP</span><span class="token operator">=</span>app.py
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> dceb15b338cf
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> COPY app.py /src/app.py
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> 0d4dfef28b5f
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">5000</span>
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> 203e9865f0d9
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span><span class="token punctuation">]</span>
 ---<span class="token operator">></span> Using cache
 ---<span class="token operator">></span> 35b5efae1293
Successfully built 35b5efae1293
Successfully tagged demo:latest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>.</code> 这个参数就是代表了 <code>build context</code> 所指向的<code>目录</code></p>
<h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>有了 <code>.dockerignore</code> 文件后，我们再 <code>build</code> , <code>build context</code>就小了很多，<code>4.096 kB</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> demo <span class="token builtin class-name">.</span>

<span class="token comment"># 这一行</span>
Sending build context to Docker daemon  <span class="token number">4</span>.096kB

Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM python:3.9.5-slim
---<span class="token operator">></span> 609da079b03a
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> RUN pip <span class="token function">install</span> flask
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 955ce495635e
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> WORKDIR /src
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 1c2f968e9f9b
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> ENV <span class="token assign-left variable">FLASK_APP</span><span class="token operator">=</span>app.py
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> dceb15b338cf
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> COPY <span class="token builtin class-name">.</span> /src/
---<span class="token operator">></span> a9a8f888fef3
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">5000</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> c71f34d32009
Removing intermediate container c71f34d32009
---<span class="token operator">></span> fed6995d5a83
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span><span class="token punctuation">]</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> 7ea669f59d5e
Removing intermediate container 7ea669f59d5e
---<span class="token operator">></span> 079bae887a47
Successfully built 079bae887a47
Successfully tagged demo:latest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>build context</code> 发送给后台的 <code>docker server</code> 。 如果 <code>build context</code> 大，发送耗时长，想办法减小 <code>build context</code> 大小 。</p>
<p>添加 <code>.dockerignore</code> 文件 忽略不需要的文件</p>
<h1 id="Dockerfile-技巧——镜像的多阶段构建"><a href="#Dockerfile-技巧——镜像的多阶段构建" class="headerlink" title="Dockerfile 技巧——镜像的多阶段构建"></a>Dockerfile 技巧——镜像的多阶段构建</h1><h2 id="C语言例子"><a href="#C语言例子" class="headerlink" title="C语言例子"></a>C语言例子</h2><p>假如有一个<code>C</code>的程序，我们想用<code>Docker</code>去做编译，然后执行可执行文件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本地测试（如果你本地有<code>C</code>环境）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc <span class="token parameter variable">--static</span> <span class="token parameter variable">-o</span> hello hello.c
$ <span class="token function">ls</span>
hello  hello.c
$ ./hello <span class="token function">docker</span>
hello <span class="token function">docker</span>
$ ./hello world
hello world
$ ./hello friends
hello friends
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构建一个<code>Docker</code>镜像，因为要有<code>C</code>的环境，所以我们选择<code>gcc</code>这个<code>image</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> gcc:9.4</span>

<span class="token instruction"><span class="token keyword">COPY</span> hello.c /src/hello.c</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>

<span class="token instruction"><span class="token keyword">RUN</span> gcc --static -o hello hello.c</span>

<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [ <span class="token string">"/src/hello"</span> ]</span>

<span class="token instruction"><span class="token keyword">CMD</span> []</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>build</code> 和 <code>测试</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> hello <span class="token builtin class-name">.</span>
Sending build context to Docker daemon   <span class="token number">5</span>.12kB
Step <span class="token number">1</span>/6 <span class="token builtin class-name">:</span> FROM gcc:9.4
---<span class="token operator">></span> be1d0d9ce039
Step <span class="token number">2</span>/6 <span class="token builtin class-name">:</span> COPY hello.c /src/hello.c
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 70a624e3749b
Step <span class="token number">3</span>/6 <span class="token builtin class-name">:</span> WORKDIR /src
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 24e248c6b27c
Step <span class="token number">4</span>/6 <span class="token builtin class-name">:</span> RUN gcc <span class="token parameter variable">--static</span> <span class="token parameter variable">-o</span> hello hello.c
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> db8ae7b42aff
Step <span class="token number">5</span>/6 <span class="token builtin class-name">:</span> ENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/src/hello"</span> <span class="token punctuation">]</span>
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 7f307354ee45
Step <span class="token number">6</span>/6 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token punctuation">]</span>
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 7cfa0cbe4e2a
Successfully built 7cfa0cbe4e2a
Successfully tagged hello:latest
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY     TAG          IMAGE ID       CREATED       SIZE
hello          latest       7cfa0cbe4e2a   <span class="token number">2</span> hours ago   <span class="token number">1</span>.14GB
gcc            <span class="token number">9.4</span>          be1d0d9ce039   <span class="token number">9</span> days ago    <span class="token number">1</span>.14GB
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello <span class="token function">docker</span>
hello <span class="token function">docker</span>
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello world
hello world
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello friends
hello friends
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到镜像非常的<code>大</code>，<code>1.14 GB</code></p>
<p>实际上当我们把 <code>hello.c</code> 编译完以后，并不需要这样一个大的<code>GCC</code>环境，一个小的<code>alpine</code>镜像就可以了。</p>
<p>这时候我们就可以使用<code>多阶段</code>构建了。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> gcc:9.4 <span class="token keyword">AS</span> builder</span>

<span class="token instruction"><span class="token keyword">COPY</span> hello.c /src/hello.c</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>

<span class="token instruction"><span class="token keyword">RUN</span> gcc --static -o hello hello.c</span>



<span class="token instruction"><span class="token keyword">FROM</span> alpine:3.13.5</span>

<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /src/hello /src/hello</span>

<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [ <span class="token string">"/src/hello"</span> ]</span>

<span class="token instruction"><span class="token keyword">CMD</span> []</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> hello-alpine <span class="token parameter variable">-f</span> Dockerfile-new <span class="token builtin class-name">.</span>
Sending build context to Docker daemon   <span class="token number">5</span>.12kB
Step <span class="token number">1</span>/8 <span class="token builtin class-name">:</span> FROM gcc:9.4 AS builder
---<span class="token operator">></span> be1d0d9ce039
Step <span class="token number">2</span>/8 <span class="token builtin class-name">:</span> COPY hello.c /src/hello.c
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 70a624e3749b
Step <span class="token number">3</span>/8 <span class="token builtin class-name">:</span> WORKDIR /src
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 24e248c6b27c
Step <span class="token number">4</span>/8 <span class="token builtin class-name">:</span> RUN gcc <span class="token parameter variable">--static</span> <span class="token parameter variable">-o</span> hello hello.c
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> db8ae7b42aff
Step <span class="token number">5</span>/8 <span class="token builtin class-name">:</span> FROM alpine:3.13.5
---<span class="token operator">></span> 6dbb9cc54074
Step <span class="token number">6</span>/8 <span class="token builtin class-name">:</span> COPY <span class="token parameter variable">--from</span><span class="token operator">=</span>builder /src/hello /src/hello
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 18c2bce629fb
Step <span class="token number">7</span>/8 <span class="token builtin class-name">:</span> ENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/src/hello"</span> <span class="token punctuation">]</span>
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 8dfb9d9d6010
Step <span class="token number">8</span>/8 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token punctuation">]</span>
---<span class="token operator">></span> Using cache
---<span class="token operator">></span> 446baf852214
Successfully built 446baf852214
Successfully tagged hello-alpine:latest
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY     TAG          IMAGE ID       CREATED       SIZE
hello-alpine   latest       446baf852214   <span class="token number">2</span> hours ago   <span class="token number">6</span>.55MB
hello          latest       7cfa0cbe4e2a   <span class="token number">2</span> hours ago   <span class="token number">1</span>.14GB
demo           latest       079bae887a47   <span class="token number">2</span> hours ago   125MB
gcc            <span class="token number">9.4</span>          be1d0d9ce039   <span class="token number">9</span> days ago    <span class="token number">1</span>.14GB
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello-alpine <span class="token function">docker</span>
hello <span class="token function">docker</span>
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello-alpine world
hello world
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> hello-alpine friends
hello friends
$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到这个镜像非常小，只有 <code>6.55 MB</code></p>
<h2 id="Go语言例子"><a href="#Go语言例子" class="headerlink" title="Go语言例子"></a>Go语言例子</h2><p>同样的，假如有一个<code>Go</code>的程序，我们想用 <code>Docker</code> 去做编译，然后执行可执行文件。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello golang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    log<span class="token punctuation">.</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>LstdFlags <span class="token operator">|</span> log<span class="token punctuation">.</span>Lshortfile<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start server on [localhost:8080] ..."</span><span class="token punctuation">)</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> test<span class="token punctuation">)</span>
    err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本地测试（如果你本地有<code>Golang</code>环境）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go build
$ <span class="token function">ls</span>
app  <span class="token function">df</span>  dockerfile  go.mod  main.go
$ ./app
<span class="token number">2023</span>/02/15 02:28:18 main.go:14: start server on <span class="token punctuation">[</span>localhost:8080<span class="token punctuation">]</span> <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另一个终端</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> localhost:8080
Hello golang
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>构建一个 <code>Docker</code> 镜像，因为要有 <code>Go</code> 的环境，所以我们选择 <code>golang</code> 这个 <code>image</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> golang:alpine3.17 <span class="token keyword">AS</span> builder</span>

<span class="token instruction"><span class="token keyword">COPY</span> main.go /src/app.go</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>

<span class="token instruction"><span class="token keyword">RUN</span> go build app.go</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 8080</span>

<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [ <span class="token string">"/src/app"</span> ]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>build</code> 和 <code>测试</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> hello-go <span class="token builtin class-name">.</span>
Sending build context to Docker daemon  <span class="token number">6</span>.512MB
Step <span class="token number">1</span>/6 <span class="token builtin class-name">:</span> FROM golang:alpine3.17 AS builder
---<span class="token operator">></span> 3257bc8ee9f7
Step <span class="token number">2</span>/6 <span class="token builtin class-name">:</span> COPY main.go /src/app.go
---<span class="token operator">></span> b0156e003e2d
Step <span class="token number">3</span>/6 <span class="token builtin class-name">:</span> WORKDIR /src
---<span class="token operator">></span> Running <span class="token keyword">in</span> 7976422fe214
Removing intermediate container 7976422fe214
---<span class="token operator">></span> 122042396c76
Step <span class="token number">4</span>/6 <span class="token builtin class-name">:</span> RUN go build app.go
---<span class="token operator">></span> Running <span class="token keyword">in</span> f321f6a73147
Removing intermediate container f321f6a73147
---<span class="token operator">></span> 21236778ceee
Step <span class="token number">5</span>/6 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">8080</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> d47b6e2fb836
Removing intermediate container d47b6e2fb836
---<span class="token operator">></span> <span class="token number">133988261356</span>
Step <span class="token number">6</span>/6 <span class="token builtin class-name">:</span> ENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/src/app"</span> <span class="token punctuation">]</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> 7f19bd8952b4
Removing intermediate container 7f19bd8952b4
---<span class="token operator">></span> 2ccb4f220a22
Successfully built 2ccb4f220a22
Successfully tagged hello-go:latest
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                                                           TAG                 IMAGE ID            CREATED             SIZE
hello-go                                                             latest              2ccb4f220a22        <span class="token number">19</span> minutes ago      321MB
golang                                                               alpine3.17          3257bc8ee9f7        <span class="token number">3</span> days ago          254MB
$ <span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">-it</span> hello-go
<span class="token number">2023</span>/02/14 <span class="token number">18</span>:16:11 app.go:14: start server on <span class="token punctuation">[</span>localhost:8080<span class="token punctuation">]</span> <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> localhost:8080
Hello golang
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到镜像也很大，<code>321</code>MB，同样的，我们使用<code>多阶段</code>构建。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> golang:alpine3.17 <span class="token keyword">AS</span> builder</span>

<span class="token instruction"><span class="token keyword">COPY</span> main.go /src/app.go</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>

<span class="token instruction"><span class="token keyword">RUN</span> go build app.go</span>

<span class="token instruction"><span class="token keyword">FROM</span> alpine:3.17.0</span>

<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /src/app /src/app</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 8080</span>

<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [ <span class="token string">"/src/app"</span> ]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> hello-go-alpine <span class="token parameter variable">-f</span> ./df <span class="token builtin class-name">.</span>
Sending build context to Docker daemon  <span class="token number">6</span>.512MB
Step <span class="token number">1</span>/8 <span class="token builtin class-name">:</span> FROM golang:alpine3.17 AS builder
---<span class="token operator">></span> 3257bc8ee9f7
Step <span class="token number">2</span>/8 <span class="token builtin class-name">:</span> COPY main.go /src/app.go
---<span class="token operator">></span> 167672dc57ce
Step <span class="token number">3</span>/8 <span class="token builtin class-name">:</span> WORKDIR /src
---<span class="token operator">></span> Running <span class="token keyword">in</span> a53f0f84c92d
Removing intermediate container a53f0f84c92d
---<span class="token operator">></span> cc8ee771cdbd
Step <span class="token number">4</span>/8 <span class="token builtin class-name">:</span> RUN go build app.go
---<span class="token operator">></span> Running <span class="token keyword">in</span> 9e8e575af675
Removing intermediate container 9e8e575af675
---<span class="token operator">></span> e8e7c7219cd5
Step <span class="token number">5</span>/8 <span class="token builtin class-name">:</span> FROM alpine:3.17.0
<span class="token number">3.17</span>.0: Pulling from library/alpine
c158987b0551: Pull complete
Digest: sha256:8914eb54f968791faf6a8638949e480fef81e697984fba772b3976835194c6d4
Status: Downloaded newer image <span class="token keyword">for</span> alpine:3.17.0
---<span class="token operator">></span> 49176f190c7e
Step <span class="token number">6</span>/8 <span class="token builtin class-name">:</span> COPY <span class="token parameter variable">--from</span><span class="token operator">=</span>builder /src/app /src/app
---<span class="token operator">></span> 8121bedd9a21
Step <span class="token number">7</span>/8 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">8080</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> 93a02551712d
Removing intermediate container 93a02551712d
---<span class="token operator">></span> e91f0c467511
Step <span class="token number">8</span>/8 <span class="token builtin class-name">:</span> ENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/src/app"</span> <span class="token punctuation">]</span>
---<span class="token operator">></span> Running <span class="token keyword">in</span> aef94175c85d
Removing intermediate container aef94175c85d
---<span class="token operator">></span> f3ee197cba4f
Successfully built f3ee197cba4f
Successfully tagged hello-go-alpine:latest
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                                                           TAG                 IMAGE ID            CREATED             SIZE
hello-go-alpine                                                      latest              f3ee197cba4f        <span class="token number">31</span> seconds ago      <span class="token number">13</span>.6MB
<span class="token operator">&lt;</span>none<span class="token operator">></span>                                                               <span class="token operator">&lt;</span>none<span class="token operator">></span>              e8e7c7219cd5        <span class="token number">46</span> seconds ago      321MB
hello-go                                                             latest              2ccb4f220a22        <span class="token number">24</span> minutes ago      321MB
golang                                                               alpine3.17          3257bc8ee9f7        <span class="token number">3</span> days ago          254MB
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">-it</span> hello-go-alpine
<span class="token number">2023</span>/02/14 <span class="token number">18</span>:42:29 app.go:14: start server on <span class="token punctuation">[</span>localhost:8080<span class="token punctuation">]</span> <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在镜像只有 <code>13.6 MB</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> localhost:8080
Hello golang
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Angular例子"><a href="#Angular例子" class="headerlink" title="Angular例子"></a>Angular例子</h2><h1 id="Dockerfile-技巧——尽量使用非root用户"><a href="#Dockerfile-技巧——尽量使用非root用户" class="headerlink" title="Dockerfile 技巧——尽量使用非root用户"></a>Dockerfile 技巧——尽量使用非root用户</h1><h2 id="Root的危险性"><a href="#Root的危险性" class="headerlink" title="Root的危险性"></a>Root的危险性</h2><p><code>docker</code> 的 root 权限一直是其遭受诟病的地方，<code>docker</code> 的 <code>root</code> 权限有那么危险么？我们举个例子。</p>
<p>假如我们有一个用户，叫 <code>demo</code> ，它本身不具有 <code>sudo</code> 的权限，所以就有很多文件无法进行读写操作，比如<code>/root</code>目录它是无法查看的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">ls</span> /root
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> demo:
demo is not <span class="token keyword">in</span> the sudoers file.  This incident will be reported.
<span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是这个用户有执行 <code>docker</code> 的权限，也就是它在 <code>docker</code> 这个 <code>group</code> 里。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">groups</span>
demo <span class="token function">docker</span>
<span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
busybox      latest    a9d583973f65   <span class="token number">2</span> days ago   <span class="token number">1</span>.23MB
<span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这时，我们就可以通过 <code>Docker</code> 做很多越权的事情了，比如，我们可以把这个无法查看的 <code>/root</code> 目录映射到<code>docker container</code> 里，你就可以自由进行查看了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host vagrant<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /root/:/root/tmp busybox <span class="token function">sh</span>
/ <span class="token comment"># cd /root/tmp</span>
~/tmp <span class="token comment"># ls</span>
anaconda-ks.cfg  original-ks.cfg
~/tmp <span class="token comment"># ls -l</span>
total <span class="token number">16</span>
-rw-------    <span class="token number">1</span> root     root          <span class="token number">5570</span> Apr <span class="token number">30</span>  <span class="token number">2020</span> anaconda-ks.cfg
-rw-------    <span class="token number">1</span> root     root          <span class="token number">5300</span> Apr <span class="token number">30</span>  <span class="token number">2020</span> original-ks.cfg
~/tmp <span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>更甚至我们可以给我们自己加 <code>sudo</code> 权限。我们现在没有 <code>sudo</code> 权限</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/sudoers
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> demo:
demo is not <span class="token keyword">in</span> the sudoers file.  This incident will be reported.
<span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是我可以给自己添加。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /etc/sudoers:/root/sudoers busybox <span class="token function">sh</span>
/ <span class="token comment"># echo "demo    ALL=(ALL)       ALL" >> /root/sudoers</span>
/ <span class="token comment"># more /root/sudoers | grep demo</span>
demo    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后退出<code>container</code>，<code>bingo</code>，我们有 <code>sudo</code> 权限了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">more</span> /etc/sudoers <span class="token operator">|</span> <span class="token function">grep</span> demo
demo    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
<span class="token punctuation">[</span>demo@docker-host ~<span class="token punctuation">]</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="如何使用非root用户"><a href="#如何使用非root用户" class="headerlink" title="如何使用非root用户"></a>如何使用非root用户</h2><p>我们准备两个 <code>Dockerfile</code> ，<code>第一个</code> <code>Dockerfile</code> 如下，其中 <code>app.py</code> 文件源码请参考 <code>一起构建一个 Python Flask 镜像</code></p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>
<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设构建的镜像名字为 <code>flask-demo</code></p>
<p><code>第二个</code> <code>Dockerfile</code> ，使用非 <code>root</code> 用户来构建这个镜像，名字叫 <code>flask-no-root</code> <code>Dockerfile</code> 如下：</p>
<ul>
<li><p>通过 <code>groupadd</code> 和 <code>useradd</code> 创建一个 <code>flask</code> 的<code>组</code>和<code>用户</code></p>
</li>
<li><p>通过 <code>USER</code> 指定后面的命令要以 <code>flask</code> 这个用户的身份运行</p>
</li>
</ul>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.9.5-slim</span>

<span class="token instruction"><span class="token keyword">RUN</span> pip install flask &amp;&amp; <span class="token operator">\</span>
    groupadd -r flask &amp;&amp; useradd -r -g flask flask &amp;&amp; <span class="token operator">\</span>
    mkdir /src &amp;&amp; <span class="token operator">\</span>
    chown -R flask:flask /src</span>

<span class="token instruction"><span class="token keyword">USER</span> flask</span>

<span class="token instruction"><span class="token keyword">COPY</span> app.py /src/app.py</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span>
<span class="token instruction"><span class="token keyword">ENV</span> FLASK_APP=app.py</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"flask"</span>, <span class="token string">"run"</span>, <span class="token string">"-h"</span>, <span class="token string">"0.0.0.0"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY      TAG          IMAGE ID       CREATED          SIZE
flask-no-root   latest       80996843356e   <span class="token number">41</span> minutes ago   126MB
flask-demo      latest       2696c68b51ce   <span class="token number">49</span> minutes ago   125MB
python          <span class="token number">3.9</span>.5-slim   609da079b03a   <span class="token number">2</span> weeks ago      115MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分别使用这两个镜像创建两个容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> flask-root flask-demo
b31588bae216951e7981ce14290d74d377eef477f71e1506b17ee505d7994774
$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> flask-no-root flask-no-root
83aaa4a116608ec98afff2a142392119b7efe53617db213e8c7276ab0ae0aaa0
$ <span class="token function">docker</span> container <span class="token function">ps</span>
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS      NAMES
83aaa4a11660   flask-no-root   <span class="token string">"flask run -h 0.0.0.0"</span>   <span class="token number">4</span> seconds ago    Up <span class="token number">3</span> seconds    <span class="token number">5000</span>/tcp   flask-no-root
b31588bae216   flask-demo      <span class="token string">"flask run -h 0.0.0.0"</span>   <span class="token number">16</span> seconds ago   Up <span class="token number">15</span> seconds   <span class="token number">5000</span>/tcp   flask-root
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h1><p>如何进行数据的持久化。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备一个 <code>Dockerfile</code> 和一个 <code>my-cron</code> 的文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span>
Dockerfile  my-cron
$ <span class="token function">more</span> Dockerfile
FROM alpine:latest
RUN apk update
RUN apk --no-cache <span class="token function">add</span> <span class="token function">curl</span>
ENV <span class="token assign-left variable">SUPERCRONIC_URL</span><span class="token operator">=</span>https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 <span class="token punctuation">\</span>
    <span class="token assign-left variable">SUPERCRONIC</span><span class="token operator">=</span>supercronic-linux-amd64 <span class="token punctuation">\</span>
    <span class="token assign-left variable">SUPERCRONIC_SHA1SUM</span><span class="token operator">=</span>048b95b48b708983effb2e5c935a1ef8483d9e3e
RUN <span class="token function">curl</span> <span class="token parameter variable">-fsSLO</span> <span class="token string">"<span class="token variable">$SUPERCRONIC_URL</span>"</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;SUPERCRONIC_SHA1SUM&#125;</span>  <span class="token variable">$&#123;SUPERCRONIC&#125;</span>"</span> <span class="token operator">|</span> sha1sum <span class="token parameter variable">-c</span> - <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x <span class="token string">"<span class="token variable">$SUPERCRONIC</span>"</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> <span class="token string">"<span class="token variable">$SUPERCRONIC</span>"</span> <span class="token string">"/usr/local/bin/<span class="token variable">$&#123;SUPERCRONIC&#125;</span>"</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token string">"/usr/local/bin/<span class="token variable">$&#123;SUPERCRONIC&#125;</span>"</span> /usr/local/bin/supercronic
COPY my-cron /app/my-cron
WORKDIR /app

VOLUME <span class="token punctuation">[</span><span class="token string">"/app"</span><span class="token punctuation">]</span>

<span class="token comment"># RUN cron job</span>
CMD <span class="token punctuation">[</span><span class="token string">"/usr/local/bin/supercronic"</span>, <span class="token string">"/app/my-cron"</span><span class="token punctuation">]</span>
$
$ <span class="token function">more</span> my-cron
*/1 * * * * <span class="token function">date</span> <span class="token operator">>></span> /app/test.txt
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> my-cron <span class="token builtin class-name">.</span>
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
my-cron      latest    e9fbd9a562c9   <span class="token number">4</span> seconds ago   <span class="token number">24</span>.7MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="创建容器-不指定-v参数"><a href="#创建容器-不指定-v参数" class="headerlink" title="创建容器(不指定-v参数)"></a>创建容器(不指定-v参数)</h2><p>此时 <code>Docker</code> 会自动创建一个随机名字的 <code>volume</code> ，去存储我们在 <code>Dockerfile</code> 定义的 <code>volume</code> <code>VOLUME [&quot;/app&quot;]</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> my-cron
9a8fa93f03c42427a498b21ac520660752122e20bcdbf939661646f71d277f8f
$ <span class="token function">docker</span> volume <span class="token function">ls</span>
DRIVER    VOLUME NAME
<span class="token builtin class-name">local</span>     043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
$ <span class="token function">docker</span> volume inspect 043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-06-22T23:06:13+02:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个 <code>Volume</code> 的 <code>mountpoint</code> 可以发现容器创建的文件</p>
<h2 id="创建容器-指定-v参数"><a href="#创建容器-指定-v参数" class="headerlink" title="创建容器(指定-v参数)"></a>创建容器(指定-v参数)</h2><p>在创建容器的时候通过 <code>-v</code> 参数我们可以手动的指定需要创建 <code>Volume</code> 的名字，以及对应于容器内的路径，这个路径是可以任意的，不必需要在 <code>Dockerfile</code> 里通过 <code>VOLUME</code> 定义</p>
<p>比如我们把上面的 <code>Dockerfile</code> 里的 <code>VOLUME</code> 删除</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> alpine:latest</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk update</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk --no-cache add curl</span>
<span class="token instruction"><span class="token keyword">ENV</span> SUPERCRONIC_URL=https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 <span class="token operator">\</span>
    SUPERCRONIC=supercronic-linux-amd64 <span class="token operator">\</span>
    SUPERCRONIC_SHA1SUM=048b95b48b708983effb2e5c935a1ef8483d9e3e</span>
<span class="token instruction"><span class="token keyword">RUN</span> curl -fsSLO <span class="token string">"$SUPERCRONIC_URL"</span> <span class="token operator">\</span>
    &amp;&amp; echo <span class="token string">"$&#123;SUPERCRONIC_SHA1SUM&#125;  $&#123;SUPERCRONIC&#125;"</span> | sha1sum -c - <span class="token operator">\</span>
    &amp;&amp; chmod +x <span class="token string">"$SUPERCRONIC"</span> <span class="token operator">\</span>
    &amp;&amp; mv <span class="token string">"$SUPERCRONIC"</span> <span class="token string">"/usr/local/bin/$&#123;SUPERCRONIC&#125;"</span> <span class="token operator">\</span>
    &amp;&amp; ln -s <span class="token string">"/usr/local/bin/$&#123;SUPERCRONIC&#125;"</span> /usr/local/bin/supercronic</span>
<span class="token instruction"><span class="token keyword">COPY</span> my-cron /app/my-cron</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token comment"># RUN cron job</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"/usr/local/bin/supercronic"</span>, <span class="token string">"/app/my-cron"</span>]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>重新 <code>build</code> 镜像，然后创建容器，加 <code>-v</code> 参数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> my-cron <span class="token builtin class-name">.</span>
$ <span class="token function">docker</span> container run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> cron-data:/app my-cron
43c6d0357b0893861092a752c61ab01bdfa62ea766d01d2fcb8b3ecb6c88b3de
$ <span class="token function">docker</span> volume <span class="token function">ls</span>
DRIVER    VOLUME NAME
<span class="token builtin class-name">local</span>     cron-data
$ <span class="token function">docker</span> volume inspect cron-data
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-06-22T23:25:02+02:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/cron-data/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"cron-data"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
$ <span class="token function">ls</span> /var/lib/docker/volumes/cron-data/_data
my-cron
$ <span class="token function">ls</span> /var/lib/docker/volumes/cron-data/_data
my-cron  test.txt
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Volume</code> 也创建了。</p>
<h2 id="环境清理"><a href="#环境清理" class="headerlink" title="环境清理"></a>环境清理</h2><p>强制删除所有容器，系统清理和 <code>volume</code> 清理</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> container <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span>
$ <span class="token function">docker</span> system prune <span class="token parameter variable">-f</span>
$ <span class="token function">docker</span> volume prune <span class="token parameter variable">-f</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>DBML 数据库标记语言</title>
    <url>//post/mysql-dbml-syntax.html</url>
    <content><![CDATA[<p>转载自： <a href="https://dbml.dbdiagram.io/home/#intro">https://dbml.dbdiagram.io/home/#intro</a></p>
<p><a href="https://github.com/holistics/dbml"><img src="https://img.shields.io/github/stars/holistics/dbml?style=social" alt="github"></a></p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>DBML（数据库标记语言）</strong>是一种开源 DSL 语言，旨在定义和记录数据库模式和结构。它的设计简单、一致且具有高度可读性。</p>
<p>它还附带命令行工具和开源模块来帮助您在 DBML 和 SQL 之间进行转换。</p>
<p><em><a href="https://dbdiagram.io/d/5d5cb582ced98361d6ddc5ab">请参阅上面在 dbdiagram 上可视化的</a>dbml 文档 <a href="https://dbdiagram.io/d/5d5cb582ced98361d6ddc5ab">（打开新窗口）</a></em></p>
<p>有关完整的 DBML 语法文档，请参阅<a href="https://dbml.dbdiagram.io/docs/">文档</a>部分。</p>
<p><em>注意：不要将 DBML 与 Microsoft 的 DBML 文件扩展名（XML 格式）混淆。</em></p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>DBML 的诞生是为了解决大型复杂软件项目开发人员的挫败感：</p>
<ul>
<li>难以建立整个项目数据库结构的心理“大局”</li>
<li>难以理解表格及其字段的含义以及它们与哪些功能相关；</li>
<li>现有的 ER 图和&#x2F;或 SQL DDL 代码写得不好并且难以阅读（并且通常已经过时）。</li>
</ul>
<p><code>database.dbml</code>我们建议的最佳实践是在根存储库中 拥有一个文件_（类似于其他配置和&#x2F;或样板文件，例如<code>packages.json</code>或<code>README.md</code>）_</p>
<h2 id="这与-SQL-DDL-类似吗？"><a href="#这与-SQL-DDL-类似吗？" class="headerlink" title="这与 SQL DDL 类似吗？"></a>这与 SQL DDL 类似吗？</h2><p>不完全的。尽管它的名称是（数据“定义”语言），DDL 的设计主要是为了帮助物理地创建、修改或删除表，而不是定义它们。换句话说，<strong>DDL 是命令式的，而 DBML 是声明式的</strong>。这使得 DBML 更容易编写、阅读和维护。</p>
<p>DDL 也是特定于数据库的（Oracle、PostgreSQL 等），而<strong>DBML 与数据库无关</strong>，专为高级数据库架构而不是低级数据库创建而设计。</p>
<h2 id="我现在能做什么？"><a href="#我现在能做什么？" class="headerlink" title="我现在能做什么？"></a>我现在能做什么？</h2><p>DBML 附带：</p>
<ol>
<li><a href="https://dbdiagram.io/">dbdiagram.io</a>上的免费数据库可视化工具 <a href="https://dbdiagram.io/">（打开新窗口）</a></li>
<li><a href="https://dbdocs.io/">dbdocs.io</a>上的免费数据库文档生成器 <a href="https://dbdocs.io/">（打开新窗口）</a></li>
<li>一个命令行工具，可帮助将 SQL 转换为 DBML 文件，反之亦然。 <a href="https://dbml.dbdiagram.io/cli">CLI 文档</a></li>
<li>一个<a href="https://dbml.dbdiagram.io/js-module/">开源 JS 库</a>（NPM 包），供您以编程方式在 DBML 和 SQL DDL 之间进行转换。</li>
<li><a href="https://dbdocs.io/?utm_source=dbml">数据库文档 （打开新窗口）</a>是一个免费工具，可帮助您从 DBML 代码构建数据库文档。</li>
</ol>
<h2 id="DBML-完整语法文档"><a href="#DBML-完整语法文档" class="headerlink" title="DBML - 完整语法文档"></a>DBML - 完整语法文档</h2><p><a href="https://dbml.dbdiagram.io/docs/#table-definition">https://dbml.dbdiagram.io/docs/#table-definition</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Dbml</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装开发环境中使用的软件</title>
    <url>//post/mysql-redis-mongo-on-dev.html</url>
    <content><![CDATA[<p>随手记录一下 <code>docker</code> 实现简单开发环境中使用的软件的安装</p>
<span id="more"></span>


<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol>
<li><p>获取镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql/mysql-server

<span class="token comment"># arm架构</span>
<span class="token function">docker</span> pull arm64v8/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>运行实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--name</span> mysql <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token operator">&lt;</span>Image ID<span class="token operator">></span>
<span class="token comment"># -v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂在到主机</span>
<span class="token comment"># -v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机</span>
<span class="token comment"># -v /mydata/mysql/data:/var/lib/mysql/：将数据文件夹挂载到主机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>进入容器配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>Container ID<span class="token operator">></span> <span class="token function">bash</span>

<span class="token comment"># 配置MYSQL</span>
mysql  mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span>
use mysql<span class="token punctuation">;</span>
update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>
flush privileges<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol>
<li><p>获取镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull redis

<span class="token comment"># arm架构</span>
<span class="token function">docker</span> pull arm64v8/redis
<span class="token function">docker</span> pull redis:7.0@sha256:6deb234aab413d78dab19d82b89c4111ca4e9a446749263cc98215122da54a9c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>运行实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--name</span> redis <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 <span class="token operator">&lt;</span>Image ID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ol>
<li><p>获取镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mongo:4.0.4

<span class="token comment"># arm架构</span>
<span class="token function">docker</span> pull arm64v8/mongo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>运行实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">27017</span>:27017 <span class="token parameter variable">-v</span> /home//mongodb/data:/data/db <span class="token parameter variable">--name</span> mongo <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token operator">&lt;</span>Image ID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>进入容器配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>CONTAINER_NAME<span class="token operator">></span> or <span class="token operator">&lt;</span>Image ID<span class="token operator">></span> <span class="token function">bash</span>
mongo
show dbs
<span class="token builtin class-name">help</span>
<span class="token comment"># 或者</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>CONTAINER_NAME<span class="token operator">></span> or <span class="token operator">&lt;</span>Image ID<span class="token operator">></span> mongosh
show dbs
<span class="token builtin class-name">help</span>

<span class="token comment"># 添加用户</span>
use admin
db.createUser<span class="token punctuation">(</span><span class="token punctuation">&#123;</span> user:<span class="token string">'root'</span>,pwd:<span class="token string">'123456'</span>,roles:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span> role:<span class="token string">'userAdminAnyDatabase'</span>, db: <span class="token string">'admin'</span><span class="token punctuation">&#125;</span>,<span class="token string">"readWriteAnyDatabase"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token function">docker</span> logs mongo <span class="token parameter variable">--follow</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><code>IP:8849/nacos/</code></p>
<ol>
<li><p>获取镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull nacos/nacos-server

<span class="token comment"># arm架构</span>
<span class="token function">docker</span> pull nacos/nacos-server:v2.2.0-slim@sha256:b1c8972c972bbf311ebf80531ca4c20969272b12b61da4609efe1da40ed93576<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>运行实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> nacos <span class="token parameter variable">-p</span> <span class="token number">8849</span>:8848 <span class="token parameter variable">-p</span> <span class="token number">9848</span>:9848 <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">-e</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span>standalone <span class="token parameter variable">-e</span> <span class="token assign-left variable">JVM_XMS</span><span class="token operator">=</span>256m <span class="token parameter variable">-e</span> <span class="token assign-left variable">JVM_XMX</span><span class="token operator">=</span>256m <span class="token parameter variable">-e</span> <span class="token assign-left variable">JVM_XMN</span><span class="token operator">=</span>256m  nacos/nacos-server:v2.2.0-slim@sha256:b1c8972c972bbf311ebf80531ca4c20969272b12b61da4609efe1da40ed93576<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>配置测试获取</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> GET <span class="token string">"http://&lt;IP>:8849/nacos/v1/cs/configs?dataId=user.web&amp;group=DEFAULT_GROUP"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>简单配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 通用配置</span>
<span class="token key atrule">name</span> <span class="token punctuation">:</span> <span class="token string">'user-web'</span>         <span class="token comment"># 服务名称</span>
<span class="token key atrule">port</span> <span class="token punctuation">:</span> <span class="token number">10051</span>              <span class="token comment"># 服务端口</span>
<span class="token key atrule">host</span> <span class="token punctuation">:</span> <span class="token string">""</span>              <span class="token comment"># 服务器host</span>
<span class="token key atrule">tag</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span><span class="token string">"mango"</span>

<span class="token comment"># Nacos配置中心配置</span>
<span class="token key atrule">nacos</span><span class="token punctuation">:</span>
  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span>       <span class="token comment"># nacos IP地址</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span>              <span class="token comment"># nacos 端口</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>
  <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>
  <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>
  <span class="token key atrule">dataid</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>
  <span class="token key atrule">group</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>

<span class="token comment"># 【用户】微服务grpc配置</span>
<span class="token key atrule">user-srv</span><span class="token punctuation">:</span>
  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span>       <span class="token comment"># grpc IP地址</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span>              <span class="token comment"># grpc 端口</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'user-srv'</span>        <span class="token comment"># 微服务名称</span>

<span class="token comment"># JWT配置</span>
<span class="token key atrule">jwt</span><span class="token punctuation">:</span>
  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">'zIcG6foVHFSHNtOf'</span> <span class="token comment"># JWT签发密钥</span>

<span class="token comment"># Redis配置</span>
<span class="token key atrule">redis</span><span class="token punctuation">:</span>
  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span>       <span class="token comment"># redis IP地址</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span>              <span class="token comment"># redis 端口</span>
  <span class="token key atrule">expire</span><span class="token punctuation">:</span> <span class="token number">120</span>             <span class="token comment"># 个别key 过期时间</span>

<span class="token comment"># consul注册中心配置</span>
<span class="token key atrule">consul</span><span class="token punctuation">:</span>
  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span>       <span class="token comment"># consul IP地址(可ping通)</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span>              <span class="token comment"># consul 端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p><code>IP:8500</code></p>
<ol>
<li><p>获取镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull hashicorp/consul

<span class="token comment"># arm架构</span>
<span class="token function">docker</span> pull arm64v8/consul
<span class="token function">docker</span> pull hashicorp/consul:1.16@sha256:fd5820d6364d1396bf3fcde9c7383a455fabbaf9eef85cd323a93a68dd225b6c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>运行实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 服务端</span>
<span class="token function">docker</span> run <span class="token punctuation">\</span>
<span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">8500</span>:8500 <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">8600</span>:8600/udp <span class="token punctuation">\</span>
<span class="token parameter variable">--name</span><span class="token operator">=</span>badger <span class="token punctuation">\</span>
hashicorp/consul:latest agent <span class="token parameter variable">-server</span> <span class="token parameter variable">-ui</span> <span class="token parameter variable">-node</span><span class="token operator">=</span>server-1 -bootstrap-expect<span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-client</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0

<span class="token comment"># 查看成员信息 172.17.0.5</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> badger consul members

<span class="token comment"># 客户端连接</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>fox  hashicorp/consul:latest agent <span class="token parameter variable">-node</span><span class="token operator">=</span>client-1 -retry-join<span class="token operator">=</span><span class="token number">172.17</span>.0.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>配置测试获取</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> GET <span class="token string">"http://&lt;IP>:8849/nacos/v1/cs/configs?dataId=user.web&amp;group=DEFAULT_GROUP"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>DEV</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计的六个阶段</title>
    <url>//post/2023-db-db-design.html</url>
    <content><![CDATA[<p>数据库设计可以分为 6 个阶段</p>
<ol>
<li>系统需求分析阶段</li>
<li>概念结构设计阶段</li>
<li>逻辑结构设计阶段</li>
<li>物理结构设计阶段</li>
<li>数据库实施阶段</li>
<li>数据库运行和维护阶段</li>
</ol>
<span id="more"></span>

<hr>
<h2 id="各阶段的任务"><a href="#各阶段的任务" class="headerlink" title="各阶段的任务"></a>各阶段的任务</h2><h4 id="系统需求分析"><a href="#系统需求分析" class="headerlink" title="系统需求分析"></a>系统需求分析</h4><p>对现实世界要处理的对象进行详细的调查，通过对原系统的了解，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。</p>
<ol>
<li>调查分析用户活动</li>
<li>收集和分析需求数据，确定系统边界信息需求，处理需求，安全性和完整性需求</li>
<li>编写系统分析报告<br>两种方法：自顶向下，自底向上</li>
</ol>
<h4 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h4><p>将需求分析数据抽象成局部 E-R 模型，再将局部 E-R 模型集成为全局 E-R 模型</p>
<h4 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h4><p>将概念模型转换成特定 DBMS 所支持的数据模型的过程<br>由初始关系模式设计到关系模式规范化再到模式评价</p>
<h4 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h4><p>对于给定的逻辑数据模型，选取一个最适合应用环境的物理结构</p>
<h4 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a>数据库实施</h4><p>根据逻辑设计和物理设计的结果，在计算机上建立起实际的数据库结构、装入数据、进行测试和试运行的过程。</p>
<h4 id="数据库运行和维护"><a href="#数据库运行和维护" class="headerlink" title="数据库运行和维护"></a>数据库运行和维护</h4><p>主要有以下三项内容：</p>
<ol>
<li>维护数据库的安全性和完整性</li>
<li>监测并改善数据库性能</li>
<li>重新组织和构造数据库</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm</title>
    <url>//post/docker-swarm-info.html</url>
    <content><![CDATA[<p>转载自： <code>https://github.com/xiaopeng163/docker.tips</code></p>
<span id="more"></span>


<h1 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h1><h2 id="docker-swarm-介绍"><a href="#docker-swarm-介绍" class="headerlink" title="docker swarm 介绍"></a>docker swarm 介绍</h2><h3 id="为什么不建议在生产环境中使用docker-Compose"><a href="#为什么不建议在生产环境中使用docker-Compose" class="headerlink" title="为什么不建议在生产环境中使用docker-Compose"></a>为什么不建议在生产环境中使用docker-Compose</h3><ul>
<li>多机器如何管理？</li>
<li>如果跨机器做<code>scale</code>横向扩展？</li>
<li>容器失败退出时如何新建容器确保服务正常运行？</li>
<li>如何确保零宕机时间？</li>
<li>如何管理密码，Key等敏感数据？</li>
<li>其它</li>
</ul>
<h3 id="容器编排-swarm"><a href="#容器编排-swarm" class="headerlink" title="容器编排 swarm"></a>容器编排 swarm</h3><p><img src="https://dockertips.readthedocs.io/en/latest/_images/docker-compose_swarm.png" alt="docker-swarm-intro"></p>
<p><code>Swarm</code>的基本架构</p>
<p><img src="https://dockertips.readthedocs.io/en/latest/_images/swarm_arch.png" alt="docker-swarm-arch"></p>
<h3 id="docker-swarm-vs-kubernetes"><a href="#docker-swarm-vs-kubernetes" class="headerlink" title="docker swarm vs kubernetes"></a>docker swarm vs kubernetes</h3><p><code>k8s</code>在容器编排领域处于绝对领先的地位</p>
<h2 id="Swarm-单节点快速上手"><a href="#Swarm-单节点快速上手" class="headerlink" title="Swarm 单节点快速上手"></a>Swarm 单节点快速上手</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>docker info</code> 这个命令可以查看我们的<code>docker engine</code>有没有激活<code>swarm</code>模式， 默认是没有的，我们会看到</p>
<p>激活<code>swarm</code>，有两个方法：</p>
<ul>
<li>初始化一个<code>swarm</code>集群，自己成为<code>manager</code></li>
<li>加入一个已经存在的<code>swarm</code>集群</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> swarm init

PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token operator">></span> <span class="token function">docker</span> swarm init
Swarm initialized: current <span class="token function">node</span> <span class="token punctuation">(</span>vjtstrkxntsacyjtvl18hcbe4<span class="token punctuation">)</span> is now a manager.

To <span class="token function">add</span> a worker to this swarm, run the following command:
<span class="token comment"># 其他节点想要加入 复制这段命令执行即可</span>
    <span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> SWMTKN-1-33ci17l1n34fh6v4r1qq8qmocjo347saeuer2xrxflrn25jgjx-7vphgu8a0gsa4anof6ffrgwqb <span class="token number">192.168</span>.65.3:2377

To <span class="token function">add</span> a manager to this swarm, run <span class="token string">'docker swarm join-token manager'</span> and follow the instructions.

PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token operator">></span> <span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
ID                            <span class="token environment constant">HOSTNAME</span>         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
vjtstrkxntsacyjtvl18hcbe4 *   docker-desktop   Ready     Active         Leader           <span class="token number">20.10</span>.7
PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>Peng Xiao<span class="token punctuation">\</span>code-demo<span class="token operator">></span>

<span class="token comment"># 查看信息</span>
<span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
<span class="token comment"># 一个节点  即是 manage 又是 worker</span>

<span class="token comment"># 退出集群</span>
<span class="token function">docker</span> swarm leave <span class="token parameter variable">--force</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="docker-swarm-init-背后发生了什么"><a href="#docker-swarm-init-背后发生了什么" class="headerlink" title="docker swarm init 背后发生了什么"></a>docker swarm init 背后发生了什么</h3><p>主要是<code>PKI</code>和<code>安全相关</code>的自动化</p>
<ul>
<li>创建<code>swarm</code>集群的根证书</li>
<li><code>manager</code>节点的证书</li>
<li>其它节点加入集群需要的<code>tokens</code></li>
</ul>
<p>创建<code>Raft</code>数据库用于存储证书，配置，密码等数据</p>
<p><code>RAFT</code>相关资料：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> ， <a href="https://raft.github.io/">https://raft.github.io/</a> ，<a href="https://docs.docker.com/engine/swarm/raft/">https://docs.docker.com/engine/swarm/raft/</a></p>
<p>看动画学会 <code>Raft</code> 算法：<a href="https://mp.weixin.qq.com/s/p8qBcIhM04REuQ-uG4gnbw">https://mp.weixin.qq.com/s/p8qBcIhM04REuQ-uG4gnbw</a></p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>创建一个 <code>service</code>, <code>swarm</code> 会帮我们选择创建在哪个 <code>节点</code> 上</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> services create

<span class="token comment"># 创建一个 services， 返回一个ID是 service 的</span>
<span class="token function">docker</span> services create nginx:latest

<span class="token comment"># 查看 service</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>

<span class="token comment"># 查看 service 详细内容，如 运行在哪个节点上</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> 5ph9

<span class="token comment"># 扩展 sevice</span>
<span class="token function">docker</span> <span class="token function">service</span> update 5ph9 <span class="token parameter variable">--replicas</span> <span class="token number">3</span>

<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>

<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> 5ph9

<span class="token comment"># 强制删除容器, swarm 会帮着维护 service ，保持住 扩展的 3 个 replicated</span>
<span class="token function">docker</span> container <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token operator">&lt;</span>Container ID<span class="token operator">></span>

<span class="token comment"># 删除 service， 删除后 swarm 就不会再维护 service 了</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>Service ID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="Swarm-三节点集群搭建"><a href="#Swarm-三节点集群搭建" class="headerlink" title="Swarm 三节点集群搭建"></a>Swarm 三节点集群搭建</h2><p>建<code>3</code>节点<code>swarm cluster</code>的方法</p>
<ul>
<li><a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a> <code>play with docker</code> 网站， 优点是快速方便，缺点是环境不持久，4个小时后环境会被重置</li>
<li>在本地通过虚拟化软件搭建 <code>Linux</code> 虚拟机，优点是稳定，方便，缺点是占用系统资源，需要电脑内存最好8G及其以上</li>
<li>在云上使用<code>云主机</code>， <code>亚马逊</code>，<code>Google</code>，<code>微软Azure</code>，<code>阿里云</code>，<code>腾讯云</code>等，缺点是需要消耗金钱（但是有些云服务，有免费试用）</li>
</ul>
<p>多节点的环境涉及到机器之间的通信需求，所以防火墙和网络安全策略组是大家一定要考虑的问题，特别是在云上使用云主机的情况，下面这些端口记得打开 <code>防火墙</code> 以及 <code>设置安全策略组</code></p>
<ul>
<li>TCP port <code>2376</code></li>
<li>TCP port <code>2377</code></li>
<li>TCP and UDP port <code>7946</code></li>
<li>UDP port <code>4789</code></li>
</ul>
<p>为了简化，以上所有端口都允许节点之间自由访问就行。</p>
<p><code>Warning</code>：请大家注意，请大家使用自己熟悉的方式去创建这样的三节点集群，如果熟悉<code>vagrant</code>和<code>virtualbox</code>，那可以使用我们课程的里方法，如果不熟悉想学习，请参考B站和<code>Youtube</code>视频，我们在课程里不会去讲解 什么是<code>vagrant/virtualbox</code>以及怎么去使用它。</p>
<h3 id="Vagrant-Virtualbox"><a href="#Vagrant-Virtualbox" class="headerlink" title="Vagrant + Virtualbox"></a>Vagrant + Virtualbox</h3><p><code>下载安装 VirtualBox</code> <a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a></p>
<p><code>下载安装 Vagarnt</code> <a href="https://www.vagrantup.com/">https://www.vagrantup.com/</a></p>
<p><code>Vagrant</code>入门系列视频</p>
<p><code>Youtube</code>： <a href="https://www.youtube.com/playlist?list=PLfQqWeOCIH4B6YAEXMr6cx4AfnKNBLbZO">https://www.youtube.com/playlist?list=PLfQqWeOCIH4B6YAEXMr6cx4AfnKNBLbZO</a></p>
<p><code>B站</code>： <a href="https://space.bilibili.com/364122352/channel/detail?cid=174004">https://space.bilibili.com/364122352/channel/detail?cid=174004</a></p>
<p>本节Vagrant搭建的文件下载</p>
<p><a href="https://dockertips.readthedocs.io/en/latest/_downloads/01803e0f19cfb47a524c08f4ed905771/vagrant-setup.zip">Centos 版 vagrant相关文件</a></p>
<p><a href="https://dockertips.readthedocs.io/en/latest/_downloads/b8bf8b42569184d1cae3e4a6987441e4/vagrant-setup-ubuntu.zip">Ubuntu 版 vagrant相关文件</a></p>
<p>Vagrant的基本操作请参考我们的上面的B站或者Youtube视频</p>
<p>虚拟机的启动：<code>vagrant up</code></p>
<p>虚拟机的停止：<code>vagrant halt</code></p>
<p>虚拟机的删除：<code>vagrant destroy</code></p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Manage node</span>
<span class="token function">docker</span> swarm init --advertise-addr <span class="token operator">&lt;</span>IP<span class="token operator">></span>

<span class="token comment"># Worker node1</span>
<span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> <span class="token operator">&lt;</span>token<span class="token operator">></span> <span class="token operator">&lt;</span>IP<span class="token operator">></span>:<span class="token operator">&lt;</span>Port<span class="token operator">></span>

<span class="token comment"># Worker node2</span>
<span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> <span class="token operator">&lt;</span>token<span class="token operator">></span> <span class="token operator">&lt;</span>IP<span class="token operator">></span>:<span class="token operator">&lt;</span>Port<span class="token operator">></span>


<span class="token comment"># Manage node 查看</span>
<span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
<span class="token comment"># Manage node</span>
<span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> web nginx
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
<span class="token comment"># 查看容器创建在哪个 node 上</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> web

<span class="token comment"># Worker node2</span>
<span class="token function">docker</span> container <span class="token function">ls</span>

<span class="token comment"># Manage node ， service 复制</span>
<span class="token function">docker</span> <span class="token function">service</span> update web <span class="token parameter variable">--replicas</span> <span class="token number">3</span>

<span class="token comment"># Manage node</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> web

<span class="token comment"># Manage node， 删除 manage node 上的 nginx 容器， swarm 会快速启动一个，可能会在 其他的 node 上启动，根据调度去启动</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> 4ff
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> web

<span class="token comment"># Manage node，增加或减少 replicated 的数量</span>
<span class="token function">docker</span> <span class="token function">service</span> scale <span class="token assign-left variable">web</span><span class="token operator">=</span><span class="token number">4</span>

<span class="token comment"># Manage node， log 的使用</span>
<span class="token function">docker</span> <span class="token function">service</span> logs web
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Swarm-的-overlay-网络详解"><a href="#Swarm-的-overlay-网络详解" class="headerlink" title="Swarm 的 overlay 网络详解"></a>Swarm 的 overlay 网络详解</h2><p>对于理解<code>swarm</code>的网络来讲，个人认为最重要的两个点：</p>
<ul>
<li>第一是外部如何访问部署运行在<code>swarm</code>集群内的服务，可以称之为 <code>入方向</code> 流量，在<code>swarm</code>里我们通过 <code>ingress</code> 来解决</li>
<li>第二是部署在<code>swarm</code>集群里的服务，如何对外进行访问，这部分又分为两块:<ul>
<li>第一，<code>东西向流量</code> ，也就是不同<code>swarm</code>节点上的容器之间如何通信，<code>swarm</code>通过 <code>overlay</code> 网络来解决；</li>
<li>第二，<code>南北向流量</code> ，也就是<code>swarm</code>集群里的容器如何对外访问，比如互联网，这个是 <code>Linux bridge + iptables NAT</code> 来解决的</li>
</ul>
</li>
</ul>
<h3 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> network create <span class="token parameter variable">-d</span> overlay mynet
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个<code>网络</code>会同步到所有的<code>swarm</code>节点上</p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>创建一个服务连接到这个 <code>overlay</code> 网络， <code>name</code> 是 <code>test</code> ， <code>replicas</code> 是 <code>2</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--network</span> mynet <span class="token parameter variable">--name</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">--replicas</span> <span class="token number">2</span> busybox <span class="token function">ping</span> <span class="token number">8.8</span>.8.8
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> <span class="token builtin class-name">test</span>
ID             NAME      IMAGE            NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
yf5uqm1kzx6d   test.1    busybox:latest   swarm-worker1   Running         Running <span class="token number">18</span> seconds ago
3tmp4cdqfs8a   test.2    busybox:latest   swarm-worker2   Running         Running <span class="token number">18</span> seconds ago
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到这<code>两个容器</code>分别被<code>创建</code>在<code>worker1</code>和<code>worker2</code> 两个节点上</p>
<h3 id="网络查看"><a href="#网络查看" class="headerlink" title="网络查看"></a>网络查看</h3><p>到<code>worker1</code>和<code>worker2</code>上分别<code>查看</code>容器的<code>网络连接情况</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-worker1:~$ <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID   IMAGE            COMMAND          CREATED      STATUS      PORTS     NAMES
cac4be28ced7   busybox:latest   <span class="token string">"ping 8.8.8.8"</span>   <span class="token number">2</span> days ago   Up <span class="token number">2</span> days             test.1.yf5uqm1kzx6dbt7n26e4akhsu
vagrant@swarm-worker1:~$ <span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> cac <span class="token function">sh</span>
/ <span class="token comment"># ip a</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
    valid_lft forever preferred_lft forever
<span class="token number">24</span>: eth0@if25: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1450</span> qdisc noqueue
    link/ether 02:42:0a:00:01:08 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">10.0</span>.1.8/24 brd <span class="token number">10.0</span>.1.255 scope global eth0
    valid_lft forever preferred_lft forever
<span class="token number">26</span>: eth1@if27: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue
    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.18</span>.0.3/16 brd <span class="token number">172.18</span>.255.255 scope global eth1
    valid_lft forever preferred_lft forever
/ <span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个容器有两个接口 <code>eth0</code>和<code>eth1</code>， 其中<code>eth0</code>是连到了<code>mynet</code>这个网络，<code>eth1</code>是连到<code>docker\_gwbridge</code>这个网络</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-worker1:~$ <span class="token function">docker</span> network <span class="token function">ls</span>
NETWORK ID     NAME              DRIVER    SCOPE
a631a4e0b63c   bridge            bridge    <span class="token builtin class-name">local</span>
56945463a582   docker_gwbridge   bridge    <span class="token builtin class-name">local</span>
9bdfcae84f94   <span class="token function">host</span>              <span class="token function">host</span>      <span class="token builtin class-name">local</span>
14fy2l7a4mci   ingress           overlay   swarm
lpirdge00y3j   mynet             overlay   swarm
c1837f1284f8   none              null      <span class="token builtin class-name">local</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个容器里是可以直接<code>ping</code>通<code>worker2</code>上容器的<code>IP</code> <code>10.0.1.9</code>的</p>
<p><img src="https://dockertips.readthedocs.io/en/latest/_images/swarm-overlay.PNG" alt="docker-swarm-overlay"></p>
<h2 id="Swarm-的-ingress网络"><a href="#Swarm-的-ingress网络" class="headerlink" title="Swarm 的 ingress网络"></a>Swarm 的 ingress网络</h2><p><code>docker swarm</code> 的 <code>ingress</code> 网络又叫 <code>Ingress Routing Mesh</code></p>
<p>主要是为了实现把 <code>service</code> 的<code>服务端口</code>对外发布出去，让其能够被外部网络<code>访问</code>到。</p>
<p><code>ingress routing mesh</code> 是 <code>docker swarm</code> 网络里最复杂的一部分内容，包括多方面的内容：</p>
<ul>
<li><code>iptables</code> 的 <code>Destination NAT</code> 流量转发</li>
<li><code>Linux bridge</code>, <code>network namespace</code></li>
<li>使用<code>IPVS</code>技术做负载均衡</li>
<li>包括容器间的通信（<code>overlay</code>）和<code>入方向流量</code>的<code>端口转发</code></li>
</ul>
<h3 id="service创建"><a href="#service创建" class="headerlink" title="service创建"></a>service创建</h3><p>·<br>创建一个 <code>service</code> ，指定网络是 <code>overlay</code> 的 <code>mynet</code> ， 通过 <code>-p</code> 把端口<code>映射</code>出来<br>·<br>我们使用的镜像 <code>containous/whoami</code> 是一个简单的<code>web服务</code>，能返回服务器的 <code>hostname</code> ，和<code>基本的网络信息</code>，比如<code>IP地址</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> web <span class="token parameter variable">--network</span> mynet <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 <span class="token parameter variable">--replicas</span> <span class="token number">2</span> containous/whoami
a9cn3p0ovg5jcz30rzz89lyfz
overall progress: <span class="token number">2</span> out of <span class="token number">2</span> tasks
<span class="token number">1</span>/2: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token number">2</span>/2: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME      MODE         REPLICAS   IMAGE                      PORTS
a9cn3p0ovg5j   web       replicated   <span class="token number">2</span>/2        containous/whoami:latest   *:8080-<span class="token operator">></span><span class="token number">80</span>/tcp
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> web
ID             NAME      IMAGE                      NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
udlzvsraha1x   web.1     containous/whoami:latest   swarm-worker1   Running         Running <span class="token number">16</span> seconds ago
mms2c65e5ygt   web.2     containous/whoami:latest   swarm-manager   Running         Running <span class="token number">16</span> seconds ago
vagrant@swarm-manager:~$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="service的访问"><a href="#service的访问" class="headerlink" title="service的访问"></a>service的访问</h3><p><code>8080</code>这个端口到底映射到哪里了？尝试三个<code>swarm</code>节点的<code>IP</code>加端口<code>8080</code></p>
<p>可以看到三个节点<code>IP</code>都可以访问，并且回应的容器是不同的（<code>hostname</code>），也就是有负载均衡的效果</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">192.168</span>.200.10:8080
Hostname: fdf7c1354507
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.0.7
IP: <span class="token number">172.18</span>.0.3
IP: <span class="token number">10.0</span>.1.14
RemoteAddr: <span class="token number">10.0</span>.0.2:36828
GET / HTTP/1.1
Host: <span class="token number">192.168</span>.200.10:8080
User-Agent: curl/7.68.0
Accept: */*

vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">192.168</span>.200.11:8080
Hostname: fdf7c1354507
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.0.7
IP: <span class="token number">172.18</span>.0.3
IP: <span class="token number">10.0</span>.1.14
RemoteAddr: <span class="token number">10.0</span>.0.3:54212
GET / HTTP/1.1
Host: <span class="token number">192.168</span>.200.11:8080
User-Agent: curl/7.68.0
Accept: */*

vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">192.168</span>.200.12:8080
Hostname: c83ee052787a
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.0.6
IP: <span class="token number">172.18</span>.0.3
IP: <span class="token number">10.0</span>.1.13
RemoteAddr: <span class="token number">10.0</span>.0.4:49820
GET / HTTP/1.1
Host: <span class="token number">192.168</span>.200.12:8080
User-Agent: curl/7.68.0
Accept: */*
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://dockertips.readthedocs.io/en/latest/_images/swarm-ingress-logic.PNG" alt="docker-swarm-ingress-logic"></p>
<h3 id="ingress-数据包的走向"><a href="#ingress-数据包的走向" class="headerlink" title="ingress 数据包的走向"></a>ingress 数据包的走向</h3><p>以 <code>manager</code> 节点为例，数据到底是如何达到<code>service</code>的<code>container</code>的</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-nvL</span> <span class="token parameter variable">-t</span> nat
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">388</span> packets, <span class="token number">35780</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
<span class="token number">296</span> <span class="token number">17960</span> DOCKER-INGRESS  all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            ADDRTYPE match dst-type LOCAL
<span class="token number">21365</span> 1282K DOCKER     all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">388</span> packets, <span class="token number">35780</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">340</span> packets, <span class="token number">20930</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">8</span>   <span class="token number">590</span> DOCKER-INGRESS  all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            ADDRTYPE match dst-type LOCAL
    <span class="token number">1</span>    <span class="token number">60</span> DOCKER     all  --  *      *       <span class="token number">0.0</span>.0.0/0           <span class="token operator">!</span><span class="token number">127.0</span>.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">340</span> packets, <span class="token number">20930</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">2</span>   <span class="token number">120</span> MASQUERADE  all  --  *      docker_gwbridge  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            ADDRTYPE match src-type LOCAL
    <span class="token number">3</span>   <span class="token number">252</span> MASQUERADE  all  --  *      <span class="token operator">!</span>docker0  <span class="token number">172.17</span>.0.0/16        <span class="token number">0.0</span>.0.0/0
    <span class="token number">0</span>     <span class="token number">0</span> MASQUERADE  all  --  *      <span class="token operator">!</span>docker_gwbridge  <span class="token number">172.18</span>.0.0/16        <span class="token number">0.0</span>.0.0/0

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">0</span>     <span class="token number">0</span> RETURN     all  --  docker0 *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0
    <span class="token number">0</span>     <span class="token number">0</span> RETURN     all  --  docker_gwbridge *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0

Chain DOCKER-INGRESS <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">2</span>   <span class="token number">120</span> DNAT       tcp  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8080 to:172.18.0.2:8080
<span class="token number">302</span> <span class="token number">18430</span> RETURN     all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>iptables</code>，可以看到一条<code>DNAT</code>的规则，<code>所有访问</code>本地<code>8080</code>端口的流量都被<code>转发</code>到<code> 172.18.0.2:8080</code></p>
<p>那这个 <code>172.18.0.2</code> 是什么？</p>
<p>首先　<code>172.18.0.0/16</code>　这个网段是 <code>docker_gwbridge</code> 的，所以这个地址肯定是连在了 <code>docker_gwbridge</code> 上。</p>
<p><code>docker network inspect docker_gwbridge</code> 可以看到这个网络连接了一个叫　<code>ingress-sbox</code>　的容器。它的地址就是　172.18.0.2&#x2F;16</p>
<p>这个　<code>ingress-sbox</code>　其实并不是一个容器，而是一个网络的命名空间　<code>network namespace</code>,　我们可以通过下面的方式进入到这个命名空间</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$　<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">-v</span> /var/run/docker/netns:/netns <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true nicolaka/netshoot nsenter <span class="token parameter variable">--net</span><span class="token operator">=</span>/netns/ingress_sbox <span class="token function">sh</span>
~ <span class="token comment"># ip a</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">8</span>: eth0@if9: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1450</span> qdisc noqueue state UP group default
    link/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">10.0</span>.0.2/24 brd <span class="token number">10.0</span>.0.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet <span class="token number">10.0</span>.0.5/32 scope global eth0
       valid_lft forever preferred_lft forever
<span class="token number">10</span>: eth1@if11: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">1</span>
    inet <span class="token number">172.18</span>.0.2/16 brd <span class="token number">172.18</span>.255.255 scope global eth1
       valid_lft forever preferred_lft forever
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过查看地址，发现这个命名空间连接了两个网络，一个<code>eth1</code>是连接了　<code>docker_gwbridge</code>　，另外一个<code>eth0</code>连接了　<code>ingress</code> 这个网络。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~ <span class="token comment"># ip route</span>
default via <span class="token number">172.18</span>.0.1 dev eth1
<span class="token number">10.0</span>.0.0/24 dev eth0 proto kernel scope <span class="token function">link</span> src <span class="token number">10.0</span>.0.2
<span class="token number">172.18</span>.0.0/16 dev eth1 proto kernel scope <span class="token function">link</span> src <span class="token number">172.18</span>.0.2

~ <span class="token comment"># iptables -nvL -t mangle</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">22</span> packets, <span class="token number">2084</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
   <span class="token number">12</span>   <span class="token number">806</span> MARK       tcp  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8080 MARK <span class="token builtin class-name">set</span> 0x100

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">14</span> packets, <span class="token number">1038</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
    <span class="token number">0</span>     <span class="token number">0</span> MARK       all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">10.0</span>.0.5             MARK <span class="token builtin class-name">set</span> 0x100

Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT <span class="token number">8</span> packets, <span class="token number">1046</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">14</span> packets, <span class="token number">940</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">22</span> packets, <span class="token number">1986</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
~ <span class="token comment"># ipvsadm</span>
IP Virtual Server version <span class="token number">1.2</span>.1 <span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">)</span>
Prot LocalAddress:Port Scheduler Flags
  -<span class="token operator">></span> RemoteAddress:Port           Forward Weight ActiveConn InActConn
FWM  <span class="token number">256</span> rr
  -<span class="token operator">></span> <span class="token number">10.0</span>.0.6:0                   Masq    <span class="token number">1</span>      <span class="token number">0</span>          <span class="token number">0</span>
  -<span class="token operator">></span> <span class="token number">10.0</span>.0.7:0                   Masq    <span class="token number">1</span>      <span class="token number">0</span>          <span class="token number">0</span>
~ <span class="token comment">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>ipvs</code>做了负载均衡</p>
<p><img src="https://dockertips.readthedocs.io/en/latest/_images/routing-mesh.PNG" alt="docker-swarm-routing-mesh"></p>
<p>关于这里的负载均衡</p>
<ul>
<li>这是一个<code>stateless load balancing</code></li>
<li>这是三层的负载均衡，不是四层的 <code>LB is at OSI Layer 3 (TCP), not Layer 4 (DNS)</code></li>
<li>以上两个限制可以通过<code>Nginx</code>或者<code>HAProxy LB proxy</code>解决 （<a href="https://docs.docker.com/engine/swarm/ingress/">https://docs.docker.com/engine/swarm/ingress/</a>）</li>
</ul>
<h2 id="内部负载均衡和-VIP"><a href="#内部负载均衡和-VIP" class="headerlink" title="内部负载均衡和 VIP"></a>内部负载均衡和 VIP</h2><p>创建一个 <code>mynet</code> 的 <code>overlay</code> 网络，创建一个 <code>service</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> network <span class="token function">ls</span>
NETWORK ID     NAME              DRIVER    SCOPE
afc8f54c1d07   bridge            bridge    <span class="token builtin class-name">local</span>
128fd1cb0fae   docker_gwbridge   bridge    <span class="token builtin class-name">local</span>
0ea68b0d28b9   <span class="token function">host</span>              <span class="token function">host</span>      <span class="token builtin class-name">local</span>
14fy2l7a4mci   ingress           overlay   swarm
lpirdge00y3j   mynet             overlay   swarm
a8edf1804fb6   none              null      <span class="token builtin class-name">local</span>
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> web <span class="token parameter variable">--network</span> mynet <span class="token parameter variable">--replicas</span> <span class="token number">2</span> containous/whoami
jozc1x1c1zpyjl9b5j5abzm0g
overall progress: <span class="token number">2</span> out of <span class="token number">2</span> tasks
<span class="token number">1</span>/2: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token number">2</span>/2: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME      MODE         REPLICAS   IMAGE                      PORTS
jozc1x1c1zpy   web       replicated   <span class="token number">2</span>/2        containous/whoami:latest
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> web
ID             NAME      IMAGE                      NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
pwi87g86kbxd   web.1     containous/whoami:latest   swarm-worker1   Running         Running <span class="token number">47</span> seconds ago
xbri2akxy2e8   web.2     containous/whoami:latest   swarm-worker2   Running         Running <span class="token number">44</span> seconds ago
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>client</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> client <span class="token parameter variable">--network</span> mynet xiaopeng163/net-box:latest <span class="token function">ping</span> <span class="token number">8.8</span>.8.8
skbcdfvgidwafbm4nciq82env
overall progress: <span class="token number">1</span> out of <span class="token number">1</span> tasks
<span class="token number">1</span>/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME      MODE         REPLICAS   IMAGE                        PORTS
skbcdfvgidwa   client    replicated   <span class="token number">1</span>/1        xiaopeng163/net-box:latest
jozc1x1c1zpy   web       replicated   <span class="token number">2</span>/2        containous/whoami:latest
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> client
ID             NAME       IMAGE                        NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
sg9b3dqrgru4   client.1   xiaopeng163/net-box:latest   swarm-manager   Running         Running <span class="token number">28</span> seconds ago
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>尝试进入<code>client</code>这个容器，去<code>ping</code> <code>web</code> 这个<code>service name</code>， 获取到的<code>IP</code> <code>10.0.1.30</code>，称之为<code>VIP</code>（虚拟IP）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID   IMAGE                        COMMAND          CREATED          STATUS          PORTS     NAMES
36dce35d56e8   xiaopeng163/net-box:latest   <span class="token string">"ping 8.8.8.8"</span>   <span class="token number">19</span> minutes ago   Up <span class="token number">19</span> minutes             client.1.sg9b3dqrgru4f14k2tpxzg2ei
vagrant@swarm-manager:~$ <span class="token function">docker</span> container <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 36dc <span class="token function">sh</span>
/omd <span class="token comment"># curl web</span>
Hostname: 6039865a1e5d
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.1.32
IP: <span class="token number">172.18</span>.0.3
RemoteAddr: <span class="token number">10.0</span>.1.37:40972
GET / HTTP/1.1
Host: web
User-Agent: curl/7.69.1
Accept: */*

/omd <span class="token comment"># curl web</span>
Hostname: c3b3e99b9bb1
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.1.31
IP: <span class="token number">172.18</span>.0.3
RemoteAddr: <span class="token number">10.0</span>.1.37:40974
GET / HTTP/1.1
Host: web
User-Agent: curl/7.69.1
Accept: */*

/omd <span class="token comment"># curl web</span>
Hostname: 6039865a1e5d
IP: <span class="token number">127.0</span>.0.1
IP: <span class="token number">10.0</span>.1.32
IP: <span class="token number">172.18</span>.0.3
RemoteAddr: <span class="token number">10.0</span>.1.37:40976
GET / HTTP/1.1
Host: web
User-Agent: curl/7.69.1
Accept: */*

/omd <span class="token comment">#</span>
/omd <span class="token comment"># ping web -c 2</span>
PING web <span class="token punctuation">(</span><span class="token number">10.0</span>.1.30<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes
<span class="token number">64</span> bytes from <span class="token number">10.0</span>.1.30: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.044</span> ms
<span class="token number">64</span> bytes from <span class="token number">10.0</span>.1.30: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.071</span> ms

--- web <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> packets received, <span class="token number">0</span>% packet loss
round-trip min/avg/max <span class="token operator">=</span> <span class="token number">0.044</span>/0.057/0.071 ms
/omd <span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个<code>虚拟IP</code>在一个特殊的网络命令空间里，这个空间连接在我们的<code>mynet</code>这个<code>overlay</code>的网络上</p>
<p>通过<code> docker network inspect mynet</code> 可以看到这个命名空间，叫 <code>lb-mynet</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"Containers"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
<span class="token string">"36dce35d56e87d43d08c5b9a94678fe789659cb3b1a5c9ddccd7de4b26e8d588"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"client.1.sg9b3dqrgru4f14k2tpxzg2ei"</span>,
    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"e8972d0091afaaa091886799aca164b742ca93408377d9ee599bdf91188416c1"</span>,
    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:0a:00:01:24"</span>,
    <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"10.0.1.36/24"</span>,
    <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>
<span class="token punctuation">&#125;</span>,
<span class="token string">"lb-mynet"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mynet-endpoint"</span>,
    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"e299d083b25a1942f6e0f7989436c3c3e8d79c7395a80dd50b7709825022bfac"</span>,
    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:0a:00:01:25"</span>,
    <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"10.0.1.37/24"</span>,
    <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过下面的命令，找到这个命名空间的名字</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">sudo</span> <span class="token function">ls</span> /var/run/docker/netns/
<span class="token number">1</span>-14fy2l7a4m  <span class="token number">1</span>-lpirdge00y  dfb766d83076  ingress_sbox  lb_lpirdge00
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>名字叫 <code>lb_lpirdge00</code></p>
<p>通过 <code>nsenter</code> 进入到这个命名空间的<code>sh</code>里， 可以看到刚才的<code>VIP</code>地址 <code>10.0.1.30</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">sudo</span> nsenter <span class="token parameter variable">--net</span><span class="token operator">=</span>/var/run/docker/netns/lb_lpirdge00 <span class="token function">sh</span>
<span class="token comment">#</span>
<span class="token comment"># ip a</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
    valid_lft forever preferred_lft forever
<span class="token number">50</span>: eth0@if51: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1450</span> qdisc noqueue state UP group default
    link/ether 02:42:0a:00:01:25 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">10.0</span>.1.37/24 brd <span class="token number">10.0</span>.1.255 scope global eth0
    valid_lft forever preferred_lft forever
    inet <span class="token number">10.0</span>.1.30/32 scope global eth0
    valid_lft forever preferred_lft forever
    inet <span class="token number">10.0</span>.1.35/32 scope global eth0
    valid_lft forever preferred_lft forever
<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和 <code>ingress</code> 网络一样，可以查看 <code>iptables</code>，<code>ipvs</code>的负载均衡， 基本就可以理解负载均衡是怎么一回事了。 <code>Mark=0x106</code>, 也就是<code>262</code>（十进制），会轮询把请求发给 <code>10.0.1.31</code> 和 <code>10.0.1.32</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># iptables -nvL -t mangle</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">128</span> packets, <span class="token number">11198</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">92</span> packets, <span class="token number">6743</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
<span class="token number">72</span>  <span class="token number">4995</span> MARK       all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">10.0</span>.1.30            MARK <span class="token builtin class-name">set</span> 0x106
    <span class="token number">0</span>     <span class="token number">0</span> MARK       all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">10.0</span>.1.35            MARK <span class="token builtin class-name">set</span> 0x107

Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT <span class="token number">36</span> packets, <span class="token number">4455</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">101</span> packets, <span class="token number">7535</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">128</span> packets, <span class="token number">11198</span> bytes<span class="token punctuation">)</span>
pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
<span class="token comment"># ipvsadm</span>
IP Virtual Server version <span class="token number">1.2</span>.1 <span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">)</span>
Prot LocalAddress:Port Scheduler Flags
-<span class="token operator">></span> RemoteAddress:Port           Forward Weight ActiveConn InActConn
FWM  <span class="token number">262</span> rr
-<span class="token operator">></span> <span class="token number">10.0</span>.1.31:0                  Masq    <span class="token number">1</span>      <span class="token number">0</span>          <span class="token number">0</span>
-<span class="token operator">></span> <span class="token number">10.0</span>.1.32:0                  Masq    <span class="token number">1</span>      <span class="token number">0</span>          <span class="token number">0</span>
FWM  <span class="token number">263</span> rr
-<span class="token operator">></span> <span class="token number">10.0</span>.1.36:0                  Masq    <span class="token number">1</span>      <span class="token number">0</span>          <span class="token number">0</span>
<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个流量会走我们的 <code>mynet</code> 这个 <code>overlay</code> 网络。</p>
<h2 id="部署多-service-应用"><a href="#部署多-service-应用" class="headerlink" title="部署多 service 应用"></a>部署多 service 应用</h2><p>如何像<code>docker-compose</code>一样部署多服务应用，这一节我们先看手动的方式</p>
<p>本节课所用的源码文件 <a href="https://github.com/xiaopeng163/flask-redis">https://github.com/xiaopeng163/flask-redis</a></p>
<p>创建一个<code>mynet</code>的<code>overlay</code>网络</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> network <span class="token function">ls</span>
NETWORK ID     NAME              DRIVER    SCOPE
afc8f54c1d07   bridge            bridge    <span class="token builtin class-name">local</span>
128fd1cb0fae   docker_gwbridge   bridge    <span class="token builtin class-name">local</span>
0ea68b0d28b9   <span class="token function">host</span>              <span class="token function">host</span>      <span class="token builtin class-name">local</span>
14fy2l7a4mci   ingress           overlay   swarm
lpirdge00y3j   mynet             overlay   swarm
a8edf1804fb6   none              null      <span class="token builtin class-name">local</span>
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>redis</code>的<code>service</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--network</span> mynet <span class="token parameter variable">--name</span> redis redis:latest redis-server <span class="token parameter variable">--requirepass</span> ABC123
qh3nfeth3wc7uoz9ozvzta5ea
overall progress: <span class="token number">1</span> out of <span class="token number">1</span> tasks
<span class="token number">1</span>/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> servce <span class="token function">ls</span>
docker: <span class="token string">'servce'</span> is not a <span class="token function">docker</span> command.
See <span class="token string">'docker --help'</span>
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME      MODE         REPLICAS   IMAGE          PORTS
qh3nfeth3wc7   redis     replicated   <span class="token number">1</span>/1        redis:latest
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> redis
ID             NAME      IMAGE          NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
111cpkjn4a0k   redis.1   redis:latest   swarm-worker2   Running         Running <span class="token number">19</span> seconds ago
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>flask</code>的<code>service</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--network</span> mynet <span class="token parameter variable">--name</span> flask <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_HOST</span><span class="token operator">=</span>redis <span class="token parameter variable">--env</span> <span class="token assign-left variable">REDIS_PASS</span><span class="token operator">=</span>ABC123 <span class="token parameter variable">-p</span> <span class="token number">8080</span>
:5000 xiaopeng163/flask-redis:latest
y7garhvlxah592j5lmqv8a3xj
overall progress: <span class="token number">1</span> out of <span class="token number">1</span> tasks
<span class="token number">1</span>/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME      MODE         REPLICAS   IMAGE                            PORTS
y7garhvlxah5   flask     replicated   <span class="token number">1</span>/1        xiaopeng163/flask-redis:latest   *:8080-<span class="token operator">></span><span class="token number">5000</span>/tcp
qh3nfeth3wc7   redis     replicated   <span class="token number">1</span>/1        redis:latest
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> flask
ID             NAME      IMAGE                            NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
quptcq7vb48w   flask.1   xiaopeng163/flask-redis:latest   swarm-worker1   Running         Running <span class="token number">15</span> seconds ago
vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">1</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is d4de54036614.
vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">2</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is d4de54036614.
vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">3</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is d4de54036614.
vagrant@swarm-manager:~$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">4</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is d4de54036614.
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="swarm-stack-部署多-service-应用"><a href="#swarm-stack-部署多-service-应用" class="headerlink" title="swarm stack 部署多 service 应用"></a>swarm stack 部署多 service 应用</h2><p>先在 <code>swarm manager</code> 节点上安装一下 <code>docker-compose</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">sudo</span> <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token string">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">)</span></span>"</span> <span class="token parameter variable">-o</span> usr/local/bin/docker-compose
vagrant@swarm-manager:~$ <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>clone</code> 我们的代码仓库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">git</span> clone https://github.com/xiaopeng163/flask-redis
Cloning into <span class="token string">'flask-redis'</span><span class="token punctuation">..</span>.
remote: Enumerating objects: <span class="token number">22</span>, done.
remote: Counting objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">22</span>/22<span class="token punctuation">)</span>, done.
remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">19</span>/19<span class="token punctuation">)</span>, done.
remote: Total <span class="token number">22</span> <span class="token punctuation">(</span>delta <span class="token number">9</span><span class="token punctuation">)</span>, reused <span class="token number">7</span> <span class="token punctuation">(</span>delta <span class="token number">2</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>
Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">22</span>/22<span class="token punctuation">)</span>, <span class="token number">8.60</span> KiB <span class="token operator">|</span> <span class="token number">1.07</span> MiB/s, done.
vagrant@swarm-manager:~$ <span class="token builtin class-name">cd</span> flask-redis
vagrant@swarm-manager:~/flask-redis$ <span class="token function">ls</span>
Dockerfile  LICENSE  README.md  app.py  docker-compose.yml
vagrant@swarm-manager:~/flask-redis$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>环境清理</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> system prune <span class="token parameter variable">-a</span> <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>镜像构建和提交， 如果你想做这一步，可以把 <code>docker-compose.yml</code> 里的  <code>xiaopeng163/flask-redis</code> 改成你的<code>dockerhub id</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker-compose</span> build
vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                TAG          IMAGE ID       CREATED         SIZE
xiaopeng163/flask-redis   latest       5efb4fcbcfc3   <span class="token number">6</span> seconds ago   126MB
python                    <span class="token number">3.9</span>.5-slim   c71955050276   <span class="token number">3</span> weeks ago     115MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>提交镜像到<code>dockerhub</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, <span class="token function">head</span> over to https://hub.docker.com to create one.
Username: xiaopeng163
Password:
WARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /home/vagrant/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/<span class="token comment">#credentials-store</span>

Login Succeeded
vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker-compose</span> push
WARNING: The REDIS_PASSWORD variable is not set. Defaulting to a blank string.
Pushing flask <span class="token punctuation">(</span>xiaopeng163/flask-redis:latest<span class="token punctuation">)</span><span class="token punctuation">..</span>.
The push refers to repository <span class="token punctuation">[</span>docker.io/xiaopeng163/flask-redis<span class="token punctuation">]</span>
f447d33c161b: Pushed
f7395da2fd9c: Pushed
5b156295b5a3: Layer already exists
115e0863702d: Layer already exists
e10857b94a57: Layer already exists
8d418cbfaf25: Layer already exists
764055ebc9a7: Layer already exists
latest: digest: sha256:c909100fda2f4160b593b4e0fb692b89046cebb909ae90546627deca9827b676 size: <span class="token number">1788</span>
vagrant@swarm-manager:~/flask-redis$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>通过<code>stack</code>启动服务</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~/flask-redis$ <span class="token function">env</span> <span class="token assign-left variable">REDIS_PASSWORD</span><span class="token operator">=</span>ABC123 <span class="token function">docker</span> stack deploy --compose-file docker-compose.yml flask-demo
Ignoring unsupported options: build

Creating network flask-demo_default
Creating <span class="token function">service</span> flask-demo_flask
Creating <span class="token function">service</span> flask-demo_redis-server
vagrant@swarm-manager:~/flask-redis$
vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> stack <span class="token function">ls</span>
NAME         SERVICES   ORCHESTRATOR
flask-demo   <span class="token number">2</span>          Swarm
vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> stack <span class="token function">ps</span> flask-demo
ID             NAME                        IMAGE                            NODE            DESIRED STATE   CURRENT STATE
ERROR     PORTS
lzm6i9inoa8e   flask-demo_flask.1          xiaopeng163/flask-redis:latest   swarm-manager   Running         Running <span class="token number">23</span> seconds ago

ejojb0o5lbu0   flask-demo_redis-server.1   redis:latest                     swarm-worker2   Running         Running <span class="token number">21</span> seconds ago

vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> stack services flask-demo
ID             NAME                      MODE         REPLICAS   IMAGE                            PORTS
mpx75z1rrlwn   flask-demo_flask          replicated   <span class="token number">1</span>/1        xiaopeng163/flask-redis:latest   *:8080-<span class="token operator">></span><span class="token number">5000</span>/tcp
z85n16zsldr1   flask-demo_redis-server   replicated   <span class="token number">1</span>/1        redis:latest
vagrant@swarm-manager:~/flask-redis$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME                      MODE         REPLICAS   IMAGE                            PORTS
mpx75z1rrlwn   flask-demo_flask          replicated   <span class="token number">1</span>/1        xiaopeng163/flask-redis:latest   *:8080-<span class="token operator">></span><span class="token number">5000</span>/tcp
z85n16zsldr1   flask-demo_redis-server   replicated   <span class="token number">1</span>/1        redis:latest
vagrant@swarm-manager:~/flask-redis$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">1</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is 21d63a8bfb57.
vagrant@swarm-manager:~/flask-redis$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">2</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is 21d63a8bfb57.
vagrant@swarm-manager:~/flask-redis$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Hello Container World<span class="token operator">!</span> I have been seen <span class="token number">3</span> <span class="token builtin class-name">times</span> and my <span class="token function">hostname</span> is 21d63a8bfb57.
vagrant@swarm-manager:~/flask-redis$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="在-swarm-中使用-secret"><a href="#在-swarm-中使用-secret" class="headerlink" title="在 swarm 中使用 secret"></a>在 swarm 中使用 secret</h2><h3 id="创建secret"><a href="#创建secret" class="headerlink" title="创建secret"></a>创建secret</h3><p>有两种方式</p>
<h4 id="从标准的收入读取"><a href="#从标准的收入读取" class="headerlink" title="从标准的收入读取"></a>从标准的收入读取</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token builtin class-name">echo</span> abc123 <span class="token operator">|</span> <span class="token function">docker</span> secret create mysql_pass -
4nkx3vpdd41tbvl9qs24j7m6w
vagrant@swarm-manager:~$ <span class="token function">docker</span> secret <span class="token function">ls</span>
ID                          NAME         DRIVER    CREATED         UPDATED
4nkx3vpdd41tbvl9qs24j7m6w   mysql_pass             <span class="token number">8</span> seconds ago   <span class="token number">8</span> seconds ago
vagrant@swarm-manager:~$ <span class="token function">docker</span> secret inspect mysql_pass
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"ID"</span><span class="token builtin class-name">:</span> <span class="token string">"4nkx3vpdd41tbvl9qs24j7m6w"</span>,
        <span class="token string">"Version"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Index"</span><span class="token builtin class-name">:</span> <span class="token number">4562</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-25T22:36:51.544523646Z"</span>,
        <span class="token string">"UpdatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-25T22:36:51.544523646Z"</span>,
        <span class="token string">"Spec"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mysql_pass"</span>,
            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
vagrant@swarm-manager:~$ <span class="token function">docker</span> secret <span class="token function">rm</span> mysql_pass
mysql_pass
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">ls</span>
mysql_pass.txt
vagrant@swarm-manager:~$ <span class="token function">more</span> mysql_pass.txt
abc123
vagrant@swarm-manager:~$ <span class="token function">docker</span> secret create mysql_pass mysql_pass.txt
elsodoordd7zzpgsdlwgynq3f
vagrant@swarm-manager:~$ <span class="token function">docker</span> secret inspect mysql_pass
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"ID"</span><span class="token builtin class-name">:</span> <span class="token string">"elsodoordd7zzpgsdlwgynq3f"</span>,
        <span class="token string">"Version"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Index"</span><span class="token builtin class-name">:</span> <span class="token number">4564</span>
        <span class="token punctuation">&#125;</span>,
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-25T22:38:14.143954043Z"</span>,
        <span class="token string">"UpdatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-07-25T22:38:14.143954043Z"</span>,
        <span class="token string">"Spec"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mysql_pass"</span>,
            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span>
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="secret-的使用"><a href="#secret-的使用" class="headerlink" title="secret 的使用"></a>secret 的使用</h3><p>参考 <a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> mysql-demo <span class="token parameter variable">--secret</span> mysql_pass <span class="token parameter variable">--env</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD_FILE</span><span class="token operator">=</span>/run/secrets/mysql_pass mysql:5.7
wb4z2ximgqaefephu9f4109c7
overall progress: <span class="token number">1</span> out of <span class="token number">1</span> tasks
<span class="token number">1</span>/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>
verify: Service converged
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>
ID             NAME         MODE         REPLICAS   IMAGE       PORTS
wb4z2ximgqae   mysql-demo   replicated   <span class="token number">1</span>/1        mysql:5.7
vagrant@swarm-manager:~$ <span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> mysql-demo
ID             NAME           IMAGE       NODE            DESIRED STATE   CURRENT STATE            ERROR     PORTS
909429p4uovy   mysql-demo.1   mysql:5.7   swarm-worker2   Running         Running <span class="token number">32</span> seconds ago
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="swarm-使用-local-volume"><a href="#swarm-使用-local-volume" class="headerlink" title="swarm 使用 local volume"></a>swarm 使用 local volume</h2><p>docker-compose.yml</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">"3.8"</span>

services:
  db:
    image: mysql:5.7
    environment:
      - <span class="token assign-left variable">MYSQL_ROOT_PASSWORD_FILE</span><span class="token operator">=</span>/run/secrets/mysql_pass
    secrets:
      - mysql_pass
    volumes:
      - data:/var/lib/mysql

volumes:
  data:

secrets:
  mysql_pass:
    file: mysql_pass.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>mysql_pass.txt</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant@swarm-manager:~$ <span class="token function">more</span> mysql_pass.txt
abc123
vagrant@swarm-manager:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
        <tag>Docker Composer</tag>
        <tag>Swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>Curl 命令详解教程</title>
    <url>//post/2023-curl-curl-dc.html</url>
    <content><![CDATA[<p><code>Curl</code> 提供了许多选项，使您可以恢复上传&#x2F;下载，限制带宽，代理支持，用户身份验证等。</p>
<p>在本教程中，我们将说明如何在 <code>Linux</code> 使用 <code>Curl</code> 命令下载文件及其选项的详解。如果您未指定使用的协议，<code>Curl</code> 默认使用 <code>HTTP</code> 协议。</p>
<span id="more"></span>

<h2 id="Curl-命令与选项"><a href="#Curl-命令与选项" class="headerlink" title="Curl 命令与选项"></a>Curl 命令与选项</h2><p><code>curl</code>命令的语法形式是<code>curl [options] [URL...]</code>，<code>options</code> <code>Curl</code> 的<a href="https://curl.haxx.se/docs/manpage.html">选项</a>，可选参数。<code>URL</code>表示远程服务器的地址。</p>
<p>在不指定任何选项运行 <code>Curl</code> 命令时，<code>curl</code> 命令下载指定的 <code>URL</code> 资源并重定向到<a href="https://www.myfreax.com/stdout-stdin-and-redirection/">标准输出</a>。</p>
<p>例如命令<code>curl https://www.google.com/</code>下载 <code>Google</code> 首页并在终端打印 <code>Google</code> 首页的<code>源码</code>。</p>
<h2 id="发送-JSON-Body"><a href="#发送-JSON-Body" class="headerlink" title="发送 JSON Body"></a>发送 JSON Body</h2><p>在发送 <code>JSON Body</code> 到服务器时，你需要设置 <code>header</code> 的<code>Content-Type</code>为<code>application/json</code>，指示 <code>Curl</code> 命令以 <code>JSON</code> 的格式发送 <code>Body</code> 的数据。</p>
<p>除了设置 <code>header</code> 的<code>Content-Type</code>之外，还需要使用 <code>Curl</code> 命令的<code>-d</code>&#x2F;<code>--data</code>指定要发送的 <code>JSON 字符串</code>，注意 <code>JSON</code> 需要使用<code>单引号</code>转义。</p>
<p>例如命令<code>curl -X POST -H &quot;Content-Type: application/json&quot;  -d &#39;JSON String&#39; URL</code>发送 <code> JSON 字符串</code> <code>&#123;&quot;email&quot;:&quot;web@myfreax.com&quot;&#125; </code>到服务器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/json"</span>  <span class="token parameter variable">-d</span> <span class="token string">'&#123;"email":"web@myfreax.com","website":"myfreax.com"&#125;'</span> http://127.0.0.1:3000/site<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="POST-JSON-并上传文件"><a href="#POST-JSON-并上传文件" class="headerlink" title="POST JSON 并上传文件"></a>POST JSON 并上传文件</h2><p>在发送 <code>JSON</code> 数据并上传文件到服务器时，需要设置 <code>header</code> 的 <code>Content-Type</code> 为 <code>multipart/mixed</code>，指示 <code>Curl</code> 命令以混合的格式发送数据。</p>
<p>除了设置 <code>header</code> 的 <code>Content-Type</code> 之外，发送 <code>JSON</code> 格式数据是以 <code>Curl</code> 命令的 <code>-F</code> 选项指定要发送的 <code>JSON</code> 字符串，注意 <code>JSON</code> 需要使用<code>单引号</code>转义。</p>
<p>因此命令最终形式是 <code>curl -X POST -H &quot;Content-Type: multipart/mixed&quot; -F blob=@文件路径 -F &#39;metadata=JSON 字符串;type=application/json&#39;</code> 。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: multipart/mixed"</span> <span class="token parameter variable">-F</span> <span class="token string">"blob=@/Users/username/Documents/bio.jpg"</span> <span class="token parameter variable">-F</span> <span class="token string">"metadata=&#123;<span class="token entity" title="\&quot;">\"</span>edipi<span class="token entity" title="\&quot;">\"</span>:123456789&#125;;type=application/json"</span> http://localhost:8080/api/v1/user/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="仅上传文件"><a href="#仅上传文件" class="headerlink" title="仅上传文件"></a>仅上传文件</h2><p>要使用 <code>Curl</code> 命令上传文件，只需要仅使用 <code>Curl</code> 命令的 <code>-F</code> 选项以键值对的形式 <code>name=content</code> 指定 <code>multipart MIME</code> 数据。</p>
<p>但在使用 <code>-F</code> 选项指定文件时，需要在文件路径之前添加<code>@</code>符号。文件可以是<code>任何类型文件</code>包括<code>图像</code>，<code>文档</code>等。</p>
<p>例如参数 <code>-F &#39;image=@/home/user/Pictures/wallpaper.jpg&#39;</code> 指定 <code>Key</code> 是 <code>image</code> ，文件是 <code>/home/user/Pictures/wallpaper.jpg</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-F</span> <span class="token string">'image=@/home/user/Pictures/wallpaper.jpg'</span> http://example.com/upload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="HTML-表单-multipart-x2F-form-data"><a href="#HTML-表单-multipart-x2F-form-data" class="headerlink" title="HTML 表单 multipart&#x2F;form-data"></a>HTML 表单 multipart&#x2F;form-data</h2><p>如果你需要使用 <code>Curl</code> 命令<code>模拟表单</code>的请求，可以使用 <code>Curl</code> 命令的<code>-F</code>选项创建 <code>POST</code> 请求并且使用<code>multipart/form-data</code>进行编码。</p>
<p><code>-F</code>选项允许你指定 <code>multipart</code> 的数据。<code>Curl</code> 命令自动将内容类型设置为<code>multipart/form-data</code>发送数据。</p>
<p>也可以使用<code>-F</code>选项指定多个数据，数据的形式是以<code>field=value</code>键值对的方式指定。</p>
<p>例如以下 <code>Curl</code> 命令将模拟 <code>HTML 表单</code>发送<code>两个</code>字段的数据，字段 <code>website</code> 值是 <code>myfreax.com</code>，字段 <code>email</code> 值是 <code>web@myfreax.com</code> 。最后是指定请求的 <code>URL</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-F</span> <span class="token string">'website=myfreax.com'</span> <span class="token parameter variable">-F</span> <span class="token string">'email=web@myfreax.com'</span> https://wwww.myfreax.com/contact.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="HTML-表单-x-www-form-urlencoded"><a href="#HTML-表单-x-www-form-urlencoded" class="headerlink" title="HTML 表单 x-www-form-urlencoded"></a>HTML 表单 x-www-form-urlencoded</h2><p>发出 <code>POST</code> 请求的另一种方法是使用 <code>Curl</code> 命令的<code>-d</code>选项。在使用<code>-d</code>选项时 <code>Curl</code> 命令使用<code>application/x-www-form-urlencoded</code>对数据进行编码。</p>
<p>也会指定内容类型为<code>application/x-www-form-urlencoded</code>。使用这种方式发送的请求，就是使用<code>查询字符串</code>发送数据。</p>
<p>如果你需要<code>发送大量的数据</code>你不必多次使用<code>-d</code>选项，可以使用<code>&amp;</code>符号合并数据，比如 <code>website=myfreax&amp;email=myfreax@example.com</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">'name=myfreax'</span> <span class="token parameter variable">-d</span> <span class="token string">'email=myfreax@example.com'</span> https://example.com/contact.php

<span class="token comment">#上面和下面的命令是等价的</span>
<span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">'name=myfreax&amp;email=myfreax@example.com'</span> https://example.com/contact.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要发送 <code>Header</code> 到服务器，可以使用 <code>Curl</code> 命令的<code>-H</code>&#x2F;<code>--header</code>选项，它允许指定 <code>Header</code> 的键 <code>Key</code> 和值 <code>Value</code>。</p>
<p><code>Header</code> 的 <code>Key</code> 和 <code>Value</code> 之间必须使用空格，并且 <code>header</code> 使用<code>双引号</code>包裹，避免 <code>shell</code> 的解释。</p>
<p>可以同时使用多个<code>-H</code>&#x2F;<code>--header</code>选项来指定多个 <code>Header</code> 的 <code>Key</code> 和 <code>Value</code>。你可以看到下面的命令将会发送<code>多个</code> <code>Header</code>。</p>
<p>第一个 <code>header</code> 设置内容类型<code>Content-Type: application/json</code>，第二个 <code>header</code> 发送<code>website: myfreax.com</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/json"</span> <span class="token parameter variable">-H</span> <span class="token string">"website: myfreax.com"</span>  <span class="token parameter variable">-d</span> <span class="token string">'&#123;"email":"web@myfreax.com","website":"myfreax.com"&#125;'</span> http://127.0.0.1:3000/site<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>默认情况下<code>curl</code>命令下载 <code>URL</code> 指定资源并重定向<a href="https://www.myfreax.com/stdout-stdin-and-redirection/">标准输出</a>。如果要保存下载到文件，可以使用<code>curl</code>命令的<code>-o</code>或<code>-O</code>选项。</p>
<p>使用小写<code>-o</code>选项时，你可以指定<code>保存文件的名称</code>，也可以指定<code>绝对路径</code>，<code>Curl</code> 命令将会把文件下载到你指定<code>绝对路径</code>。</p>
<p><code>Curl</code> 命令的大写<code>-O</code>选项将使用其<code>原始文件名</code>保存到文件在<code>当前目录</code>，也就是运行<code>curl</code>命令所在的目录。</p>
<p>例如命令<code>curl -O https://cdn.jsdelivr.net/npm/vue/dist/vue.js</code>下载 vue.js 文件到<code>当前的目录</code>中。</p>
<p>命令<code>curl -o /home/myfreax/vue3.js https://cdn.jsdelivr.net/dist/vue.js</code>下载文件 vue.js 保存到文件<code>/home/myfreax/vue3.js</code>。</p>
<p>下载完成后，可以运行<a href="https://www.myfreax.com/how-to-list-files-in-linux-using-the-ls-command/">ls 命令</a>列出 <code>curl</code> 下载的文件。<code>ls vue*</code>表示列出名称包含 <code>vue</code> 字符串的文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-o</span> /home/myfreax/work/vue.js https://cdn.jsdelivr.net/npm/vue/dist/vue.js

<span class="token function">curl</span> <span class="token parameter variable">-O</span> https://cdn.jsdelivr.net/npm/vue/dist/vue.js

<span class="token function">ls</span> vue* <span class="token comment">#查看刚下载文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h2><p>要一次下载<code>多个</code>文件，请使用<code>多个</code> <code>-O</code>选项或者小写的<code>-o</code>选项，后跟要下载文件的 <code>URL</code>。</p>
<p>与使用<code>curl</code>命令下载单个文件一样。当使用小写的<code>-o</code>选项时你需要指定的下载目录路径。使用大写<code>-O</code>选项会保存当前目录下。</p>
<p>还可以混合使用小写的<code>-o</code>选项和大写<code>-O</code>选项。下面的<code>curl</code>命令在使用<code>-O</code>选项时下载 <code>vue.js</code> 文件到当前的目录，以名称<code>vue.js</code>保存文件。</p>
<p>小写<code>-o</code>选项下载 <code>vue.js</code> 文件 <code>myfreax</code> 用户的家目录下的 <code>wrok</code> 目录，并将文件保存为<code>vue.js</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-o</span> /home/myfreax/work/vue.js https://cdn.jsdelivr.net/npm/vue/dist/vue.js <span class="token punctuation">\</span>
<span class="token parameter variable">-O</span> https://cdn.jsdelivr.net/npm/vue/dist/vue.js

<span class="token function">ls</span> /home/myfreax/work/vue.js <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span> vue.js <span class="token comment">#查看刚下载文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="断点续传-x2F-恢复下载"><a href="#断点续传-x2F-恢复下载" class="headerlink" title="断点续传&#x2F;恢复下载"></a>断点续传&#x2F;恢复下载</h2><p>如果您在<code>下载大文件</code>期间<code>断开连接</code>。无需重新开始下载，可以使用<code>curl</code>命令的<code>-C -</code>选项<code>恢复上一次</code>的<code>下载</code>。</p>
<p>也可以在第一次下载文件时直接指定<code>-C -</code>选项，当<code>下载大文件</code>断开连接时，直接<code>使用之前的命令</code>即可恢复下载。</p>
<p>但有一点值得注意点是，<code>Curl</code> 命令的断点续传&#x2F;恢复下载需要服务器端支持断点续传，否则 <code>Curl</code> 会重新开始下载文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-C</span> - <span class="token parameter variable">-O</span> https://releases.ubuntu.com/22.04/ubuntu-22.04-desktop-amd64.iso<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>HTTP</code> 响应头是使用<code>冒号分隔</code>的<code>键/值</code>对，其中包含<code>服务器类型</code>，通常是 <code>Nginx/Apache</code>，<code>内容类型</code>和 <code>HTTP 状态码</code>等信息。</p>
<p><code>Curl</code> 命令的 <code>-I</code> 选项允许你<code>查看</code>指定 <code>URL</code> 资源的 <code>HTTP 响应头</code>，也包括在 <code>Nginx</code> 或者 <code>Apache</code> 设置的<code>自定义响应头</code>。</p>
<p>例如命令 <code>curl -I https://www.myfreax.com/</code> 打印 URL <code>https://www.ubuntu.com/</code>响应头。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-I</span> <span class="token parameter variable">--http2</span> https://www.ubuntu.com/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="测试-HTTP-x2F-2-的支持"><a href="#测试-HTTP-x2F-2-的支持" class="headerlink" title="测试 HTTP&#x2F;2 的支持"></a>测试 HTTP&#x2F;2 的支持</h2><p>要检查指定的 <code>URL</code> 是否支持 <code>HTTP/2</code> 协议，请组合使用 <code>Curl</code> 命令的 <code>-I</code> 和 <code>--http2</code>选项查看 <code>HTTP</code> 响应头，然后使用 <a href="https://www.myfreax.com/how-to-use-grep-command-to-search-files-in-linux/">grep 命令</a>搜索<a href="https://www.myfreax.com/stdout-stdin-and-redirection/">标准输出</a>。</p>
<p>如果你使用的 <code>Curl</code> 版本 <code>7.47.0</code> 或<code>更高版本</code>，则不需要使用 <code>--http2</code> 选项。默认情况下，<code>Curl</code> 默认使用 <code>HTTP/2</code> 协议进行连接。</p>
<p><code>Curl</code> 命令的 <code>-s</code> 选项以静默方式运行 <code>Curl</code> 并<code>隐藏进度</code>和<code>错误消息</code>。如果<code>远程服务器</code>支持 <code>HTTP/2</code> 协议，终端打印消息 <code>HTTP/2.0 200</code>，否则是 <code>HTTP/1.1 200</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-I</span> <span class="token parameter variable">--http2</span> <span class="token parameter variable">-s</span> https://www.myfreax.com/ <span class="token operator">|</span> <span class="token function">grep</span> HTTP/2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HTTP/2 <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="301-HTTP-重定向"><a href="#301-HTTP-重定向" class="headerlink" title="301 HTTP 重定向"></a>301 HTTP 重定向</h2><p>如果尝试在没有 <code>www</code> 的情况下抓取 <code>google.com</code> 主页，你会注意到 <code>Google</code> 返回是 <code>301</code> 页面的内容，运行命令 <code>curl google.com</code>。</p>
<p>从 <code>301</code> 重定向的页面内容中可以看到，<code>google.com</code> 被重定向到 <code>www</code> 版本。并且在默认情况下 <code>Curl</code> 命令不遵循 <code>HTTP Location header</code>。</p>
<p>因此你不会获得 <code>Google</code> 主页的源码。要跟随 <code>301</code> 重定向请使用 <code>Curl</code> 命令的<code>-L</code>&#x2F;<code>--location</code>选项，<code>Curl</code> 命令直到服务器不返回状态码 <code>301</code> 才会终止。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="指定用户代理-User-Agent"><a href="#指定用户代理-User-Agent" class="headerlink" title="指定用户代理 User-Agent"></a>指定用户代理 User-Agent</h2><p>你应该遇到在使用不同浏览器时，有的浏览器可以下载，或者某个浏览器不能下载的情况。或者根据访问者的设备和浏览器，提供的不同页面内容。</p>
<p>这是因为<code>服务器程序</code>根据<code>用户</code>代理 <code>User-Agent</code> 进行区分<code>用户</code>的设备类型，从而确定返回不同的内容或者阻止你的<code>下载</code>与<code>访问</code>。</p>
<p>为了避免服务器根据访问者的 <code>User-Agent</code> 用户代理提供不同内容。请使用<code>curl</code>命令的<code>-A</code>选项模拟 <code>User-Agent</code> 用户代理。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-A</span> <span class="token string">"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"</span> https://getfedora.org/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="限制下载速度"><a href="#限制下载速度" class="headerlink" title="限制下载速度"></a>限制下载速度</h2><p><code>Curl</code> 命令的<code>--limit-rate</code>选项允许您限制数据传输速度&#x2F;速率。默认的速度的单位是字节。也可以使用<code>k</code>，<code>m</code>，<code>g</code>作为后缀，表示以不同的单位作为下载速度。</p>
<p><code>Curl</code> 命令将下载 <code>Go 二进制文件</code>并将下载速度限制为 <code>1MB</code>，<code>-O</code>选项表示保存到文件在当前目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> --limit-rate 1m <span class="token parameter variable">-O</span> https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="下载-x2F-上传-FTP-文件"><a href="#下载-x2F-上传-FTP-文件" class="headerlink" title="下载&#x2F;上传 FTP 文件"></a>下载&#x2F;上传 FTP 文件</h2><p><code>Curl</code> 命令除了支持 <code>HTTP</code> 协议之外，还支持 <code>FTP 协议文件下载</code>和<code>上传</code>，以及<code>列出 FTP 服务器</code>的<code>文件</code>。</p>
<p>如果你需要使用<code>curl</code>命令访问<code>受保护的 FTP 服务器</code>，请使用 Curl 命令的<code>-u</code>选项并指定<code>用户名</code>和<code>密码</code>。</p>
<p><code>Curl</code> 命令的<code>-T</code>选项允许你将文件上传到 <code>FTP 服务器</code>，<code>-T</code>选项之后是您要上传的文件，也可以指定文件的绝对路径。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-u</span> FTP_USERNAME:FTP_PASSWORD ftp://ftp.example.com/ <span class="token comment">#列出文件</span>

<span class="token function">curl</span> <span class="token parameter variable">-u</span> FTP_USERNAME:FTP_PASSWORD ftp://ftp.example.com/file.tar.gz <span class="token comment">#下载文件</span>

<span class="token function">curl</span> <span class="token parameter variable">-T</span> newfile.tar.gz <span class="token parameter variable">-u</span> FTP_USERNAME:FTP_PASSWORD ftp://ftp.example.com/ <span class="token comment">#上传文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="发送-Cookie"><a href="#发送-Cookie" class="headerlink" title="发送 Cookie"></a>发送 Cookie</h2><p>使用 <code>curl</code> 发出 <code>HTTP</code> 请求时，默认情况下，<code>Curl</code> 命令不发送或存储任何 <code>Cookie</code> 信息。有时您可能需要指定 <code>Cookie</code> 发起 <code>HTTP</code> 请求才能访问服务器资源。</p>
<p><code>Curl</code> 命令的<code>-b</code>选项允许你将指定 <code>Cookie</code> 信息发送到服务器，请在<code>-b</code>选项后跟 <code>Cookie</code> 字符串或者包含 <code>Cookie</code> 的文件名称。</p>
<p>例如，你要下载 Oracle Java JDK 的<a href="https://www.myfreax.com/how-to-install-rpm-packages-on-centos/">rpm 文件</a><code>jdk-10.0.2_linux-x64_bin.rpm</code>，您需要发送 Cookie 键值对<code>oraclelicense=a</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-b</span> <span class="token string">"oraclelicense=a"</span> <span class="token parameter variable">-O</span> http://download.oracle.com/otn-pub/java/jdk/10.0.2+13/19aef61b38124481863b1413dce1855f/jdk-10.0.2_linux-x64_bin.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="使用代理服务器"><a href="#使用代理服务器" class="headerlink" title="使用代理服务器"></a>使用代理服务器</h2><p><code>Curl</code> 命令支持不同类型的代理，包括 <code>HTTP</code>，<code>HTTPS</code> 和 <code>SOCKS</code>。要通过指定代理服务传输数据，请使用 Curl 命令<code>-x</code>&#x2F;<code>--proxy</code>选项，后跟代理服务器 <code>URL</code>。</p>
<p>如果代理服务器需要身份验证，请使用 Curl 命令的<code>-U</code>&#x2F;<code>--proxy-user</code>选项，后跟用冒号分隔的用户名和密码。</p>
<p>例如命令<code>curl -x 192.168.44.1:8888 URL</code>使用代理服务器<code>192.168.44.1:8888</code>。<code>curl -U 用户名:密码 -x URL</code>指定代理服务器用户名与密码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-x</span> <span class="token number">192.168</span>.44.1:8888 http://linux.com/

<span class="token function">curl</span> <span class="token parameter variable">-U</span> mark:Passvv0rd <span class="token parameter variable">-x</span> <span class="token number">192.168</span>.44.1:8888 http://linux.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言开发环境(二) GO编译工具安装配置</title>
    <url>//post/2023-golang-go-install-centos8.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8.4</td>
</tr>
<tr>
<td>Golang</td>
<td>1.18.3 linux-arm64</td>
</tr>
</tbody></table>
<p>对于Windows和Mac用户，只需双击下载的安装程序，然后按照提示完成安装<br>对于Linux用户，需要手动安装，具体方法可以查看官方文档</p>
<h2 id="下载GO二进制文件或源代码"><a href="#下载GO二进制文件或源代码" class="headerlink" title="下载GO二进制文件或源代码"></a>下载GO二进制文件或源代码</h2><p>选择适合你的操作系统的版本，比如Windows、Mac或Linux</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /tmp
<span class="token function">wget</span> https://go.dev/dl/go1.18.3.linux-arm64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/go
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> go1.18.3.linux-arm64.tar.gz <span class="token parameter variable">-C</span> <span class="token environment constant">$HOME</span>/go
<span class="token function">mv</span> <span class="token environment constant">$HOME</span>/go/go <span class="token environment constant">$HOME</span>/go/go1.18.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p><strong>配置<code>$HOME/.bashrc</code>，将环境变量追加到<code>$HOME/.bashrc</code></strong></p>
<p>需要将GO编译器的二进制文件路径添加到PATH环境变量中<br>对于Windows用户，在“系统属性”中设置环境变量<br>对于Linux和Mac用户，需要编辑bashrc或bash_profile文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 文件末尾追加</span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export GOVERSION=go1.18.3   # Go版本设置
export GO_INSTALL_DIR=$HOME/go  # Go安装目录
export GOROOT=$GO_INSTALL_DIR/$GOVERSION   # GOROOT设置
export GOPATH=$WORKSPACE/golang # GOPATH设置

# 将GO语言自带的和通过go install安装的二进制文件加入PATH路径中
export PATH=$GOROOT/bin:$GOPATH/bin:$PATH
export GO111MODULE="on" # 开启go moudles特性
export GOPROXY=https://goproxy.io,direct    # 安装go模块时代理服务器设置
export GOPRIVATE=
export GOSUMDB=sum.golang.org # 校验go依赖包的哈希值
EOF</span>

<span class="token function">bash</span>  <span class="token comment"># 加载 .bashrc 文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go version <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="初始化工作区"><a href="#初始化工作区" class="headerlink" title="初始化工作区"></a>初始化工作区</h2><p>使用的 Go 版本为 ​​go1.18.3​​​，​​go1.18.3​​ 支持多模块工作区，所以这里也需要初始化工作区。初始化命令如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$GOPATH</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token variable">$GOPATH</span>
go work init
go <span class="token function">env</span> GOWORK <span class="token comment"># 执行此命令，查看 go.work 工作区文件路径</span>
/home/going/workspace/golang/go.work<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="使用Go编译器"><a href="#使用Go编译器" class="headerlink" title="使用Go编译器"></a>使用Go编译器</h2><p>创建一个Go项目<br>编写代码并保存为.go文件<br>在终端或命令行界面中使用<code>go build</code>命令编译项目<br>使用<code>go run</code>命令运行项目<br>使用<code>go install</code>命令安装项目</p>
<p>注意事项：<br><em><strong>安装过程可能因为操作系统和版本的不同而有所区别<br>需要注意Go的版本和操作系统的兼容性<br>需要熟悉常用的Go编译器命令</strong></em></p>
<hr>
<blockquote>
<p>go 环境变量 中文翻译</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token builtin class-name">help</span> environment   
<span class="token comment"># go 命令及其调用的工具参考环境变量进行配置. </span>
<span class="token comment"># 如果未设置环境变量，go 命令使用合理的默认设置. </span>
<span class="token comment"># 查看变量的有效设置 &lt;NAME>, 请运行 'go env &lt;NAME>'. </span>
<span class="token comment"># 要更改默认设置，请运行 'go env -w &lt;NAME>=&lt;VALUE>'. </span>
<span class="token comment"># 根据 os.UserConfigDir 的报告，使用'go env -w' 更改的默认值记录在存储在每个用户配置目录中的 Go 环境配置文件中.</span>
<span class="token comment"># 配置文件的位置可以通过设置环境变量GOENV来改变，'go env GOENV'打印有效位置，但是'go env -w'不能改变默认位置。</span>
<span class="token comment"># 详见'go help env'</span>

<span class="token comment"># 通用环境变量:</span>

        <span class="token comment"># GO111MODULE</span>
              <span class="token comment">#  控制 go 命令是在模块感知模式下运行还是在 GOPATH 模式下运行.</span>
              <span class="token comment">#  可以是 "off", "on", or "auto".</span>
              <span class="token comment">#  请参阅 https://golang.org/ref/mod#mod-commands.</span>
        <span class="token comment"># GCCGO</span>
              <span class="token comment">#  为'go build -compiler=gccgo'运行的 gccgo 命令</span>
        <span class="token comment"># GOARCH</span>
              <span class="token comment">#  要为其编译代码的体系结构或处理器.</span>
              <span class="token comment">#  例如 amd64、386、arm、ppc64.</span>
        <span class="token comment"># GOBIN</span>
              <span class="token comment">#  'go install'的安装目录.</span>
        <span class="token comment"># GOCACHE</span>
              <span class="token comment">#  go 命令将存储缓存信息以供在未来构建中重用的目录.</span>
        <span class="token comment"># GOMODCACHE</span>
              <span class="token comment">#  go 命令将存储下载模块的目录.</span>
        <span class="token comment"># GODEBUG</span>
              <span class="token comment">#  启用各种调试工具。 有关详细信息，请参阅'go doc runtime'.</span>
        <span class="token comment"># GOENV</span>
              <span class="token comment">#  Go 环境配置文件的位置.</span>
              <span class="token comment">#  无法使用'go env -w'设置.</span>
              <span class="token comment">#  在环境中设置 GOENV=off 将禁用默认配置文件.</span>
        <span class="token comment"># GOFLAGS</span>
              <span class="token comment">#  当前命令已知给定标志时，默认情况下应用于 go 命令的 -flag=value 设置的空格分隔列表. </span>
              <span class="token comment">#  每个条目必须是一个独立的标志.</span>
              <span class="token comment">#  因为条目是用空格分隔的，所以标志值不能包含空格. </span>
              <span class="token comment">#  命令行上列出的标志在此列表之后应用，因此覆盖它.</span>
        <span class="token comment"># GOINSECURE</span>
              <span class="token comment">#  逗号分隔的 glob 模式列表（在 Go 的 path.Match 语法中）应该始终以不安全的方式获取的模块路径前缀. </span>
              <span class="token comment">#  仅适用于直接获取的依赖项.</span>
              <span class="token comment">#  GOINSECURE 不会禁用校验和数据库验证. 可以使用 GOPRIVATE 或 GONOSUMDB 来实现这一点.</span>
        <span class="token comment"># GOOS</span>
              <span class="token comment">#  为其编译代码的操作系统.</span>
              <span class="token comment">#  例如 linux、darwin、windows、netbsd.</span>
        <span class="token comment"># GOPATH</span>
              <span class="token comment">#  有关详细信息，请参阅：'go help gopath'.</span>
        <span class="token comment"># GOPROXY</span>
              <span class="token comment">#  UGo 模块代理的 RL. </span>
              <span class="token comment">#  请参阅 https://golang.org/ref/mod#environment-variables</span>
              <span class="token comment">#  和 https://golang.org/ref/mod#module-proxy 了解详情.</span>
        <span class="token comment"># GOPRIVATE, GONOPROXY, GONOSUMDB</span>
              <span class="token comment">#  以逗号分隔的 glob 模式列表（在 Go 的 path.Match 语法中）</span>
              <span class="token comment">#  应该始终直接获取或不应与校验和数据库进行比较的模块路径前缀.</span>
              <span class="token comment">#  See https://golang.org/ref/mod#private-modules.</span>
        <span class="token comment"># GOROOT</span>
              <span class="token comment">#  Go语言编译工具，标准库等的安装路径.</span>
        <span class="token comment"># GOSUMDB</span>
              <span class="token comment">#  要使用的校验和数据库的名称以及可选的公钥和 URL。 请参阅 https://golang.org/ref/mod#authenticating.</span>
        <span class="token comment"># GOTMPDIR</span>
              <span class="token comment">#  go 命令将写入临时源文件、包和二进制文件的目录.</span>
        <span class="token comment"># GOVCS</span>
              <span class="token comment">#  列出可用于匹配服务器的版本控制命令. 请参阅“帮助 vcs”.</span>
        <span class="token comment"># GOWORK</span>
              <span class="token comment">#  在模块感知模式下，使用给定的 go.work 文件作为工作区文件.</span>
              <span class="token comment">#  默认情况下或当 GOWORK 为'auto'时，go 命令会在当前目录中搜索名为 go.work 的文件，然后搜索包含的目录，直到找到一个. </span>
              <span class="token comment">#  如果找到有效的 go.work 文件，则指定的模块将共同用作主要模块.</span>
              <span class="token comment">#  如果 GOWORK 处于“关闭”状态，或者在“自动”模式下找不到 go.work 文件，则工作空间模式将被禁用.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Go开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言 work 工作区模式</title>
    <url>//post/2023-golang-go-work-note.html</url>
    <content><![CDATA[<ul>
<li>本文摘自 <a href="https://polarisxu.studygolang.com/posts/go/workspace/">https://polarisxu.studygolang.com/posts/go/workspace</a></li>
</ul>
<p>工作区模式（Workspace mode），可不是之前 GOPATH 时代的 Workspace，而是希望在本地开发时支持多 Module。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>为了大家全面理解工作区模式，通过一个具体例子讲解。</p>
<p>本地有两个项目，分别是两个 module：mypkg 和 example。（Windows 系统请按自己方式创建目录）</p>
<span id="more"></span>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/
<span class="token function">mkdir</span> polarisxu
<span class="token builtin class-name">cd</span> polarisxu
<span class="token function">mkdir</span> mypkg example
<span class="token builtin class-name">cd</span> mypkg
go mod init github.com/polaris1119/mypkg
<span class="token function">touch</span> bar.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 bar.go 中增加如下示例代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> mypkg

<span class="token keyword">func</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is package mypkg"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着，在 example 模块中处理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/polarisxu/example
go mod init github.com/polaris1119/example
<span class="token function">touch</span> main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在 main.go 中增加如下内容：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"github.com/polaris1119/mypkg"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    mypkg<span class="token punctuation">.</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这时候，如果我们运行 go mod tidy，肯定会报错，因为我们的 mypkg 包根本没有提交到 github 上，肯定找不到。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go mod tidy
<span class="token punctuation">..</span><span class="token punctuation">..</span>
fatal: repository <span class="token string">'https://github.com/polaris1119/mypkg/'</span> not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>go run main.go</code> 也就不成功。</p>
<p>我们当然可以提交 mypkg 到 github，但我们每修改一次 mypkg，就需要提交（而且每次提交之后需要在 example 中 go get 最新版本），否则 example 中就没法使用上最新的。</p>
<p>针对这种情况，目前是建议通过 replace 来解决，即在 example 中的 go.mod 增加如下 replace：（v1.0.0 根据具体情况修改，还未提交，可以使用 v1.0.0）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">module github<span class="token punctuation">.</span>com<span class="token operator">/</span>polaris1119<span class="token operator">/</span>example

<span class="token keyword">go</span> <span class="token number">1.19</span>

require github<span class="token punctuation">.</span>com<span class="token operator">/</span>polaris1119<span class="token operator">/</span>mypkg v1<span class="token punctuation">.</span><span class="token number">0.0</span>

replace github<span class="token punctuation">.</span>com<span class="token operator">/</span>polaris1119<span class="token operator">/</span>mypkg <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>mypkg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次运行 go run main.go，输出如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run main.go
This is package mypkg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当都开发完成时，我们需要手动删除 replace，并执行 go mod tidy 后提交，否则别人使用就报错了。</p>
<p>这还是挺不方便的，如果本地有多个 module，每一个都得这么处理。</p>
<h2 id="工作区模式"><a href="#工作区模式" class="headerlink" title="工作区模式"></a>工作区模式</h2><p>针对上面的这个问题，Michael Matloob 提出了 Workspace Mode（工作区模式）。相关 issue 讨论：<a href="https://github.com/golang/go/issues/45713">cmd&#x2F;go: add a workspace mode</a> ，<a href="https://go.googlesource.com/proposal/+/master/design/45713-workspace.md">这里是 Proposal</a> 。并在 Go1.18 中发布了。</p>
<p>因此，要使用工作区，请确保 Go 版本在 1.18+。</p>
<p>我本地当前版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go version
go version go1.19.2 darwin/arm64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过 go help work 可以看到 work 相关命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token builtin class-name">help</span> work
Work provides access to operations on workspaces.

Note that support <span class="token keyword">for</span> workspaces is built into many other commands, not
just <span class="token string">'go work'</span><span class="token builtin class-name">.</span>

See <span class="token string">'go help modules'</span> <span class="token keyword">for</span> information about Go<span class="token string">'s module system of which
workspaces are a part.

See https://go.dev/ref/mod#workspaces for an in-depth reference on
workspaces.

See https://go.dev/doc/tutorial/workspaces for an introductory
tutorial on workspaces.

A workspace is specified by a go.work file that specifies a set of
module directories with the "use" directive. These modules are used as
root modules by the go command for builds and related operations.  A
workspace that does not specify modules to be used cannot be used to do
builds from local modules.

go.work files are line-oriented. Each line holds a single directive,
made up of a keyword followed by arguments. For example:

    go 1.18

    use ../foo/bar
    use ./baz

    replace example.com/foo v1.2.3 => example.com/bar v1.4.5

The leading keyword can be factored out of adjacent lines to create a block,
like in Go imports.

    use (
      ../foo/bar
      ./baz
    )

The use directive specifies a module to be included in the workspace'</span>s
<span class="token builtin class-name">set</span> of main modules. The argument to the use directive is the directory
containing the module's go.mod file.

The go directive specifies the version of Go the <span class="token function">file</span> was written at. It
is possible there may be future changes <span class="token keyword">in</span> the semantics of workspaces
that could be controlled by this version, but <span class="token keyword">for</span> now the version
specified has no effect.

The replace directive has the same syntax as the replace directive <span class="token keyword">in</span> a
go.mod <span class="token function">file</span> and takes precedence over replaces <span class="token keyword">in</span> go.mod files.  It is
primarily intended to override conflicting replaces <span class="token keyword">in</span> different workspace
modules.

To determine whether the go <span class="token builtin class-name">command</span> is operating <span class="token keyword">in</span> workspace mode, use
the <span class="token string">"go env GOWORK"</span> command. This will specify the workspace <span class="token function">file</span> being
used.

Usage:

    go work <span class="token operator">&lt;</span>command<span class="token operator">></span> <span class="token punctuation">[</span>arguments<span class="token punctuation">]</span>

The commands are:

    edit        edit go.work from tools or scripts
    init        initialize workspace <span class="token function">file</span>
    <span class="token function">sync</span>        <span class="token function">sync</span> workspace build list to modules
    use         <span class="token function">add</span> modules to workspace <span class="token function">file</span>

Use <span class="token string">"go help work &lt;command>"</span> <span class="token keyword">for</span> <span class="token function">more</span> information about a command.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：上文中提到，工作区不只是 go work 相关命令，Go 其他命令也会涉及工作区内容，比如 go run、go build 等。</strong></p>
<p>根据这个提示，我们初始化 workspace：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/polarisxu
go work init mypkg example
tree
<span class="token builtin class-name">.</span>
├── example
│   ├── go.mod
│   └── main.go
├── go.work
└── mypkg
    ├── bar.go
    └── go.mod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意几点：</p>
<ul>
<li>多个子模块应该在一个目录下（或其子目录）。比如这里的 polarisxu 目录；（这不是必须的，但更好管理，否则 go work init 需要提供正确的子模块路径）</li>
<li>go work init 需要在 polarisxu 目录执行；</li>
<li>go work init 之后跟上需要本地开发的子模块目录名；</li>
</ul>
<p>打开 go.work 看看长什么样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> <span class="token number">1.19</span>

use <span class="token punctuation">(</span>
    <span class="token punctuation">.</span><span class="token operator">/</span>example
    <span class="token punctuation">.</span><span class="token operator">/</span>mypkg
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>go.work 文件的语法和 go.mod 类似（go.work 优先级高于 go.mod），因此也支持 replace。</p>
<p><strong>注意：实际项目中，多个模块之间可能还依赖第三方包，其他模块，建议在 go.work 所在目录执行 <code>go work sync</code>。</strong></p>
<p>现在，我们将 example&#x2F;go.mod 中的 replace 语句删除，再次执行 go run main.go（在 example 目录下），得到了正常的输出。也可以在 polarisxu 目录下，这么运行：go run example&#x2F;main.go，也能正常。</p>
<p><strong>注意，go.work 不需要提交到 Git 中，因为它只是你本地开发使用的。</strong></p>
<p>当你开发完成，应该先提交 mypkg 包到 GitHub，然后在 example 下面执行 go get：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go get <span class="token parameter variable">-u</span> github.com/polaris1119/mypkg@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后禁用 workspace（通过 GOWORK&#x3D;off 禁用），再次运行 example 模块，是否正确：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/polarisxu/example
<span class="token assign-left variable">GOWORK</span><span class="token operator">=</span>off go run main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>工作区模式</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言开发环境(一) linux 服务器配置</title>
    <url>//post/2023-golang-go-workspace-centos8.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8.4</td>
</tr>
<tr>
<td>Git</td>
<td>2.39.2</td>
</tr>
</tbody></table>
<h3 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h3><p>使用<code>root</code>用户登录Linux服务器，并创建普通用户</p>
<p>一般来说， 一个项目会由多个开发人员协作完成 。 为了节省企业成本，公司不会为每个开发人员都配备一台服务器 ， 而是让所有的开发人员共用一个开发机，并以普通用户的身份登录开发机进行开发。</p>
<p>尽量避免使用<code>root</code>账户 ， 以普通用户登录和操作开发机可以保证系统的安全性</p>
<span id="more"></span>
<p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> going  <span class="token comment"># 创建用户</span>
<span class="token function">passwd</span> going    <span class="token comment"># 设置密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>演示</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># useradd going</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># passwd going</span>
Changing password <span class="token keyword">for</span> user going.
New password:
BAD PASSWORD: The password is shorter than <span class="token number">8</span> characters
Retype new password:
passwd: all authentication tokens updated successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="添加sudoers"><a href="#添加sudoers" class="headerlink" title="添加sudoers"></a>添加<code>sudoers</code></h3><p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 把用户going添加/etc/sudoers文件</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'/^root.*ALL=(ALL)/a\going\tALL=(ALL) \tALL'</span>  /etc/sudoers
<span class="token comment"># 在/etc/sudoers文件中查找</span>
<span class="token comment"># root	ALL=(ALL) 	ALL</span>
<span class="token comment"># 在此行下添加</span>
<span class="token comment"># going	ALL=(ALL) 	ALL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 把用户going添加wheel组</span>
<span class="token function">usermod</span> <span class="token parameter variable">-aG</span> wheel going   
<span class="token comment"># -a 添加用户到基本的组，仅和 -G选项一起使用</span>
<span class="token comment"># -G 用户也是其成员的补充组列表。 每个组之间用逗号分隔，中间没有空格。如果用户当前是未列出的组的成员，则该用户将从该组中删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>测试</strong></p>
<pre class="line-numbers language-none"><code class="language-none">sudo -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="替换CentOS8-4系统自带的Yum源"><a href="#替换CentOS8-4系统自带的Yum源" class="headerlink" title="替换CentOS8.4系统自带的Yum源"></a>替换<code>CentOS8.4</code>系统自带的<code>Yum</code>源</h3><p>官方的Yum源已不可用</p>
<p><code>阿里镜像源</code> <a href="https://mirrors.aliyun.com/repo/">https://mirrors.aliyun.com/repo/</a></p>
<p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/yum.repos.d/ /etc/yum.repos.d.bak
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/yum.repos.d/
<span class="token function">wget</span> <span class="token parameter variable">-O</span> /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
dnf clean all <span class="token operator">&amp;&amp;</span> dnf makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>演示</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/ /etc/yum.repos.d.bak</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /etc/yum.repos.d/</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span>
--2023-02-23 09:39:05--  https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
Resolving mirrors.aliyun.com <span class="token punctuation">(</span>mirrors.aliyun.com<span class="token punctuation">)</span><span class="token punctuation">..</span>. <span class="token number">198.18</span>.0.49
Connecting to mirrors.aliyun.com <span class="token punctuation">(</span>mirrors.aliyun.com<span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">198.18</span>.0.49<span class="token operator">|</span>:443<span class="token punctuation">..</span>. connected.
HTTP request sent, awaiting response<span class="token punctuation">..</span>. <span class="token number">200</span> OK
Length: <span class="token number">2495</span> <span class="token punctuation">(</span><span class="token number">2</span>.4K<span class="token punctuation">)</span> <span class="token punctuation">[</span>application/octet-stream<span class="token punctuation">]</span>
Saving to: <span class="token string">'/etc/yum.repos.d/CentOS-Base.repo'</span>

/etc/yum.repos.d/CentOS-Base.repo              <span class="token number">100</span>%<span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">]</span>   <span class="token number">2</span>.44K  --.-KB/s    <span class="token keyword">in</span> 0s

<span class="token number">2023</span>-02-23 09:39:05 <span class="token punctuation">(</span><span class="token number">6.01</span> MB/s<span class="token punctuation">)</span> - <span class="token string">'/etc/yum.repos.d/CentOS-Base.repo'</span> saved <span class="token punctuation">[</span><span class="token number">2495</span>/2495<span class="token punctuation">]</span>

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># dnf clean all &amp;&amp; dnf makecache</span>
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
<span class="token number">18</span> files removed
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
CentOS-8.5.2111 - Base - mirrors.aliyun.com                                                                                                              <span class="token number">897</span> kB/s <span class="token operator">|</span> <span class="token number">3.7</span> MB     00:04
CentOS-8.5.2111 - Extras - mirrors.aliyun.com                                                                                                             <span class="token number">27</span> kB/s <span class="token operator">|</span>  <span class="token number">10</span> kB     00:00
CentOS-8.5.2111 - AppStream - mirrors.aliyun.com                                                                                                         <span class="token number">590</span> kB/s <span class="token operator">|</span> <span class="token number">7.2</span> MB     00:12
Metadata cache created.
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-HOME-bashrc文件"><a href="#配置-HOME-bashrc文件" class="headerlink" title="配置$HOME/.bashrc文件"></a>配置<code>$HOME/.bashrc</code>文件</h3><p>使用<code>going</code>用户登录</p>
<p>配置$HOME&#x2F;.bashrc文件，使Linux Shell更加易用</p>
<p><code>vim $HOME/.bashrc</code><br>原文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># .bashrc</span>
<span class="token comment"># Source global definitions</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>

<span class="token comment"># User specific environment</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$PATH</span>"</span> <span class="token operator">=~</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配置后内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># .bashrc</span>
<span class="token comment"># Source global definitions</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>

<span class="token comment"># User specific environment</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$PATH</span>"</span> <span class="token operator">=~</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token comment"># 用户特定的别名函数</span>
<span class="token comment"># 操作前询问</span>
<span class="token builtin class-name">alias</span> <span class="token function">rm</span> <span class="token operator">=</span><span class="token string">'rm -i'</span>
<span class="token builtin class-name">alias</span> <span class="token function">cp</span> <span class="token operator">=</span><span class="token string">'cp -i'</span>
<span class="token builtin class-name">alias</span> <span class="token function">mv</span> <span class="token operator">=</span><span class="token string">'mv -i'</span>

<span class="token comment"># 源全局定义</span>
<span class="token comment"># 判断/etc/bashrc这个文件是否存在，如果存在执行这个文件</span>
<span class="token comment">#if [ -f /etc/bashrc ]; then</span>
<span class="token comment">#    . /etc/bashrc</span>
<span class="token comment">#fi</span>
<span class="token comment"># 判断$HOME/workspace是否为目录,不是则创建</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token environment constant">$HOME</span>/workspace <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/workspace
<span class="token keyword">fi</span>

<span class="token comment"># 用户特定环境</span>
<span class="token comment"># Basic envs</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>   <span class="token comment"># 设置系统语言为en_US.UTF-8 避免中断出现中文乱码</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'[\u@dev \w]\$ '</span>    <span class="token comment"># 默认的PS1设置会展示全部的路径，为防止过长，这里只展示: "用户名 @dev 最后的目录名"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">WORKSPACE</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/workspace"</span>  <span class="token comment"># 设置工作目录</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span> <span class="token comment"># 将$HOME/bin目录加入PATH变量中</span>

<span class="token comment"># 设置默认入口目录</span>
<span class="token builtin class-name">cd</span> <span class="token variable">$WORKSPACE</span>   <span class="token comment"># 登录系统 默认进入workspace目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配置好后</p>
<pre class="line-numbers language-none"><code class="language-none">bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>注意</strong></p>
<p><code>export PATH</code> 时，最好把<code>$PATH</code>放在最后，一维添加到<code>$HOME/bin</code>目录中的命令是期望被优先搜索并使用的</p>
<p><code>$HOME/.bashrc</code>会自动创建目录<code>workspace</code>，所有的工作都在这个目录下展开:</p>
<ul>
<li>可以使<code>$HOME</code>保持整洁</li>
<li>分区空间不足，可以移动<code>workspace</code>到另一个分区，并在分区中保留软连接，如：<code>/home/going/workspace -&gt; /data/workspace/</code></li>
<li>备份所有工作文件，直接备份<code>workspace</code></li>
</ul>
<h3 id="依赖安装和配置"><a href="#依赖安装和配置" class="headerlink" title="依赖安装和配置"></a>依赖安装和配置</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">make</span> cmake autoconf automake cmake perl-CPAN libcurl-devel libtool gcc gcc-c++ glibc-headers zlib-devel git-lfs telnet lrzsz jq expat-devel openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /tmp
<span class="token function">wget</span> --no-check-certificate https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.39.2.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> git-2.39.2.tar.gz
<span class="token builtin class-name">cd</span> git-2.39.2
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 将Git二进制目录添加到 PATH 路径中 </span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH=/usr/local/libexec/git-core:$PATH
EOF</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改用户名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"gzwillyy"</span>
<span class="token comment"># 修改邮箱</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"gzwillyy@gmail.com"</span>
<span class="token comment"># 设置git，保存用户名和密码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper store 
<span class="token comment"># 解决git中 'Filename too lang' 的错误</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.longpaths <span class="token boolean">true</span> 
<span class="token comment"># 防止乱码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.quotepath off
<span class="token comment"># github限制最大克隆 需要安装 Git Large File Storage</span>
<span class="token function">git</span> lfs <span class="token function">install</span> --skip-repo
<span class="token comment"># 设置自动更正</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> help.autocorrect <span class="token number">15</span>
<span class="token comment"># Git 中设置 GPG 签名主键,替换要使用的 GPG 密钥ID： 3AA5C34371567BD2</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.signingkey 3AA5C34371567BD2
<span class="token comment"># 将 Git 配置为默认对所有提交进行签名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> gpg.program gpg
<span class="token function">git</span> config <span class="token parameter variable">--global</span> commit.gpgsign <span class="token boolean">true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>








]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Go开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言开发环境(三) ProtoBuf 编译环境安装</title>
    <url>//post/2023-golang-go-protobuf-centos8.html</url>
    <content><![CDATA[<p>安装 <code>​​protobuf​​​</code> 的编译器 <code>​​protoc​​​</code>。<code>​​protoc</code>​​​ 需要 ​<code>​protoc-gen-go</code>​​​ 来完成 <code>Go</code> 语言的代码转换。<br>因此需要安装 <code>​​protoc​​​</code> 和 ​<code>​protoc-gen-go</code>​​ 这 2 个工具。</p>
<blockquote>
<p><strong><em>注意：</em></strong> &gt; <code>ProtoBuf</code> 新发布的版本中删除了 <code>autotools</code> 的支持。<br>当前支持的唯一<code>C++</code>构建系统是 <a href="https://bazel.build/install"><strong><code>Bazel</code></strong> </a> 和 <a href="https://cmake.org/"><strong><code>CMake</code></strong> </a></p>
</blockquote>
<span id="more"></span>

<h2 id="安装-protobuf"><a href="#安装-protobuf" class="headerlink" title="安装 protobuf"></a>安装 protobuf</h2><p><code>protobuf</code>在<code>github</code>上更新的 <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/README.md"><strong><code>文档地址</code></strong></a></p>
<p>使用<code>cmake</code> 安装<code>protobuf</code></p>
<p><code>protobuf</code>文档 <a href="https://protobuf.dev/">https://protobuf.dev</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token builtin class-name">cd</span> /tmp/

<span class="token comment"># 把最近的一次commit给clone下来 --depth=1 限制 clone 的深度，不会下载 Git 协作的历史记录</span>
<span class="token function">git</span> clone <span class="token parameter variable">-b</span> v22.0 <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span> https://github.com/protocolbuffers/protobuf

<span class="token builtin class-name">cd</span> protobuf

<span class="token comment"># 下载的工程带有子模块 submodule</span>
<span class="token comment"># 当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的</span>
<span class="token comment"># 使用 git submodule update --init --recursive 来递归的初始化并下载子模块仓库的内容</span>
<span class="token function">git</span> submodule update <span class="token parameter variable">--init</span> <span class="token parameter variable">--recursive</span>

<span class="token function">mkdir</span> build

<span class="token builtin class-name">cd</span> build

<span class="token comment"># cmake .. 使用 ../CMakeLists.txt 文件作为起始点在当前目录中生成makefile</span>
cmake <span class="token punctuation">..</span>

<span class="token function">make</span>

<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 查看 protoc 版本，成功输出版本号，说明安装成功</span>
protoc <span class="token parameter variable">--version</span>

<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH=$PATH:/usr/local/bin
EOF</span>
<span class="token comment"># 或者</span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> /etc/profile <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH=$PATH:/usr/local/bin
EOF</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="安装支持go的插件"><a href="#安装支持go的插件" class="headerlink" title="安装支持go的插件"></a>安装支持go的插件</h2><p><code>快速开始</code>： <code>https://grpc.io/docs/languages/go/quickstart/</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token function">install</span> google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go <span class="token function">install</span> google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2

<span class="token builtin class-name">cd</span> <span class="token variable">$WORKSPACE</span>/golang/bin

<span class="token comment"># 针对用户修改</span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH="$PATH:$(go env GOPATH)/bin"
EOF</span>
<span class="token comment"># 或者</span>
<span class="token comment"># 系统永久修改</span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> /etc/profile <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH=$PATH:/usr/local/bin
EOF</span>
<span class="token comment"># 查看版本</span>
protoc-gen-go <span class="token parameter variable">--version</span>
protoc-gen-go-grpc <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>protoc-gen-go</code>包 <a href="https://pkg.go.dev/google.golang.org/protobuf">https://pkg.go.dev/google.golang.org/protobuf</a></p>
<h2 id="如何在-proto-文件中引入其他-proto-文件"><a href="#如何在-proto-文件中引入其他-proto-文件" class="headerlink" title="如何在 proto 文件中引入其他 proto 文件"></a>如何在 proto 文件中引入其他 proto 文件</h2><p><strong>Protocol buffers</strong> 是一种语言无关、平台无关的可扩展机制或者说是<strong>数据交换格式</strong>，用于<strong>序列化结构化数据</strong>。与 XML、JSON 相比，Protocol buffers 序列化后的码流更小、速度更快、操作更简单。</p>
<p><strong><em>一个简单的 <code>protobuf</code> 文件定义如下:</em></strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"protobuf/import;proto"</span><span class="token punctuation">;</span>
<span class="token keyword">package</span> <span class="token keyword">import</span><span class="token punctuation">;</span>

<span class="token keyword">message</span> <span class="token class-name">Computer</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>syntax &#x3D; “proto3”;</strong> 指定使用 <code>proto3</code> 语法</p>
<p><strong>option go_package &#x3D; “protobuf&#x2F;import;proto”;</strong> 前一个参数 <code>protobuf/import</code> 用于指定生成文件的位置，后一个参数 <code>proto</code> 指定生成的 .go 文件的 package 。具体语法如下：</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"&#123;out_path&#125;;out_go_package"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意：<strong>这里指定的 out_path 并不是<code>绝对路径</code>，只是<code>相对路径</code>或者说只是路径的一部分，和 <code>protoc</code> 的 <code>--go_out</code> 拼接后才是完整的路径。</strong> 也使用<code>--go_opt=paths=source_relative</code>直接指定 protoc 中 指定的是绝对路径，这样就不会去管 protobuf 文件中指定的路径。</p>
<p><strong>package import;</strong> 表示当前 <code>protobuf</code> 文件属于 <code>import</code> 包，这个 <code>package</code> 不是 <code>Go</code> 语言中的那个 <code>package</code>。 这个 package 主要在导入外部 proto 文件时用到。</p>
<p><strong><em>要导入其他 proto 文件只需要使用 import 键字，具体如下：</em></strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"protobuf/import/component.proto"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>导入后则通过 <code>被导入文件包名.结构体名</code> 使用。<code>component.proto</code> 文件中 <code>package</code> 指定为 <code>import</code>，所以这里通过 <code>import.CPU</code> 和 <code>import.Memory</code> 语法进行引用。</p>
<p>完整代码如下:</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"protobuf/import;proto"</span><span class="token punctuation">;</span>
<span class="token keyword">package</span> <span class="token keyword">import</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"protobuf/import/component.proto"</span><span class="token punctuation">;</span>

<span class="token keyword">message</span> <span class="token class-name">Computer</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span><span class="token positional-class-name class-name"><span class="token punctuation">.</span>CPU</span> cpu <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span><span class="token positional-class-name class-name"><span class="token punctuation">.</span>Memory</span> memory <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>导入 <code>compoent.proto</code> 文件，这个也是相对路径，具体和 <code>protoc –proto_path</code> 组合起来才是完整路径。 一般指定为项目根目录的次一级目录，编译的时候直接在根目录编译</p>
<p><code>protoc</code> 编译的时候通过 <code>--proto_path</code> 指定在哪个目录去寻找 import 指定的文件。 比如指定 <code>--proto_path=.</code>即表示在当前目录下去寻找<code>protobuf/import/compoent.proto</code>这个文件。</p>
<p>目录结构如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── protobuf
│   │ 
│   └── <span class="token function">import</span>
│       ├── compoent.proto
│       └── computer.proto
└── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"protobuf/import;proto"</span><span class="token punctuation">;</span>
<span class="token keyword">package</span> <span class="token keyword">import</span><span class="token punctuation">;</span>

<span class="token keyword">message</span> <span class="token class-name">CPU</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> Name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int64</span> Frequency <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">message</span> <span class="token class-name">Memory</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> Name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int64</span> Cap <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"protobuf/import;proto"</span><span class="token punctuation">;</span>
<span class="token keyword">package</span> <span class="token keyword">import</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"protobuf/import/component.proto"</span><span class="token punctuation">;</span>

<span class="token keyword">message</span> <span class="token class-name">Computer</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span><span class="token positional-class-name class-name"><span class="token punctuation">.</span>CPU</span> cpu <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span><span class="token positional-class-name class-name"><span class="token punctuation">.</span>Memory</span> memory <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><em>在<code>项目根路径(grpc-go-example)</code>下进行编译</em></strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">protoc <span class="token parameter variable">--proto_path</span><span class="token operator">=</span>. <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./protobuf/import/*.proto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数详解：</p>
<p><strong>1）–proto_path&#x3D;.</strong></p>
<p>指定在当前目录( grpc-go-example)寻找 <code>import</code> 的文件（默认值也是当前目录）</p>
<p>然后 <code>protobuf</code> 文件中的 import 路径如下</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"protobuf/import/component.proto"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>所以最终会去找 <code>grpc-go-example/protobuf/import/component.proto</code>。</p>
<p><code>--proto_path</code>和<code>import</code>是可以互相调整的，只需要能找到就行。 建议 protoc 参数 –proto_path 指定为根目录，proto 文件中的 import 则从根目录次一级目录开始。</p>
<p><strong>2）–go_out&#x3D;.</strong></p>
<p>指定将生成文件放在当前目录( grpc-go-example)，同时因为 <code>proto</code> 文件中也指定了目录为<code>protobuf/import</code>,具体如下：</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"protobuf/import;proto"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>所以最终生成目录为<code>--go_out+go_package= grpc-go-example/protobuf/import</code>。 可以通过参数 <code>--go_opt=paths=source_relative</code> 来指定使用绝对路径，从而忽略掉 proto 文件中的 go_package 路径，直接生成在 –go_out 指定的路径。</p>
<p><strong>3）.&#x2F;protobuf&#x2F;import&#x2F;*.proto</strong></p>
<p>指定编译 <code>import</code> 目录下的所有 <code>proto</code> 文件，由于有文件的引入所以需要一起编译才能生效。 也可以一个一个编译，只要把相关文件都编译好即可</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  c <span class="token operator">:=</span> Computer<span class="token punctuation">&#123;</span>
    Name<span class="token punctuation">:</span> <span class="token string">"alienware"</span><span class="token punctuation">,</span>
    Cpu<span class="token punctuation">:</span> <span class="token operator">&amp;</span>CPU<span class="token punctuation">&#123;</span>
      Name<span class="token punctuation">:</span>      <span class="token string">"intel"</span><span class="token punctuation">,</span>
      Frequency<span class="token punctuation">:</span> <span class="token number">4096</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    Memory<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Memory<span class="token punctuation">&#123;</span>
      Name<span class="token punctuation">:</span> <span class="token string">"芝奇"</span><span class="token punctuation">,</span>
      Cap<span class="token punctuation">:</span>  <span class="token number">8192</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>1）通过<code>import &quot;&#123;path&#125;&quot;;</code> 命令引入；</li>
<li>2）导入后通过<strong>被导入文件包名.结构体名</strong>方式使用；</li>
<li>3）编译时通过<code>--proto_path=.</code> 指定寻找 proto 文件的目录，一起编译。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Golang</tag>
        <tag>开发环境</tag>
        <tag>ProtoBuf</tag>
        <tag>​​protoc-gen-go</tag>
        <tag>protoc</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 之 给源文件添加版本声明</title>
    <url>//post/2023-golang-tips-go-addlicense.html</url>
    <content><![CDATA[<h1 id="安装-license-软件"><a href="#安装-license-软件" class="headerlink" title="安装 license 软件"></a>安装 license 软件</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token function">install</span> github.com/nishanths/license/v5@latest

<span class="token comment"># 生成 LICENSE 文件</span>
license <span class="token parameter variable">-name</span> <span class="token string">"The Project Authors"</span>  <span class="token parameter variable">-project</span> <span class="token string">"Project"</span> <span class="token parameter variable">-o</span> LICENSE apache-2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<h1 id="安装-addlicense-软件"><a href="#安装-addlicense-软件" class="headerlink" title="安装 addlicense 软件"></a>安装 addlicense 软件</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token function">install</span> github.com/google/addlicense@latest

<span class="token comment"># 根据 LICENSE 文件 ，为每个文件生成 版权头</span>
addlicense <span class="token parameter variable">-c</span> <span class="token string">"The Project Authors"</span> <span class="token parameter variable">-l</span> apache  <span class="token builtin class-name">.</span>

<span class="token comment"># 检查文件是否已生成版权头 --skip-dirs 检查时跳过third_party文件夹</span>
addlicense <span class="token parameter variable">--check</span>  <span class="token builtin class-name">.</span> --skip-dirs<span class="token operator">=</span>third_party<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="检查文件版权头是否正确"><a href="#检查文件版权头是否正确" class="headerlink" title="检查文件版权头是否正确"></a>检查文件版权头是否正确</h1><p><code>validate.sh :</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>

<span class="token builtin class-name">set</span> <span class="token parameter variable">-euo</span> pipefail
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span><span class="token entity" title="\t">\t</span>'</span>

<span class="token function-name function">find_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-not</span> <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token punctuation">\</span>
    <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token punctuation">\</span>
      <span class="token parameter variable">-wholename</span> <span class="token string">'./vendor'</span> <span class="token punctuation">\</span>
      <span class="token parameter variable">-o</span> <span class="token parameter variable">-wholename</span> <span class="token string">'*testdata*'</span> <span class="token punctuation">\</span>
      <span class="token parameter variable">-o</span> <span class="token parameter variable">-wholename</span> <span class="token string">'*third_party*'</span> <span class="token punctuation">\</span>
      <span class="token parameter variable">-o</span> <span class="token parameter variable">-wholename</span> <span class="token string">'*grpc.pb.*'</span> <span class="token punctuation">\</span>
    <span class="token punctuation">\</span><span class="token punctuation">)</span> <span class="token parameter variable">-prune</span> <span class="token punctuation">\</span>
  <span class="token punctuation">\</span><span class="token punctuation">)</span> <span class="token punctuation">\</span>
  <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token parameter variable">-name</span> <span class="token string">'*.go'</span> <span class="token parameter variable">-o</span> <span class="token parameter variable">-name</span> <span class="token string">'*.sh'</span> <span class="token punctuation">\</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment"># 使用"|| :"忽略grep返回空时的错误码</span>
<span class="token assign-left variable">failed_license_header</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>find_files <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">grep</span> <span class="token parameter variable">-L</span> <span class="token string">'Licensed under the Apache License, Version 2.0 (the "License")'</span> <span class="token operator">||</span> <span class="token builtin class-name">:</span><span class="token variable">)</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> $&#123;#failed_license_header[@]&#125; <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"某些源文件缺少许可证标头。"</span>
  <span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token string">"<span class="token variable">$&#123;failed_license_header<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>

<span class="token comment"># 使用"|| :"忽略grep返回空时的错误码</span>
<span class="token assign-left variable">failed_copyright_header</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>find_files <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">grep</span> <span class="token parameter variable">-L</span> <span class="token string">'Copyright 2023 The Project Authors'</span> <span class="token operator">||</span> <span class="token builtin class-name">:</span><span class="token variable">)</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> $&#123;#failed_copyright_header[@]&#125; <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"某些源文件缺少版权标头。"</span>
  <span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token string">"<span class="token variable">$&#123;failed_copyright_header<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>addlicense</tag>
        <tag>license</tag>
        <tag>版本声明</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 之 更正源文件中经常拼写错误的英文单词</title>
    <url>//post/2023-golang-tips-go-misspell.html</url>
    <content><![CDATA[<h1 id="安装-misspell-软件"><a href="#安装-misspell-软件" class="headerlink" title="安装 misspell 软件"></a>安装 misspell 软件</h1><p><code>软件仓库地址</code> ： <a href="https://github.com/client9/misspell">https://github.com/client9/misspell</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-o</span> ./install-misspell.sh https://git.io/misspell
<span class="token function">sh</span> ./install-misspell.sh

<span class="token comment"># 或者</span>
go <span class="token function">install</span> github.com/client9/misspell/cmd/misspell@latest

<span class="token function">which</span> misspell

<span class="token comment"># 自动修改 文件地址</span>
misspell <span class="token parameter variable">-w</span> ./
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<h1 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h1><p><em><strong>makefile 文件:</strong></em></p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">GOFILES <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> find . -name <span class="token string">"*.go"</span><span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> misspell
<span class="token target symbol">misspell</span><span class="token punctuation">:</span> <span class="token comment"># 拼写错误检查</span>
	<span class="token operator">@</span>misspell -w <span class="token variable">$</span><span class="token punctuation">(</span>GOFILES<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>misspell</tag>
        <tag>拼写错误</tag>
      </tags>
  </entry>
  <entry>
    <title>ProtoBuf 文档参考</title>
    <url>//post/2023-protocbuf-protobuf-doc.html</url>
    <content><![CDATA[<h2 id="一-定义一个消息类型"><a href="#一-定义一个消息类型" class="headerlink" title="一 定义一个消息类型"></a>一 定义一个消息类型</h2><p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的<code>.proto</code> 文件了：</p>
<span id="more"></span>

<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">message</span> <span class="token class-name">SearchRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>文件的第一行指定了你正在使用 <code>proto3</code> 语法：如果你没有指定这个，编译器会使用 <code>proto2</code>。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li><code>SearchRequest</code> 消息格式有 <code>3</code> 个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h2 id="1-1-指定字段类型"><a href="#1-1-指定字段类型" class="headerlink" title="1.1 指定字段类型"></a>1.1 指定字段类型</h2><p>在上面的例子中，所有字段都是标量类型：两个整型（<code>page_number</code> 和 <code>result_per_page</code>），一个 <code>string</code> 类型（<code>query</code>）。当然，你也可以为字段指定其他的合成类型，包括枚举（<code>enumerations</code>）或其他消息类型。</p>
<h2 id="1-2-分配标识号"><a href="#1-2-分配标识号" class="headerlink" title="1.2 分配标识号"></a>1.2 分配标识号</h2><p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用 2 个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从 <code>1</code> 开始，最大到 <code>2</code>^29 - 1, or <code>536,870,911</code>。不可以使用其中的[19000－19999]（ (从 FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， <code>Protobuf</code> 协议实现中对这些进行了预留。如果非要在 <code>.proto</code> 文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期<a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#reserved">保留</a>的标识号。</p>
<h2 id="1-3-指定字段规则"><a href="#1-3-指定字段规则" class="headerlink" title="1.3 指定字段规则"></a>1.3 指定字段规则</h2><p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li><code>singular</code>：一个格式良好的消息应该有 0 个或者 1 个这种字段（但是不能超过 1 个）。</li>
<li><code>repeated</code>：在一个格式良好的消息中，这种字段可以重复任意多次（包括 0 次）。重复的值的顺序会被保留。<br>在 <code>proto3</code> 中，<code>repeated</code> 的标量域默认情况下使用 <code>packed</code>。<br>你可以了解更多的 pakced 属性在<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn#packed">Protocol Buffer 编码</a></li>
</ul>
<h2 id="1-4-添加更多消息类型"><a href="#1-4-添加更多消息类型" class="headerlink" title="1.4 添加更多消息类型"></a>1.4 添加更多消息类型</h2><p>在一个<code>.proto</code> 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 <code>SearchResponse</code> 消息类型对应的回复消息格式的话，你可以将它添加到相同的<code>.proto</code> 文件中，如：</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">SearchRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">message</span> <span class="token class-name">SearchResponse</span> <span class="token punctuation">&#123;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-5-添加注释"><a href="#1-5-添加注释" class="headerlink" title="1.5 添加注释"></a>1.5 添加注释</h2><p>向<code>.proto</code> 文件添加注释，可以使用 <code>C/C++/java</code> 风格的双斜杠（&#x2F;&#x2F;） 语法格式，如：</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">SearchRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// Which page number do we want?</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// Number of results to return per page.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-6-保留标识符（Reserved）"><a href="#1-6-保留标识符（Reserved）" class="headerlink" title="1.6 保留标识符（Reserved）"></a>1.6 保留标识符（Reserved）</h2><p>如果你通过删除或者注释所有域，以后的用户可以重用<code>标识号</code>当你重新更新类型的时候。如果你使用旧版本加载相同的<code>.proto</code> 文件这会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是指定保留标识符（and&#x2F;or names, which can also cause issues for JSON serialization 不明白什么意思），protocol buffer 的编译器会警告未来尝试使用这些域标识符的用户。</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">reserved</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token keyword">to</span> <span class="token number">11</span><span class="token punctuation">;</span>
  <span class="token keyword">reserved</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>注：不要在同一行 <code>reserved</code> 声明中同时声明<code>域名字</code>和<code>标识号</code></p>
<h2 id="1-7-从-proto-文件生成了什么？"><a href="#1-7-从-proto-文件生成了什么？" class="headerlink" title="1.7 从.proto 文件生成了什么？"></a>1.7 从.proto 文件生成了什么？</h2><p>当用 <code>protocol buffer</code> 编译器来运行<code>.proto</code> 文件时，编译器将生成所选择语言的代码，这些代码可以操作在<code>.proto</code> 文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对 C++来说，编译器会为每个<code>.proto</code> 文件生成一个.h 文件和一个.cc 文件，<code>.proto</code> 文件中的每一个消息有一个对应的类。</li>
<li>对 Java 来说，编译器为每一个消息类型生成了一个.java 文件，以及一个特殊的 Builder 类（该类是用来创建消息类接口的）。</li>
<li>对 Python 来说，有点不太一样——Python 编译器为<code>.proto</code> 文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的 Python 数据访问类。</li>
<li>对 go 来说，编译器会位每个消息类型生成了一个.pd.go 文件。</li>
<li>对于 Ruby 来说，编译器会为每个消息类型生成了一个.rb 文件。</li>
<li>javaNano 来说，编译器输出类似域 java 但是没有 Builder 类</li>
<li>对于 Objective-C 来说，编译器会为每个消息类型生成了一个 pbobjc.h 文件和 pbobjcm 文件，<code>.proto</code> 文件中的每一个消息有一个对应的类。</li>
<li>对于 C#来说，编译器会为每个消息类型生成了一个.cs 文件，<code>.proto</code> 文件中的每一个消息有一个对应的类。</li>
</ul>
<p>你可以从如下的文档链接中获取每种语言更多 API。<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">API Reference</a></p>
<h2 id="二-标量数值类型"><a href="#二-标量数值类型" class="headerlink" title="二 标量数值类型"></a>二 标量数值类型</h2><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于<code>.proto</code> 文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>Python Type</th>
<th>Go Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>float</td>
<td>float64</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float32</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用 sint64 替代</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>int</td>
<td>uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>int</td>
<td>uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比 int32 高效的多</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的 int64 高效。</td>
<td>int</td>
<td>int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是 4 个字节，如果数值总是比总是比 228 大的话，这个类型会比 uint32 高效。</td>
<td>int</td>
<td>uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是 8 个字节，如果数值总是比总是比 256 大的话，这个类型会比 uint64 高效。</td>
<td>int</td>
<td>uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是 4 个字节</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是 8 个字节</td>
<td>int</td>
<td>int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>bool</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是 UTF-8 编码或者 7-bit ASCII 编码的文本。</td>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>str</td>
<td>[]byte</td>
</tr>
</tbody></table>
<p>你可以在文章<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn">Protocol Buffer 编码</a>中，找到更多“序列化消息时各种类型如何编码”的信息。</p>
<ol>
<li>在 java 中，无符号 32 位和 64 位整型被表示成他们的整型对应形似，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64 位或者无符号 32 位整型在解码时被表示成为 ilong，但是在设置时可以使用 int 型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python 中 string 被表示成在解码时表示成 unicode。但是一个 ASCIIstring 可以被表示成 str 类型。</li>
<li>Integer 在 64 位的机器上使用，string 在 32 位机器上使用</li>
</ol>
<h2 id="三-默认值"><a href="#三-默认值" class="headerlink" title="三 默认值"></a>三 默认值</h2><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的 singular 元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于 strings，默认是一个空 string</li>
<li>对于 bytes，默认是一个空的 bytes</li>
<li>对于 bools，默认是 false</li>
<li>对于数值类型，默认是 0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为 0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a><br>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。<br>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如 boolean 值是否被设置为 false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义 boolean 的默认值 false 作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。<br>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>选择你的语言的默认值的工作细节。</li>
</ul>
<h2 id="四-枚举"><a href="#四-枚举" class="headerlink" title="四 枚举"></a>四 枚举</h2><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个 SearchRequest 消息添加一个 corpus 字段，而 corpus 的值可能是 UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO 中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做 Corpus 的枚举类型——它含有所有可能的值 ——以及一个类型为 Corpus 的字段：</p>
<p>如你所见，Corpus 枚举的第一个常量映射为 0：每个枚举类型必须将其第一个类型映射为 0，这是因为：</p>
<ul>
<li>必须有有一个 0 值，我们可以用这个 0 值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容 proto2 语义，枚举类的第一个值总是默认值。<br>你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将 allow_alias 设定位 true，否则编译器会在别名的地方产生一个错误信息。</li>
</ul>
<p>枚举常量必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在<code>.proto</code> 文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用 MessageType.EnumType 的语法格式。</p>
<p>当对一个使用了枚举的<code>.proto</code> 文件运行 protocol buffer 编译器的时候，生成的代码中将有一个对应的 enum（对 Java 或 C++来说），或者一个特殊的 EnumDescriptor 类（对 Python 来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如 C++和 Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html%E3%80%82">generated code guide</a></p>
<h2 id="五-使用其他消息类型"><a href="#五-使用其他消息类型" class="headerlink" title="五 使用其他消息类型"></a>五 使用其他消息类型</h2><p>你可以将其他消息类型用作字段类型。例如，假设在每一个 SearchResponse 消息中包含 Result 消息，此时可以在相同的<code>.proto</code> 文件中定义一个 Result 消息类型，然后在 SearchResponse 消息中指定一个 Result 类型的字段，如：</p>
<h2 id="5-1-导入定义"><a href="#5-1-导入定义" class="headerlink" title="5.1 导入定义"></a>5.1 导入定义</h2><p>在上面的例子中，Result 消息类型与 SearchResponse 是定义在同一文件中的。如果想要使用的消息类型已经在其他<code>.proto</code> 文件中已经定义过了呢？</p>
<p>你可以通过导入（importing）其他<code>.proto</code> 文件中的定义来使用它们。要导入其他<code>.proto</code> 文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<p>默认情况下你只能使用直接导入的<code>.proto</code> 文件中的定义. 然而， 有时候你需要移动一个<code>.proto</code> 文件到一个新的位置， 可以不直接移动<code>.proto</code> 文件， 只需放入一个伪 <code>.proto</code> 文件在老的位置， 然后使用 import public 转向新的位置。import public 依赖性会通过任意导入包含 import public 声明的 proto 文件传递。例如：</p>
<p>通过在编译器命令行参数中使用<code>-I/--proto_path</code>protocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定 proto_path 标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h2 id="5-2-使用-proto2-消息类型"><a href="#5-2-使用-proto2-消息类型" class="headerlink" title="5.2 使用 proto2 消息类型"></a>5.2 使用 proto2 消息类型</h2><p>在你的 proto3 消息中导入 proto2 的消息类型也是可以的，反之亦然，然后 proto2 枚举不可以直接在 proto3 的标识符中使用（如果仅仅在 proto2 消息中使用是可以的）。</p>
<h2 id="5-3-嵌套类型"><a href="#5-3-嵌套类型" class="headerlink" title="5.3 嵌套类型"></a>5.3 嵌套类型</h2><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result 消息就定义在 SearchResponse 消息内，如：</p>
<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以 Parent.Type 的形式使用它，如：</p>
<p>当然，你也可以将消息嵌套任意多层，如：</p>
<h2 id="5-4-更新一个消息类型"><a href="#5-4-更新一个消息类型" class="headerlink" title="5.4 更新一个消息类型"></a>5.4 更新一个消息类型</h2><p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和 proto2 中的行为是不同的，在 proto2 中未定义的域依然会随着消息被序列化）</li>
<li>非 required 的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的<code>.proto</code> 文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>int32, uint32, int64, uint64,和 bool 是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在 C++中对它进行了强制类型转换一样（例如，如果把一个 64 位数字当作 int32 来 读取，那么它就会被截断为 32 位的数字）。</li>
<li>sint32 和 sint64 是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string 和 bytes 是兼容的——只要 bytes 是有效的 UTF-8 编码。</li>
<li>嵌套消息与 bytes 是兼容的——只要 bytes 包含该消息的一个编码过的版本。</li>
<li>fixed32 与 sfixed32 是兼容的，fixed64 与 sfixed64 是兼容的。</li>
<li>枚举类型与 int32，uint32，int64 和 uint64 相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的 proto3 枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int 类型的字段总会保留他们的</li>
</ul>
<h2 id="六-Any"><a href="#六-Any" class="headerlink" title="六 Any"></a>六 Any</h2><p>Any 类型消息允许你在没有指定他们的<code>.proto</code> 定义的情况下使用消息作为一个嵌套类型。一个 Any 类型包括一个可以被序列化 bytes 类型的任意消息，以及一个 URL 作为一个全局标识符和解析消息类型。为了使用 Any 类型，你需要导入<code>import google/protobuf/any.proto</code></p>
<p>对于给定的消息类型的默认类型 URL 是<code>type.googleapis.com/packagename.messagename</code>。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装 Any 值。例如在 java 中，Any 类型会有特殊的<code>pack()</code>和<code>unpack()</code>访问器，在 C++中会有<code>PackFrom()</code>和<code>UnpackTo()</code>方法。</p>
<p><strong>目前，用于 Any 类型的动态库仍在开发之中</strong></p>
<p>如果你已经很熟悉<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn">proto2 语法</a>，使用 Any 替换<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#extensions">拓展</a></p>
<h2 id="七-Oneof"><a href="#七-Oneof" class="headerlink" title="七 Oneof"></a>七 Oneof</h2><p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用 oneof 特性节省内存.</p>
<p>Oneof 字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用<code>case()</code>或者<code>WhichOneof()</code> 方法检查哪个 oneof 字段被设置， 看你使用什么语言了.</p>
<h2 id="7-1-使用-Oneof"><a href="#7-1-使用-Oneof" class="headerlink" title="7.1 使用 Oneof"></a>7.1 使用 Oneof</h2><p>为了在<code>.proto</code> 定义 Oneof 字段， 你需要在名字前面加上 oneof 关键字, 比如下面例子的 test_oneof:</p>
<p>然后你可以增加 oneof 字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用 repeated 关键字.</p>
<p>在产生的代码中, oneof 字段拥有同样的 getters 和 setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">API 指南</a>中找到 oneof API 介绍.</p>
<h2 id="7-2-Oneof-特性"><a href="#7-2-Oneof-特性" class="headerlink" title="7.2 Oneof 特性"></a>7.2 Oneof 特性</h2><ul>
<li>设置 oneof 会自动清楚其它 oneof 字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
<li>如果解析器遇到同一个 oneof 中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof 不支持<code>repeated</code>.</li>
<li>反射 API 对 oneof 字段有效.</li>
<li>如果使用 C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为<code>sub_message</code> 已经通过<code>set_name()</code>删除了</li>
<li>在 C++中，如果你使用<code>Swap()</code>两个 oneof 消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，<code>msg1</code>会拥有<code>sub_message</code>并且<code>msg2</code>会有<code>name</code>。</li>
</ul>
<h2 id="7-3-向后兼容性问题"><a href="#7-3-向后兼容性问题" class="headerlink" title="7.3 向后兼容性问题"></a>7.3 向后兼容性问题</h2><p>当增加或者删除 oneof 字段时一定要小心. 如果检查 oneof 的值返回<code>None/NOT_SET</code>, 它意味着 oneof 字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个 oneof 字段。</p>
<p>Tage 重用问题：</p>
<ul>
<li>将字段移入或移除 oneof：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li>删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除你现在设置的 oneof 字段</li>
<li>分离或者融合 oneof：行为与移动常规字段相似。</li>
</ul>
<h2 id="八-Map（映射）"><a href="#八-Map（映射）" class="headerlink" title="八 Map（映射）"></a>八 Map（映射）</h2><p>如果你希望创建一个关联映射，protocol buffer 提供了一种快捷的语法：</p>
<p>其中<code>key_type</code>可以是任意 Integer 或者 string 类型（所以，除了 floating 和 bytes 的任意标量类型都是可以的）<code>value_type</code>可以是任意类型。</p>
<p>例如，如果你希望创建一个 project 的映射，每个<code>Projecct</code>使用一个 string 作为 key，你可以像下面这样定义：</p>
<ul>
<li>Map 的字段可以是 repeated。</li>
<li>序列化后的顺序和 map 迭代器的顺序是不确定的，所以你不要期望以固定顺序处理 Map</li>
<li>当为<code>.proto</code> 文件产生生成文本格式的时候，map 会按照 key 的顺序排序，数值化的 key 会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的 key 则后一个 key 不会被使用，当从文本格式中解析 map 时，如果存在重复的 key。</li>
</ul>
<p>生成 map 的 API 现在对于所有 proto3 支持的语言都可用了，你可以从<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">API 指南</a>找到更多信息。</p>
<h2 id="8-1-向后兼容性问题"><a href="#8-1-向后兼容性问题" class="headerlink" title="8.1 向后兼容性问题"></a>8.1 向后兼容性问题</h2><p>map 语法序列化后等同于如下内容，因此即使是不支持 map 语法的 protocol buffer 实现也是可以处理你的数据的：</p>
<h2 id="九-包"><a href="#九-包" class="headerlink" title="九 包"></a>九 包</h2><p>当然可以为<code>.proto</code> 文件新增一个可选的 package 声明符，用来防止不同的消息类型有命名冲突。如：</p>
<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于 C++，产生的类会被包装在 C++的命名空间中，如上例中的<code>Open</code>会被封装在 <code>foo::bar</code>空间中； - 对于 Java，包声明符会变为 java 的一个包，除非在<code>.proto</code> 文件中提供了一个明确有<code>java_package</code>；</li>
<li>对于 Python，这个包声明符是被忽略的，因为 Python 模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于 Go，包可以被用做 Go 包名称，除非你显式的提供一个<code>option go_package</code>在你的<code>.proto</code> 文件中。</li>
<li>对于 Ruby，生成的类可以被包装在内置的 Ruby 名称空间中，转换成 Ruby 所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用 PB_前缀），例如<code>Open</code>会在<code>Foo::Bar</code>名称空间中。</li>
<li>对于 javaNano 包会使用 Java 包，除非你在你的文件中显式的提供一个<code>option java_package</code>。</li>
<li>对于 C#包可以转换为<code>PascalCase</code>后作为名称空间，除非你在你的文件中显式的提供一个<code>option csharp_namespace</code>，例如，<code>Open</code>会在<code>Foo.Bar</code>名称空间中</li>
</ul>
<h2 id="9-1-包及名称的解析"><a href="#9-1-包及名称的解析" class="headerlink" title="9.1 包及名称的解析"></a>9.1 包及名称的解析</h2><p>Protocol buffer 语言中类型名称的解析与 C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （<code>foo.bar.Baz</code>）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer 编译器会解析<code>.proto</code> 文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="十-定义服务-Service"><a href="#十-定义服务-Service" class="headerlink" title="十 定义服务(Service)"></a>十 定义服务(Service)</h2><p>如果想要将消息类型用在 RPC(远程方法调用)系统中，可以在<code>.proto</code> 文件中定义一个 RPC 服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个 RPC 服务并具有一个方法，该方法能够接收 SearchRequest 并返回一个 SearchResponse，此时可以在<code>.proto</code> 文件中进行如下定义：</p>
<p>最直观的使用 protocol buffer 的 RPC 系统是<a href="https://github.com/grpc/grpc-experiments">gRPC</a>一个由谷歌开发的语言和平台中的开源的 PRC 系统，gRPC 在使用 protocl buffer 时非常有效，如果使用特殊的 protocol buffer 插件可以直接为您从<code>.proto</code> 文件中产生相关的 RPC 代码。</p>
<p>如果你不想使用 gRPC，也可以使用 protocol buffer 用于自己的 RPC 实现，你可以从<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#services">proto2 语言指南中找到更多信息</a></p>
<p>还有一些第三方开发的 PRC 实现使用 Protocol Buffer。参考<a href="https://github.com/google/protobuf/blob/master/docs/third_party.md">第三方插件 wiki</a>查看这些实现的列表。</p>
<h2 id="十一-JSON-映射"><a href="#十一-JSON-映射" class="headerlink" title="十一 JSON 映射"></a>十一 JSON 映射</h2><p>Proto3 支持 JSON 的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果 JSON 编码的数据丢失或者其本身就是<code>null</code>，这个数据会在解析成 protocol buffer 的时候被表示成默认值。如果一个字段在 protocol buffer 中表示为默认值，体会在转化成 JSON 的时候编码的时候忽略掉以节省空间。具体实现可以提供在 JSON 编码中可选的默认值。</p>
<table>
<thead>
<tr>
<th>proto3</th>
<th>JSON</th>
<th>JSON 示例</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>object</td>
<td></td>
<td>产生 JSON 对象，消息字段名可以被映射成 lowerCamelCase 形式，并且成为 JSON 对象键，null 被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td>enum</td>
<td>string</td>
<td>“FOO_BAR”</td>
<td>枚举值的名字在 proto 文件中被指定</td>
</tr>
<tr>
<td>map</td>
<td>object</td>
<td></td>
<td>所有的键都被转换成 string</td>
</tr>
<tr>
<td>repeated V</td>
<td>array</td>
<td>[v, …]</td>
<td>null 被视为空列表</td>
</tr>
<tr>
<td>bool</td>
<td>true, false</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>“Hello World!”</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td>base64 string</td>
<td>“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td></td>
</tr>
<tr>
<td>int32, fixed32, uint32</td>
<td>number</td>
<td>1, -10, 0</td>
<td>JSON 值会是一个十进制数，数值型或者 string 类型都会接受</td>
</tr>
<tr>
<td>int64, fixed64, uint64</td>
<td>string</td>
<td>“1”, “-10”</td>
<td>JSON 值会是一个十进制数，数值型或者 string 类型都会接受</td>
</tr>
<tr>
<td>float, double</td>
<td>number</td>
<td>1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td>JSON 值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td>Any</td>
<td>object</td>
<td></td>
<td>如果一个 Any 保留一个特上述的 JSON 映射，则它会转换成一个如下形式：<code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>否则，该值会被转换成一个 JSON 对象，<code>@type</code>字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>string</td>
<td>“1972-01-01T10:00:20.021Z”</td>
<td>使用 RFC 339，其中生成的输出将始终是 Z-归一化啊的，并且使用 0，3，6 或者 9 位小数</td>
</tr>
<tr>
<td>Duration</td>
<td>string</td>
<td>“1.000340012s”, “1s”</td>
<td>生成的输出总是 0，3，6 或者 9 位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td>Struct</td>
<td>object</td>
<td></td>
<td>任意的 JSON 对象，见 struct.proto</td>
</tr>
<tr>
<td>Wrapper types</td>
<td>various types</td>
<td>2, “2”, “foo”, true, “true”, null, 0, …</td>
<td>包装器在 JSON 中的表示方式类似于基本类型，但是允许 nulll，并且在转换的过程中保留 null</td>
</tr>
<tr>
<td>FieldMask</td>
<td>string</td>
<td>“f.fooBar,h”</td>
<td>见 fieldmask.proto</td>
</tr>
<tr>
<td>ListValue</td>
<td>array</td>
<td>[foo, bar, …]</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>value</td>
<td></td>
<td>任意 JSON 值</td>
</tr>
<tr>
<td>NullValue</td>
<td>null</td>
<td></td>
<td>JSON null</td>
</tr>
</tbody></table>
<h2 id="十二-选项"><a href="#十二-选项" class="headerlink" title="十二 选项"></a>十二 选项</h2><p>在定义<code>.proto</code> 文件时能够标注一系列的 options。Options 并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在 google&#x2F;protobuf&#x2F;descriptor.proto 找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum 或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum 类型、enum 值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选择：</p>
<ul>
<li><code>java_package</code> (文件选项) :这个选项表明生成 java 类所在的包。如果在<code>.proto</code> 文件中没有明确的声明 java_package，就采用默认的包名。当然了，默认方式产生的 java 包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生 java 代码，则该选项将不起任何作用。如：</li>
<li><code>java_outer_classname</code> (文件选项): 该选项表明想要生成 Java 类的名称。如果在<code>.proto</code> 文件中没有明确的 java_outer_classname 定义，生成的 class 名称将会根据<code>.proto</code> 文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto 生成的 java 类名为 FooBar.java）,如果不生成 java 代码，则该选项不起任何作用。如：</li>
<li><code>optimize_for</code>(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者 LITE_RUNTIME。这些值将通过如下的方式影响 C++及 java 代码的生成：</li>
<li><code>SPEED (default)</code>: protocol buffer 编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li><code>CODE_SIZE</code>: protocol buffer 编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比 SPEED 要少得多， 但是操作要相对慢些。当然实现的类及其对外的 API 与 SPEED 模式都是一样的。这种方式经常用在一些包含大量的<code>.proto</code> 文件而且并不盲目追求速度的 应用中。</li>
<li><code>LITE_RUNTIME</code>: protocol buffer 编译器依赖于运行时核心类库来生成代码（即采用 libprotobuf-lite 替代 libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与 SPEED 模式不相上下，产生的类通过实现 MessageLite 接口，但它仅仅是 Messager 接口的一个子集。</li>
<li><code>cc_enable_arenas</code>(文件选项):对于 C++产生的代码启用<a href="https://developers.google.com/protocol-buffers/docs/reference/arenas?hl=zh-cn">arena allocation</a></li>
<li><code>objc_class_prefix</code>(文件选项):设置 Objective-C 类的前缀，添加到所有 Objective-C 从此<code>.proto</code> 文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的 3-5 个大写字符，注意 2 个字节的前缀是苹果所保留的。</li>
<li><code>deprecated</code>(字段选项):如果设置为<code>true</code>则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在 java 中，这回变成<code>@Deprecated</code>注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<h2 id="12-1-自定义选项"><a href="#12-1-自定义选项" class="headerlink" title="12.1 自定义选项"></a>12.1 自定义选项</h2><p>ProtocolBuffers 允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 <a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#customoptions">Proto2 Language Guide</a>。注意创建自定义选项使用了拓展，拓展只在 proto3 中可用。</p>
<h2 id="十三-生成访问类"><a href="#十三-生成访问类" class="headerlink" title="十三 生成访问类"></a>十三 生成访问类</h2><p>可以通过定义好的.proto 文件来生成 Java,Python,C++, Ruby, JavaNano, Objective-C,或者 C# 代码，需要基于<code>.proto</code> 文件运行 protocol buffer 编译器 protoc。如果你没有安装编译器，下载<a href="https://developers.google.com/protocol-buffers/docs/downloads?hl=zh-cn">安装包</a>并遵照 README 安装。对于 Go,你还需要安装一个特殊的代码生成器插件。你可以通过 GitHub 上的<a href="https://github.com/golang/protobuf/">protobuf 库</a>找到安装过程</p>
<p>通过如下方式调用 protocol 编译器：</p>
<ul>
<li><code>IMPORT_PATH</code>声明了一个<code>.proto</code> 文件所在的解析 import 具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用<code>--proto_path</code>，它们将会顺序的被访问并执行导入。<code>-I=IMPORT_PATH</code>是<code>--proto_path</code>的简化形式。</li>
<li>当然也可以提供一个或多个输出路径：</li>
<li><code>--cpp_out</code> 在目标目录 DST_DIR 中产生 C++代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated?hl=zh-cn">C++代码生成参考</a>中查看更多。</li>
<li><code>--java_out</code> 在目标目录 DST_DIR 中产生 Java 代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated?hl=zh-cn">Java 代码生成参考</a>中查看更多。</li>
<li><code>--python_out</code> 在目标目录 DST_DIR 中产生 Python 代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated?hl=zh-cn">Python 代码生成参考</a>中查看更多。</li>
<li><code>--go_out</code> 在目标目录 DST_DIR 中产生 Go 代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated?hl=zh-cn">GO 代码生成参考</a>中查看更多。</li>
<li><code>--ruby_out</code>在目标目录 DST_DIR 中产生 Go 代码，参考正在制作中。</li>
<li><code>--javanano_out</code>在目标目录 DST_DIR 中生成 JavaNano，JavaNano 代码生成器有一系列的选项用于定制自定义生成器的输出：你可以通过生成器的<a href="https://github.com/google/protobuf/tree/master/javanano">README</a>查找更多信息，JavaNano 参考正在制作中。</li>
<li><code>--objc_out</code>在目标目录 DST_DIR 中产生 Object 代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated?hl=zh-cn">Objective-C 代码生成参考</a>中查看更多。</li>
<li><code>--csharp_out</code>在目标目录 DST_DIR 中产生 Object 代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/csharp-generated?hl=zh-cn">C#代码生成参考</a>中查看更多。</li>
<li><code>--php_out</code>在目标目录 DST_DIR 中产生 Object 代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/php-generated?hl=zh-cn">PHP 代码生成参考</a>中查看更多。</li>
</ul>
<p>作为一个方便的拓展，如果 DST_DIR 以.zip 或者.jar 结尾，编译器会将输出写到一个 ZIP 格式文件或者符合 JAR 标准的.jar 文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。</p>
<p>- 你必须提议一个或多个<code>.proto</code> 文件作为输入，多个<code>.proto</code> 文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其 IMPORT_PATH 下，以便每个文件可以确定其规范的名称。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>ProtoBuf</tag>
        <tag>​​protoc-gen-go</tag>
        <tag>protoc</tag>
      </tags>
  </entry>
  <entry>
    <title>ProtoBuf 进阶</title>
    <url>//post/2023-protocbuf-protobuf-next.html</url>
    <content><![CDATA[<h2 id="一-定义一个消息类型"><a href="#一-定义一个消息类型" class="headerlink" title="一 定义一个消息类型"></a>一 定义一个消息类型</h2><p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的<code>.proto</code> 文件了：</p>
<span id="more"></span>

<p>官方地址： <a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p>
<h2 id="一-protobuf-基本类型和默认值"><a href="#一-protobuf-基本类型和默认值" class="headerlink" title="一 protobuf 基本类型和默认值"></a>一 protobuf 基本类型和默认值</h2><h3 id="1-1-protobuf-类型和语言对应关系"><a href="#1-1-protobuf-类型和语言对应关系" class="headerlink" title="1.1 protobuf 类型和语言对应关系"></a>1.1 protobuf 类型和语言对应关系</h3><p>该表格展示了定义于<code>.proto</code> 文件中的类型，与 <code>go</code> 和 <code>python</code> 对应的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>Python Type</th>
<th>Go Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>float</td>
<td>float64</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float32</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用 sint64 替代</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>int</td>
<td>uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>int</td>
<td>uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比 int32 高效的多</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的 int64 高效。</td>
<td>int</td>
<td>int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是 4 个字节，如果数值总是比总是比 228 大的话，这个类型会比 uint32 高效。</td>
<td>int</td>
<td>uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是 8 个字节，如果数值总是比总是比 256 大的话，这个类型会比 uint64 高效。</td>
<td>int</td>
<td>uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是 4 个字节</td>
<td>int</td>
<td>int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是 8 个字节</td>
<td>int</td>
<td>int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>bool</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是 UTF-8 编码或者 7-bit ASCII 编码的文本。</td>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>str</td>
<td>[]byte</td>
</tr>
</tbody></table>
<p>可以在文章<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn">Protocol Buffer 编码</a>中，找到更多”序列化消息时各种类型如何编码”的信息。</p>
<ol>
<li>在 <code>java</code> 中，无符号 <code>32</code> 位和 <code>64</code> 位整型被表示成他们的整型对应形似，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li><code>64</code> 位或者无符号 <code>32</code> 位整型在解码时被表示成为 <code>ilong</code>，但是在设置时可以使用 <code>int</code> 型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li><code>python</code> 中 <code>string</code> 被表示成在解码时表示成 <code>unicode</code>。但是一个 <code>ASCIIstring</code> 可以被表示成 <code>str</code> 类型。</li>
<li><code>Integer</code> 在 <code>64</code> 位的机器上使用，<code>string</code> 在 <code>32</code> 位机器上使用</li>
</ol>
<h3 id="1-2-protobuf-默认值"><a href="#1-2-protobuf-默认值" class="headerlink" title="1.2 protobuf 默认值"></a>1.2 protobuf 默认值</h3><p>如果 <code>protobuf</code> 定义了类型，在 <code>gRPC</code> 使用过程中没有传值，会使用默认值</p>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于 <code>strings</code>，默认是一个空 <code>string</code></li>
<li>对于 <code>bytes</code>，默认是一个空的 <code>bytes</code></li>
<li>对于 <code>bools</code>，默认是 <code>false</code></li>
<li>对于<code>数值</code>类型，默认是 <code>0</code></li>
<li>对于<code>枚举</code>，默认是第一个定义的<code>枚举值</code>，必须为 <code>0</code>;</li>
<li>对于<code>消息类型（message）</code>，<code>域</code>没有被设置，确切的消息是根据语言确定的，详见<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a><br>对于<code>可重复域</code>的默认值是<code>空</code>（通常情况下是对应语言中空列表）。<br>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如 <code>boolean</code> 值是否被设置为 <code>false</code>）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义 <code>boolean</code> 的默认值 <code>false</code> 作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。<br>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>选择你的语言的默认值的工作细节</li>
</ul>
<h4 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h4><p><strong>目录结构</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf">proto_default_demo
  <span class="token operator">-</span>client
  main<span class="token punctuation">.</span>go
  <span class="token operator">-</span>proto
  hello<span class="token punctuation">.</span>proto
  <span class="token operator">-</span>server
  main<span class="token punctuation">.</span>go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>hello.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>
<span class="token comment">// 定义一个服务,gRPC自有的，它需要用grpc插件生成，也就是咱们安装的那个插件</span>
<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token comment">// 服务内有一个函数叫Hello，接收HelloRequest类型参数，返回HelloResponse类型参数</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 类似于go的结构体，可以定义属性</span>
<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1 是编号，不是值</span>
  <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">repeated</span> <span class="token builtin">string</span> girls <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>
<span class="token comment">// 定义一个响应的类型</span>
<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. <span class="token parameter variable">--go_opt</span><span class="token operator">=</span>paths<span class="token operator">=</span>source_relative ./hello.proto
//protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false --go-grpc_opt<span class="token operator">=</span>paths<span class="token operator">=</span>source_relative ./hello.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/proto_default_demo/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 不传值，看服务端打印</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//打印出返回的数据</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的消息为："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Name<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二-option-go-package-的作用"><a href="#二-option-go-package-的作用" class="headerlink" title="二 option go_package 的作用"></a>二 option go_package 的作用</h2><p>可以为<code>.proto</code> 文件新增一个可选的 <code>package</code> 声明符，用来防止不同的消息类型有命名冲突,区分语言，<code>go_package</code> 为 <code>go</code> 语言的定义</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">// 基本使用</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>
<span class="token comment">// 这样会把go文件生成到当前路径，并且go文件的包名为proto</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 指定生成的go文件放到某个路径下
option go_package <span class="token operator">=</span> <span class="token string">"common/hello/proto/v1"</span><span class="token punctuation">;</span>
// 这样会把go文件生成到当前路径下的common/hello/proto/文件夹中，包名为v1

// 使用命令生成
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./hello.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./hello.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">// 指定生成的go文件放到某个路径下</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">"../../common/hello/proto/v1"</span><span class="token punctuation">;</span>
<span class="token comment">// 这样会把go文件生成到当前路径下的上两级目录的common/hello/proto/文件夹中，包名为v1</span>
<span class="token comment">// 这样便于以后公共的生成到一起，多个微服务共用同样的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 使用命令生成
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./hello.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./hello.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="三-服务端客户端同步问题"><a href="#三-服务端客户端同步问题" class="headerlink" title="三 服务端客户端同步问题"></a>三 服务端客户端同步问题</h2><p>因为客户端和服务端要使用同一个 <code>proto</code> 文件，可能是两个人写的，如果两个 <code>proto</code> 文件内容不一致，会导致错误</p>
<h3 id="3-1-顺序导致的错误"><a href="#3-1-顺序导致的错误" class="headerlink" title="3.1 顺序导致的错误"></a>3.1 顺序导致的错误</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dif_proto
<span class="token parameter variable">-server</span>
    <span class="token parameter variable">-main.go</span>
<span class="token parameter variable">-proto</span>
    <span class="token parameter variable">-hello.proto</span>  // 该文件应该和client下的文件完全一致
<span class="token parameter variable">-client</span>
    <span class="token parameter variable">-main.go</span>
    <span class="token parameter variable">-proto</span>
    <span class="token parameter variable">-hello.proto</span> // 该文件应该和server下的文件完全一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;proto&#x2F;hello.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>

<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 服务端编号为 name是1，gender 是2</span>
  <span class="token builtin">string</span> gender <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;proto&#x2F;hello.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>

<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 客户端编号与服务端编号顺序不一致 name是2，gender 是1</span>
  <span class="token builtin">string</span> gender <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>
<span class="token comment">// 定义一个响应的类型</span>
<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> dif_proto/client/proto
//protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./hello.proto
//protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./hello.proto
<span class="token builtin class-name">cd</span> dif_proto/server/proto
//protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./hello.proto
//protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./hello.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/dif_proto/client/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span>
		Name<span class="token punctuation">:</span>   <span class="token string">"lqz"</span><span class="token punctuation">,</span>
		Gender<span class="token punctuation">:</span> <span class="token string">"男"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//打印出返回的数据</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/dif_proto/server/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"name:"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"gender:"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>Gender<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>Reply<span class="token punctuation">:</span> <span class="token string">"ok"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-服务端数据多，客户端数据少"><a href="#3-2-服务端数据多，客户端数据少" class="headerlink" title="3.2 服务端数据多，客户端数据少"></a>3.2 服务端数据多，客户端数据少</h3><p>这样不客户端和服务端都能运行，只是数据会少</p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">//client/proto/hello.proto</span>
<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">string</span> gender <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//server/proto/hello.proto</span>
<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 重新命令生成go文件，重新运行客户端和服务端</span>

<span class="token comment">// 程序正常运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="四-import-另一个-proto"><a href="#四-import-另一个-proto" class="headerlink" title="四 import 另一个 proto"></a>四 import 另一个 proto</h2><h3 id="4-1-引入自定义的-proto"><a href="#4-1-引入自定义的-proto" class="headerlink" title="4.1 引入自定义的 proto"></a>4.1 引入自定义的 proto</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 目录结构
import_proto
  <span class="token parameter variable">-client</span>
  <span class="token parameter variable">-main.go</span>
  <span class="token parameter variable">-server</span>
  <span class="token parameter variable">-main.go</span>
  <span class="token parameter variable">-proto</span>
  <span class="token parameter variable">-order.proto</span>
  <span class="token parameter variable">-base.proto</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>proto&#x2F;order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"base.proto"</span><span class="token punctuation">;</span>  <span class="token comment">// 导入另一个proto，就可以使用里面的Empty和Pong了</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>

<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 因为 rpc的服务必须要传一个参数，但是有时候我们不需要传参数，所以定义一个Empty的message</span>
  <span class="token keyword">rpc</span> <span class="token function">Ping</span><span class="token punctuation">(</span><span class="token class-name">Empty</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">Pong</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>oproto&#x2F;order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span> <span class="token comment">// 此处不要忘了加入包的声明</span>
<span class="token keyword">message</span> <span class="token class-name">Empty</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 定义一个Pong</span>
<span class="token keyword">message</span> <span class="token class-name">Pong</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">int32</span> code <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto
// base.proto也要生成
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./base.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>Empty<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//打印出返回的数据</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Code<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的消息为："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Name<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Ping</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>Empty<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token comment">//request是Empty的对象，没有值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">&#123;</span>Code<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-引入内置的-proto"><a href="#4-2-引入内置的-proto" class="headerlink" title="4.2 引入内置的 proto"></a>4.2 引入内置的 proto</h3><p><strong>proto&#x2F;order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"base.proto"</span><span class="token punctuation">;</span>  <span class="token comment">// 导入另一个proto，就可以使用里面的Empty和Pong了</span>
<span class="token comment">// 引入谷歌提供的，必须要使用protoc/include/google/protobuf内带empty.proto文件，否则报错</span>
<span class="token keyword">import</span> <span class="token string">"google/protobuf/empty.proto"</span><span class="token punctuation">;</span> <span class="token comment">// 谷歌内置了empty给咱们用，按住control可以看源码，内有go_package是go包导入路径</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>

<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 因为 rpc的服务必须要传一个参数，但是有时候我们不需要传参数，所以定义一个Empty的message</span>
  <span class="token comment">//  rpc Ping(Empty) returns(Pong);</span>
  <span class="token comment">// 此处使用必须用google.protobuf.Empty</span>
  <span class="token keyword">rpc</span> <span class="token function">Ping</span><span class="token punctuation">(</span><span class="token class-name">google.protobuf.Empty</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">Pong</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>oproto&#x2F;order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span> <span class="token comment">// 此处不要忘了加入包的声明</span>

<span class="token comment">// 定义一个Pong</span>
<span class="token keyword">message</span> <span class="token class-name">Pong</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">int32</span> code <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto
// base.proto也要生成
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./base.proto

// 删除已下载的模块缓存
go clean <span class="token parameter variable">--modcache</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/golang/protobuf/ptypes/empty"</span> <span class="token comment">// empty使用这个包下的</span>
	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> empty<span class="token punctuation">.</span>Empty<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//打印出返回的数据</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Code<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"github.com/golang/protobuf/ptypes/empty"</span> <span class="token comment">// empty使用这个包下的</span>
	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的消息为："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Name<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Ping</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>empty<span class="token punctuation">.</span>Empty<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token comment">//request是Empty的对象，没有值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">&#123;</span>Code<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="五-嵌套-message-对象"><a href="#五-嵌套-message-对象" class="headerlink" title="五 嵌套 message 对象"></a>五 嵌套 message 对象</h2><p><code>proto</code> 文件的 <code>message</code> 可以嵌套其他的 <code>message</code>，修改 <code>order.proto</code> 如下</p>
<p><strong>order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"base.proto"</span><span class="token punctuation">;</span>  <span class="token comment">// 导入另一个proto，就可以使用里面的Empty和Pong了</span>
<span class="token keyword">import</span> <span class="token string">"google/protobuf/empty.proto"</span><span class="token punctuation">;</span> <span class="token comment">// 谷歌内置了empty给咱们用，按住control可以看源码，内有go_package是go包导入路径</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>


<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 因为 rpc的服务必须要传一个参数，但是有时候我们不需要传参数，所以定义一个Empty的message</span>
  <span class="token comment">//  rpc Ping(Empty) returns(Pong);</span>
  <span class="token comment">// 此处使用必须用google.protobuf.Empty</span>
  <span class="token keyword">rpc</span> <span class="token function">Ping</span><span class="token punctuation">(</span><span class="token class-name">google.protobuf.Empty</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">Pong</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">message</span> <span class="token class-name">Result</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 嵌套Result，也可以放在message HelloResponse外面</span>
    <span class="token builtin">string</span> code <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token builtin">string</span> msg <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token positional-class-name class-name">Result</span> data <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto
// base.proto也要生成
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./base.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">//message嵌套，可以嵌套获取</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Data<span class="token punctuation">.</span>Code<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Data<span class="token punctuation">.</span>Msg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"github.com/golang/protobuf/ptypes/empty"</span> <span class="token comment">// empty使用这个包下的</span>
	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>
		Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的消息为："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>
		Data<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse_Result<span class="token punctuation">&#123;</span>Code<span class="token punctuation">:</span> <span class="token string">"100"</span><span class="token punctuation">,</span> Msg<span class="token punctuation">:</span> <span class="token string">"成功"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 注意此处，嵌套的Result变成了HelloResponse_Result</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Ping</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>empty<span class="token punctuation">.</span>Empty<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token comment">//request是Empty的对象，没有值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>Pong<span class="token punctuation">&#123;</span>Code<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="六-enum-枚举类型"><a href="#六-enum-枚举类型" class="headerlink" title="六 enum 枚举类型"></a>六 enum 枚举类型</h2><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>

<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token positional-class-name class-name">Gender</span> gen <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 使用枚举类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义枚举类型</span>
<span class="token keyword">enum</span> <span class="token class-name">Gender</span><span class="token punctuation">&#123;</span>
  Male <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  Female <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>
		Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的性别为："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Gen<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	<span class="token comment">// 使用枚举类型Gen: proto.Gender_Male，本质是int32</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">,</span> Gen<span class="token punctuation">:</span> proto<span class="token punctuation">.</span>Gender_Male<span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="七-map-类型"><a href="#七-map-类型" class="headerlink" title="七 map 类型"></a>七 map 类型</h2><p><strong>order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>


<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token positional-class-name class-name">Gender</span> gen <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 使用枚举类型</span>
  <span class="token map class-name">map<span class="token punctuation">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token builtin">string</span><span class="token punctuation">></span></span> info <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// map类型，要指定key和value的类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义枚举类型</span>
<span class="token keyword">enum</span> <span class="token class-name">Gender</span><span class="token punctuation">&#123;</span>
  Male <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  Female <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token comment">// 取出map类型</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>
		Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的map："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Info<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	<span class="token comment">// 使用map类型，实质给映射成map[string]string</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">,</span>
		Gen<span class="token punctuation">:</span>  proto<span class="token punctuation">.</span>Gender_Male<span class="token punctuation">,</span>
		Info<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token string">"19"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="八-内置的-timestamp-类型"><a href="#八-内置的-timestamp-类型" class="headerlink" title="八 内置的 timestamp 类型"></a>八 内置的 timestamp 类型</h2><p><strong>order.proto</strong></p>
<pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"google/protobuf/timestamp.proto"</span><span class="token punctuation">;</span>  <span class="token comment">// 先引入</span>
<span class="token keyword">option</span> go_package <span class="token operator">=</span> <span class="token string">".;proto"</span><span class="token punctuation">;</span>


<span class="token keyword">service</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">HelloResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token positional-class-name class-name">Gender</span> gen <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 使用枚举类型</span>
  <span class="token map class-name">map<span class="token punctuation">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token builtin">string</span><span class="token punctuation">></span></span> info <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// map类型，要指定key和value的类型</span>
  <span class="token positional-class-name class-name">google<span class="token punctuation">.</span>protobuf<span class="token punctuation">.</span>Timestamp</span> now <span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 使用Timestamp时间类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">message</span> <span class="token class-name">HelloResponse</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义枚举类型</span>
<span class="token keyword">enum</span> <span class="token class-name">Gender</span><span class="token punctuation">&#123;</span>
  Male <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  Female <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>命令生成 go 文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 切换到相应路径下
protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. ./order.proto
protoc --go-grpc_out<span class="token operator">=</span>. --go-grpc_opt<span class="token operator">=</span>require_unimplemented_servers<span class="token operator">=</span>false  ./order.proto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>server&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> HelloServer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>HelloServer<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>context context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> request <span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token comment">//此处打印出默认值</span>
	<span class="token comment">// 取出map类型</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>proto<span class="token punctuation">.</span>HelloResponse<span class="token punctuation">&#123;</span>
		Reply<span class="token punctuation">:</span> <span class="token string">"收到客户端的时间："</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>Now<span class="token punctuation">.</span><span class="token function">AsTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	g <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	s <span class="token operator">:=</span> HelloServer<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	proto<span class="token punctuation">.</span><span class="token function">RegisterHelloServer</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	lis<span class="token punctuation">,</span> <span class="token builtin">error</span> <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"0.0.0.0:50052"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token builtin">error</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"启动服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	g<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>client&#x2F;main.go</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>

	<span class="token string">"go_test_learn/import_proto/proto"</span>
	<span class="token string">"google.golang.org/grpc"</span>
	<span class="token string">"google.golang.org/grpc/credentials/insecure"</span>

	<span class="token comment">// "github.com/golang/protobuf/ptypes/timestamp" // 不导入这个路径</span>
	<span class="token string">"google.golang.org/protobuf/types/known/timestamppb"</span> <span class="token comment">//上指向这个，直接导入这个路径</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:50052"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">WithTransportCredentials</span><span class="token punctuation">(</span>insecure<span class="token punctuation">.</span><span class="token function">NewCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接服务异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	client <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">NewHelloClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	request <span class="token operator">:=</span> proto<span class="token punctuation">.</span>HelloRequest<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">,</span>
		Gen<span class="token punctuation">:</span>  proto<span class="token punctuation">.</span>Gender_Male<span class="token punctuation">,</span>
		Info<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"lqz"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token string">"19"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		Now<span class="token punctuation">:</span>  timestamppb<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// timestamppb有New方法，传入Time对象即可</span>
	<span class="token punctuation">&#125;</span>
	res<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"调用方法异常"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>ProtoBuf</tag>
        <tag>​​protoc-gen-go</tag>
        <tag>protoc</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul API 文档</title>
    <url>//post/2023-consul-consul-api-doc.html</url>
    <content><![CDATA[<p><code>官方 API 文档</code> ： <a href="https://developer.hashicorp.com/consul/api-docs">https://developer.hashicorp.com/consul/api-docs</a></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Micro</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Consul</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言开发环境(二) Python编译安装配置</title>
    <url>//post/2023-python-python-install-centos8.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8.4</td>
</tr>
<tr>
<td>Python</td>
<td>3.8.10</td>
</tr>
</tbody></table>
<p>对于Windows和Mac用户，只需双击下载的安装程序，然后按照提示完成安装<br>对于Linux用户，需要手动安装，具体方法可以查看官方文档</p>
<h2 id="下载Python源代码"><a href="#下载Python源代码" class="headerlink" title="下载Python源代码"></a>下载Python源代码</h2><p>选择适合你的操作系统的版本，比如Windows、Mac或Linux</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /tmp
<span class="token function">wget</span> https://www.python.org/ftp/python/3.8.10/Python-3.8.10.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> Python-3.8.10.tgz
<span class="token builtin class-name">cd</span> Python-3.8.10
<span class="token function">sudo</span> ./configure --enable-optimizations
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span> <span class="token comment"># 注意：使用 altinstall 可以避免覆盖系统默认的 Python 版本。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<h2 id="配置-Python-开发目录和环境变量"><a href="#配置-Python-开发目录和环境变量" class="headerlink" title="配置 Python 开发目录和环境变量"></a>配置 Python 开发目录和环境变量</h2><p><strong>配置<code>$HOME/.bashrc</code>，将环境变量追加到<code>$HOME/.bashrc</code></strong></p>
<p>需要将Python编译器的二进制文件路径添加到PATH环境变量中<br>对于Windows用户，在“系统属性”中设置环境变量<br>对于Linux和Mac用户，需要编辑bashrc或bash_profile文件</p>
<pre class="line-numbers language-none"><code class="language-none"># 文件末尾追加
tee -a $HOME&#x2F;.bashrc &lt;&lt;&#39;EOF&#39;
export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;bin
EOF

bash  # 加载 .bashrc 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-V</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="使用-pipenv-初始化工作区"><a href="#使用-pipenv-初始化工作区" class="headerlink" title="使用 pipenv 初始化工作区"></a>使用 pipenv 初始化工作区</h2><h3 id="安装和配置-pipenv"><a href="#安装和配置-pipenv" class="headerlink" title="安装和配置 pipenv"></a>安装和配置 pipenv</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> pipenv
pipenv <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<h3 id="初始化工作区"><a href="#初始化工作区" class="headerlink" title="初始化工作区"></a>初始化工作区</h3><h4 id="使用-pipenv-创建一个虚拟环境-与-项目目录绑定"><a href="#使用-pipenv-创建一个虚拟环境-与-项目目录绑定" class="headerlink" title="使用 pipenv 创建一个虚拟环境 与 项目目录绑定"></a>使用 pipenv 创建一个虚拟环境 与 项目目录绑定</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$WORKSPACE</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token builtin class-name">test</span>
<span class="token builtin class-name">cd</span> <span class="token builtin class-name">test</span>

<span class="token comment"># 从 Pipfile 安装 ，Pipfile如果一个不存在，这将创建一个</span>
pipenv <span class="token function">install</span>
<span class="token comment"># 激活 Pipenv shell ， 这将生成一个新的 shell 子进程，可以使用exit退出.</span>
pipenv shell

python <span class="token parameter variable">--version</span>

<span class="token comment"># 查看虚拟环境中安装的包</span>
pip list

<span class="token comment"># Package    Version</span>
<span class="token comment"># ---------- -------</span>
<span class="token comment"># pip        23.0.1</span>
<span class="token comment"># setuptools 67.4.0</span>
<span class="token comment"># wheel      0.38.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="安装-Flask-框架"><a href="#安装-Flask-框架" class="headerlink" title="安装 Flask 框架"></a>安装 Flask 框架</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在虚拟环境中安装 flask</span>
pipenv <span class="token function">install</span> flask
<span class="token comment"># 在虚拟环境中卸载 flask</span>
pipenv uninstall flask
<span class="token comment"># 查看是否安装成功</span>
flask <span class="token parameter variable">--version</span>
<span class="token comment"># 查看安装包依赖关系</span>
pipenv graph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>













]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Git</tag>
        <tag>开发环境</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 案例,技巧</title>
    <url>//post/2023-python-python-skill-study.html</url>
    <content><![CDATA[<h2 id="数值与字符串"><a href="#数值与字符串" class="headerlink" title="数值与字符串"></a>数值与字符串</h2><p>数值转换</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> source <span class="token operator">=</span> <span class="token number">100</span>
<span class="token operator">>></span><span class="token operator">></span> temp <span class="token operator">=</span> <span class="token number">37.2</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
<span class="token number">37</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">float</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
<span class="token number">100.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<p>定义数值字面量过长 ，可以通过插入 <code>_</code> 分隔符来变得易读</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> <span class="token number">1_000_000</span>
<span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">10</span>
<span class="token number">1000010</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>浮点数计算精度问题 ， 内置模块： <code>decimal</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal
<span class="token comment"># 注意这里的 0.1 和 0.2 必须是字符串</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'0.1'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'0.2'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>布尔值其实也是数字(<code>True 1</code>,<code>False 0</code>) ， 可以用来简化统计总数操作</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 计算列表 一共有多少个偶数</span>
numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>

count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>
    <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>

count <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> numbers<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
````


字符串也是一种序列类型

```python
usernames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'asdds'</span><span class="token punctuation">,</span> <span class="token string">'raymondzhu'</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> username <span class="token keyword">in</span> usernames<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span>


chars <span class="token operator">=</span> <span class="token string">'abc'</span>

<span class="token comment"># 展开赋值为多个变量，就好像 a, b, c = ['a', 'b', 'c'] 一样</span>
a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> chars

<span class="token comment"># 循环整个字符串</span>
<span class="token keyword">for</span> ch <span class="token keyword">in</span> chars<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>

<span class="token comment"># 对字符串做切片</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment"># 输出：</span>
<span class="token comment"># ab</span>

<span class="token comment"># 调用 join 方法拼接</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出：</span>
<span class="token comment"># a_b_c</span>

<span class="token comment"># 用星号表达式展开</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&#123;&#125;&#123;&#125;&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token operator">*</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出：</span>
<span class="token comment"># abc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>字符串的格式化</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">username<span class="token punctuation">,</span> score <span class="token operator">=</span> <span class="token string">'piglei'</span><span class="token punctuation">,</span> <span class="token number">100</span>

<span class="token comment"># f-string</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Welcome </span><span class="token interpolation"><span class="token punctuation">&#123;</span>username<span class="token punctuation">&#125;</span></span><span class="token string">, your score is </span><span class="token interpolation"><span class="token punctuation">&#123;</span>score<span class="token punctuation">:</span><span class="token format-spec">d</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>

<span class="token comment"># str.format</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Welcome &#123;&#125;, your score is &#123;:d&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># C 风格格式化</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Welcome %s, your score is %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>username<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&#123;:>20&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>username<span class="token punctuation">:</span><span class="token format-spec">>20</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>


<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&#123;0&#125;: name=&#123;0&#125; score=&#123;1&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><code>text</code> vs <code>orm</code> </p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span>
<span class="token keyword">import</span> datetime
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> create_engine
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> <span class="token punctuation">(</span>
    Table<span class="token punctuation">,</span>
    Column<span class="token punctuation">,</span>
    Integer<span class="token punctuation">,</span>
    String<span class="token punctuation">,</span>
    MetaData<span class="token punctuation">,</span>
    ForeignKey<span class="token punctuation">,</span>
    DateTime<span class="token punctuation">,</span>
    Boolean<span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token keyword">from</span> sqlalchemy<span class="token punctuation">.</span>sql <span class="token keyword">import</span> select


metadata <span class="token operator">=</span> MetaData<span class="token punctuation">(</span><span class="token punctuation">)</span>

users <span class="token operator">=</span> Table<span class="token punctuation">(</span>
    <span class="token string">'users'</span><span class="token punctuation">,</span>
    metadata<span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> Integer<span class="token punctuation">,</span> primary_key<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> String<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'gender'</span><span class="token punctuation">,</span> Integer<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'level'</span><span class="token punctuation">,</span> Integer<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'has_membership'</span><span class="token punctuation">,</span> Boolean<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">,</span> default<span class="token operator">=</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">)</span><span class="token punctuation">,</span>
    Column<span class="token punctuation">(</span><span class="token string">'created'</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">,</span> default<span class="token operator">=</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>


GENDER_FEMALE <span class="token operator">=</span> <span class="token number">0</span>
GENDER_MALE <span class="token operator">=</span> <span class="token number">1</span>


<span class="token keyword">def</span> <span class="token function">fetch_users</span><span class="token punctuation">(</span>
    conn<span class="token punctuation">,</span>
    min_level<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    gender<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    has_membership<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    sort_field<span class="token operator">=</span><span class="token string">"created"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""获取用户列表

    :param min_level: 要求的最低用户级别，默认为所有级别
    :type min_level: int, optional
    :param gender: 筛选用户性别，默认为所有性别
    :type gender: int, optional
    :param has_membership: 筛选会员或非会员用户，默认为 False，代表非会员
    :type has_membership: bool, optional
    :param sort_field: 排序字段，默认为 "created"，代表按用户创建日期排序
    :type sort_field: str, optional
    :return: 一个包含用户信息的列表：[(User ID, User Name), ...]
    """</span>
    <span class="token comment"># 一种古老的 SQL 拼接技巧，使用 "WHERE 1=1" 来简化字符串拼接操作</span>
    statement <span class="token operator">=</span> <span class="token string">"SELECT id, name FROM users WHERE 1=1"</span>
    params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> min_level <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        statement <span class="token operator">+=</span> <span class="token string">" AND level >= ?"</span>
        params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min_level<span class="token punctuation">)</span>
    <span class="token keyword">if</span> gender <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        statement <span class="token operator">+=</span> <span class="token string">" AND gender >= ?"</span>
        params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>gender<span class="token punctuation">)</span>
    <span class="token keyword">if</span> has_membership<span class="token punctuation">:</span>
        statement <span class="token operator">+=</span> <span class="token string">" AND has_membership = true"</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        statement <span class="token operator">+=</span> <span class="token string">" AND has_membership = false"</span>

    statement <span class="token operator">+=</span> <span class="token string">" ORDER BY ?"</span>
    params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sort_field<span class="token punctuation">)</span>
    <span class="token comment"># 将查询参数 params 作为位置参数传递，避免 SQL 注入问题</span>
    <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>statement<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">fetch_users_v2</span><span class="token punctuation">(</span>
    conn<span class="token punctuation">,</span>
    min_level<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    gender<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    has_membership<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    sort_field<span class="token operator">=</span><span class="token string">"created"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""获取用户列表"""</span>
    query <span class="token operator">=</span> select<span class="token punctuation">(</span><span class="token punctuation">[</span>users<span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token builtin">id</span><span class="token punctuation">,</span> users<span class="token punctuation">.</span>c<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> min_level <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        query <span class="token operator">=</span> query<span class="token punctuation">.</span>where<span class="token punctuation">(</span>users<span class="token punctuation">.</span>c<span class="token punctuation">.</span>level <span class="token operator">>=</span> min_level<span class="token punctuation">)</span>
    <span class="token keyword">if</span> gender <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        query <span class="token operator">=</span> query<span class="token punctuation">.</span>where<span class="token punctuation">(</span>users<span class="token punctuation">.</span>c<span class="token punctuation">.</span>gender <span class="token operator">==</span> gender<span class="token punctuation">)</span>
    query <span class="token operator">=</span> query<span class="token punctuation">.</span>where<span class="token punctuation">(</span>users<span class="token punctuation">.</span>c<span class="token punctuation">.</span>has_membership <span class="token operator">==</span> has_membership<span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span>users<span class="token punctuation">.</span>c<span class="token punctuation">[</span>sort_field<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span><span class="token string">'sqlite:///:memory:'</span><span class="token punctuation">,</span> echo<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    metadata<span class="token punctuation">.</span>create_all<span class="token punctuation">(</span>engine<span class="token punctuation">)</span>

    conn <span class="token operator">=</span> engine<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>
        users<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span>
            <span class="token punctuation">&#123;</span>
                <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"piglei"</span><span class="token punctuation">,</span>
                <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token string">"level"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
                <span class="token string">"has_membership"</span><span class="token punctuation">:</span> <span class="token boolean">False</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#123;</span>
                <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"cotton"</span><span class="token punctuation">,</span>
                <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
                <span class="token string">"level"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
                <span class="token string">"has_membership"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"zyx"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"level"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"has_membership"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>

    <span class="token keyword">for</span> func <span class="token keyword">in</span> <span class="token punctuation">(</span>fetch_users<span class="token punctuation">,</span> fetch_users_v2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> min_level<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> has_membership<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> min_level<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>使用特殊数字： 无穷大<br>比如一个包含用户名和年龄的字典，把里面的用户名按照年龄升序排序，没有年龄的放在最后</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">users <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"tom"</span><span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jenny"</span><span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token string">"jack"</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"andrew"</span><span class="token punctuation">:</span> <span class="token number">43</span><span class="token punctuation">&#125;</span>


<span class="token keyword">def</span> <span class="token function">sort_users</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 普通写法：生成一份复合排序 key：（是否没有年龄，年龄）</span>
    <span class="token keyword">def</span> <span class="token function">key_func</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">:</span>
        age <span class="token operator">=</span> users<span class="token punctuation">[</span>username<span class="token punctuation">]</span>
        <span class="token comment"># 当年龄为空时，第一个元素值为 True，永远会被排在最后面</span>
        <span class="token keyword">return</span> age <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">,</span> age

    <span class="token keyword">return</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>users<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>key_func<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">sort_users_inf</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">key_func</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">:</span>
        age <span class="token operator">=</span> users<span class="token punctuation">[</span>username<span class="token punctuation">]</span>
        <span class="token comment"># 当年龄为空时，返回正无穷大做为 key，因此就会被排到最后面</span>
        <span class="token keyword">return</span> age <span class="token keyword">if</span> age <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>users<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>key_func<span class="token punctuation">)</span>


<span class="token keyword">print</span><span class="token punctuation">(</span>sort_users<span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sort_users_inf<span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改善代码可读性<br>使用<code>enum</code> 内置模块枚举 或 常量</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span>


<span class="token keyword">def</span> <span class="token function">add_daily_points</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""当用户每天第一次登录后，为其增加积分"""</span>
    <span class="token keyword">if</span> user<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> user<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
        user<span class="token punctuation">.</span>points <span class="token operator">+=</span> <span class="token number">120</span>
        <span class="token keyword">return</span>
    user<span class="token punctuation">.</span>points <span class="token operator">+=</span> <span class="token number">100</span>
    <span class="token keyword">return</span>


DAILY_POINTS_REWARDS <span class="token operator">=</span> <span class="token number">100</span>
VIP_EXTRA_POINTS <span class="token operator">=</span> <span class="token number">20</span>

<span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum


<span class="token keyword">class</span> <span class="token class-name">UserType</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># VIP 用户</span>
    VIP <span class="token operator">=</span> <span class="token number">3</span>
    <span class="token comment"># 小黑屋用户</span>
    BANNED <span class="token operator">=</span> <span class="token number">13</span>


<span class="token keyword">def</span> <span class="token function">add_daily_points</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""当用户每天第一次登录后，为其增加积分"""</span>
    <span class="token keyword">if</span> user<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> UserType<span class="token punctuation">.</span>BANNED<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> user<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> UserType<span class="token punctuation">.</span>VIP<span class="token punctuation">:</span>
        user<span class="token punctuation">.</span>points <span class="token operator">+=</span> DAILY_POINTS_REWARDS <span class="token operator">+</span> VIP_EXTRA_POINTS
        <span class="token keyword">return</span>
    user<span class="token punctuation">.</span>points <span class="token operator">+=</span> DAILY_POINTS_REWARDS
    <span class="token keyword">return</span>


UserType<span class="token punctuation">.</span>XX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>长字符串的可读性，使用<code>括号</code>将长字符串抱起来</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span>
<span class="token comment"># A simple logger as print</span>
<span class="token keyword">import</span> textwrap
<span class="token keyword">import</span> logging
<span class="token keyword">import</span> logging<span class="token punctuation">.</span>handlers

hdr <span class="token operator">=</span> logging<span class="token punctuation">.</span>StreamHandler<span class="token punctuation">(</span><span class="token punctuation">)</span>
hdr<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>Formatter<span class="token punctuation">(</span><span class="token string">'[%(asctime)s] %(name)s:%(levelname)s: %(message)s'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>hdr<span class="token punctuation">)</span>
logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"There is something really bad happened during the "</span>
                 <span class="token string">"process. Please contact your administrator."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># if user.is_active:</span>
    <span class="token keyword">if</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        message <span class="token operator">=</span> textwrap<span class="token punctuation">.</span>dedent<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""\
            Welcome, here is your movie list:
            - Jaw (1975)
            - The Shining (1980)
            - Saw (2004)"""</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>



<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<hr>
<h2 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h2><p>list 是非常经典的容器类型，通常用于存放多个同类对象，比如从 1 到 10 的所有整数</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言开发环境(一) linux 服务器配置</title>
    <url>//post/2023-python-python-workspace-centos8.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>环境&#x2F;组件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mac M1虚拟机</td>
<td>Centos8.4</td>
</tr>
<tr>
<td>Git</td>
<td>2.39.2</td>
</tr>
</tbody></table>
<h3 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h3><p>使用<code>root</code>用户登录Linux服务器，并创建普通用户</p>
<p>一般来说， 一个项目会由多个开发人员协作完成 。 为了节省企业成本，公司不会为每个开发人员都配备一台服务器 ， 而是让所有的开发人员共用一个开发机，并以普通用户的身份登录开发机进行开发。</p>
<p>尽量避免使用<code>root</code>账户 ， 以普通用户登录和操作开发机可以保证系统的安全性</p>
<span id="more"></span>
<p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> pying  <span class="token comment"># 创建用户</span>
<span class="token function">passwd</span> pying    <span class="token comment"># 设置密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>演示</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># useradd pying</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># passwd pying</span>
Changing password <span class="token keyword">for</span> user pying.
New password:
BAD PASSWORD: The password is shorter than <span class="token number">8</span> characters
Retype new password:
passwd: all authentication tokens updated successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="添加sudoers"><a href="#添加sudoers" class="headerlink" title="添加sudoers"></a>添加<code>sudoers</code></h3><p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 把用户pying添加/etc/sudoers文件</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'/^root.*ALL=(ALL)/a\pying\tALL=(ALL) \tALL'</span>  /etc/sudoers
<span class="token comment"># 在/etc/sudoers文件中查找</span>
<span class="token comment"># root	ALL=(ALL) 	ALL</span>
<span class="token comment"># 在此行下添加</span>
<span class="token comment"># pying	ALL=(ALL) 	ALL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 把用户pying添加wheel组</span>
<span class="token function">usermod</span> <span class="token parameter variable">-aG</span> wheel pying
<span class="token comment"># -a 添加用户到基本的组，仅和 -G选项一起使用</span>
<span class="token comment"># -G 用户也是其成员的补充组列表。 每个组之间用逗号分隔，中间没有空格。如果用户当前是未列出的组的成员，则该用户将从该组中删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>测试</strong></p>
<pre class="line-numbers language-none"><code class="language-none">sudo -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="替换CentOS8-4系统自带的Yum源"><a href="#替换CentOS8-4系统自带的Yum源" class="headerlink" title="替换CentOS8.4系统自带的Yum源"></a>替换<code>CentOS8.4</code>系统自带的<code>Yum</code>源</h3><p>官方的Yum源已不可用</p>
<p><code>阿里镜像源</code> <a href="https://mirrors.aliyun.com/repo/">https://mirrors.aliyun.com/repo/</a></p>
<p><strong>命令</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/yum.repos.d/ /etc/yum.repos.d.bak
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/yum.repos.d/
<span class="token function">wget</span> <span class="token parameter variable">-O</span> /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
dnf clean all <span class="token operator">&amp;&amp;</span> dnf makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>演示</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/ /etc/yum.repos.d.bak</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /etc/yum.repos.d/</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span>
--2023-02-23 09:39:05--  https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
Resolving mirrors.aliyun.com <span class="token punctuation">(</span>mirrors.aliyun.com<span class="token punctuation">)</span><span class="token punctuation">..</span>. <span class="token number">198.18</span>.0.49
Connecting to mirrors.aliyun.com <span class="token punctuation">(</span>mirrors.aliyun.com<span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">198.18</span>.0.49<span class="token operator">|</span>:443<span class="token punctuation">..</span>. connected.
HTTP request sent, awaiting response<span class="token punctuation">..</span>. <span class="token number">200</span> OK
Length: <span class="token number">2495</span> <span class="token punctuation">(</span><span class="token number">2</span>.4K<span class="token punctuation">)</span> <span class="token punctuation">[</span>application/octet-stream<span class="token punctuation">]</span>
Saving to: <span class="token string">'/etc/yum.repos.d/CentOS-Base.repo'</span>

/etc/yum.repos.d/CentOS-Base.repo              <span class="token number">100</span>%<span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">]</span>   <span class="token number">2</span>.44K  --.-KB/s    <span class="token keyword">in</span> 0s

<span class="token number">2023</span>-02-23 09:39:05 <span class="token punctuation">(</span><span class="token number">6.01</span> MB/s<span class="token punctuation">)</span> - <span class="token string">'/etc/yum.repos.d/CentOS-Base.repo'</span> saved <span class="token punctuation">[</span><span class="token number">2495</span>/2495<span class="token punctuation">]</span>

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># dnf clean all &amp;&amp; dnf makecache</span>
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
<span class="token number">18</span> files removed
Failed to <span class="token builtin class-name">set</span> locale, defaulting to C.UTF-8
CentOS-8.5.2111 - Base - mirrors.aliyun.com                                                                                                              <span class="token number">897</span> kB/s <span class="token operator">|</span> <span class="token number">3.7</span> MB     00:04
CentOS-8.5.2111 - Extras - mirrors.aliyun.com                                                                                                             <span class="token number">27</span> kB/s <span class="token operator">|</span>  <span class="token number">10</span> kB     00:00
CentOS-8.5.2111 - AppStream - mirrors.aliyun.com                                                                                                         <span class="token number">590</span> kB/s <span class="token operator">|</span> <span class="token number">7.2</span> MB     00:12
Metadata cache created.
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-HOME-bashrc文件"><a href="#配置-HOME-bashrc文件" class="headerlink" title="配置$HOME/.bashrc文件"></a>配置<code>$HOME/.bashrc</code>文件</h3><p>使用<code>pying</code>用户登录</p>
<p>配置$HOME&#x2F;.bashrc文件，使Linux Shell更加易用</p>
<p><code>vim $HOME/.bashrc</code><br>原文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># .bashrc</span>
<span class="token comment"># Source global definitions</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>

<span class="token comment"># User specific environment</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$PATH</span>"</span> <span class="token operator">=~</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配置后内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># .bashrc</span>
<span class="token comment"># Source global definitions</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>

<span class="token comment"># User specific environment</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$PATH</span>"</span> <span class="token operator">=~</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token comment"># 用户特定的别名函数</span>
<span class="token comment"># 操作前询问</span>
<span class="token builtin class-name">alias</span> <span class="token function">rm</span> <span class="token operator">=</span><span class="token string">'rm -i'</span>
<span class="token builtin class-name">alias</span> <span class="token function">cp</span> <span class="token operator">=</span><span class="token string">'cp -i'</span>
<span class="token builtin class-name">alias</span> <span class="token function">mv</span> <span class="token operator">=</span><span class="token string">'mv -i'</span>

<span class="token comment"># 源全局定义</span>
<span class="token comment"># 判断/etc/bashrc这个文件是否存在，如果存在执行这个文件</span>
<span class="token comment">#if [ -f /etc/bashrc ]; then</span>
<span class="token comment">#    . /etc/bashrc</span>
<span class="token comment">#fi</span>
<span class="token comment"># 判断$HOME/workspace是否为目录,不是则创建</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token environment constant">$HOME</span>/workspace <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/workspace
<span class="token keyword">fi</span>

<span class="token comment"># 用户特定环境</span>
<span class="token comment"># Basic envs</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>   <span class="token comment"># 设置系统语言为en_US.UTF-8 避免中断出现中文乱码</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'[\u@dev \w]\$ '</span>    <span class="token comment"># 默认的PS1设置会展示全部的路径，为防止过长，这里只展示: "用户名 @dev 最后的目录名"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">WORKSPACE</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/workspace"</span>  <span class="token comment"># 设置工作目录</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span> <span class="token comment"># 将$HOME/bin目录加入PATH变量中</span>

<span class="token comment"># 设置默认入口目录</span>
<span class="token builtin class-name">cd</span> <span class="token variable">$WORKSPACE</span>   <span class="token comment"># 登录系统 默认进入workspace目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配置好后</p>
<pre class="line-numbers language-none"><code class="language-none">bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>注意</strong></p>
<p><code>export PATH</code> 时，最好把<code>$PATH</code>放在最后，一维添加到<code>$HOME/bin</code>目录中的命令是期望被优先搜索并使用的</p>
<p><code>$HOME/.bashrc</code>会自动创建目录<code>workspace</code>，所有的工作都在这个目录下展开:</p>
<ul>
<li>可以使<code>$HOME</code>保持整洁</li>
<li>分区空间不足，可以移动<code>workspace</code>到另一个分区，并在分区中保留软连接，如：<code>/home/pying/workspace -&gt; /data/workspace/</code></li>
<li>备份所有工作文件，直接备份<code>workspace</code></li>
</ul>
<h3 id="依赖安装和配置"><a href="#依赖安装和配置" class="headerlink" title="依赖安装和配置"></a>依赖安装和配置</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">make</span> cmake autoconf automake cmake perl-CPAN libcurl-devel libtool gcc gcc-c++ glibc-headers zlib-devel git-lfs telnet lrzsz jq expat-devel openssl-devel bzip2-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /tmp
<span class="token function">wget</span> --no-check-certificate https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.39.2.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> git-2.39.2.tar.gz
<span class="token builtin class-name">cd</span> git-2.39.2
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 将Git二进制目录添加到 PATH 路径中 </span>
<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
export PATH=/usr/local/libexec/git-core:$PATH
EOF</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改用户名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"gzwillyy"</span>
<span class="token comment"># 修改邮箱</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"gzwillyy@gmail.com"</span>
<span class="token comment"># 设置git，保存用户名和密码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper store 
<span class="token comment"># 解决git中 'Filename too lang' 的错误</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.longpaths <span class="token boolean">true</span> 
<span class="token comment"># 防止乱码</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.quotepath off
<span class="token comment"># github限制最大克隆 需要安装 Git Large File Storage</span>
<span class="token function">git</span> lfs <span class="token function">install</span> --skip-repo
<span class="token comment"># 设置自动更正</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> help.autocorrect <span class="token number">15</span>
<span class="token comment"># Git 中设置 GPG 签名主键,替换要使用的 GPG 密钥ID： 3AA5C34371567BD2</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.signingkey 3AA5C34371567BD2
<span class="token comment"># 将 Git 配置为默认对所有提交进行签名</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> commit.gpgsign <span class="token boolean">true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>








]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CentOS8</tag>
        <tag>Git</tag>
        <tag>开发环境</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 Commit规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-commit-lint.html</url>
    <content><![CDATA[<h2 id="Commit-规范"><a href="#Commit-规范" class="headerlink" title="Commit 规范"></a>Commit 规范</h2><p><a href="https://www.conventionalcommits.org/en/v1.0.0">Conventional Commits</a> 规范。</p>
<blockquote>
<p>中文翻译版：<a href="https://tool.lu/en_US/article/2ac/preview">Conventional Commits：一份让代码提交记录人机友好的规范</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>Commit规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 接口规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-api-lint.html</url>
    <content><![CDATA[<h2 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h2><p><a href="https://spec.openapis.org/oas/latest.html">OpenAPI 3.0</a> 接口规范。</p>
<blockquote>
<p>中文翻译版：<a href="https://fishead.gitbook.io/openapi-specification-zhcn-translation/3.0.0.zhcn">开放 API 规范中文翻译</a></p>
</blockquote>
<span id="more"></span>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>接口规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul 注册中心 docker开发环境部署</title>
    <url>//post/2023-consul-consul-dev.html</url>
    <content><![CDATA[<p><strong>教程地址</strong>： <a href="https://developer.hashicorp.com/consul/tutorials/day-0/docker-container-agents"><strong><em>https://developer.hashicorp.com/consul/tutorials/day-0/docker-container-agents</em></strong></a></p>
<p>在本教程中使用 <code>Consul v1.16.1</code></p>
<p>在本教程中，您将学习如何部署两个联合的 <code>Consul agents</code>，每个 <code>agents</code> 在单独的 <code>Docker</code> 容器中运行。您还将<code>注册服务</code>并 执行 <code>基本维护</code> 操作。两个 <code>Consul agents</code>将形成一个 <code>小型数据中心</code> 。</p>
<p>通过学习本教程，您将学习如何：</p>
<ol>
<li>获取 <code>Consul</code> 的 <code>Docker</code> 镜像</li>
<li>配置并运行 <code>Consul server</code></li>
<li>配置并运行 <code>Consul client</code></li>
<li>与 <code>Consul agents</code> 交互</li>
<li>执行<code>维护</code>操作（备份 <code>Consul 数据</code>、停止 <code>Consul agents</code>等）</li>
</ol>
<span id="more"></span>

<p>本教程以 <code>Docker</code> 为重点，但您将学习的原理也适用于其他容器运行时。</p>
<p><strong><em>安全警告:</em></strong> 本教程不适合生产用途</p>
<p>有关 <code>Consul</code> 最佳实践，请参阅 [Consul 参考架构](&#x2F;consul&#x2F;tutorials&#x2F;product-deploy&#x2F;reference-architecture)</p>
<p>有关 <code>Docker</code> 最佳实践，请参阅 [Docker 文档](<a href="https://docs.docker.com/">https://docs.docker.com/</a>)</p>
<p>要扩展您将在本教程中学习的概念，请查看<a href="https://developer.hashicorp.com/consul/tutorials/docker/docker-compose-datacenter">使用 Docker Compose 部署安全的本地 Consul 数据中心</a>教程，以了解有关部署安全 <code>Consul</code> 数据中心的更多信息。</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>对于本教程，您需要在计算机上本地安装运行的 <code>Docker</code>。<a href="https://docs.docker.com/install/">您可以在此处</a>找到在您的特定操作系统上安装 <code>Docker</code> 的说明。</p>
<h3 id="Consul（可选）"><a href="#Consul（可选）" class="headerlink" title="Consul（可选）"></a>Consul（可选）</h3><p>如果您想使用本地安装的 <code>Consul</code> 与 容器化 <code>Consul agents</code> 进行交互，请按照<a href="https://developer.hashicorp.com/consul/docs/install">此处的</a>说明进行操作，并将<code>二进制文件</code>安装在您的 <code>PATH</code> 中的某个位置。</p>
<h3 id="获取-Docker-image"><a href="#获取-Docker-image" class="headerlink" title="获取 Docker image"></a>获取 Docker image</h3><p>首先，拉取最新的镜像。您将在本教程中使用 <code>Consul</code> 的官方 <code>Docker</code> 镜像。</p>
<p>通过列出匹配的 <code>Docker</code> 镜像来检查镜像是否已下载<code>consul</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images <span class="token parameter variable">-f</span> <span class="token string">'reference=consul'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">REPOSITORY     TAG      IMAGE ID        CREATED             SIZE
consul       latest    8b6c5f52aa82   <span class="token number">18</span> hours ago   149MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="配置并运行-Consul-Server"><a href="#配置并运行-Consul-Server" class="headerlink" title="配置并运行 Consul Server"></a>配置并运行 Consul Server</h3><p>接下来，您将使用 <code>Docker</code> 命令行标志将 <code>agents</code> 作为<code>服务器</code>启动、配置网络并在一台<code>服务器</code>启动时引导<code>数据中心</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token punctuation">\</span>
    <span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">8500</span>:8500 <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">8600</span>:8600/udp <span class="token punctuation">\</span>
    <span class="token parameter variable">--name</span><span class="token operator">=</span>badger <span class="token punctuation">\</span>
    consul agent <span class="token parameter variable">-server</span> <span class="token parameter variable">-ui</span> <span class="token parameter variable">-node</span><span class="token operator">=</span>server-1 -bootstrap-expect<span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-client</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于您以<code>detached mode</code> 模式启动容器，<code>-d</code>因此该进程将在后台运行。</p>
<p>您还可以将<code>端口映射</code>设置到本地计算机，并将我们 <code>agents</code> 的 <code>client</code> 接口绑定到 <code>0.0.0.0</code>。</p>
<p>这允许您从本地计算机直接使用 <code>Consul</code> 数据中心，并通过本地主机访问 <code>Consul</code> 的 <code>UI</code> 和 <code>DNS</code>。</p>
<p>最后，您将使用 <code>Docker</code> 的默认<code>桥接网络</code>。</p>
<p><code>/consul/config</code>请注意，<code>Consul Docker</code> 镜像默认设置 <code>Consul</code> 配置目录。 <code>agents</code> 将<code>加载</code>放置在<code>该目录</code>中的<code>所有配置文件</code>。</p>
<p><strong>配置目录<code>不</code>作为卷公开，并且不会保留数据。Consul 仅在启动期间使用它，并且不存储任何状态。</strong></p>
<p>为了避免<code>安装卷</code>或将<code>文件复制到容器</code>，您还可以通过环境变量将<a href="https://developer.hashicorp.com/consul/docs/agent/config/config-files#configuration-files">配置 JSON</a> <code>CONSUL_LOCAL_CONFIG</code> 保存到该目录，本教程稍后将介绍这一点。</p>
<h3 id="发现-Consul-Server-IP-地址"><a href="#发现-Consul-Server-IP-地址" class="headerlink" title="发现 Consul Server IP 地址"></a>发现 Consul Server IP 地址</h3><p><code>consul members</code>您可以通过在容器内执行命令来找到 <code>Consul Server</code> 的 <code>IP</code> 地址<code>badger</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$  <span class="token function">docker</span> <span class="token builtin class-name">exec</span> badger consul members<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.13</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="配置和运行-Consul-Client"><a href="#配置和运行-Consul-Client" class="headerlink" title="配置和运行 Consul Client"></a>配置和运行 Consul Client</h3><p>接下来，部署一个<code>容器化</code>的 <code>Consul client</code>，并通过向其提供 <code>Consul Server</code> 的 <code>IP 地址</code>来指示<code>其</code>加入服务器。</p>
<p>不要使用 detached mode 模式，以便您可以在后续步骤中引用 <code>Client</code> 日志。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token punctuation">\</span>
   <span class="token parameter variable">--name</span><span class="token operator">=</span>fox <span class="token punctuation">\</span>
   consul agent <span class="token parameter variable">-node</span><span class="token operator">=</span>client-1 -retry-join<span class="token operator">=</span><span class="token number">172.17</span>.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">==</span><span class="token operator">></span> Starting Consul agent<span class="token punctuation">..</span>.
              Version: <span class="token string">'1.14.3'</span>
           Build Date: <span class="token string">'2022-12-13 17:13:55 +0000 UTC'</span>
              Node ID: <span class="token string">'2edc1554-13de-1476-fc20-1212aa29126d'</span>
         Node name: <span class="token string">'client-1'</span>
        Datacenter: <span class="token string">'dc1'</span> <span class="token punctuation">(</span>Segment: <span class="token string">''</span><span class="token punctuation">)</span>
            Server: <span class="token boolean">false</span> <span class="token punctuation">(</span>Bootstrap: <span class="token boolean">false</span><span class="token punctuation">)</span>
          Client Addr: <span class="token punctuation">[</span><span class="token number">127.0</span>.0.1<span class="token punctuation">]</span> <span class="token punctuation">(</span>HTTP: <span class="token number">8500</span>, HTTPS: -1, gRPC: -1, gRPC-TLS: -1, DNS: <span class="token number">8600</span><span class="token punctuation">)</span>
         Cluster Addr: <span class="token number">172.17</span>.0.3 <span class="token punctuation">(</span>LAN: <span class="token number">8301</span>, WAN: <span class="token number">8302</span><span class="token punctuation">)</span>
    Gossip Encryption: <span class="token boolean">false</span>
     Auto-Encrypt-TLS: <span class="token boolean">false</span>
            HTTPS TLS: Verify Incoming: false, Verify Outgoing: false, Min Version: TLSv1_2
             gRPC TLS: Verify Incoming: false, Min Version: TLSv1_2
     Internal RPC TLS: Verify Incoming: false, Verify Outgoing: <span class="token boolean">false</span> <span class="token punctuation">(</span>Verify Hostname: <span class="token boolean">false</span><span class="token punctuation">)</span>, Min Version: TLSv1_2

<span class="token operator">==</span><span class="token operator">></span> Log data will now stream <span class="token keyword">in</span> as it occurs:

<span class="token number">2022</span>-12-15T18:59:45.065Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent.client.serf.lan: serf: EventMemberJoin: client-1 <span class="token number">172.17</span>.0.3
<span class="token number">2022</span>-12-15T18:59:45.065Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent.router: Initializing LAN area manager
<span class="token number">2022</span>-12-15T18:59:45.065Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Started DNS server: <span class="token assign-left variable">address</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:8600 <span class="token assign-left variable">network</span><span class="token operator">=</span>tcp
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Started DNS server: <span class="token assign-left variable">address</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:8600 <span class="token assign-left variable">network</span><span class="token operator">=</span>udp
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Starting server: <span class="token assign-left variable">address</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:8500 <span class="token assign-left variable">network</span><span class="token operator">=</span>tcp <span class="token assign-left variable">protocol</span><span class="token operator">=</span>http
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: started state syncer
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Consul agent running<span class="token operator">!</span>
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Retry <span class="token function">join</span> is supported <span class="token keyword">for</span> the following discovery methods: <span class="token assign-left variable">cluster</span><span class="token operator">=</span>LAN <span class="token assign-left variable">discovery_methods</span><span class="token operator">=</span><span class="token string">"aliyun aws azure digitalocean gce hcp k8s linode mdns os packet scaleway softlayer tencentcloud triton vsphere"</span>
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Joining cluster<span class="token punctuation">..</span>.: <span class="token assign-left variable">cluster</span><span class="token operator">=</span>LAN
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: <span class="token punctuation">(</span>LAN<span class="token punctuation">)</span> joining: <span class="token assign-left variable">lan_addresses</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"172.17.0.2"</span><span class="token punctuation">]</span>
<span class="token number">2022</span>-12-15T18:59:45.066Z <span class="token punctuation">[</span>WARN<span class="token punctuation">]</span>  agent.router.manager: No servers available
<span class="token number">2022</span>-12-15T18:59:45.067Z <span class="token punctuation">[</span>ERROR<span class="token punctuation">]</span> agent.anti_entropy: failed to <span class="token function">sync</span> remote state: <span class="token assign-left variable">error</span><span class="token operator">=</span><span class="token string">"No known Consul servers"</span>
<span class="token number">2022</span>-12-15T18:59:45.070Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent.client.serf.lan: serf: EventMemberJoin: server-1 <span class="token number">172.17</span>.0.2
<span class="token number">2022</span>-12-15T18:59:45.071Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent.client: adding server: <span class="token assign-left variable">server</span><span class="token operator">=</span><span class="token string">"server-1 (Addr: tcp/172.17.0.2:8300) (DC: dc1)"</span>
<span class="token number">2022</span>-12-15T18:59:45.071Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: <span class="token punctuation">(</span>LAN<span class="token punctuation">)</span> joined: <span class="token assign-left variable">number_of_nodes</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token number">2022</span>-12-15T18:59:45.071Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Join cluster completed. Synced with initial agents: <span class="token assign-left variable">cluster</span><span class="token operator">=</span>LAN <span class="token assign-left variable">num_agents</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token number">2022</span>-12-15T18:59:46.454Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Synced <span class="token function">node</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在新终端中，通过 <code>consul members</code> 在 <code>Consul Server</code>容器中再次执行命令来<code>检查客户端</code>是否已加入。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$  <span class="token function">docker</span> <span class="token builtin class-name">exec</span> badger consul members<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span>
client-1  <span class="token number">172.17</span>.0.3:8301  alive   client  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>default<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>现在您有了一个小型数据中心，您可以<code>注册服务</code>并执行<code>维护</code>操作。</p>
<h3 id="注册一个服务"><a href="#注册一个服务" class="headerlink" title="注册一个服务"></a>注册一个服务</h3><p>在第<code>三</code>个容器中<code>启动服务</code>并向 <code>Consul Client</code> 注册。 基本服务每次被<code>访问</code>时都会增加<code>一个数字</code>并返回该<code>数字</code>。</p>
<p>Pull the container.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull hashicorp/counting-service:0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用<code>端口转发</code>运行容器，以便您可以通过访问<a href="http://localhost:9001/">http://localhost:9001</a>从<code> Web 浏览器</code>访问它。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token punctuation">\</span>
   <span class="token parameter variable">-p</span> <span class="token number">9001</span>:9001 <span class="token punctuation">\</span>
   <span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
   <span class="token parameter variable">--name</span><span class="token operator">=</span>weasel <span class="token punctuation">\</span>
   hashicorp/counting-service:0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来，您将通过添加在<code>目录</code>中调用的<code>服务定义文件</code>来向 <code>Consul Client</code> 注册 <code>counting 服务</code> 到 <code>consul/config/counting.json</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> fox /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"echo '&#123;<span class="token entity" title="\&quot;">\"</span>service<span class="token entity" title="\&quot;">\"</span>: &#123;<span class="token entity" title="\&quot;">\"</span>name<span class="token entity" title="\&quot;">\"</span>: <span class="token entity" title="\&quot;">\"</span>counting<span class="token entity" title="\&quot;">\"</span>, <span class="token entity" title="\&quot;">\"</span>tags<span class="token entity" title="\&quot;">\"</span>: [<span class="token entity" title="\&quot;">\"</span>go<span class="token entity" title="\&quot;">\"</span>], <span class="token entity" title="\&quot;">\"</span>port<span class="token entity" title="\&quot;">\"</span>: 9001&#125;&#125;' >> /consul/config/counting.json"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于 <code>Consul Client</code> 不会<code>自动检测</code>配置<code>目录</code>中的更改，因此您需要为同一<code>容器</code>发出<code>重新加载</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> fox consul reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Configuration reload triggered<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果您返回启动 <code>Client</code> 的终端窗口，应该<code>有日志</code>条目确认 <code>Consul Client</code> 收到<code>挂断信号</code>、<code>重新加载</code>其<code>配置</code>并 synced <code>counting 服务</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2022</span>-12-15T19:02:24.945Z <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  agent: Synced service: <span class="token assign-left variable">service</span><span class="token operator">=</span>counting<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="使用-Consul-DNS-发现-counting-服务"><a href="#使用-Consul-DNS-发现-counting-服务" class="headerlink" title="使用 Consul DNS 发现 counting 服务"></a>使用 Consul DNS 发现 counting 服务</h3><p>现在，您可以使用以下 <code>dig</code> 命令针对 <code>Consul</code> 的 <code>DNS</code> 查询 <code>Consul</code> 服务的位置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @127.0.0.1 <span class="token parameter variable">-p</span> <span class="token number">8600</span> counting.service.consul<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> DiG <span class="token number">9.10</span>.6 <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> @127.0.0.1 <span class="token parameter variable">-p</span> <span class="token number">8600</span> counting.service.consul
<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span> server found<span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd
<span class="token punctuation">;</span><span class="token punctuation">;</span> Got answer:
<span class="token punctuation">;</span><span class="token punctuation">;</span> -<span class="token operator">>></span>HEADER<span class="token operator">&lt;&lt;-</span> opcode: QUERY, status: NOERROR, id: <span class="token number">61865</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> flags: qr aa rd<span class="token punctuation">;</span> QUERY: <span class="token number">1</span>, ANSWER: <span class="token number">1</span>, AUTHORITY: <span class="token number">0</span>, ADDITIONAL: <span class="token number">1</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> WARNING: recursion requested but not available

<span class="token punctuation">;</span><span class="token punctuation">;</span> OPT PSEUDOSECTION:
<span class="token punctuation">;</span> EDNS: version: <span class="token number">0</span>, flags:<span class="token punctuation">;</span> udp: <span class="token number">4096</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:
<span class="token punctuation">;</span>counting.service.consul.       IN      A

<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
counting.service.consul. <span class="token number">0</span>      IN      A       <span class="token number">172.17</span>.0.3

<span class="token punctuation">;</span><span class="token punctuation">;</span> Query time: <span class="token number">4</span> msec
<span class="token punctuation">;</span><span class="token punctuation">;</span> SERVER: <span class="token number">127.0</span>.0.1<span class="token comment">#8600(127.0.0.1)</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> WHEN: Thu Dec <span class="token number">15</span> <span class="token number">13</span>:03:30 CST <span class="token number">2022</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> MSG SIZE  rcvd: <span class="token number">68</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="http://localhost:8500/">您还可以从 Consul 的 UI http://localhost:8500</a>访问新注册的服务</p>
<h3 id="Consul-容器的维护操作"><a href="#Consul-容器的维护操作" class="headerlink" title="Consul 容器的维护操作"></a>Consul 容器的维护操作</h3><h4 id="Docker-exec"><a href="#Docker-exec" class="headerlink" title="Docker exec"></a>Docker exec</h4><p>您可以使用 直接在 <code>Consul</code> 容器内执行 <code>Consul</code> 命令 <code>docker exec</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>container_id<span class="token operator">></span> consul members<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span>
client-1  <span class="token number">172.17</span>.0.3:8301  alive   client  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>default<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="Docker-exec-attach"><a href="#Docker-exec-attach" class="headerlink" title="Docker exec attach"></a>Docker exec attach</h4><p>您还可以通过打开交互式 <code>shell</code> 并使用容器中包含的 <code>Consul</code> <code>二进制文件</code>在容器内发出命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>container_id<span class="token operator">></span> /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ <span class="token comment"># consul members</span>
Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span>
client-1  <span class="token number">172.17</span>.0.3:8301  alive   client  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>default<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="本地-Consul-二进制文件"><a href="#本地-Consul-二进制文件" class="headerlink" title="本地 Consul 二进制文件"></a>本地 Consul 二进制文件</h4><p>如果您的 <code>PATH</code> 中有本地 <code>Consul</code> 二进制文件，您还可以导出<code>CONSUL_HTTP_ADDR</code> <code>环境变量</code>以指向<code>远程 Consul 服务器</code>的 <code>HTTP</code> 地址。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">CONSUL_HTTP_ADDR</span><span class="token operator">=</span><span class="token operator">&lt;</span>consul_server_ip<span class="token operator">></span>:8500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这样就可以绕过<code>docker exec &lt;container_id&gt; consul &lt;command&gt;</code>并<code>consul &lt;command&gt;</code>直接使用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ consul members
Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span>
client-1  <span class="token number">172.17</span>.0.3:8301  alive   client  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>default<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在本教程中，您将 绑定容器化 <code>Consul Server</code>的 <code>Client</code>地址，以便<code>0.0.0.0</code>您可以使用本地 <code>Consul</code> 安装与 <code>Consul</code> 数据中心进行通信。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> consul
/usr/local/bin/consul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认情况下，<code>Client Address</code>绑定到 <code>localhost</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Node      Address          Status  Type    Build   Protocol  DC   Partition  Segment
server-1  <span class="token number">172.17</span>.0.2:8301  alive   server  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>all<span class="token operator">></span>
client-1  <span class="token number">172.17</span>.0.3:8301  alive   client  <span class="token number">1.14</span>.3  <span class="token number">2</span>         dc1  default    <span class="token operator">&lt;</span>default<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="停止、启动和重新启动容器"><a href="#停止、启动和重新启动容器" class="headerlink" title="停止、启动和重新启动容器"></a>停止、启动和重新启动容器</h3><p>官方 <code>Consul</code> 容器支持<code>停止</code>、<code>启动</code>和<code>重新启动</code>。</p>
<p>要停止容器，请运行<code>docker stop</code>.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> stop <span class="token operator">&lt;</span>container_id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要启动容器，请运行<code>docker start</code>.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> start <span class="token operator">&lt;</span>container_id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要进行内存中重新加载，请向容器发送 <code>SIGHUP</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">kill</span> <span class="token parameter variable">--signal</span><span class="token operator">=</span>HUP <span class="token operator">&lt;</span>container_id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="从数据中心删除-Server"><a href="#从数据中心删除-Server" class="headerlink" title="从数据中心删除 Server"></a>从数据中心删除 Server</h3><p>只要<code>数据中心</code>中有足够的 <code>Server</code> 来维持<a href="https://developer.hashicorp.com/consul/docs/architecture/consensus#deployment-table">quorum</a>，<code>Consul</code> 的<a href="https://developer.hashicorp.com/consul/tutorials/datacenter-operations/autopilot-datacenter-operations">Autopilot</a>功能就会<code>处理``删除</code>容器已<code>停止</code>的 <code>Server</code>。</p>
<p><code>Autopilot</code> 的默认设置已正确配置。</p>
<p>如果您覆盖它们，请确保以下<a href="https://developer.hashicorp.com/consul/docs/agent/config/config-files#autopilot">设置</a>合适。</p>
<ul>
<li><a href="https://developer.hashicorp.com/consul/tutorials/day-0/docker-container-agents#cleanup_dead_servers"><code>cleanup_dead_servers</code></a>必须设置为 <code>true</code> 以确保从数据中心删除已停止的容器。</li>
<li><a href="https://developer.hashicorp.com/consul/tutorials/day-0/docker-container-agents#last_contact_threshold"><code>last_contact_threshold</code></a>应该相当<code>小</code>，以便快速删除死 <code>Server</code>。</li>
<li><a href="https://developer.hashicorp.com/consul/tutorials/day-0/docker-container-agents#server_stabilization_time"><code>server_stabilization_time</code></a>应足够大（大约几秒），以便不稳定的 <code>Server</code> 在稳定之前不会添加到数据中心。</li>
</ul>
<p>如果运行当前<code>选举</code>的 <code>Consul Server</code> <code>leader</code> 的容器停止，将会触发 <code>leader</code> 选举。</p>
<p>当使用 <code>重新启动</code>先前<code>停止</code>的 <code>Server</code> 容器，并将其配置为获取新 <code>IP</code> 时，</p>
<p><code>Autopilot</code> 会将其添加回具有相同 <code>node-id</code> 和 新 <code>IP Address</code> 的<code>docker start &lt;container_id&gt;</code> <code>Raft</code> 对等点集合，之后它可以作为再次 <code>Server</code> 。</p>
<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p><a href="https://developer.hashicorp.com/consul/commands/snapshot">您可以使用 <code>consul snapshot</code></a>命令备份 <code>Consul</code> 数据中心。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>container_id<span class="token operator">></span> consul snapshot save backup.snap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这会将<code>快照文件</code>保留<code>backup.snap</code>在<code>容器</code>内。如果您不将<code>快照</code>保存到<a href="https://docs.docker.com/storage/volumes/">持久卷</a>，那么您将需要使用将<code> docker cp</code> <code>快照 </code>移动到<code>容器外部</code>的位置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>container_id<span class="token operator">></span>:backup.snap ./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行 <code>Consul Enterprise Docker</code> 容器的用户可以运行<a href="https://developer.hashicorp.com/consul/commands/snapshot/agent">consul 快照代理</a>来自动保存备份。<code>Consul Enterprise</code> 的快照 <code>agent</code> 还允许您将快照保存到 <code>Amazon S3</code> 和 <code>Azure Blob</code> 存储。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><code>Consul Docker </code>镜像支持通过从 <code>Docker</code> <code>命令行</code>传入的<code>环境变量</code>进行配置。</p>
<h4 id="Consul-agent"><a href="#Consul-agent" class="headerlink" title="Consul agent"></a>Consul agent</h4><p><code>CONSUL_LOCAL_CONFIG</code>，<code>CONSUL_CLIENT_INTERFACE</code>并<code>CONSUL_BIND_INTERFACE</code>传递到带有标志的容器<code>-e</code>。</p>
<p><code>CONSUL_LOCAL_CONFIG</code>支持传递键和值的<code> JSON</code> 字符串。</p>
<p>要定义<code>datacenter</code>、<code>server</code>并使用 开启调试<code>enable_debug</code>，请在启动 <code>Consul agent</code> 时使用以下代码片段。</p>
<pre class="line-numbers language-none"><code class="language-none">$ docker run \
  -d \
  -e CONSUL_LOCAL_CONFIG&#x3D;&#39;&#123;
  &quot;datacenter&quot;:&quot;us_west&quot;,
  &quot;server&quot;:true,
  &quot;enable_debug&quot;:true
  &#125;&#39; \
  consul agent -server -bootstrap-expect&#x3D;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>CONSUL_CLIENT_INTERFACE</code>是一个<code>字符串</code>值，表示 <code>Consul</code> 公开 <code>DNS</code>、<code>gRPC</code> 和 <code>HTTP API</code> 的接口名称。</p>
<p><code>CONSUL_BIND_INTERFACE</code>是一个<code>字符串</code>值，表示 <code>Consul</code> 用于内部 <code>Consul</code> 集群通信的接口。</p>
<p><code>-bind</code>在运行时，这些环境变量作为二进制文件的和<code>-client</code>参数传递<code>consul</code>。</p>
<p><strong>常见的实现模式包括对 <code>Client</code> 和绑定参数使用相同的接口。这不是必需的；您可以选择为每个值配置不同的接口。一个例子如下所示。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run <span class="token punctuation">\</span>
  <span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
  <span class="token parameter variable">-e</span> <span class="token assign-left variable">CONSUL_CLIENT_INTERFACE</span><span class="token operator">=</span>en0 <span class="token punctuation">\</span>
  <span class="token parameter variable">-e</span> <span class="token assign-left variable">CONSUL_BIND_INTERFACE</span><span class="token operator">=</span>en1 <span class="token punctuation">\</span>
  consul agent <span class="token parameter variable">-server</span> -bootstrap-expect-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>设置<code>CONSUL_ALLOW_PRIVILEGED_PORTS</code>为在 <code>Consul</code> 二进制文件上<code>true</code>运行<a href="https://man7.org/linux/man-pages/man8/setcap.8.html"><code>setcap</code></a>，允许其绑定到<a href="https://www.w3.org/Daemon/User/Installation/PrivilegedPorts.html">特权端口</a>。</p>
<p>在此示例中，<code>consul agent</code>在端口 <code>53</code>（特权端口）上运行 <code>DNS</code> 服务器，并<code>8.8.8.8</code>通过<code>-recursor</code>参数将上游<code> DNS 服务器</code>设置为。</p>
<pre class="line-numbers language-none"><code class="language-none">$ docker run -d --net&#x3D;host -e &#39;CONSUL_ALLOW_PRIVILEGED_PORTS&#x3D;true&#39; consul agent -dns-port&#x3D;53 -recursor&#x3D;8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>并非所有 <code>Docker</code> 存储后端都支持此功能（尤其是 <code>AUFS</code>）。请阅读<a href="https://github.com/hashicorp/docker-vault/issues/19">docker-vault 的 github 上的 aufs 问题</a>以获取更多信息。</p>
<p>在本教程中，您学习了如何部署容器化 <code>Consul</code> 数据中心。您还学习了如何部署容器化服务以及如何配置 <code>Consul Client</code> 以在 <code>Consul 数据中心</code>注册该<code>服务</code>。</p>
<p><a href="https://developer.hashicorp.com/consul/tutorials/docker/docker-compose-datacenter">您可以通过完成使用 Docker Compose 部署安全的本地</a> <code>Consul 数据中心</code>教程来继续学习如何部署<code>安全</code>的 <code>Consul 数据中心</code>。</p>
<p>有关 <code>Consul</code> 官方 <code>Docker</code> 的其他参考文档，请参阅以下网站：</p>
<ul>
<li><a href="https://docs.docker.com/">Docker 文档</a></li>
<li><a href="https://hub.docker.com/_/consul">Consul@Docker Hub</a></li>
<li><a href="https://github.com/hashicorp/docker-consul">hashcorp&#x2F;docker-consul GitHub 存储库</a></li>
</ul>
]]></content>
      <categories>
        <category>Micro</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Consul</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 目录规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-directory-lint.html</url>
    <content><![CDATA[<h2 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h2><p><a href="https://github.com/golang-standards/project-layout">project-layout</a> 目录规范。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>目录规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 错误规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-errorcode-lint.html</url>
    <content><![CDATA[<h2 id="错误码规范"><a href="#错误码规范" class="headerlink" title="错误码规范"></a>错误码规范</h2><p>错误码是用户定位及解决问题的重要手段之一，当应用发生异常时，用户根据错误码及文档中的错误码描述和解决方案就可以快速定位并解决问题。</p>
<h3 id="错误码命名规范"><a href="#错误码命名规范" class="headerlink" title="错误码命名规范"></a>错误码命名规范</h3><ul>
<li>遵循驼峰命名法；</li>
<li>错误码分为两级。例如，<code>InvalidParameter.BindError</code>，以 <code>.</code> 号分隔。其中，第一级错误码为平台级，第二级错误码为资源级别，可根据场景自定义；</li>
<li>第二级错误码只能使用英文字母或数字（[a-zA-Z0-9]），应使用英文单词规范拼写、规范缩写、RFC 术语缩写等；</li>
<li>错误码应避免同一语义多种定义，例如：<code>InvalidParameter.ErrorBind</code>, <code>InvalidParameter.BindError</code>。<span id="more"></span></li>
</ul>
<h3 id="第一级公共错误码"><a href="#第一级公共错误码" class="headerlink" title="第一级公共错误码"></a>第一级公共错误码</h3><p>| 错误码 | 错误描述 | 错误类型 |<br>| —- | —- |<br>| InternalError | 内部错误 | 1 |<br>| InvalidParameter | 参数错误（包括参数类型、格式、值等错误） | 0 |<br>| AuthFailure | 认证 &#x2F; 授权错误 | 0 |<br>| ResourceNotFound | 资源不存在 | 0 |<br>| FailedOperation | 操作失败 | 2 |</p>
<blockquote>
<p>错误类型：0 代表客户端，1 代表服务端，2 代表客户端 &#x2F; 服务端。</p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>错误规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 日志规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-logging-lint.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://juejin.cn/book/7176608782871429175">《从零开发企业级 Go 应用》</a></li>
</ul>
<h2 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h2><h3 id="日志规范-1"><a href="#日志规范-1" class="headerlink" title="日志规范"></a>日志规范</h3><ul>
<li>日志包统一使用 <code>github.com/marmotedu/miniblog/internal/pkg/log</code>;</li>
<li>使用结构化的日志打印格式：<code>log.Infow</code>, <code>log.Warnw</code>, <code>log.Errorw</code> 等; 例如：<code>log.Infow(&quot;Update post function called&quot;)</code>;</li>
<li>日志均以大写开头，结尾不跟 <code>.</code>，例如：<code>log.Infow(&quot;Update post function called&quot;)</code>;</li>
<li>使用过去时，例如：<code>Could not delete B</code> 而不是 <code>Cannot delete B</code>;<span id="more"></span></li>
<li>遵循日志级别规范：<ul>
<li>Debug 级别的日志使用 <code>log.Debugw</code>;</li>
<li>Info 级别的日志使用 <code>log.Infow</code>;</li>
<li>Warning 级别的日志使用 <code>log.Warnw</code>;</li>
<li>Error 级别的日志使用 <code>log.Errorw</code>;</li>
<li>Panic 级别的日志使用 <code>log.Panicw</code>;</li>
<li>Fatal 级别的日志使用 <code>log.Fatalw</code>.</li>
</ul>
</li>
<li>日志设置：<ul>
<li>开发测试环境：日志级别设置为 <code>debug</code>、日志格式可根据需要设置为 <code>console</code> &#x2F; <code>json</code>、开启 caller；</li>
<li>生产环境：日志级别设置为 <code>info</code>、日志格式设置为 <code>json</code>、开启 caller。（注意：上线初期，为了方便现网排障，日志级别可以设置为 <code>debug</code>）</li>
</ul>
</li>
<li>在记录日志时，不要输出一些敏感信息，例如密码、密钥等。</li>
<li>如果在具有 <code>context.Context</code> 参数的函数&#x2F;方法中，调用日志函数，建议使用 <code>log.L(ctx).Infow()</code> 进行日志记录。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>日志规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 代码规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-code-lint.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://juejin.cn/book/7176608782871429175">《从零开发企业级 Go 应用》</a></li>
</ul>
<h2 id="Go-代码开发规范"><a href="#Go-代码开发规范" class="headerlink" title="Go 代码开发规范"></a>Go 代码开发规范</h2><p>在Go 项目开发中，一个好的编码规范可以极大的提高代码质量。为了帮你节省时间和精力，这里我整理了一份清晰、可直接套用的 Go 编码规范，供你参考。</p>
<p>这份规范，是我参考了 Go 官方提供的编码规范，以及 Go 社区沉淀的一些比较合理的规范之后，加入自己的理解总结出的，它比很多公司内部的规范更全面，你掌握了，以后在面试大厂的时候，或者在大厂里写代码的时候，都会让人高看你一眼，觉得你code很专业。</p>
<p>这份编码规范中包含代码风格、命名规范、注释规范、类型、控制结构、函数、GOPATH 设置规范、依赖管理和最佳实践九类规范。如果你觉得这些规范内容太多了，看完一遍也记不住，这完全没关系。你可以多看几遍，也可以在用到时把它翻出来，在实际应用中掌握。这篇特别放送的内容，更多是作为写代码时候的一个参考手册。</p>
<span id="more"></span>
<h2 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1. 代码风格"></a>1. 代码风格</h2><h3 id="1-1-代码格式"><a href="#1-1-代码格式" class="headerlink" title="1.1 代码格式"></a>1.1 代码格式</h3><ul>
<li>代码都必须用 <code>gofmt</code> 进行格式化。</li>
<li>运算符和操作数之间要留空格。</li>
<li>建议一行代码不超过120个字符，超过部分，请采用合适的换行方式换行。但也有些例外场景，例如import行、工具自动生成的代码、带tag的struct字段。</li>
<li>文件长度不能超过800行。</li>
<li>函数长度不能超过80行。</li>
<li>import规范<ul>
<li>代码都必须用<code>goimports</code>进行格式化（建议将代码Go代码编辑器设置为：保存时运行 <code>goimports</code>）。</li>
<li>不要使用相对路径引入包，例如 <code>import ../util/net</code> 。</li>
<li>包名称与导入路径的最后一个目录名不匹配时，或者多个相同包名冲突时，则必须使用导入别名。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token string">"github.com/dgrijalva/jwt-go/v4"</span>

<span class="token comment">//good</span>
jwt <span class="token string">"github.com/dgrijalva/jwt-go/v4"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>- 导入的包建议进行分组，匿名包的引用使用一个新的分组，并对匿名包引用进行说明。
</code></pre>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token comment">// go 标准包</span>
	<span class="token string">"fmt"</span>

	<span class="token comment">// 第三方包</span>
    <span class="token string">"github.com/jinzhu/gorm"</span>
    <span class="token string">"github.com/spf13/cobra"</span>
    <span class="token string">"github.com/spf13/viper"</span>

	<span class="token comment">// 匿名包单独分组，并对匿名包引用进行说明</span>
    <span class="token comment">// import mysql driver</span>
    <span class="token boolean">_</span> <span class="token string">"github.com/jinzhu/gorm/dialects/mysql"</span>

	<span class="token comment">// 内部包</span>
    v1 <span class="token string">"github.com/marmotedu/api/apiserver/v1"</span>
    metav1 <span class="token string">"github.com/marmotedu/apimachinery/pkg/meta/v1"</span>
    <span class="token string">"github.com/marmotedu/iam/pkg/cli/genericclioptions"</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-声明、初始化和定义"><a href="#1-2-声明、初始化和定义" class="headerlink" title="1.2 声明、初始化和定义"></a>1.2 声明、初始化和定义</h3><p>当函数中需要使用到多个变量时，可以在函数开始处使用<code>var</code>声明。在函数外部声明必须使用 <code>var</code> ，不要采用 <code>:=</code> ，容易踩到变量的作用域的问题。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>
	Width  <span class="token builtin">int</span>
	Height <span class="token builtin">int</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在初始化结构引用时，请使用<code>&amp;T&#123;&#125;</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
sptr <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>
sptr<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"bar"</span>

<span class="token comment">// good</span>
sptr <span class="token operator">:=</span> <span class="token operator">&amp;</span>T<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>struct 声明和初始化格式采用多行，定义如下。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>
    Username  <span class="token builtin">string</span>
    Email     <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

user <span class="token operator">:=</span> User<span class="token punctuation">&#123;</span>
	Username<span class="token punctuation">:</span> <span class="token string">"belm"</span><span class="token punctuation">,</span>
	Email<span class="token punctuation">:</span> <span class="token string">"nosbelm@qq.com"</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>相似的声明放在一组，同样适用于常量、变量和类型声明。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">import</span> <span class="token string">"a"</span>
<span class="token keyword">import</span> <span class="token string">"b"</span>

<span class="token comment">// good</span>
<span class="token keyword">import</span> <span class="token punctuation">(</span>
  <span class="token string">"a"</span>
  <span class="token string">"b"</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>尽可能指定容器容量，以便为容器预先分配内存，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
v <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>在顶层，使用标准var关键字。请勿指定类型，除非它与表达式的类型不同。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">var</span> _s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"A"</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">var</span> _s <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span>
<span class="token comment">// 还是那种类型</span>

<span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"A"</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于未导出的顶层常量和变量，使用<code>_</code>作为前缀。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
  defaultHost <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span>
  defaultPort <span class="token operator">=</span> <span class="token number">8080</span>
<span class="token punctuation">)</span>

<span class="token comment">// good</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
  _defaultHost <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span>
  _defaultPort <span class="token operator">=</span> <span class="token number">8080</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
  version <span class="token builtin">int</span>
  http<span class="token punctuation">.</span>Client
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
  http<span class="token punctuation">.</span>Client

  version <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-3-错误处理"><a href="#1-3-错误处理" class="headerlink" title="1.3 错误处理"></a>1.3 错误处理</h3><ul>
<li><code>error</code>作为函数的值返回，必须对<code>error</code>进行处理，或将返回值赋值给明确忽略。对于<code>defer xx.Close()</code>可以不用显式处理。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// bad</span>
<span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// good</span>
 <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>error</code>作为函数的值返回且有多个返回值的时候，<code>error</code>必须是最后一个参数。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">func</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">func</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>尽早进行错误处理，并尽早返回，减少嵌套。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error code</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token comment">// normal code</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果需要在 if 之外使用函数调用的结果，则应采用下面的方式。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">if</span> v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>错误要单独判断，不与其他逻辑组合判断。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> v  <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"invalid value v"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果返回值需要初始化，则采用下面的方式。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// error handling</span>
    <span class="token keyword">return</span> <span class="token comment">// or continue.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>错误描述建议<ul>
<li>错误描述用小写字母开头，结尾不要加标点符号，例如：<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"Redis connection failed"</span><span class="token punctuation">)</span>
errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"redis connection failed."</span><span class="token punctuation">)</span>

<span class="token comment">// good</span>
errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"redis connection failed"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>告诉用户他们可以做什么，而不是告诉他们不能做什么。</li>
<li>当声明一个需求时，用must 而不是should。例如，<code>must be greater than 0、must match regex &#39;[a-z]+&#39;</code>。</li>
<li>当声明一个格式不对时，用must not。例如，<code>must not contain</code>。</li>
<li>当声明一个动作时用may not。例如，<code>may not be specified when otherField is empty、only name may be specified</code>。</li>
<li>引用文字字符串值时，请在单引号中指示文字。例如，<code>ust not contain &#39;..&#39;</code>。</li>
<li>当引用另一个字段名称时，请在反引号中指定该名称。例如，must be greater than <code>request</code>。</li>
<li>指定不等时，请使用单词而不是符号。例如，<code>must be less than 256、must be greater than or equal to 0 (不要用 larger than、bigger than、more than、higher than)</code>。</li>
<li>指定数字范围时，请尽可能使用包含范围。</li>
<li>建议 Go 1.13 以上，error 生成方式为 <code>fmt.Errorf(&quot;module xxx: %w&quot;, err)</code>。</li>
</ul>
</li>
</ul>
<h3 id="1-4-panic处理"><a href="#1-4-panic处理" class="headerlink" title="1.4 panic处理"></a>1.4 panic处理</h3><ul>
<li>在业务逻辑处理中禁止使用panic。</li>
<li>在main包中，只有当程序完全不可运行时使用panic，例如无法打开文件、无法连接数据库导致程序无法正常运行。</li>
<li>在main包中，使用 <code>log.Fatal</code> 来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。</li>
<li>可导出的接口一定不能有panic。</li>
<li>包内建议采用error而不是panic来传递错误。</li>
</ul>
<h3 id="1-5-单元测试"><a href="#1-5-单元测试" class="headerlink" title="1.5 单元测试"></a>1.5 单元测试</h3><ul>
<li>单元测试文件名命名规范为 <code>example_test.go</code>。</li>
<li>每个重要的可导出函数都要编写测试用例。</li>
<li>因为单元测试文件内的函数都是不对外的，所以可导出的结构体、函数等可以不带注释。</li>
<li>如果存在 <code>func (b *Bar) Foo</code> ，单测函数可以为 <code>func TestBar_Foo</code>。</li>
</ul>
<h3 id="1-6-类型断言失败处理"><a href="#1-6-类型断言失败处理" class="headerlink" title="1.6 类型断言失败处理"></a>1.6 类型断言失败处理</h3><ul>
<li>type assertion 的单个返回值针对不正确的类型将产生 panic。请始终使用 “comma ok”的惯用法。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
t <span class="token operator">:=</span> n<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token comment">// good</span>
t<span class="token punctuation">,</span> ok <span class="token operator">:=</span> n<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2. 命名规范"></a>2. 命名规范</h2><p>命名规范是代码规范中非常重要的一部分，一个统一的、短小的、精确的命名规范可以大大提高代码的可读性，也可以借此规避一些不必要的Bug。</p>
<h3 id="2-1-包命名"><a href="#2-1-包命名" class="headerlink" title="2.1 包命名"></a>2.1 包命名</h3><ul>
<li>包名必须和目录名一致，尽量采取有意义、简短的包名，不要和标准库冲突。</li>
<li>包名全部小写，没有大写或下划线，使用多级目录来划分层级。</li>
<li>项目名可以通过中划线来连接多个单词。</li>
<li>包名以及包所在的目录名，不要使用复数，例如，是<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用 common、util、shared 或者 lib 这类宽泛的、无意义的包名。</li>
<li>包名要简单明了，例如 net、time、log。</li>
</ul>
<h3 id="2-2-函数命名"><a href="#2-2-函数命名" class="headerlink" title="2.2 函数命名"></a>2.2 函数命名</h3><ul>
<li>函数名采用驼峰式，首字母根据访问控制决定使用大写或小写，例如：<code>MixedCaps</code>或者<code>mixedCaps</code>。</li>
<li>代码生成工具自动生成的代码(如<code>xxxx.pb.go</code>)和为了对相关测试用例进行分组，而采用的下划线(如<code>TestMyFunction_WhatIsBeingTested</code>)排除此规则。</li>
</ul>
<h3 id="2-3-文件命名"><a href="#2-3-文件命名" class="headerlink" title="2.3 文件命名"></a>2.3 文件命名</h3><ul>
<li>文件名要简短有意义。</li>
<li>文件名应小写，并使用下划线分割单词。</li>
</ul>
<h3 id="2-4-结构体命名"><a href="#2-4-结构体命名" class="headerlink" title="2.4 结构体命名"></a>2.4 结构体命名</h3><ul>
<li>采用驼峰命名方式，首字母根据访问控制决定使用大写或小写，例如<code>MixedCaps</code>或者<code>mixedCaps</code>。</li>
<li>结构体名不应该是动词，应该是名词，比如 <code>Node</code>、<code>NodeSpec</code>。</li>
<li>避免使用Data、Info这类无意义的结构体名。</li>
<li>结构体的声明和初始化应采用多行，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// User 多行声明</span>
<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Name  <span class="token builtin">string</span>
    Email <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 多行初始化</span>
u <span class="token operator">:=</span> User<span class="token punctuation">&#123;</span>
    UserName<span class="token punctuation">:</span> <span class="token string">"belm"</span><span class="token punctuation">,</span>
    Email<span class="token punctuation">:</span>    <span class="token string">"nosbelm@qq.com"</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-5-接口命名"><a href="#2-5-接口命名" class="headerlink" title="2.5 接口命名"></a>2.5 接口命名</h3><ul>
<li>接口命名的规则，基本和结构体命名规则保持一致：<ul>
<li>单个函数的接口名以 “er””作为后缀（例如Reader，Writer），有时候可能导致蹩脚的英文，但是没关系。</li>
<li>两个函数的接口名以两个函数名命名，例如ReadWriter。</li>
<li>三个以上函数的接口名，类似于结构体名。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Seeking to an offset before the start of the file is an error.
&#x2F;&#x2F; Seeking to any positive offset is legal, but the behavior of subsequent
&#x2F;&#x2F; I&#x2F;O operations on the underlying object is implementation-dependent.
type Seeker interface &#123;
    Seek(offset int64, whence int) (int64, error)
&#125;

&#x2F;&#x2F; ReadWriter is the interface that groups the basic Read and Write methods.
type ReadWriter interface &#123;
    Reader
    Writer
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-6-变量命名"><a href="#2-6-变量命名" class="headerlink" title="2.6 变量命名"></a>2.6 变量命名</h3><ul>
<li>变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。</li>
<li>在相对简单（对象数量少、针对性强）的环境中，可以将一些名称由完整单词简写为单个字母，例如：<ul>
<li>user 可以简写为 u；</li>
<li>userID 可以简写 uid。</li>
</ul>
</li>
<li>特有名词时，需要遵循以下规则：<ul>
<li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient。</li>
<li>其他情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID。</li>
</ul>
</li>
</ul>
<p>下面列举了一些常见的特有名词。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; A GonicMapper that contains a list of common initialisms taken from golang&#x2F;lint
var LintGonicMapper &#x3D; GonicMapper&#123;
    &quot;API&quot;:   true,
    &quot;ASCII&quot;: true,
    &quot;CPU&quot;:   true,
    &quot;CSS&quot;:   true,
    &quot;DNS&quot;:   true,
    &quot;EOF&quot;:   true,
    &quot;GUID&quot;:  true,
    &quot;HTML&quot;:  true,
    &quot;HTTP&quot;:  true,
    &quot;HTTPS&quot;: true,
    &quot;ID&quot;:    true,
    &quot;IP&quot;:    true,
    &quot;JSON&quot;:  true,
    &quot;LHS&quot;:   true,
    &quot;QPS&quot;:   true,
    &quot;RAM&quot;:   true,
    &quot;RHS&quot;:   true,
    &quot;RPC&quot;:   true,
    &quot;SLA&quot;:   true,
    &quot;SMTP&quot;:  true,
    &quot;SSH&quot;:   true,
    &quot;TLS&quot;:   true,
    &quot;TTL&quot;:   true,
    &quot;UI&quot;:    true,
    &quot;UID&quot;:   true,
    &quot;UUID&quot;:  true,
    &quot;URI&quot;:   true,
    &quot;URL&quot;:   true,
    &quot;UTF8&quot;:  true,
    &quot;VM&quot;:    true,
    &quot;XML&quot;:   true,
    &quot;XSRF&quot;:  true,
    &quot;XSS&quot;:   true,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>若变量类型为bool类型，则名称应以Has，Is，Can或Allow开头，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> hasConflict <span class="token builtin">bool</span>
<span class="token keyword">var</span> isExist <span class="token builtin">bool</span>
<span class="token keyword">var</span> canManage <span class="token builtin">bool</span>
<span class="token keyword">var</span> allowGitHook <span class="token builtin">bool</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>局部变量应当尽可能短小，比如使用buf指代buffer，使用i指代index。</li>
<li>代码生成工具自动生成的代码可排除此规则(如<code>xxx.pb.go</code>里面的Id)</li>
</ul>
<h3 id="2-7-常量命名"><a href="#2-7-常量命名" class="headerlink" title="2.7 常量命名"></a>2.7 常量命名</h3><ul>
<li>常量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。</li>
<li>如果是枚举类型的常量，需要先创建相应类型：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Code defines an error code type.</span>
<span class="token keyword">type</span> Code <span class="token builtin">int</span>

<span class="token comment">// Internal errors.</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
    <span class="token comment">// ErrUnknown - 0: An unknown error occurred.</span>
    ErrUnknown Code <span class="token operator">=</span> <span class="token boolean">iota</span>
    <span class="token comment">// ErrFatal - 1: An fatal error occurred.</span>
    ErrFatal
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-8-Error的命名"><a href="#2-8-Error的命名" class="headerlink" title="2.8 Error的命名"></a>2.8 Error的命名</h3><ul>
<li>Error类型应该写成FooError的形式。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ExitError <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// ....</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Error变量写成ErrFoo的形式。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ErrFormat <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unknown format"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-注释规范"><a href="#3-注释规范" class="headerlink" title="3. 注释规范"></a>3. 注释规范</h2><ul>
<li>每个可导出的名字都要有注释，该注释对导出的变量、函数、结构体、接口等进行简要介绍。</li>
<li>全部使用单行注释，禁止使用多行注释。</li>
<li>和代码的规范一样，单行注释不要过长，禁止超过 120 字符，超过的请使用换行展示，尽量保持格式优雅。</li>
<li>注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾，<code>格式为 // 名称 描述.</code>。例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token comment">// logs the flags in the flagset.</span>
<span class="token keyword">func</span> <span class="token function">PrintFlags</span><span class="token punctuation">(</span>flags <span class="token operator">*</span>pflag<span class="token punctuation">.</span>FlagSet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token comment">// PrintFlags logs the flags in the flagset.</span>
<span class="token keyword">func</span> <span class="token function">PrintFlags</span><span class="token punctuation">(</span>flags <span class="token operator">*</span>pflag<span class="token punctuation">.</span>FlagSet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>所有注释掉的代码在提交code review前都应该被删除，否则应该说明为什么不删除，并给出后续处理建议。</p>
</li>
<li><p>在多段注释之间可以使用空行分隔加以区分，如下所示：</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package superman implements methods for saving the world.</span>
<span class="token comment">//</span>
<span class="token comment">// Experience has shown that a small number of procedures can prove</span>
<span class="token comment">// helpful when attempting to save the world.</span>
<span class="token keyword">package</span> superman<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-1-包注释"><a href="#3-1-包注释" class="headerlink" title="3.1 包注释"></a>3.1 包注释</h3><ul>
<li>每个包都有且仅有一个包级别的注释。</li>
<li>包注释统一用 &#x2F;&#x2F; 进行注释，格式为 <code>// Package 包名 包描述</code>，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package genericclioptions contains flags which can be added to you command, bound, completed, and produce</span>
<span class="token comment">// useful helper functions.</span>
<span class="token keyword">package</span> genericclioptions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-变量-x2F-常量注释"><a href="#3-2-变量-x2F-常量注释" class="headerlink" title="3.2 变量&#x2F;常量注释"></a>3.2 变量&#x2F;常量注释</h3><ul>
<li>每个可导出的变量&#x2F;常量都必须有注释说明，<code>格式为// 变量名 变量描述</code>，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ErrSigningMethod defines invalid signing method error.</span>
<span class="token keyword">var</span> ErrSigningMethod <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"Invalid signing method"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>出现大块常量或变量定义时，可在前面注释一个总的说明，然后在每一行常量的前一行或末尾详细注释该常量的定义，例如：<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Code must start with 1xxxxx.</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
    <span class="token comment">// ErrSuccess - 200: OK.</span>
    ErrSuccess <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">100001</span>

    <span class="token comment">// ErrUnknown - 500: Internal server error.</span>
    ErrUnknown

    <span class="token comment">// ErrBind - 400: Error occurred while binding the request body to the struct.</span>
    ErrBind

    <span class="token comment">// ErrValidation - 400: Validation failed.</span>
    ErrValidation
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="3-3-结构体注释"><a href="#3-3-结构体注释" class="headerlink" title="3.3 结构体注释"></a>3.3 结构体注释</h3><ul>
<li>每个需要导出的结构体或者接口都必须有注释说明，格式为 <code>// 结构体名 结构体描述.</code>。</li>
<li>结构体内的可导出成员变量名，如果意义不明确，必须要给出注释，放在成员变量的前一行或同一行的末尾。例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// User represents a user restful resource. It is also used as gorm model.</span>
<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Standard object's metadata.</span>
    metav1<span class="token punctuation">.</span>ObjectMeta <span class="token string">`json:"metadata,omitempty"`</span>

    Nickname <span class="token builtin">string</span> <span class="token string">`json:"nickname" gorm:"column:nickname"`</span>
    Password <span class="token builtin">string</span> <span class="token string">`json:"password" gorm:"column:password"`</span>
    Email    <span class="token builtin">string</span> <span class="token string">`json:"email" gorm:"column:email"`</span>
    Phone    <span class="token builtin">string</span> <span class="token string">`json:"phone" gorm:"column:phone"`</span>
    IsAdmin  <span class="token builtin">int</span>    <span class="token string">`json:"isAdmin,omitempty" gorm:"column:isAdmin"`</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-方法注释"><a href="#3-4-方法注释" class="headerlink" title="3.4 方法注释"></a>3.4 方法注释</h3><p>每个需要导出的函数或者方法都必须有注释，格式为&#x2F;&#x2F; 函数名 函数描述.，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// BeforeUpdate run before update database record.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Policy<span class="token punctuation">)</span> <span class="token function">BeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-5-类型注释"><a href="#3-5-类型注释" class="headerlink" title="3.5 类型注释"></a>3.5 类型注释</h3><ul>
<li>每个需要导出的类型定义和类型别名都必须有注释说明，格式为 <code>// 类型名 类型描述.</code>，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Code defines an error code type.</span>
<span class="token keyword">type</span> Code <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="4-类型"><a href="#4-类型" class="headerlink" title="4. 类型"></a>4. 类型</h2><h3 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h3><ul>
<li>空字符串判断。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>[]byte</code>&#x2F;<code>string</code>相等比较。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token keyword">var</span> s2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token operator">...</span>
bytes<span class="token punctuation">.</span><span class="token function">Equal</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
bytes<span class="token punctuation">.</span><span class="token function">Equal</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span>

<span class="token comment">// good</span>
<span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token keyword">var</span> s2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token operator">...</span>
bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>复杂字符串使用raw字符串避免字符转义。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
regexp<span class="token punctuation">.</span><span class="token function">MustCompile</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span>

<span class="token comment">// good</span>
regexp<span class="token punctuation">.</span><span class="token function">MustCompile</span><span class="token punctuation">(</span><span class="token string">`\.`</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-切片"><a href="#4-2-切片" class="headerlink" title="4.2 切片"></a>4.2 切片</h3><ul>
<li>空slice判断。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">if</span> slice <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面判断同样适用于map、channel。</p>
<ul>
<li>声明slice。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">// good</span>
<span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>slice复制。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">var</span> b1<span class="token punctuation">,</span> b2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> b1 <span class="token punctuation">&#123;</span>
   b2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> b1 <span class="token punctuation">&#123;</span>
   b2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token function">copy</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> b1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>slice新增。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">var</span> a<span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>
    b <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">var</span> a<span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
b <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3-结构体"><a href="#4-3-结构体" class="headerlink" title="4.3 结构体"></a>4.3 结构体</h3><ul>
<li>struct初始化。</li>
</ul>
<p>struct以多行格式初始化。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> user <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Id   <span class="token builtin">int64</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

u1 <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"Colin"</span><span class="token punctuation">&#125;</span>

u2 <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span>
    Id<span class="token punctuation">:</span>   <span class="token number">200</span><span class="token punctuation">,</span>
    Name<span class="token punctuation">:</span> <span class="token string">"Lex"</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-控制结构"><a href="#5-控制结构" class="headerlink" title="5. 控制结构"></a>5. 控制结构</h2><h3 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if"></a>5.1 if</h3><ul>
<li>if 接受初始化语句，约定如下方式建立局部变量。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// error handling</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>if 对于bool类型的变量，应直接进行真假判断。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> isAllow <span class="token builtin">bool</span>
<span class="token keyword">if</span> isAllow <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-2-for"><a href="#5-2-for" class="headerlink" title="5.2 for"></a>5.2 for</h3><ul>
<li>采用短声明建立局部变量。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
    sum <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>不要在 for 循环里面使用 defer，defer只有在函数退出时才会执行。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// bad</span>
<span class="token keyword">for</span> file <span class="token operator">:=</span> <span class="token keyword">range</span> files <span class="token punctuation">&#123;</span>
	fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// good</span>
<span class="token keyword">for</span> file <span class="token operator">:=</span> <span class="token keyword">range</span> files <span class="token punctuation">&#123;</span>
	<span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token comment">// normal code</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-range"><a href="#5-3-range" class="headerlink" title="5.3 range"></a>5.3 range</h3><ul>
<li>如果只需要第一项（key），就丢弃第二个。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> keys <span class="token punctuation">&#123;</span>
<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果只需要第二项，则把第一项置为下划线。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> array <span class="token punctuation">&#123;</span>
    sum <span class="token operator">+=</span> value
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-4-switch"><a href="#5-4-switch" class="headerlink" title="5.4 switch"></a>5.4 switch</h3><ul>
<li>必须要有default。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> os <span class="token operator">:=</span> runtime<span class="token punctuation">.</span>GOOS<span class="token punctuation">;</span> os <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token string">"linux"</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Linux."</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token string">"darwin"</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"OS X."</span><span class="token punctuation">)</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s.\n"</span><span class="token punctuation">,</span> os<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-5-goto"><a href="#5-5-goto" class="headerlink" title="5.5 goto"></a>5.5 goto</h3><ul>
<li>业务代码禁止使用 goto 。</li>
<li>框架或其他底层源码尽量不用。</li>
</ul>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><ul>
<li>传入变量和返回变量以小写字母开头。</li>
<li>函数参数个数不能超过5个。</li>
<li>函数分组与顺序</li>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
<li>尽量采用值传递，而非指针传递。</li>
<li>传入参数是 map、slice、chan、interface ，不要传递指针。</li>
</ul>
<h3 id="6-1-函数参数"><a href="#6-1-函数参数" class="headerlink" title="6.1 函数参数"></a>6.1 函数参数</h3><ul>
<li>如果函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其他情况不建议使用命名返回，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coordinate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">float64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// normal code</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>传入变量和返回变量都以小写字母开头。</li>
<li>尽量用值传递，非指针传递。</li>
<li>参数数量均不能超过5个。</li>
<li>多返回值最多返回三个，超过三个请使用 struct。</li>
</ul>
<h3 id="6-2-defer"><a href="#6-2-defer" class="headerlink" title="6.2 defer"></a>6.2 defer</h3><ul>
<li>当存在资源创建时，应紧跟defer释放资源(可以大胆使用defer，defer在Go1.14版本中，性能大幅提升，defer的性能损耗即使在性能敏感型的业务中，也可以忽略)。</li>
<li>先判断是否错误，再defer释放资源，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rep<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>

<span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-3-方法的接收器"><a href="#6-3-方法的接收器" class="headerlink" title="6.3 方法的接收器"></a>6.3 方法的接收器</h3><ul>
<li>推荐以类名第一个英文首字母的小写作为接收器的命名。</li>
<li>接收器的命名在函数超过20行的时候不要用单字符。</li>
<li>接收器的命名不能采用me、this、self这类易混淆名称。</li>
</ul>
<h3 id="6-4-嵌套"><a href="#6-4-嵌套" class="headerlink" title="6.4 嵌套"></a>6.4 嵌套</h3><ul>
<li>嵌套深度不能超过4层。</li>
</ul>
<h3 id="6-5-变量命名"><a href="#6-5-变量命名" class="headerlink" title="6.5 变量命名"></a>6.5 变量命名</h3><ul>
<li>变量声明尽量放在变量第一次使用的前面，遵循就近原则。</li>
<li>如果魔法数字出现超过两次，则禁止使用，改用一个常量代替，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PI ...</span>
<span class="token keyword">const</span> Prise <span class="token operator">=</span> <span class="token number">3.14</span>

<span class="token keyword">func</span> <span class="token function">getAppleCost</span><span class="token punctuation">(</span>n <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> Prise <span class="token operator">*</span> n
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">getOrangeCost</span><span class="token punctuation">(</span>n <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> Prise <span class="token operator">*</span> n
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="7-GOPATH-设置规范"><a href="#7-GOPATH-设置规范" class="headerlink" title="7. GOPATH 设置规范"></a>7. GOPATH 设置规范</h2><ul>
<li>Go 1.11 之后，弱化了 GOPATH 规则，已有代码（很多库肯定是在1.11之前建立的）肯定符合这个规则，建议保留 GOPATH 规则，便于维护代码。</li>
<li>建议只使用一个 GOPATH，不建议使用多个 GOPATH。如果使用多个GOPATH，编译生效的 bin 目录是在第一个 GOPATH 下。</li>
</ul>
<h2 id="8-依赖管理"><a href="#8-依赖管理" class="headerlink" title="8. 依赖管理"></a>8. 依赖管理</h2><ul>
<li>Go 1.11 以上必须使用 Go Modules。</li>
<li>使用Go Modules作为依赖管理的项目时，不建议提交vendor目录。</li>
<li>使用Go Modules作为依赖管理的项目时，必须提交go.sum文件。</li>
</ul>
<h3 id="9-最佳实践"><a href="#9-最佳实践" class="headerlink" title="9. 最佳实践"></a>9. 最佳实践</h3><ul>
<li>尽量少用全局变量，而是通过参数传递，使每个函数都是“无状态”的。这样可以减少耦合，也方便分工和单元测试。</li>
<li>在编译时验证接口的符合性，例如：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> LogHandler <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
  h   http<span class="token punctuation">.</span>Handler
  log <span class="token operator">*</span>zap<span class="token punctuation">.</span>Logger
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> http<span class="token punctuation">.</span>Handler <span class="token operator">=</span> LogHandler<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>服务器处理请求时，应该创建一个context，保存该请求的相关信息（如requestID），并在函数调用链中传递。</li>
</ul>
<h3 id="9-1-性能"><a href="#9-1-性能" class="headerlink" title="9.1 性能"></a>9.1 性能</h3><ul>
<li>string 表示的是不可变的字符串变量，对 string 的修改是比较重的操作，基本上都需要重新申请内存。所以，如果没有特殊需要，需要修改时多使用 []byte。</li>
<li>优先使用 strconv 而不是 fmt。</li>
</ul>
<h3 id="9-2-注意事项"><a href="#9-2-注意事项" class="headerlink" title="9.2 注意事项"></a>9.2 注意事项</h3><ul>
<li>append 要小心自动分配内存，append 返回的可能是新分配的地址。</li>
<li>如果要直接修改 map 的 value 值，则 value 只能是指针，否则要覆盖原来的值。</li>
<li>map 在并发中需要加锁。</li>
<li>编译过程无法检查 interface{} 的转换，只能在运行时检查，小心引起 panic。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里向你介绍了九类常用的编码规范。但今天的最后，我要在这里提醒你一句：规范是人定的，你也可以根据需要，制定符合你项目的规范，但同时我也建议你采纳这些业界沉淀下来的规范，并通过工具来确保规范的执行。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 项目设计(汇总)</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-project-design-lint.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://juejin.cn/book/7176608782871429175">《从零开发企业级 Go 应用》</a></li>
</ul>
<p>如何构建出一个完整的 Go 项目，并且尽可能地说明开发过程中我的思考。希望能够通过这些思考让你知道如何开发 Go 项目，并且了解其他开发者的开发思路。</p>
<span id="more"></span>
<h2 id="项目研发流程介绍"><a href="#项目研发流程介绍" class="headerlink" title="项目研发流程介绍"></a>项目研发流程介绍</h2><p>在动手撸代码之前，你最好先鸟瞰整个 Go 项目开发流程，通过对流程的了解，可以减少你在初次进行完整 Go 项目开发中的那种“不知所措”的感觉，可以让你掌握业界最优、也是最标准的项目开发流程，增强你的自信。</p>
<p>业界通常把研发流程分为六个阶段，分别是需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段。其中，开发人员需要参与的阶段有 4 个：设计阶段、开发阶段、测试阶段和发布阶段。研发流程及流程中每个阶段的具体内容，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d1c206d83f642feb5877279343c8832~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">  </p>
<p>作为一名开发人员，在设计阶段也会有一些设计类工作需要你去完成，例如：规范设计、目录结构设计、工作流设计、研发流程设计、Go 代码结构设计等，其中比较重要的设计是规范设计、目录结构设计、Go 代码结构设计。接下来，我会详细介绍如何来设计这些内容。</p>
<h2 id="规范设计"><a href="#规范设计" class="headerlink" title="规范设计"></a>规范设计</h2><p>规范设计内容也比较多，通常包含代码规范、Commit 规范、版本规范、接口规范、日志规范、错误码规范等。</p>
<ul>
<li><p><strong>代码规范：</strong> <a href="./go-code-lint">Go 代码开发规范</a>。</p>
</li>
<li><p><strong>Commit 规范：</strong> <a href="./go-commit-lint">Commit 规范</a>。</p>
</li>
<li><p><strong>版本规范：</strong> <a href="./go-version-lint">版本规范</a>。</p>
</li>
<li><p><strong>接口规范：</strong> <a href="./go-api-lint">接口规范</a>。</p>
</li>
<li><p><strong>日志规范：</strong> <a href="./go-logging-lint">日志规范</a>。</p>
</li>
<li><p><strong>错误码规范：</strong> <a href="./go-errorcode-lint">错误码规范</a>。</p>
</li>
</ul>
<p>上面只列举了一些常用的规范，对于一个项目来说，如果有需要可以制定更多的规范，例如：开发流程规范、发布规范、校验规范等。这些规范不仅可以提高代码质量，还可以提高研发效率，降低后期的代码维护成本和学习成本。</p>
<blockquote>
<p>提示：在实际开发中，大部分团队和项目其实也只用到了这些规范。甚至，我所见过的更多的团队，包括腾讯、阿里内部的不少团队都没有制定过开发规范，或者说一些团队只是在项目开始时曾经制定过规范，但随着项目的迭代，会遗忘这些规范。</p>
</blockquote>
<p>规范是开发人员制定的软约束，靠开发人员自觉的去遵守，并不太可行。在实际开发中，我们要多思考怎么通过工具去保证这些规范被遵守，例如：可以通过 <code>golangci-lint</code> 进行静态代码检查，来保证代码规范；通过 <code>gitlint</code> 工具来保证 Commit 规范；通过 <code>gsemver</code> 工具来生 SemVer 格式的版本号；通过 OpenAPI 编辑器来编写 OpenAPI 接口文档；通过调用统一的请求返回方法，来确保错误码规范；通过开发规范化的日志包，来保证日志规范等。</p>
<h2 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h2><p>目录结构是一个项目的门面。很多时候，根据目录结构就能看出开发者对这门语言的掌握程度。所以，在我看来，遵循一个好的目录规范，把代码目录设计的可维护、可扩展，甚至比文档规范、Commit 规范都要重要。通常，根据功能，可以将目录结构分为以下两种。</p>
<ul>
<li><p><strong>平铺式目录结构：</strong> 主要用在 Go 包中，相对简单。</p>
</li>
<li><p><strong>结构化目录结构：</strong> 主要用在 Go 应用中，相对复杂。</p>
</li>
</ul>
<h3 id="平铺式目录结构"><a href="#平铺式目录结构" class="headerlink" title="平铺式目录结构"></a>平铺式目录结构</h3><p>一个 Go 项目可以是一个应用，也可以是一个代码库，当项目是代码库时，比较适合采用平铺式目录结构。</p>
<p>平铺方式就是在项目的根目录下存放项目的代码，整个目录结构看起来更像是一层的，这种方式在很多库中存在，使用这种方式的好处是引用路径长度明显减少。例如 <a href="https://github.com/golang/glog">glog</a> 包就是平铺式的，目录内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">$ ls glog&#x2F;
glog_file.go  glog.go  glog_test.go  go.mod  LICENSE  README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>对于一些功能简单的工具或项目，也可以采用平铺式的目录结构，以减小开发者的理解成本和编写复杂度。</p>
<h3 id="结构化目录结构"><a href="#结构化目录结构" class="headerlink" title="结构化目录结构"></a>结构化目录结构</h3><p>当前 Go 社区比较推荐的结构化目录结构是 <a href="https://link.juejin.cn/?target=https://github.com/golang-standards/project-layout" title="https://github.com/golang-standards/project-layout">project-layout</a>。虽然它并不是官方和社区的规范，但因为组织方式比较合理，被很多 Go 开发人员接受。所以，我们可以把它当作是一个事实上的规范。本实战项目 miniblog 目录也遵循了 project-layout 项目的目录规范。</p>
<h3 id="miniblog-目录结构设计"><a href="#miniblog-目录结构设计" class="headerlink" title="miniblog 目录结构设计"></a>miniblog 目录结构设计</h3><ul>
<li><a href="https://github.com/marmotedu/miniblog"> https://github.com/marmotedu/miniblog</a></li>
</ul>
<p>miniblog 目录结构遵循了 project-layout 的目录结构设计。项目目录及功能介绍如下：</p>
<pre class="line-numbers language-none"><code class="language-none">├── api # Swagger &#x2F; OpenAPI 文档存放目录
│   └── openapi
│       └── openapi.yaml # OpenAPI 3.0 API 接口文档
├── cmd # main 文件存放目录
│   └── miniblog
│       └── miniblog.go
├── configs # 配置文件存放目录
│   ├── miniblog.sql # 数据库初始化 SQL
│   ├── miniblog.yaml # miniblog 配置文件
│   └── nginx.conf # Nginx 配置
├── docs # 项目文档
│   ├── devel # 开发文档
│   │   ├── en-US # 英文文档
│   │   └── zh-CN # 中文文档
│   │       ├── architecture.md # miniblog 架构介绍
│   │       ├── conversions # 规范文档存放目录
│   │       │   ├── api.md # 接口规范
│   │       │   ├── commit.md # Commit 规范
│   │       │   ├── directory.md # 目录结构规范
│   │       │   ├── error_code.md # 错误码规范
│   │       │   ├── go_code.md # 代码规范
│   │       │   ├── log.md # 日志规范
│   │       │   └── version.md # 版本规范
│   │       └── README.md
│   ├── guide # 用户文档
│   │   ├── en-US # 英文文档
│   │   └── zh-CN # 中文文档
│   │       ├── announcements.md # 动态与公告
│   │       ├── best-practice # 最佳实践
│   │       ├── faq # 常见问题
│   │       ├── installation # 安装指南
│   │       ├── introduction # 产品介绍
│   │       ├── operation-guide # 操作指南
│   │       ├── quickstart # 快速入门
│   │       └── README.md
│   └── images # 项目图片存放目录
├── examples # 示例源码
├── go.mod
├── go.sum
├── init # Systemd Unit 文件保存目录
│   ├── miniblog.service # miniblog systemd unit
├── internal # 内部代码保存目录，这里面的代码不能被外部程序引用
│   ├── miniblog # miniblog 代码实现目录
│   │   ├── biz # biz 层代码
│   │   ├── controller # controller 层代码
│   │   │   └── v1 # API 接口版本
│   │   │       ├── post # 博客相关代码实现
│   │   │       │   ├── create.go # 创建博客
│   │   │       │   ├── delete_collection.go #批量删除博客
│   │   │       │   ├── delete.go # 删除博客
│   │   │       │   ├── get.go # 获取博客详情
│   │   │       │   ├── list.go # 获取博客列表
│   │   │       │   ├── post.go # 博客 Controller 结构定义、创建
│   │   │       │   └── update.go # 更新博客
│   │   │       └── user
│   │   │           ├── change_password.go # 修改用户密码
│   │   │           ├── create.go #创建用户
│   │   │           ├── delete.go # 删除用户
│   │   │           ├── get.go # 获取用户详情
│   │   │           ├── list.go # 获取用户列表
│   │   │           ├── login.go # 用户登录
│   │   │           ├── update.go  # 更新用户
│   │   │           └── user.go # 用户 Controller 结构定义、创建
│   │   ├── helper.go # 工具类代码存放文件
│   │   ├── miniblog.go # miniblog 主业务逻辑实现代码
│   │   ├── router.go # Gin 路由加载代码
│   │   └── store # store 层代码
│   └── pkg # 内部包保存目录
│       ├── core # core 包，用来保存一些核心的函数
│       ├── errno # errno 包，实现了 miniblog 的错误码功能
│       │   ├── code.go # 错误码定义文件
│       │   └── errno.go # errno 包功能函数文件
│       ├── known # 存放项目级的常量定义
│       ├── log # miniblog 自定义 log 包
│       ├── middleware # Gin 中间件包
│       │   ├── authn.go # 认证中间件
│       │   ├── authz.go # 授权中间件
│       │   ├── header.go # 指定 HTTP Response Header
│       │   └── requestid.go # 请求 &#x2F; 返回头中添加 X-Request-ID
│       └── model # GORM Model
├── LICENSE # 声明代码所遵循的开源协议
├── Makefile # Makefile 文件，一般大型软件系统都是采用 make 来作为编译工具
├── _output # 临时文件存放目录
├── pkg # 可供外部程序直接使用的 Go 包存放目录
│   ├── api # REST API 接口定义存放目录
│   ├── proto # Protobuf 接口定义存放目录
│   ├── auth # auth 包，用来完成认证、授权功能
│   │   ├── authn.go # 认证功能
│   │   └── authz.go # 授权功能
│   ├── db # db 包，用来完成 MySQL 数据库连接
│   ├── token # JWT Token 的签发和解析
│   ├── util # 工具类包存放目录
│   │   └── id # id 包，用来生成唯一短 ID
│   └── version # version 包，用来保存 &#x2F; 输出版本信息
├── README-en.md # 英文 README
├── README.md # 中文 README
├── scripts # 脚本文件
│   ├── boilerplate.txt # 指定版权头信息
│   ├── coverage.awk # awk 脚本，用来计算覆盖率
│   ├── make-rules # 子 Makefile 保存目录
│   │   ├── common.mk # 存放通用的 Makefile 变量
│   │   ├── golang.mk # 用来编译源码
│   │   └── tools.mk # 用来完成工具的安装
│   └── wrktest.sh # wrk 性能测试脚本
└── third_party # 第三方 Go 包存放目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟 project-layout 目录规范唯一不一样的地方是，miniblog 将具体的实现目录 miniblog 放在 <code>internal/</code> 目录下，而非 <code>internal/app/</code> 目录下，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">$ ls internal&#x2F;         
miniblog  pkg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这样做既可以保证 <code>internal</code> 目录下的文件功能清晰、整齐，又能缩短引用路径。</p>
<h2 id="代码结构设计"><a href="#代码结构设计" class="headerlink" title="代码结构设计"></a>代码结构设计</h2><p>项目代码设计遵循简洁架构设计，一个简洁架构具有以下 5 个特性：</p>
<ul>
<li><p><strong>独立于框架：</strong> 该架构不会依赖于某些功能强大的软件库存在。这可以让你使用这样的框架作为工具，而不是让你的系统陷入到框架的约束中。</p>
</li>
<li><p><strong>可测试性：</strong> 业务规则可以在没有 UI、数据库、Web 服务或其他外部元素的情况下进行测试，在实际的开发中，我们通过 Mock 来解耦这些依赖。</p>
</li>
<li><p><strong>独立于UI ：</strong> 在无需改变系统其他部分的情况下，UI 可以轻松地改变。例如，在没有改变业务规则的情况下，Web UI 可以替换为控制台 UI。</p>
</li>
<li><p><strong>独立于数据库：</strong> 你可以用 Mongo、Oracle、Etcd 或者其他数据库来替换 MariaDB，你的业务规则不要绑定到数据库。</p>
</li>
<li><p><strong>独立于外部媒介：</strong> 实际上，你的业务规则可以简单到根本不去了解外部世界。</p>
</li>
</ul>
<p><strong>所以，基于这些约束，每一层都必须是独立的和可测试的。代码架构分为 4 层：模型层（Model）、控制层（Controller）、业务层 （Biz）、仓库层（Store）。从控制层、业务层到仓库层，从左到右层级依次加深。模型层独立于其他层，可供其他层引用。代码架构如下图所示：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2da85aa1405945519dbf5f645587fb5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p><strong>层与层之间导入包时，都有严格的导入关系，这可以防止包的循环导入问题。导入关系如下：</strong></p>
<ul>
<li>模型层的包可以被仓库层、业务层和控制层导入。</li>
<li>控制层能够导入业务层和仓库层的包。这里需要注意，如果没有特殊需求，控制层要避免导入仓库层的包，控制层需要完成的业务功能都通过业务层来完成。</li>
<li>业务层能够导入仓库层的包。</li>
</ul>
<h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p><strong>接下来，我们就来详细看下每一层所完成的功能，以及其中的一些注意点：</strong></p>
<ol>
<li>模型层（Model）：模型层在有些软件架构中也叫做实体层（Entities），模型会在每一层中使用，在这一层中存储对象的结构和它的方法。</li>
<li>控制层（Controller）：控制层接收 HTTP 请求，并进行参数解析、参数校验、逻辑分发处理、请求返回这些操作。控制层会将逻辑分发给业务层，业务层处理后返回，返回数据在控制层中被整合再加工，最终返回给请求方。控制层相当于实现了业务路由的功能。具体流程如下图所示：</li>
<li>业务层 (Biz)：业务层主要用来完成业务逻辑处理，我们可以把所有的业务逻辑处理代码放在业务层。业务层会处理来自控制层的请求，并根据需要请求仓库层完成数据的 CURD 操作。业务层功能如下图所示：</li>
<li>仓库层（Store)：仓库层用来跟数据库&#x2F;第三方服务进行 CURD 交互，作为应用程序的数据引擎进行应用数据的输入和输出。这里需要注意，仓库层仅对数据库&#x2F;第三方服务执行 CRUD 操作，不封装任何业务逻辑。这一层也会起到数据转换的作用：将从数据库&#x2F;微服务中获取的数据转换为控制层、业务层能识别的数据结构，将控制层、业务层的数据格式转换为数据库或微服务能识别的数据格式。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf1b54fea8bd4e2e9a059b4b10599787~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89451e92ff3f4f888e56f16c638bbc55~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<h3 id="层之间的通信"><a href="#层之间的通信" class="headerlink" title="层之间的通信"></a>层之间的通信</h3><p>上面介绍了 4 层结构，接下来我们再看看每一层之间是如何通信的。</p>
<p>除了模型层，控制层、业务层、仓库层之间都是通过接口进行通信的。通过接口通信，一方面可以使相同的功能支持不同的实现（也就是说具有插件化能力），另一方面也使得每一层的代码变得可测试。</p>
<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>控制层、业务层和仓库层之间是通过接口来通信的。通过接口通信有一个好处，就是可以让各层变得可测。那接下来，我们就来看下如何测试各层的代码。这里只介绍下测试思路。</p>
<ol>
<li>模型层: 因为模型层不依赖其他任何层，我们只需要测试其中定义的结构及其函数和方法即可。</li>
<li>控制层: 控制层依赖于业务层，意味着该层需要业务层来支持测试。你可以通过 <code>golang/mock</code> 来 mock 业务层</li>
<li>业务层: 因为该层依赖于仓库层，意味着该层需要仓库层来支持测试。你可以通过 <code>golang/mock</code> 来 mock 仓库层</li>
<li>仓库层: 仓库层依赖于数据库，如果调用了其他微服务，那还会依赖第三方服务。我们可以通过 <a href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a> 来模拟数据库连接，通过 <a href="https://github.com/jarcoal/httpmock">httpmock</a> 来模拟 HTTP 请求。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>比较重要的工作有：规范设计、目录结构设计和代码结构设计。其中规范类，本课程采用了业界的最佳规范实践，目录结构采用了当前最受 Go 开发者欢迎的 <code>project-layout</code> 目录结构，代码结构采用了简洁架构。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>项目设计</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 版本规范</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-version-lint.html</url>
    <content><![CDATA[<h2 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h2><p><a href="https://semver.org/lang/zh-CN/">语义化版本 2.0.0</a> 规范。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>开发规范</tag>
        <tag>版本规范</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开发企业级 Go 应用 之 单元测试</title>
    <url>//post/2023-golang-practice-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7-Go-%E5%BA%94%E7%94%A8-go-unit-test-now.html</url>
    <content><![CDATA[<ul>
<li>本文摘自<a href="https://juejin.cn/book/7176608782871429175">《从零开发企业级 Go 应用》</a></li>
</ul>
<p>在实际开发中，不仅要开发功能，更重要的是确保这些功能稳定可靠，并且拥有一个不错的性能，要确保这些，就要对代码进行测试。测试分为很多种，例如：功能测试、性能测试、集成测试、端到端测试、单元测试等。</p>
<span id="more"></span>
<p>对于开发者，需要执行的测试种类一般是单元测试和性能测试。除此之外，Go 还提供了其他类型的测试，例如：模糊测试、示例测试。本节课，我就来详细介绍下开发者可以执行的测试种类，以及如何编写和执行测试用例。</p>
<p>这里，想跟大家分享下，在实际项目开发中，开发人员编写并执行单元测试的现状。</p>
<p>其实，即使在像腾讯、阿里这样的大厂，也并没有多少开发人员能够在开发过程中，编写高质量、高覆盖率的单元测试用例。并不是说编写单元测试用例不重要，而是，在项目开发过程中，你可能经常需要忙于追赶项目进度，而没时间去编写单元测试用例。</p>
<p>在实际开发中，<strong>开发者一般不太习惯随时编写单元测试用例，并不是说编写单元测试用例不重要</strong>，而是因为很多时候，实现功能需求优先级更高。这里分享下我对编写单元测试用例的一点思考：</p>
<ul>
<li><p>编写单元测试用例很重要，但单元测试用例并不一定需要边开发边编写。很多时候，我们需要在功能开发进度和编写单元测试用例之间进行权衡；</p>
</li>
<li><p>对于开发过程中，需要编写代码测试某块功能的时候，不妨顺便将测试代码变成单元测试用例；</p>
</li>
<li><p>单元测试用例对后期的代码维护很重要，在项目上线后，如果有时间，建议补全单元测试用例。</p>
</li>
</ul>
<h2 id="Go-语言如何编写测试用例？"><a href="#Go-语言如何编写测试用例？" class="headerlink" title="Go 语言如何编写测试用例？"></a>Go 语言如何编写测试用例？</h2><p>Go 语言有自带的测试框架 <code>testing</code>，可以用来实现单元测试和性能测试，通过 <code>go test</code> 命令来执行单元测试和性能测试。</p>
<p><code>go test</code> 执行测试用例时，是以 Go 包为单位进行测试的。执行时需要指定包名，比如：<code>go test 包名</code>，如果没有指定包名，默认会选择执行命令时所在的包。<code>go test</code> 在执行时会遍历以 <code>_test.go</code> 结尾的源码文件，执行其中以 <code>Test</code>、<code>Benchmark</code>、<code>Example</code>、<code>Fuzz</code> 开头的测试函数。其中源码文件需要满足以下规范：</p>
<ul>
<li>文件名必须是 <code>_test.go</code> 结尾，跟源文件在同一个包；</li>
<li>测试用例函数必须以 <code>Test</code>、<code>Benchmark</code>、<code>Example</code>、<code>Fuzz</code> 开头；</li>
<li>执行测试用例时的顺序，会按照源码中的顺序依次执行；</li>
<li>单元测试函数 <code>TestXxx()</code> 的参数是 <code>testing.T</code>，可以使用该类型来记录错误或测试状态；</li>
<li>性能测试函数 <code>BenchmarkXxx()</code> 的参数是 <code>testing.B</code>，函数内以 <code>b.N</code> 作为循环次数，其中 <code>N</code> 会动态变化；</li>
<li>示例函数 <code>ExampleXxx()</code> 没有参数，执行完会将输出与注释 <code>// Output:</code> 进行对比；</li>
<li>测试函数原型：<code>func TestXxx(t *testing.T)</code>，<code>Xxx</code> 部分为任意字母数字组合，首字母大写，例如： <code>TestgenShortId</code> 是错误的函数名，<code>TestGenShortId</code> 是正确的函数名；</li>
<li>通过调用 <code>testing.T</code> 的 <code>Error</code>、<code>Errorf</code>、<code>FailNow</code>、<code>Fatal</code>、<code>FatalIf</code> 方法来说明测试不通过，通过调用 <code>Log</code>、<code>Logf</code> 方法来记录测试信息：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">t.Log t.Logf     # 正常信息 
t.Error t.Errorf # 测试失败信息 
t.Fatal t.Fatalf # 致命错误，测试程序退出的信息
t.Fail     # 当前测试标记为失败
t.Failed   # 查看失败标记
t.FailNow  # 标记失败，并终止当前测试函数的执行，需要注意的是，我们只能在运行测试函数的 Goroutine 中调用 t.FailNow 方法，而不能在我们在测试代码创建出的 Goroutine 中调用它
t.Skip     # 调用 t.Skip 方法相当于先后对 t.Log 和 t.SkipNow 方法进行调用，而调用 t.Skipf 方法则相当于先后对 t.Logf 和 t.SkipNow 方法进行调用。方法 t.Skipped 的结果值会告知我们当前的测试是否已被忽略
t.Parallel # 标记为可并行运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Go-语言测试种类及用例编写方法"><a href="#Go-语言测试种类及用例编写方法" class="headerlink" title="Go 语言测试种类及用例编写方法"></a>Go 语言测试种类及用例编写方法</h2><p>上面，我介绍了 Go 语言层面对测试用例的支持，这里我就简单介绍下常见的测试用例编写及执行方法。</p>
<p>在实际项目开发中，我们编写最多的是单元测试用例，接着是性能测试用例，在某些场景还可能会需要编写模糊测试用例。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>在 <code>pkg/util/id/</code> 目录下创建文件 <code>id_test.go</code>，内容为：</p>
<pre class="line-numbers language-none"><code class="language-none">package id

import (
    &quot;testing&quot;

    &quot;github.com&#x2F;stretchr&#x2F;testify&#x2F;assert&quot;
)

func TestGenShortID(t *testing.T) &#123;
    shortID :&#x3D; GenShortID()
    assert.NotEqual(t, &quot;&quot;, shortID)
    assert.Equal(t, 6, len(shortID))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>你可以通过运行 <code>go test</code> 命令来执行测试用例。<code>go test</code> 通过不同的参数，来支持不同的测试效果，常用的 <code>go test</code> 命令如下：</p>
<ul>
<li><strong>执行默认的测试用例</strong></li>
</ul>
<p>在 <code>pkg/util/id/</code> 目录下执行命令 <code>go test</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>根据 <code>go test</code> 的输出可以知道 <code>TestGenShortID</code> 用例测试通过。</p>
<ul>
<li><strong>查看更详细的执行信息</strong></li>
</ul>
<p>要查看更详细的执行信息可以执行 <code>go test -v</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v
&#x3D;&#x3D;&#x3D; RUN   TestGenShortID
--- PASS: TestGenShortID (0.00s)
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>执行测试</strong> <strong><code>N</code></strong> <strong>次</strong></li>
</ul>
<p>如果要执行测试 <code>N</code> 次可以使用 <code>-count N</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v -count 2
&#x3D;&#x3D;&#x3D; RUN   TestGenShortID
--- PASS: TestGenShortID (0.00s)
&#x3D;&#x3D;&#x3D; RUN   TestGenShortID
--- PASS: TestGenShortID (0.00s)
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>只运行指定的单测用例</strong></li>
</ul>
<p>此外，你还可以只运行指定的单测用例：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -run TestGenShortID -v
&#x3D;&#x3D;&#x3D; RUN   TestGenShortID
--- PASS: TestGenShortID (0.00s)
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>-run</code> 参数支持正则表达式。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>在企业应用开发中，也需要你学会编写和运行性能测试用例。</p>
<h4 id="编写性能测试用例"><a href="#编写性能测试用例" class="headerlink" title="编写性能测试用例"></a>编写性能测试用例</h4><p>在 <code>pkg/util/id/id_test.go</code> 测试文件中，新增两个性能测试函数：<code>BenchmarkGenShortID</code> 和 <code>BenchmarkGenShortIDTimeConsuming</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">func BenchmarkGenShortID(b *testing.B) &#123;
    for i :&#x3D; 0; i &lt; b.N; i++ &#123;
        GenShortID()
    &#125;
&#125;

func BenchmarkGenShortIDTimeConsuming(b *testing.B) &#123;
    b.StopTimer() &#x2F;&#x2F;调用该函数停止压力测试的时间计数

    shortId :&#x3D; GenShortID()
    if shortId &#x3D;&#x3D; &quot;&quot; &#123;
        b.Error(&quot;Failed to generate short id&quot;)
    &#125;

    b.StartTimer() &#x2F;&#x2F;重新开始时间

    for i :&#x3D; 0; i &lt; b.N; i++ &#123;
        GenShortID()
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码说明：</strong></p>
<ul>
<li><p>性能测试函数名必须以 <code>Benchmark</code> 开头，如 <code>BenchmarkXxx</code> 或 <code>Benchmark_xxx</code>；</p>
</li>
<li><p><code>go test</code> 默认不会执行性能测试函数，需要通过指定参数 <code>-test.bench</code> 来运行性能测试函数，<code>-test.bench</code> 后跟正则表达式，如 <code>go test -test.bench=&quot;.*&quot;</code> 表示执行所有的性能测试函数；</p>
</li>
<li><p>在性能测试中，需要在循环体中指定 <code>testing.B.N</code> 来循环执行性能测试代码。</p>
</li>
</ul>
<h4 id="运行性能测试用例"><a href="#运行性能测试用例" class="headerlink" title="运行性能测试用例"></a><strong>运行性能测试用例</strong></h4><p>在 <code>pkg/util/id/</code> 目录下执行命令 <code>go test -test.bench=&quot;.*&quot;</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -test.bench&#x3D; &quot;.*&quot;
goos: linux
goarch: amd64
pkg: github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id
cpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz
BenchmarkGenShortID-16                           841854              1367 ns&#x2F;op
BenchmarkGenShortIDTimeConsuming-16              880039              1349 ns&#x2F;op
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        2.376s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>上面的结果显示，我们没有执行任何 <code>TestXXX</code> 的单元测试函数，只执行了性能测试函数；</p>
</li>
<li><p>第一条显示了 <code>BenchmarkGenShortID</code> 执行了 841854 次，每次的执行平均时间是 1367 纳秒；</p>
</li>
<li><p>第二条显示了 <code>BenchmarkGenShortIDTimeConsuming</code> 执行了 880039，每次的平均执行时间是 1349 纳秒；</p>
</li>
<li><p>最后一条显示总执行时间。</p>
</li>
</ul>
<p><code>BenchmarkGenShortIdTimeConsuming</code> 比 <code>BenchmarkGenShortID</code> 多了两个调用 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code>：</p>
<ul>
<li><p><code>b.StopTimer()</code>：调用该函数停止性能测试的时间计数；</p>
</li>
<li><p><code>b.StartTimer()</code>：重新开始时间。</p>
</li>
</ul>
<p>在 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code> 之间可以做一些准备工作，这样这些时间不影响我们测试函数本身的性能。</p>
<h4 id="查看性能并生成函数调用图"><a href="#查看性能并生成函数调用图" class="headerlink" title="查看性能并生成函数调用图"></a>查看性能并生成函数调用图</h4><p>执行以下命令，保存性能测试指标：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go test -bench&#x3D; &quot;.*&quot; -cpuprofile&#x3D;cpu.profile
goos: linux
goarch: amd64
pkg: github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id
cpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz
BenchmarkGenShortID-16                           909586              1319 ns&#x2F;op
BenchmarkGenShortIDTimeConsuming-16              916029              1356 ns&#x2F;op
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        2.583s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述命令会在当前目录下生成 <code>cpu.profile</code> 和 <code>id.test</code> 文件。</p>
<p>之后，我们可以执行 <code>go tool pprof id.test cpu.profile</code> 查看性能（进入交互界面后执行 <code>top</code> 指令）：</p>
<pre class="line-numbers language-none"><code class="language-none">$ go tool pprof id.test cpu.profile
File: id.test
Type: cpu
Time: Jan 11, 2023 at 4:18pm (CST)
Duration: 2.58s, Total samples &#x3D; 2.54s (98.56%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top
Showing nodes accounting for 2040ms, 80.31% of 2540ms total
Dropped 44 nodes (cum &lt;&#x3D; 12.70ms)
Showing top 10 nodes out of 57
      flat  flat%   sum%        cum   cum%
    1490ms 58.66% 58.66%     1560ms 61.42%  syscall.Syscall
     180ms  7.09% 65.75%      300ms 11.81%  runtime.mallocgc
     110ms  4.33% 70.08%      110ms  4.33%  time.Now
      60ms  2.36% 72.44%      140ms  5.51%  strings.ToLower
      40ms  1.57% 74.02%     2250ms 88.58%  github.com&#x2F;jasonsoft&#x2F;go-short-id.Generate
      40ms  1.57% 75.59%       40ms  1.57%  time.absDate
      30ms  1.18% 76.77%     1630ms 64.17%  crypto&#x2F;rand.(*devReader).Read
      30ms  1.18% 77.95%       30ms  1.18%  runtime.nextFreeFast (inline)
      30ms  1.18% 79.13%       40ms  1.57%  runtime.reentersyscall
      30ms  1.18% 80.31%       50ms  1.97%  runtime.scanobject
(pprof) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pprof 程序中最重要的命令就是 <code>topN</code>，此命令用于显示 profile 文件中的最靠前的 <code>N</code> 个样本（sample），它的输出格式各字段的含义依次是：</p>
<ol>
<li><p>采样点落在该函数中的总时间；</p>
</li>
<li><p>采样点落在该函数中的百分比；</p>
</li>
<li><p>上一项的累积百分比；</p>
</li>
<li><p>采样点落在该函数，以及被它调用的函数中的总时间；</p>
</li>
<li><p>采样点落在该函数，以及被它调用的函数中的总次数百分比；</p>
</li>
<li><p>函数名。</p>
</li>
</ol>
<p>此外，在 pprof 程序中还可以使用 <code>svg</code> 来生成函数调用关系图（需要安装 <code>graphviz</code>），例如：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36c20ee79df4caa8496520c018e85e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>该调用图生成方法如下：</p>
<ol>
<li>安装 <code>graphviz</code> 命令。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ sudo yum -y install graphviz.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>执行 <code>go tool pprof</code> 生成 svg 图。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">$ go tool pprof id.test cpu.profile
File: id.test
Type: cpu
Time: Jan 11, 2023 at 4:18pm (CST)
Duration: 2.58s, Total samples &#x3D; 2.54s (98.56%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) svg
Generating report in profile001.svg
(pprof) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>svg</code> 子命令会默认在当前目录下生成了一个 svg 文件 <code>profile001.svg</code>。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>关于如何看懂 pprof 信息，请参考官方文档 <a href="%22https://blog.golang.org/profiling-go-programs%22">Profiling Go Programs</a>。</li>
<li>关于如何做性能分析，请参考郝林大神的文章 <a href="%22https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md%22">go tool pprof</a>。</li>
</ul>
</blockquote>
<h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>Fuzzing 是一种自动化的测试技术， 它不断地创建输入用来测试程序的 bug。 Go fuzzing 使用覆盖率智能指导遍历被模糊化测试的代码，发现缺陷并报告给用户。由于模糊测试可以达到人类经常忽略的边缘场景，因此它对于发现安全漏洞和缺陷特别有价值。</p>
<p>Go 语言在 1.18 版本支持了模糊测试用例。</p>
<p>单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。Fuzzing 的优点之一是可以基于开发者代码里指定的测试输入作为基础数据，进一步自动生成新的随机测试数据，用来发现指定测试输入没有覆盖到的边界情况。</p>
<p>然而 Fuzzing 也有一定的局限性， 在单元测试里，因为测试输入是固定的，你可以知道调用 <code>Reverse</code> 函数（Reverse 函数用来将传入的字符串进行翻转）后每个输入字符串得到的反转字符串应该是什么，然后在单元测试的代码里判断 <code>Reverse</code> 的执行结果是否和预期相符。但是使用 Fuzzing 时，我们没办法预期输出结果是什么。所以 Fuzzing 模糊测试和 Go 已有的单元测试以及性能测试框架是互为补充的，并不是替代关系。</p>
<p>接下来就看一下如何编写模糊测试。</p>
<p>在 <code>internal/miniblog/store</code> 目录下，新增 <code>helper_test.go</code> 文件，内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">package store

import (
    &quot;testing&quot;

    &quot;github.com&#x2F;stretchr&#x2F;testify&#x2F;assert&quot;
)

&#x2F;&#x2F; FuzzDefaultLimit 模糊测试用例.
func FuzzDefaultLimit(f *testing.F) &#123;
    testcases :&#x3D; []int&#123;0, 1, 2&#125;
    for _, tc :&#x3D; range testcases &#123;
        f.Add(tc)
    &#125;

    f.Fuzz(func(t *testing.T, orig int) &#123;
        limit :&#x3D; defaultLimit(orig)
        if orig &#x3D;&#x3D; 0 &#123;
            assert.Equal(t, defaultLimitValue, limit)
        &#125; else &#123;
            assert.Equal(t, orig, limit)
        &#125;
    &#125;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>FuzzDefaultLimit</code> 就是我们编写的模糊测试用例。</p>
<p><strong>代码说明：</strong></p>
<ul>
<li><p>模糊测试用例函数名必须以 <code>Fuzz</code> 开头，例如：如 <code>FuzzXxx</code> 或 <code>Fuzz_xxx</code>。函数接收一个 <code>*testing.F</code> 类型的参数, 无返回值；</p>
</li>
<li><p><code>f.Add(tc)</code> 告诉了 Fuzzing 引擎我们需要的数据类型和顺序；</p>
</li>
<li><p><code>f.Fuzz</code> 函数传入一个用于模糊测试的函数，该函数的首个入参必须是 <code>*testing.T</code>，后面的参数就是你希望 Go 的 Fuzzing 引擎帮你生成的随机数据类型。并且要注意，这个函数不能有返回值。</p>
</li>
</ul>
<p><strong>运行模糊测试用例：</strong></p>
<p>我们可以通过以下 2 种方式来运行模糊测试用例。</p>
<ul>
<li>只使用种子语料库，而不生成随机测试数据。运行命令如下：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$ go test -v -run&#x3D;FuzzDefaultLimit 
&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit
&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#0
&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#1
&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#2
--- PASS: FuzzDefaultLimit (0.00s)
    --- PASS: FuzzDefaultLimit&#x2F;seed#0 (0.00s)
    --- PASS: FuzzDefaultLimit&#x2F;seed#1 (0.00s)
    --- PASS: FuzzDefaultLimit&#x2F;seed#2 (0.00s)
PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;internal&#x2F;miniblog&#x2F;store        0.020s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方式只会使用种子语料库，而不会生成随机测试数据。通过这种方式可以用来验证种子语料库的测试数据是否可以测试通过。</p>
<blockquote>
<p>所谓语料库（seed corpus），就是一组用户提供的语料，Fuzzing 引擎将会使用这个语料来生成随机数据。其实就是一个样板，有了样板，Fuzzing 引擎就知道要生成什么类型的随机数据了。</p>
</blockquote>
<ul>
<li>基于种子语料库生成随机测试数据。运行命令如下：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$ go test -fuzz&#x3D;Fuzz
fuzz: elapsed: 0s, gathering baseline coverage: 0&#x2F;4 completed
fuzz: elapsed: 0s, gathering baseline coverage: 4&#x2F;4 completed, now fuzzing with 16 workers
fuzz: elapsed: 3s, execs: 52911 (17633&#x2F;sec), new interesting: 1 (total: 5)

...

PASS
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;internal&#x2F;miniblog&#x2F;store        143.123s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，执行模糊测试的时间是由开发者自己定的，如果你的代码非常强健，不管怎么更换随机数据，测试都能通过，那么 Fuzzing 将一直执行下去。除非找到了 error，或者你手动用 <code>Ctrl^C</code> 来停掉。</p>
<p><code>go test</code> 跟模糊测试相关的参数还有以下 3 个：</p>
<ul>
<li><p><code>-fuzztime</code>: 执行的模糊目标在退出的时候要执行的总时间或者迭代次数，默认是永不结束；</p>
</li>
<li><p><code>-fuzzminimizetime</code>: 模糊目标在每次最少尝试时要执行的时间或者迭代次数，默认是 60 秒。你可以禁用最小化尝试，只需把这个参数设置为 0；</p>
</li>
<li><p><code>-parallel</code>: 同时执行的模糊化数量，默认是 <code>$GOMAXPROCS</code>。当前进行模糊化测试时设置 <code>-cpu</code>无效果。</p>
</li>
</ul>
<h2 id="测试工具介绍"><a href="#测试工具介绍" class="headerlink" title="测试工具介绍"></a>测试工具介绍</h2><p>在编写测试用例的时候，我们还可以借助众多的优秀工具&#x2F;包，来协助我们快速编写高质量的测试用例。这些工具，按功能可以分为测试框架和 Mock 工具两类。测试框架，能够协助我们编写高质量的测试用例。Mock 工具，可以使我们在编写测试用例时，摆脱一些限制，使代码变得可测，提高代码的可测性。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><ul>
<li><a href="%22https://github.com/stretchr/testify%22">Testify 框架</a>：Testify是 Go test 的预判工具，它能让你的测试代码变得更优雅和高效，测试结果也变得更详细。<code>miniblog</code> 项目中，<code>testify</code> 的使用案例见 <a href="%22https://github.com/marmotedu/miniblog/blob/feature/s23/internal/miniblog/store/helper_test.go%22">helper_test.go</a>、<a href="%22https://github.com/marmotedu/miniblog/blob/feature/s23/internal/miniblog/biz/user/user_test.go%22">user_test.go</a>、<a href="%22https://github.com/marmotedu/miniblog/blob/feature/s23/pkg/util/id/id_test.go%22">id_test.go</a> 文件；</li>
<li><a href="%22https://github.com/smartystreets/goconvey%22">GoConvey 框架</a>：GoConvey 是一款针对 Go 语言的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。</li>
</ul>
<h3 id="Mock-工具"><a href="#Mock-工具" class="headerlink" title="Mock 工具"></a>Mock 工具</h3><p>Mock 工具用的最多的是 Go 官方提供的 Mock 框架 <a href="%22https://github.com/golang/mock%22">GoMock</a>。关于 GoMock 的使用方法，可参考：<a href="%22https://geektutu.com/post/quick-gomock.html%22">Go Mock (gomock)简明教程</a>。</p>
<p>此外，还有一些其他的优秀 Mock 工具可供我们使用。这些 Mock 工具分别用在不同的 Mock 场景中，常用的 Mock 工具如下：</p>
<ul>
<li><p><a href="%22https://github.com/DATA-DOG/go-sqlmock%22">sqlmock</a>：可以用来模拟数据库连接。数据库是项目中比较常见的依赖，在遇到数据库依赖时都可以用它。</p>
</li>
<li><p><a href="%22https://github.com/jarcoal/httpmock%22">httpmock</a>：可以用来 Mock HTTP 请求。</p>
</li>
<li><p><a href="%22https://github.com/bouk/monkey%22">bouk&#x2F;monkey</a>：猴子补丁，能够通过替换函数指针的方式来修改任意函数的实现。如果 GoMock、sqlmock 和 httpmock 这几种方法都不能满足我们的需求，我们可以尝试用猴子补丁的方式来 Mock 依赖。可以这么说，猴子补丁提供了单元测试 Mock 依赖的最终解决方案。</p>
</li>
</ul>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>我们写单元测试的时候应该想得很全面，能够覆盖到所有的测试用例，但有时也会漏过一些 case，Go 提供了 <code>cover</code> 工具来统计测试覆盖率。</p>
<p>可以通过以下 2 个命令来进行覆盖率测试：</p>
<ul>
<li><p><code>go test -coverprofile=cover.out</code>：在测试文件目录下运行测试并统计测试覆盖率；</p>
</li>
<li><p><code>go tool cover -func=cover.out</code>：分析覆盖率文件，可以看出哪些函数没有测试，哪些函数内部的分支没有测试完全，<code>cover</code> 工具会通过执行代码的行数与总行数的比例表示出覆盖率。</p>
</li>
</ul>
<p><strong>测试覆盖率</strong></p>
<p>执行以下命令进行测试：</p>
<pre class="line-numbers language-none"><code class="language-none">$ cd miniblog&#x2F;pkg&#x2F;util&#x2F;id
$ go test -coverprofile&#x3D;cover.out
PASS
coverage: 100.0% of statements
ok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s
$ go tool cover -func&#x3D;cover.out
github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id&#x2F;id.go:15:        GenShortID        100.0%
total:                                                        (statements)        100.0%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 <code>TestGenShortID</code> 函数测试覆盖率为 <code>100%</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节课简单介绍了如何用 testing 包，编写单元测试用例和性能测试用例。在实际的开发中，要养成编写单元测试用例的好习惯，在项目上线前，最好对一些业务逻辑比较复杂的函数做一些性能测试，提前发现性能问题。</p>
<p>至于怎么去分析性能，比如查找耗时最久的函数等，我链接了郝林大神专业的分析方法 <a href="%22https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md%22">go tool pprof</a>。更深的分析技巧需要你在实际开发中自己去探索。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>01 | IAM项目安装</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-01-iam-project-install.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<h2 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h2><p><strong>可以执行脚本完成 <code>IAM</code> 系统的安装 ：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 导出 going 用户密码</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">LINUX_PASSWORD</span><span class="token operator">=</span><span class="token string">'112233'</span>
<span class="token function">wget</span> https://github.com/marmotedu/iam/releases/download/v1.6.2/iam.tar.gz <span class="token operator">|</span> <span class="token function">tar</span> <span class="token parameter variable">-xz</span> <span class="token parameter variable">-C</span> /tmp/ <span class="token parameter variable">-f</span> iam.tar.gz
<span class="token builtin class-name">cd</span> /tmp/iam/ <span class="token operator">&amp;&amp;</span> ./scripts/install/install.sh iam:install::install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="下载项目代码"><a href="#下载项目代码" class="headerlink" title="下载项目代码"></a>下载项目代码</h2><p><strong>iam源码下载命令如下：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$WORKSPACE</span>/golang/src/github.com/marmotedu
<span class="token builtin class-name">cd</span> <span class="token variable">$WORKSPACE</span>/golang/src/github.com/marmotedu
<span class="token function">git</span> clone <span class="token parameter variable">-b</span> v1.6.2 <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span> https://github.com/marmotedu/iam.git
go work use ./iam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<span id="more"></span>

<p>说明： 其中 <code>marmotedu</code> 和 <code>marmotedu/iam</code> 目录存放了项目代码<br>追加目录到环境变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">tee</span> <span class="token parameter variable">-a</span> <span class="token environment constant">$HOME</span>/.bashrc <span class="token operator">&lt;&lt;</span><span class="token string">'EOF'
# Alias for quick access
export GOSRC="$WORKSPACE/golang/src/"
export IAM_ROOT="$GOSRC/github.com/marmotedu/iam"
alias mm="cd $GOSRC/github.com/marmotedu"
alias i="cd $GOSRC/github.com/marmotedu/iam"
EOF</span>

<span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>安装配置<code>IAM</code>系统之前，需要执行以下命令导出<code>going</code>用户的密码，这里假设密码是<code>112233</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LINUX_PASSWORD</span><span class="token operator">=</span><span class="token string">'112233'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在项目开发中，像密码，密钥Key这类敏感信息 ， 一般不会直接硬编码在代码中，而是通过环境变量的方式来使用。如果应用的噢诶之文件存放在一个安全的网络环境中，并且有访问授权流程，比较阿全，该文件可以用于配置密码等敏感信息。</p>
<h2 id="安装和配置-数据库"><a href="#安装和配置-数据库" class="headerlink" title="安装和配置 数据库"></a>安装和配置 数据库</h2><p><strong>因为<code>IAM</code>系统用到了<code>MariaDB</code>,<code>Redis</code>,<code>MongoDB</code>数据库来存储数据，而<code>IAM</code>服务在启动时会先舱室连接这些数据库 ， 所以为了避免启动时连接数据库失败 ，需要先安装这些数据库</strong></p>
<h3 id="配置-scripts-install-environment-sh"><a href="#配置-scripts-install-environment-sh" class="headerlink" title="配置 scripts/install/environment.sh"></a>配置 <code>scripts/install/environment.sh</code></h3><p><strong>因为<code>IAM</code>组件的安装配置都是通过环境变量文件 <code>scripts/install/environment.sh</code> 进行配置的，所以先配置好， 文件中的环境变量都有注释，你可以根据注释来配置。 你可以使用<code>environment.sh</code>中配置的默认值 ， 以提高安装效率</strong></p>
<p><code>scripts/install/environment.sh</code> 文件中<code>MariaDB</code>用户名的配置语句如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">readonly</span> <span class="token assign-left variable">MARIADB_USERNAME</span><span class="token operator">=</span><span class="token variable">$&#123;MARIADB_USERNAME<span class="token operator">:-</span>iam&#125;</span>
<span class="token comment"># readonly 说明 MARIADB_USERNAME 只能被赋值一次。</span>
<span class="token comment"># $&#123;MARIADB_USERNAME:-iam&#125; 使用了Bash shell的变量扩展语法，其语法格式为：</span>
<span class="token comment"># $&#123;待测变量:-默认值&#125; ， 该语法标识：</span>
<span class="token comment"># 如果待测变量不存在或其值为空 则返回默认值，否则返回待测变量的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="安装和配置-MariaDB"><a href="#安装和配置-MariaDB" class="headerlink" title="安装和配置 MariaDB"></a>安装和配置 <code>MariaDB</code></h3><p><strong><code>IAM</code> 会把<code>REST</code>资源的定义信息存储在关系型数据库中 ， 这里选择 <code>MariaDB</code></strong></p>
<p><strong>为什么是 <code>MariaDB</code> 而不是  <code>MySQL</code> 。</strong></p>
<ol>
<li><code>MariaDB</code>是发展最快的 <code>MySQL</code> 分支，相比<code>MySQL</code>加入了许多新特性</li>
<li><pre><code>完全兼容`MySQL` ， 包括 `API` 和 `命令行`
</code></pre>
</li>
<li><code>MariaDB</code>是开源的 ， 迭代速度很快</li>
</ol>
<h4 id="安装和配置-MariaDB-1"><a href="#安装和配置-MariaDB-1" class="headerlink" title="安装和配置 MariaDB"></a>安装和配置 MariaDB</h4><p>root密码为 <code>LINUX_PASSWORD</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
./scripts/install/mariadb.sh iam::mariadb::install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="测试-MariaDB-是否安装成功"><a href="#测试-MariaDB-是否安装成功" class="headerlink" title="测试 MariaDB 是否安装成功"></a>测试 MariaDB 是否安装成功</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-h127.0.0.1</span> <span class="token parameter variable">-uroot</span> -p<span class="token string">'112233'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="安装配置-Redis"><a href="#安装配置-Redis" class="headerlink" title="安装配置 Redis"></a>安装配置 Redis</h3><h4 id="安装和配置-Redis"><a href="#安装和配置-Redis" class="headerlink" title="安装和配置 Redis"></a>安装和配置 Redis</h4><p>redis 密码为 <code>LINUX_PASSWORD</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
./scripts/install/redis.sh iam::redis::install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong><code>iam::redis::install</code>函数对<code>Redis</code>做了一些配置 ， 例如： 修改<code>Redis</code>使其以守护进程的方式运行，修改<code>Redis</code>密码等</strong></p>
<h4 id="测试-Redis-是否安装成功"><a href="#测试-Redis-是否安装成功" class="headerlink" title="测试 Redis 是否安装成功"></a>测试 Redis 是否安装成功</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p</span> <span class="token number">6279</span> <span class="token parameter variable">-a</span> <span class="token string">'112233'</span> <span class="token comment"># -h 主机， -a 密码， -p 端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h3 id="安装配置-MongoDB"><a href="#安装配置-MongoDB" class="headerlink" title="安装配置 MongoDB"></a>安装配置 MongoDB</h3><p>可以通过<code>docker</code>安装</p>
<h4 id="配置-MongoDB-yum源-，-并安装-MongoDB"><a href="#配置-MongoDB-yum源-，-并安装-MongoDB" class="headerlink" title="配置 MongoDB yum源 ， 并安装 MongoDB"></a>配置 MongoDB yum源 ， 并安装 MongoDB</h4><p>使用 <code>mango 5.0</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/mongodb-org-5.0.repo<span class="token operator">&lt;&lt;</span><span class="token string">'EOF'</span><span class="token punctuation">[</span>mongodb-org-5.0<span class="token punctuation">]</span>name<span class="token operator">=</span>MongoDB <span class="token assign-left variable">Repositorybaseurl</span><span class="token operator">=</span>https://repo.mongodb.org/yum/redhat/<span class="token variable">$releasever</span>/mongodb-org/5.0/x86_64/gpgcheck<span class="token operator">=</span>1enabled<span class="token operator">=</span>1gpgkey<span class="token operator">=</span>https://www.mongodb.org/static/pgp/server-5.0.ascEOF $ <span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> mongodb-org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h4 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h4><p><strong>在安装过程中， <code>SELinux</code> 可能会组织 <code>MongoDB</code>访问 <code>/sys/fs/cgroup</code></strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> setenforce <span class="token number">0</span>

<span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/^SELINUX=.*$/SELINUX=disabled/'</span> /etc/selinux/config <span class="token comment"># 永久关闭 SELINUX</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="开启外网访问权限和登录验证"><a href="#开启外网访问权限和登录验证" class="headerlink" title="开启外网访问权限和登录验证"></a>开启外网访问权限和登录验证</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'/bindIp/&#123;s/127.0.0.1/0.0.0.0/&#125;'</span> /etc/mongod.conf
 <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'/^#security/a\security:\n authorization: enabled'</span> /etc/mongod.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="启动-MongoDB"><a href="#启动-MongoDB" class="headerlink" title="启动 MongoDB"></a>启动 MongoDB</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动 ， 开机自启 ， 状态</span>
<span class="token function">sudo</span> systemclt start mongod
<span class="token function">sudo</span> systemclt <span class="token builtin class-name">enable</span> mongod
<span class="token function">sudo</span> systemclt status mongod

<span class="token comment"># 登录 MongoDB</span>
mongosh <span class="token parameter variable">--quiet</span> <span class="token string">"mongodb://127.0.0.1:27017"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="创建-MongoDB-账号"><a href="#创建-MongoDB-账号" class="headerlink" title="创建 MongoDB 账号"></a>创建 MongoDB 账号</h4><p><strong>安装完 <code>MongoDB</code> 后 ， 默认是没有用户的</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongosh <span class="token parameter variable">--quiet</span> <span class="token string">"mongodb://127.0.0.1:27017"</span>
use admin
db.createUser<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>user:<span class="token string">"root"</span>,pwd:<span class="token string">"112233"</span>,roles:<span class="token punctuation">[</span><span class="token string">"root"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
db.auth<span class="token punctuation">(</span><span class="token string">"root"</span>,<span class="token string">"112233"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>如果想删除用户 ， 可以使用 <code>db.dropUser(&quot;用户名&quot;)</code>命令来删除</strong><br><strong><code>db.createUser</code> 用于创建一个<code>MongoDB</code>用户 ， 涉及三个参数 ：</strong></p>
<ol>
<li><code>user</code>: 用户名</li>
<li><code>pwd</code>: 用户密码</li>
<li><code>roles</code>: 用于设置用户的权限, 比如读，写等</li>
</ol>
<p>创建<code>iam</code>普通用户</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 用管理员账户连接 `MongoDB`</span>
mongosh <span class="token parameter variable">--quiet</span> mongodb://root:<span class="token string">'112233'</span>@127.0.0.1:27017/iam_analytics?authSource<span class="token operator">=</span>admin
db.createUser<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>user:<span class="token string">"iam"</span>,pwd:<span class="token string">"112233"</span>,roles:<span class="token punctuation">[</span><span class="token string">"dbOwner"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
db.auth<span class="token punctuation">(</span><span class="token string">"iam"</span>,<span class="token string">"112233"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建完 <code>iam</code> 普通用户后，可以执行以下命令 ， 通过 <code>iam</code> 用户登录 <code>MongoDB</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongosh <span class="token parameter variable">--quiet</span> mongodb://iam:<span class="token string">'112233'</span>@127.0.0.1:27017/iam_analytics?authSource<span class="token operator">=</span>iam_analytics
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="安装和配置-IAM-系统"><a href="#安装和配置-IAM-系统" class="headerlink" title="安装和配置 IAM 系统"></a>安装和配置 IAM 系统</h2><p><strong>需要安装和配置 <code>iam-apiserver</code> ,<code>iamctl</code>, <code>iam-authz-server</code>, <code>iam-pump</code>, <code>iam-watcher</code>, <code>man page</code></strong></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>再开始安装之前需要准备工作，分为以下4步：</strong></p>
<ol>
<li>初始化<code>MongoDB</code>数据库 , 创建 <code>iam</code> 数据库</li>
<li>创建需要的目录</li>
<li>创建<code>CA</code>根证书和密钥</li>
<li>配置 <code>hosts</code></li>
</ol>
<h4 id="初始化-MariaDB数据库"><a href="#初始化-MariaDB数据库" class="headerlink" title="初始化 MariaDB数据库"></a>初始化 MariaDB数据库</h4><p><strong>需要再<code>MariaDB</code>数据库中创建<code>IAM</code>系统需要的数据库 表 和存储过程</strong><br><em><strong>创建<code>SQL</code>语句保存在<code>configs/iam.sql</code>文件中，具体创建步骤如下：</strong></em></p>
<ol>
<li><p>登录数据库并创建<code>iam</code>用户:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
mysql <span class="token parameter variable">-h127.0.0.1</span> <span class="token parameter variable">-P3306</span> <span class="token parameter variable">-uroot</span> -p<span class="token string">'112233'</span>
grant all on iam.* TO iam@127.0.0.1 identified by <span class="token string">'112233'</span><span class="token punctuation">;</span>
flush privileges<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用<code>iam</code>用户登录<code>MariaDB</code>，执行<code>configs/iam.sql</code>文件。从而创建<code>iam</code>数据库:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-h127.0.0.1</span> <span class="token parameter variable">-P3306</span> <span class="token parameter variable">-uiam</span> -p<span class="token string">'112233'</span>
<span class="token builtin class-name">source</span> configs/iam.sql<span class="token punctuation">;</span>
show databases<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>上面的命令除了创建<code>iam</code>数据库之外 ， 也会在<code>iam</code>数据库中创建以下资源：</strong></p>
</li>
</ol>
<blockquote>
<p><em><strong><code>表：</code></strong></em></p>
</blockquote>
<p><code>user</code>是用户表，用来存放用户信息；</p>
<p><code>secret</code>是密钥表，用来存放密钥信息；</p>
<p><code>policy</code>是策略表，用来存放策略信息；</p>
<p><code>policy_audit</code>是授权策略历史表，被删除的授权策略会被转存到该表</p>
<blockquote>
<p><em><strong><code>admin用户：</code></strong></em></p>
</blockquote>
<p>在<code>user</code>表中，我们需要创建一个管理员用户，用户名是<code>admin</code>，初始密码是 <code>Admin@2021</code></p>
<blockquote>
<p><em><strong><code>存储过程：</code></strong></em></p>
</blockquote>
<p>删除用户时会自动删除该用户所属的密钥和策略信息。</p>
<h4 id="创建需要的目录"><a href="#创建需要的目录" class="headerlink" title="创建需要的目录"></a>创建需要的目录</h4><p>将配置，二进制文件和数据文件存放到指定的目录。需要先创建好这些目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token comment"># 加载环境文件中的环境配置</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token comment"># 创建 Systemd WorkingDirectory 目录</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$&#123;IAM_DATA_DIR&#125;</span>/<span class="token punctuation">&#123;</span>iam-apiserver,iam-authz-server,iam-pump,iam-watcher<span class="token punctuation">&#125;</span>
<span class="token comment"># 创建 IAM 系统安装目录</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$&#123;IAM_INSTALL_DIR&#125;</span>/bin
<span class="token comment"># 创建 IAM 系统配置文件存放目录</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert
<span class="token comment"># 创建 IAM 日志文件存放目录</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$&#123;IAM_LOG_DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em><strong><code>注意</code>：执行<code>source scripts/install/environment.sh</code>时，如果遇到<code>bash: XXXXXX: readonly variable</code>这类保存，说明变量已经被加载到当前<code>Shell</code>中,可以忽略这类报错</strong></em></p>
<h4 id="创建-CA-根证书和密钥"><a href="#创建-CA-根证书和密钥" class="headerlink" title="创建 CA 根证书和密钥"></a>创建 CA 根证书和密钥</h4><p><strong><code>IAM</code>系统各组件需要使用<code>x509</code>证书对通信进行加密和认证。需要先创建<code>CA 证书</code></strong></p>
<p><strong><code>CA 根证书</code>是所有组件共享的，只需要创建一个<code>CA 证书</code>， 后续创建的所有证书都由它<code>签名</code></strong></p>
<p><strong>我们可以使用<code>CloudFlare</code>的<code>PKI</code>工具集<code>cfssl</code>来创建所有的证书：</strong></p>
<ol>
<li>安装<code>cfssl</code>工具集，<code>cfssl</code> , <code>cfssljson</code> , <code>cfssl-certinfo</code></li>
</ol>
<ul>
<li><code>cfssl</code>: 证书签发工具</li>
<li><code>cfssljson</code>: 将<code>cfssl</code>生成的证书（<code>json</code>格式）转变为文件承载式证书</li>
<li><code>cfssl-certinfo</code>: 可以显示<code>CSR</code>或者证书文件的详细信息<br>可以通过以下命令安装<code>cfssl</code>工具集：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
./scripts/install/install.sh iam::install::install_cfssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<ol start="2">
<li>创建配置文件<br><code>CA</code>配置文件用来配置根证书的使用场景（profile） 和具体参数（usage ， 包括过期时间，服务端认证，客户端认证，加密等），也可以在签名其他证书时指定特定场景：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token function">tee</span> ca-config.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF
&#123;
    "signing": &#123;
        "default": &#123;
            "expiry": "87600h"
        &#125;,
        "profiles": &#123;
            "iam": &#123;
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            &#125;
        &#125;
    &#125;
&#125;
EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>在上面的<code>JSON</code>配置中，一些字段的解释如下：</p>
<ul>
<li><code>profiles</code>：指定了不同角色的配置信息；可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile。</li>
<li><code>profiles.iam</code>：为服务使用该配置文件颁发证书的配置模块；</li>
<li><code>key encipherment</code>：密钥加密</li>
<li><code>signing</code>：签署，表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA&#x3D;TRUE；</li>
<li><code>server auth</code>：服务器身份验证；表示 client 可以用该 CA 对 server 提供的证书进行验证；</li>
<li><code>client auth</code>：客户端身份验证；表示 server 可以用该 CA 对 client 提供的证书进行验证；</li>
<li><code>expiry</code>：设置为<code>87600h</code>，表示证书有效期设置为100年</li>
</ul>
<ol start="3">
<li>创建证书签名请求文件<br>我们可以通过使用以下命令来创建生成<code>CA</code>证书签名请求(<code>CSR</code>)的<code>JSON</code>配置文件：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token function">tee</span> ca-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF
&#123;
    "CN": "iam-ca",
    "key": &#123;
        "algo": "rsa",
        "size": 2048
    &#125;,
     "names": [
        &#123;
            "C": "CN",
            "ST": "BeiJing",
            "L": "BeiJing",
            "OU": "iam",
        &#125;
    ],
    "ca": &#123;
      "expiry":"876000h"
    &#125;,
 
&#125;
EOF</span>

  <span class="token comment">#  "hosts": [</span>
  <span class="token comment">#       "127.0.0.1",</span>
  <span class="token comment">#       "192.168.2.81"</span>
  <span class="token comment">#   ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在上面的<code>JSON</code>配置中，一些字段的解释如下：</li>
</ol>
<ul>
<li><code>hosts</code>：包含的授权范围，不在此范围的的节点或者服务使用此证书就会报证书不匹配错误，证书如果不包含可能会出现无法连接的情况，此处需要改为本机的IP地址；</li>
<li><code>Key</code>: 指定使用的加密算法，一般使用rsa非对称加密算法<code>algo:rsa；size:2048</code></li>
<li><code>C</code>：对应英文为 <code>Country</code>， 表示国家</li>
<li><code>ST</code>：对应英文为 <code>State</code>， 表示省份</li>
<li><code>L</code>：对应英文为 <code>Locality</code>(L)或 <code>City</code>， 表示城市</li>
<li><code>CN</code>：Common Name，<code>iam-apiserver</code> 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；CN是域名，也就是你现在使用什么域名就写什么域名</li>
<li><code>O</code>：Organization，<code>iam-apiserver</code> 从证书中提取该字段作为请求用户所属的组 (Group)；</li>
<li><code>OU</code>：对应英文为 Organization Unit(或者 Company Division)，部门&#x2F;单位</li>
</ul>
<p><em><strong>除此之外还有两点需要注意：</strong></em></p>
<ul>
<li>不同证书<code>CSR</code>文件的 <code>CN</code>,<code>C</code>,<code>ST</code>,<code>L</code>,<code>O</code>,<code>OU</code> 组合必须不同 ，否则可能出现<code>PEER’S CERTIFICATE HAS AN INVALID SIGNATURE</code>错误</li>
<li>后续创建证书的<code>CSR</code>文件时，保证 <code>CN</code> ，<code>OU</code> 都不相同（<code>C</code>,<code>ST</code>,<code>L</code>,<code>O</code>相同），以达到区分的目的</li>
</ul>
<ol start="4">
<li>创建<code>CA</code>证书和私钥<br>可以通过<code>cfssl gencert</code>命令来创建<code>CA</code>证书和私钥：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
cfssl gencert <span class="token parameter variable">-initca</span> ca-cer.json <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> ca
<span class="token function">ls</span> ca* <span class="token comment"># ca-config.json ca.csr ca-csr.json ca-key.pem ca.pem</span>
<span class="token comment"># 将证书文件拷贝到指定文件夹下(分发证书)，方便各组件引用</span>
<span class="token function">sudo</span> <span class="token function">mv</span> ca* <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
上述命令会创建运行<code>CA</code>所必须的文件 <code>ca-key.pem</code>(私钥) 和 <code>ca.pem</code>(证书)，还会生成 <code>ca.csr</code>(证书签名请求)，用于交叉签名或重新签名。</li>
</ol>
<p>创建完后，我们可以通过 <code>cfssl certinfo</code>命令查看<code>cert</code>和<code>csr</code>信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 cert (证书信息)</span>
cfssl certinfo <span class="token parameter variable">-cert</span> <span class="token variable">$&#123;IMA_CONFIG_DIR&#125;</span>/cert/ca.pem
<span class="token comment"># 查看 csr (证书签名请求)信息</span>
cfssl certinfo <span class="token parameter variable">-c</span> <span class="token variable">$&#123;IMA_CONFIG_DIR&#125;</span>/cert/ca.csr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="配置-hosts"><a href="#配置-hosts" class="headerlink" title="配置 hosts"></a>配置 hosts</h4><p><code>IAM</code>通过域名访问<code>API</code>接口，因为这些域名没有注册过，还不能在互联网上被解析出来，<br>所以需要配置<code>hosts</code>，我们通过<code>hosts</code>来解析，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> /etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF
127.0.0.1 iam.api.marmotedu.com
127.0.0.1 iam.authz.marmotedu.com
EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="安装和配置-iam-apiserver"><a href="#安装和配置-iam-apiserver" class="headerlink" title="安装和配置 iam-apiserver"></a>安装和配置 iam-apiserver</h3><p>完成准备工作后，就可以安装<code>IAM</code>系统的各个组件了</p>
<h4 id="创建-iam-server-证书和私钥"><a href="#创建-iam-server-证书和私钥" class="headerlink" title="创建 iam-server 证书和私钥"></a>创建 iam-server 证书和私钥</h4><p>其他服务为了安全都是通过<code>HTTPS</code>协议访问<code>iam-apiserver</code>，所以要先创建<code>iam-apiserver</code>的证书和私钥：</p>
<ol>
<li><p>创建证书签名请求</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token function">tee</span> iam-apiserver-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF
&#123;
    "CN": "iam-apiserver",
    "key": &#123;
        "algo": "rsa",
        "size": 2048
    &#125;,
     "names": [
        &#123;
            "C": "CN",
            "ST": "BeiJing",
            "L": "BeiJing",
            "O": "marmotedu",
            "OU": "iam-apiserver",
        &#125;
    ],
   "hosts": [
        "127.0.0.1",
        "localhost",
        "iam.api.marmotedu.com"
    ],
&#125;
EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述<code>JSON</code>配置中的<code>hosts</code>字段用来指定授权使用该证书的<code>IP</code>和<code>域名</code>列表，上面的<code>hosts</code>列出了<code>iam-apiserver</code>服务的<code>IP</code>和<code>域名</code></p>
</li>
<li><p>生成证书和私钥</p>
</li>
</ol>
<p>通过<code>cfssl gencert</code>来生成证书和私钥</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cfssl gencert <span class="token parameter variable">-ca</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca.pem <span class="token punctuation">\</span>
              -ca-key<span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-key.pem <span class="token punctuation">\</span>
              <span class="token parameter variable">-config</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-config.json <span class="token punctuation">\</span>
              <span class="token parameter variable">-profile</span><span class="token operator">=</span>iam iam-apiserver-csr.json <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> iam-apiserver
<span class="token comment"># 将生成的证书和私钥文件拷贝到配置文件目录</span>
<span class="token function">sudo</span> <span class="token function">mv</span> iam-apiserver*pem <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="安装并运行-iam-apiserver"><a href="#安装并运行-iam-apiserver" class="headerlink" title="安装并运行 iam-apiserver"></a>安装并运行 iam-apiserver</h4><p><code>iam-apiserver</code>是<code>IAM</code>系统的核心组件，需要第一个安装。</p>
<ol>
<li>安装<code>iam-apiserver</code>可执行二进制文件<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span>iam-apiserver
<span class="token function">sudo</span> <span class="token function">cp</span> _output/platforms/linux/amd64/iam-apiserver <span class="token variable">$&#123;IAM_INSTALL_DIR&#125;</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>生成并安装<code>iam-apiserver</code>的配置文件<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh configs/iam-apiserver.yaml <span class="token operator">></span> iam-apiserver.yaml
<span class="token function">sudo</span> <span class="token function">mv</span> iam-apiserver.yaml <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>创建并安装<code>iam-apiserver</code> <code>systemd unit</code>文件<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh init/iam-apiserver.service <span class="token operator">></span> iam-apiserver.service
<span class="token function">sudo</span> <span class="token function">mv</span> iam-apiserver.service /etc/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>启动<code>iam-apiserver</code>服务<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> iam-apiserver
<span class="token function">sudo</span> systemctl restart iam-apiserver
<span class="token function">sudo</span> systemctl status iam-apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="测试-iam-apiserver-是否成功安装"><a href="#测试-iam-apiserver-是否成功安装" class="headerlink" title="测试 iam-apiserver 是否成功安装"></a>测试 iam-apiserver 是否成功安装</h4><p>测试<code>iam-apiserver</code>主要是测试<code>用户</code>，<code>密钥</code>，<code>授权策略</code>这3类<code>REST</code>资源的增删改查操作</p>
<p>首先，需要执行以下命令来获取访问<code>iam-apiserver</code>的<code>token</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> <span class="token parameter variable">-H</span> <span class="token string">'Content-Type: application/json'</span> <span class="token parameter variable">-d</span> <span class="token string">'&#123;"username":"admin","password":"Admin@2021"&#125;'</span> http://127.0.0.1:8080/login <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> .token<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下面的操作都会使用<code>curl</code>命令来发送<code>HTTP</code>请求，在请求时，需要通过 <code>-H &#39;Authori-zation: Bearer $token&#39; </code>指定认证头信息</p>
<p>为了操作方便，可以将获取到的<code>token</code>保存在<code>token</code>变量中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> token <span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> <span class="token parameter variable">-H</span> <span class="token string">'Content-Type: application/json'</span> <span class="token parameter variable">-d</span> <span class="token string">'&#123;"username":"admin","password":"Admin@2021"&#125;'</span> http://127.0.0.1:8080/login <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> .token<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接下来 ，通过以下3步来完成<code>iam-apiserver</code>的测试：</p>
<ol>
<li><p>用户的增删改查</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建用户</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -d<span class="token string">'&#123;"password":"User@2021","metadata":&#123;"name":"colin"&#125;,"nickname":"colin","email":"colin@foxmail.com","phone":"1812884xxxx"&#125;'</span> http://127.0.0.1:8080/v1/users

<span class="token comment"># 列出用户</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> <span class="token string">'http://127.0.0.1:8080/v1/users?offset=0&amp;limit=10'</span>

<span class="token comment"># 获取 colin 用户的详细信息</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/users/colin

<span class="token comment"># 修改 colin 用户</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPUT</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"nickname":"colin","email":"colin_modified@foxmail.com","phone":"1812884xxxx"&#125;'</span> http://127.0.0.1:8080/v1/users/colin

<span class="token comment"># 删除 colin 用户</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XDELETE</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/users/colin

<span class="token comment"># 批量删除用户</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XDELETE</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> <span class="token string">'http://127.0.0.1:8080/v1/users?name=colin&amp;name=mark&amp;name=john'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>密钥增删改查</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建 secret0 密钥</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"secret0"&#125;,"expires":0,"description":"admin secret"&#125;'</span> http://127.0.0.1:8080/v1/secrets

<span class="token comment"># 列出所有密钥</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/secrets

<span class="token comment"># 获取 secret0 密钥的详细信息</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/secrets/secret0

<span class="token comment"># 修改 secret0 密钥</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPUT</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"secret0"&#125;,"expires":0,"description":"admin secret(modified)"&#125;'</span> http://127.0.0.1:8080/v1/secrets/secret0

<span class="token comment"># 删除 secret0 密钥</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XDELETE</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/secrets/secret0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>这里需要注意，因为密钥属于重要资源，被删除会导致所有的访问请求失败。为了安全，密钥不支持批量删除。</p>
<ol start="3">
<li>授权策略增删改查<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建策略</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"policy0"&#125;,"policy":&#123;"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken>","users:maria","groups:admins"],"actions":["delete","&lt;create|update>"],"effect":"allow","resources":["resources:articles:&lt;.*>","resources:printer"],"conditions":&#123;"remoteIPAddress":&#123;"type":"CIDRCondition","options":&#123;"cidr":"192.168.0.1/16"&#125;&#125;&#125;&#125;&#125;'</span> http://127.0.0.1:8080/v1/policies

<span class="token comment"># 列出所有策略</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/policies

<span class="token comment"># 获取 policy0 策略的详细信息</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XGET</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/policies/policy0

<span class="token comment"># 修改 policy0 策略</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPUT</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"policy0"&#125;,"policy":&#123;"description":"One policy to rule them all(modified).","subjects":["users:&lt;peter|ken>","users:maria","groups:admins"],"actions":["delete","&lt;create|update>"],"effect":"allow","resources":["resources:articles:&lt;.*>","resources:printer"],"conditions":&#123;"remoteIPAddress":&#123;"type":"CIDRCondition","options":&#123;"cidr":"192.168.0.1/16"&#125;&#125;&#125;&#125;&#125;'</span> http://127.0.0.1:8080/v1/policies/policy0

<span class="token comment"># 删除 policy0 策略</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XDELETE</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> http://127.0.0.1:8080/v1/policies/policy0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="安装-iamctl"><a href="#安装-iamctl" class="headerlink" title="安装 iamctl"></a>安装 iamctl</h3><p>安装了 <code>IAM</code> 系统的 <code>iam-apiserver</code> 服务后,想要访问 <code>iam</code> 服务，我们还需要安装客户端工具 <code>iamctl</code>。具体来说，我们可以通过 3 步完成 <code>iamctl</code> 的安装和配置。</p>
<h4 id="创建-iamctl证书和私钥"><a href="#创建-iamctl证书和私钥" class="headerlink" title="创建 iamctl证书和私钥"></a>创建 iamctl证书和私钥</h4><p><code>iamctl</code> 使用 <code>HTTPS</code> 协议与 <code>iam-apiserver</code> 进行通信，<code>iam-apiserver</code> 对 <code>iamctl</code> 请求包含的证书进行认证和授权。<code>iamctl</code>还用于对 <code>IAM</code> 系统的访问和管理，所以这里创建具有最高权限的 <code>admin</code> 证书。</p>
<ol>
<li>创建<code>证书签名请求</code></li>
</ol>
<p>下面创建的该证书只会被 <code>iamctl</code> 当做 <code>client</code> 证书使用，所以 <code>hosts</code> 字段为空。创建命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">cat</span> <span class="token operator">></span> admin-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF
&#123;
  "CN": "admin",
  "key": &#123;
    "algo": "rsa",
    "size": 2048
  &#125;,
  "names": [
    &#123;
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "marmotedu",
      "OU": "iamctl"
    &#125;
  ],
  "hosts": []
&#125;
EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>生成<code>证书</code>和<code>私钥</code></li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cfssl gencert <span class="token parameter variable">-ca</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca.pem <span class="token punctuation">\</span>
  -ca-key<span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-key.pem <span class="token punctuation">\</span>
  <span class="token parameter variable">-config</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-config.json <span class="token punctuation">\</span>
  <span class="token parameter variable">-profile</span><span class="token operator">=</span>iam admin-csr.json <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> admin
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> $<span class="token punctuation">&#123;</span>CONFIG_USER_CLIENT_CERTIFICATE<span class="token punctuation">&#125;</span><span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> $<span class="token punctuation">&#123;</span>CONFIG_USER_CLIENT_KEY<span class="token punctuation">&#125;</span><span class="token variable">)</span></span> <span class="token comment"># 创建客户端证书存放的目录</span>
<span class="token function">mv</span> admin.pem <span class="token variable">$&#123;CONFIG_USER_CLIENT_CERTIFICATE&#125;</span> <span class="token comment"># 安装 TLS 的客户端证书</span>
<span class="token function">mv</span> admin-key.pem <span class="token variable">$&#123;CONFIG_USER_CLIENT_KEY&#125;</span> <span class="token comment"># 安装 TLS 的客户端私钥文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="安装-iamctl-1"><a href="#安装-iamctl-1" class="headerlink" title="安装 iamctl"></a>安装 iamctl</h4><p><code>iamctl</code> 是 <code>IAM</code> 系统的客户端工具，其安装位置和 <code>iam-apiserver</code>、<code>iam-authz-server</code>、<code>iam-pump</code>、<code>iam-watcher</code> 位置不同，为了能够在 <code>shell</code> 下直接运行 <code>iamctl</code> 命令，我们需要将 <code>iamctl</code> 安装到 <code>$HOME/bin</code> 下，同时将 <code>iamctl</code> 的配置存放到默认加载的 <code>$HOME/.iam</code> 目录下。具体来说，可以通过以下 2 步来完成。</p>
<ol>
<li>安装 <code>iamctl</code> 可执行程序</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span>iamctl
<span class="token function">cp</span> _output/platforms/linux/amd64/iamctl <span class="token environment constant">$HOME</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>生成并安装 <code>iamctl</code> 的配置文件（<code>iamctl.yaml</code>）</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh configs/iamctl.yaml <span class="token operator">></span> iamctl.yaml
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.iam
<span class="token function">mv</span> iamctl.yaml <span class="token environment constant">$HOME</span>/.iam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为 <code>iamctl</code> 是一个客户端工具，可能会在多台机器上运行。为了简化部署 <code>iamctl</code> 工具的复杂度，我们可以把 <code>iamctl.yaml</code> 配置文件中跟 <code>CA</code> 认证相关的 <code>CA</code> 文件内容用 <code>base64</code> 加密后，放置在 <code>iamctl.yaml</code> 配置文件中，这样我们就不需要再部署这些 <code>CA</code> 文件。具体的加密方法为：把 <code>iamctl.yaml</code> 文件中的配置项 <code>client-certificate</code>、<code>client-key</code>、<code>certificate-authority</code> 分别用如下配置项替换 <code>client-certificate-data</code>、<code>client-key-data</code>、<code>certificate-authority-data</code>。这些配置项的值可以通过对 <code>CA</code> 文件使用 <code>base64</code> 加密获得。假如 <code>certificate-authority</code> 值为 <code>/etc/iam/cert/ca.pem</code>，则 <code>certificate-authority-data</code> 的值为 <code>cat &quot;/etc/iam/cert/ca.pem&quot; | base64 | tr -d &#39;\r\n&#39;</code>，其他 <code>xxx-data</code> 变量的值类似。</p>
<h4 id="测试-iamctl-是否成功安装"><a href="#测试-iamctl-是否成功安装" class="headerlink" title="测试 iamctl 是否成功安装"></a>测试 iamctl 是否成功安装</h4><p>执行 <code>iamctl user list</code> 可以列出预创建的 <code>admin</code> 用户，如图2-3所示。</p>
<p><a href="https://github.com/marmotedu/iam/blob/master/docs/images/iamctl_user_list.png"><img src="https://github.com/marmotedu/iam/raw/master/docs/images/iamctl_user_list.png" alt="用户列表"></a></p>
<h3 id="安装和配置-iam-authz-server"><a href="#安装和配置-iam-authz-server" class="headerlink" title="安装和配置 iam-authz-server"></a>安装和配置 iam-authz-server</h3><p>接下来，我们需要安装另外一个核心组件：<code>iam-authz-server</code>，可以通过以下 3 步来安装。</p>
<h4 id="创建-iam-authz-server-证书和私钥"><a href="#创建-iam-authz-server-证书和私钥" class="headerlink" title="创建 iam-authz-server 证书和私钥"></a>创建 iam-authz-server 证书和私钥</h4><ol>
<li>创建证书签名请求</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">tee</span> iam-authz-server-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF
&#123;
  "CN": "iam-authz-server",
  "key": &#123;
    "algo": "rsa",
    "size": 2048
  &#125;,
  "names": [
    &#123;
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "marmotedu",
      "OU": "iam-authz-server"
    &#125;
  ],
  "hosts": [
    "127.0.0.1",
    "localhost",
    "iam.authz.marmotedu.com"
  ]
&#125;
EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>iam-authz-server-csr.json</code> 配置中的 <code>hosts</code> 字段指定授权使用该证书的 IP 和域名列表，上面的 <code>hosts</code> 列出了 <code>iam-authz-server</code> 服务的 <code>IP</code> 和<code>域名</code>。</p>
<ol start="2">
<li>生成证书和私钥</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cfssl gencert <span class="token parameter variable">-ca</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca.pem <span class="token punctuation">\</span>
  -ca-key<span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-key.pem <span class="token punctuation">\</span>
  <span class="token parameter variable">-config</span><span class="token operator">=</span><span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert/ca-config.json <span class="token punctuation">\</span>
  <span class="token parameter variable">-profile</span><span class="token operator">=</span>iam iam-authz-server-csr.json <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> iam-authz-server
<span class="token function">sudo</span> <span class="token function">mv</span> iam-authz-server*pem <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span>/cert <span class="token comment"># 将生成的证书和私钥文件拷贝到配置文件目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="安装并运行-iam-authz-server"><a href="#安装并运行-iam-authz-server" class="headerlink" title="安装并运行 iam-authz-server"></a>安装并运行 iam-authz-server</h4><p>安装并运行 <code>iam-authz-server</code> 步骤和安装并运行 <code>iam-apiserver</code> 步骤基本一样，也需要 4 步。</p>
<ol>
<li>安装 <code>iam-authz-server</code> 可执行程序</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span>iam-authz-server
<span class="token function">sudo</span> <span class="token function">cp</span> _output/platforms/linux/amd64/iam-authz-server <span class="token variable">$&#123;IAM_INSTALL_DIR&#125;</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>生成并安装 <code>iam-authz-server</code> 的配置文件<code>iam-authz-server.yaml</code></li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh configs/iam-authz-server.yaml <span class="token operator">></span> iam-authz-server.yaml
<span class="token function">sudo</span> <span class="token function">mv</span> iam-authz-server.yaml <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="3">
<li>创建并安装 <code>iam-authz-server</code> <code>systemd unit</code> 文件</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh init/iam-authz-server.service <span class="token operator">></span> iam-authz-server.service
<span class="token function">sudo</span> <span class="token function">mv</span> iam-authz-server.service /etc/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="4">
<li>启动 <code>iam-authz-server</code> 服务</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> iam-authz-server
<span class="token function">sudo</span> systemctl restart iam-authz-server
systemctl status iam-authz-server <span class="token comment"># 查看 iam-authz-server 运行状态，如果输出中包含 active (running)字样说明 iam-authz-server 成功启动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="测试-iam-authz-server-是否成功安装"><a href="#测试-iam-authz-server-是否成功安装" class="headerlink" title="测试 iam-authz-server 是否成功安装"></a>测试 iam-authz-server 是否成功安装</h4><ol>
<li>重新登录系统，并获取访问令牌</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">token</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -d<span class="token string">'&#123;"username":"admin","password":"Admin@2021"&#125;'</span> http://127.0.0.1:8080/login <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> .token<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>创建授权策略</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">"Content-Type: application/json"</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"authztest"&#125;,"policy":&#123;"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken>","users:maria","groups:admins"],"actions":["delete","&lt;create|update>"],"effect":"allow","resources":["resources:articles:&lt;.*>","resources:printer"],"conditions":&#123;"remoteIPAddress":&#123;"type":"CIDRCondition","options":&#123;"cidr":"192.168.0.1/16"&#125;&#125;&#125;&#125;&#125;'</span> http://127.0.0.1:8080/v1/policies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>创建密钥，并从命令的输出中提取<code>secretID</code>和<code>secretKey</code>。</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">"Content-Type: application/json"</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$token</span>"</span> -d<span class="token string">'&#123;"metadata":&#123;"name":"authztest"&#125;,"expires":0,"description":"admin secret"&#125;'</span> http://127.0.0.1:8080/v1/secrets
<span class="token punctuation">&#123;</span><span class="token string">"metadata"</span>:<span class="token punctuation">&#123;</span><span class="token string">"id"</span>:23,<span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"authztest"</span>,<span class="token string">"createdAt"</span><span class="token builtin class-name">:</span><span class="token string">"2021-04-08T07:24:50.071671422+08:00"</span>,<span class="token string">"updatedAt"</span><span class="token builtin class-name">:</span><span class="token string">"2021-04-08T07:24:50.071671422+08:00"</span><span class="token punctuation">&#125;</span>,<span class="token string">"username"</span><span class="token builtin class-name">:</span><span class="token string">"admin"</span>,<span class="token string">"secretID"</span><span class="token builtin class-name">:</span><span class="token string">"ZuxvXNfG08BdEMqkTaP41L2DLArlE6Jpqoox"</span>,<span class="token string">"secretKey"</span><span class="token builtin class-name">:</span><span class="token string">"7Sfa5EfAPIwcTLGCfSvqLf0zZGCjF3l8"</span>,<span class="token string">"expires"</span>:0,<span class="token string">"description"</span><span class="token builtin class-name">:</span><span class="token string">"admin secret"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="4">
<li>生成访问 <code>iam-authz-server</code> 的 <code>token</code></li>
</ol>
<p><code>iamctl</code> 提供了 <code>jwt sigin</code> 命令，可以根据 <code>secretID</code> 和 <code>secretKey</code> 签发 <code>Token</code>，方便你使用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">authzAccessToken</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>iamctl jwt sign EqmMJgOFHyexjNE3q3LbqcfkUp0IQqf2n8F4 Iavj7aSOuekrmuOeoUl21MQ6hD46GzKG<span class="token variable">`</span></span> <span class="token comment"># iamctl jwt sign $secretID $secretKey</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果你开发过程中有些重复性的操作，为了方便使用，也可以将这些操作以 <code>iamctl</code> 子命令的方式集成到 <code>iamctl</code> 命令行中。</p>
<ol start="5">
<li>测试资源授权是否通过</li>
</ol>
<p>我们可以通过请求 <code>/v1/authz</code> API 接口来完成资源授权：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$authzAccessToken</span>"</span> -d<span class="token string">'&#123;"subject":"users:maria","action":"delete","resource":"resources:articles:ladon-introduction","context":&#123;"remoteIPAddress":"192.168.0.5"&#125;&#125;'</span> http://127.0.0.1:9090/v1/authz

<span class="token punctuation">&#123;</span><span class="token string">"allowed"</span>:true<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果授权通过会返回：<code>&#123;&quot;allowed&quot;:true&#125;</code></p>
<h3 id="安装和配置-iam-pump"><a href="#安装和配置-iam-pump" class="headerlink" title="安装和配置 iam-pump"></a>安装和配置 iam-pump</h3><p>安装 <code>iam-pump</code> 步骤和安装 <code>iam-apiserver</code>、<code>iam-authz-server</code> 步骤基本一样，可以通过 5 步来安装。</p>
<h4 id="安装-iam-pump-可执行程序"><a href="#安装-iam-pump-可执行程序" class="headerlink" title="安装 iam-pump 可执行程序"></a>安装 iam-pump 可执行程序</h4><p>可以通过执行以下命令来安装 iam-pump 可执行程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span>iam-pump
<span class="token function">sudo</span> <span class="token function">cp</span> _output/platforms/linux/amd64/iam-pump <span class="token variable">$&#123;IAM_INSTALL_DIR&#125;</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="生成并安装-iam-pump-的配置文件"><a href="#生成并安装-iam-pump-的配置文件" class="headerlink" title="生成并安装 iam-pump 的配置文件"></a>生成并安装 iam-pump 的配置文件</h4><p><code>iam-pump</code> 的配置文件为 <code>iam-pump.yaml</code>，生成并安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh configs/iam-pump.yaml <span class="token operator">></span> iam-pump.yaml
<span class="token function">sudo</span> <span class="token function">mv</span> iam-pump.yaml <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="创建并安装-systemd-unit-文件"><a href="#创建并安装-systemd-unit-文件" class="headerlink" title="创建并安装 systemd unit 文件"></a>创建并安装 systemd unit 文件</h4><p><code>iam-pump</code> 的 <code>systemd uint</code> 文件为 <code>iam-pump.service</code>，生成并安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh init/iam-pump.service <span class="token operator">></span> iam-pump.service
<span class="token function">sudo</span> <span class="token function">mv</span> iam-pump.service /etc/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="启动-iam-pump-服务"><a href="#启动-iam-pump-服务" class="headerlink" title="启动 iam-pump 服务"></a>启动 iam-pump 服务</h4><p>可以通过执行以下命令来启动 <code>iam-pump</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> iam-pump
<span class="token function">sudo</span> systemctl restart iam-pump
systemctl status iam-pump <span class="token comment"># 查看 iam-pump 运行状态，如果输出中包含 active (running)字样说明 iam-pump 成功启动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="测试-iam-pump-是否安装成功"><a href="#测试-iam-pump-是否安装成功" class="headerlink" title="测试 iam-pump 是否安装成功"></a>测试 iam-pump 是否安装成功</h4><p>可以通过执行以下命令来测试 <code>iam-pump</code> 服务是否安装成功：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> http://127.0.0.1:7070/healthz
<span class="token punctuation">&#123;</span><span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"ok"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>经过以上 5 个步骤，如果返回 <code>&#123;&quot;status&quot;: &quot;ok&quot;&#125;</code> 就说明 <code>iam-pump</code> 服务健康。</p>
<p>当然，你还可以通过一个真实的授权请求，来看 <code>iam-pump</code> 是否成功将授权日志分析后，转存到 <code>MongoDB</code> 中。具体操作如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 创建访问 iam-authz-server 需要用到的密钥对</span>
iamctl secret create pumptest 
secret/pumptest created

<span class="token comment"># 2. 使用步骤 1 创建的密钥对生成 JWT Token</span>
<span class="token assign-left variable">authzAccessToken</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>iamctl jwt sign njcho8gJQArsq7zr5v1YpG5NcvL0aeuZ38Ti if70HgRgp021iq5ex2l7pfy5XvgtZM3q<span class="token variable">`</span></span>

<span class="token comment"># 3. 创建授权策略</span>
iamctl policy create pumptest <span class="token string">'&#123;"metadata":&#123;"name":"policy0"&#125;,"policy":&#123;"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken>","users:maria","groups:admins"],"actions":["delete","&lt;create|update>"],"effect":"allow","resources":["resources:articles:&lt;.*>","resources:printer"],"conditions":&#123;"remoteIPAddress":&#123;"type":"CIDRCondition","options":&#123;"cidr":"192.168.0.1/16"&#125;&#125;&#125;&#125;&#125;'</span>
policy/pumptest created

<span class="token comment"># 4. 访问 /v1/authz 接口进行资源授权</span>
<span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -H<span class="token string">"Authorization: Bearer <span class="token variable">$authzAccessToken</span>"</span> -d<span class="token string">'&#123;"subject":"users:maria","action":"delete","resource":"resources:articles:ladon-introduction","context":&#123;"remoteIPAddress":"192.168.0.5"&#125;&#125;'</span> http://127.0.0.1:9090/v1/authz

<span class="token comment"># 5. 登录 MongoDB，查看经过解析后的授权日志。如果出现以下记录，说明iam-pump正常工作</span>
mongosh <span class="token parameter variable">--quiet</span> mongodb://iam:<span class="token string">'iam59!z$'</span>@127.0.0.1:27017/iam_analytics?authSource<span class="token operator">=</span>iam_analytics
iam_analytics<span class="token operator">></span> db.iam_analytics.find<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span>
    _id: ObjectId<span class="token punctuation">(</span><span class="token string">"62a9e8b85f395dc7a4ce1767"</span><span class="token punctuation">)</span>,
    timestamp: Long<span class="token punctuation">(</span><span class="token string">"1655302321"</span><span class="token punctuation">)</span>,
    username: <span class="token string">'admin'</span>,
    effect: <span class="token string">'allow'</span>,
    conclusion: <span class="token string">'policies policy0 allow access'</span>,
    request: <span class="token string">'&#123;"resource":"resources:articles:ladon-introduction","action":"delete","subject":"users:maria","context":&#123;"remoteIPAddress":"192.168.0.5","username":"admin"&#125;&#125;'</span>,
    policies: <span class="token string">''</span>,
    deciders: <span class="token string">''</span>,
    expireAt: ISODate<span class="token punctuation">(</span><span class="token string">"2122-05-22T14:12:01.423Z"</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="安装和配置-iam-watcher"><a href="#安装和配置-iam-watcher" class="headerlink" title="安装和配置 iam-watcher"></a>安装和配置 iam-watcher</h3><p>安装 <code>iam-watcher</code> 步骤和安装 <code>iam-apiserver</code>、<code>iam-authz-server</code>、<code>iam-pump</code> 步骤基本一样，可以通过 5 步来安装。</p>
<h4 id="安装-iam-watcher-可执行程序"><a href="#安装-iam-watcher-可执行程序" class="headerlink" title="安装 iam-watcher 可执行程序"></a>安装 iam-watcher 可执行程序</h4><p>可以通过执行以下命令来安装 <code>iam-watcher</code> 可执行程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token builtin class-name">source</span> scripts/install/environment.sh
<span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span>iam-watcher
<span class="token function">sudo</span> <span class="token function">cp</span> _output/platforms/linux/amd64/iam-watcher <span class="token variable">$&#123;IAM_INSTALL_DIR&#125;</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="生成并安装-iam-watcher-的配置文件"><a href="#生成并安装-iam-watcher-的配置文件" class="headerlink" title="生成并安装 iam-watcher 的配置文件"></a>生成并安装 iam-watcher 的配置文件</h4><p><code>iam-watcher</code> 的配置文件为 <code>iam-watcher.yaml</code>，生成并安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh configs/iam-watcher.yaml <span class="token operator">></span> iam-watcher.yaml
<span class="token function">sudo</span> <span class="token function">mv</span> iam-watcher.yaml <span class="token variable">$&#123;IAM_CONFIG_DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="创建并安装-systemd-unit-文件-1"><a href="#创建并安装-systemd-unit-文件-1" class="headerlink" title="创建并安装 systemd unit 文件"></a>创建并安装 systemd unit 文件</h4><p><code>iam-watcher</code> 的 <code>systemd uint</code> 文件为 <code>iam-watcher.service</code>，生成并安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/genconfig.sh scripts/install/environment.sh init/iam-watcher.service <span class="token operator">></span> iam-watcher.service
<span class="token function">sudo</span> <span class="token function">mv</span> iam-watcher.service /etc/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="启动-iam-watcher-服务"><a href="#启动-iam-watcher-服务" class="headerlink" title="启动 iam-watcher 服务"></a>启动 iam-watcher 服务</h4><p>可以通过执行以下命令来启动 <code>iam-watcher</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> iam-watcher
<span class="token function">sudo</span> systemctl restart iam-watcher
systemctl status iam-watcher <span class="token comment"># 查看 iam-watcher运行状态，如果输出中包含 active (running)字样说明 iam-watcher成功启动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="测试-iam-watcher-是否安装成功"><a href="#测试-iam-watcher-是否安装成功" class="headerlink" title="测试 iam-watcher 是否安装成功"></a>测试 iam-watcher 是否安装成功</h4><p>可以通过执行以下命令来测试 <code>iam-watcher</code> 服务是否安装成功：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> http://127.0.0.1:5050/healthz
<span class="token punctuation">&#123;</span><span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"ok"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>经过以上 5 个步骤，如果返回 <code>&#123;&quot;status&quot;: &quot;ok&quot;&#125;</code> 就说明 <code>iam-watcher</code> 服务健康。</p>
<h3 id="安装-man-文件"><a href="#安装-man-文件" class="headerlink" title="安装 man 文件"></a>安装 man 文件</h3><p>IAM 系统通过组合调用包：<code>github.com/cpuguy83/go-md2man/v2/md2man</code> 和 <code>github.com/spf13/cobra</code> 提供的函数生成了各个组件的 man1 文件，具体来说，需要 3 步实现。</p>
<ol>
<li>生成各个组件的 <code>man1</code> 文件</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
$ ./scripts/update-generated-docs.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="2">
<li>安装生成的 ·a 文件</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> docs/man/man1/* /usr/share/man/man1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>检查是否成功安装 <code>man1</code> 文件</li>
</ol>
<p>执行 <code>man iam-apiserver</code> 命令后，会弹出 <code>man</code> 文档界面，如下图所示。</p>
<p><a href="https://github.com/marmotedu/iam/blob/master/docs/images/iam-apiserver-man1.png"><img src="https://github.com/marmotedu/iam/raw/master/docs/images/iam-apiserver-man1.png" alt="man page"></a></p>
<p>至此，<code>IAM</code> 系统所有组件都已经安装成功了，你可以通过 <code>iamctl version</code> 查看客户端和服务端的版本，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iamctl version <span class="token parameter variable">-o</span> yaml
clientVersion:
  buildDate: <span class="token string">"2021-10-15T07:47:54Z"</span>
  compiler: gc
  gitCommit: 34444662f5e09449caca1f6b318c7e0896d7d4d5
  gitTreeState: dirty
  gitVersion: v1.6.2
  goVersion: go1.17.2
  platform: linux/amd64
serverVersion:
  buildDate: <span class="token string">"2021-10-15T07:40:26Z"</span>
  compiler: gc
  gitCommit: 34444662f5e09449caca1f6b318c7e0896d7d4d5
  gitTreeState: dirty
  gitVersion: v1.6.2
  goVersion: go1.17.2
  platform: linux/amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="测试-IAM-系统是否安装成功"><a href="#测试-IAM-系统是否安装成功" class="headerlink" title="测试 IAM 系统是否安装成功"></a>测试 IAM 系统是否安装成功</h3><p>最后，我们可以执行以下命令来测试整个 <code>IAM</code> 系统是否被成功安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/install/test.sh iam::test::test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果安装成功，最后会输出一行：<code>congratulations, install iam application successfully!</code>。如下图所示。</p>
<p><a href="https://github.com/marmotedu/iam/blob/master/docs/images/iamtest%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"><img src="https://github.com/marmotedu/iam/raw/master/docs/images/iamtest%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="iam::test::test运行结果"></a></p>
<hr>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
      </tags>
  </entry>
  <entry>
    <title>03 | 工作流设计</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-02-flow-work.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>一个企业级项目通常是有多人合作完成的，不同开发者在本地开发完代码之后，可能提交到同一个代码仓，同一个开发者也可能同时开发几个功能特性。<br>这种多人合作、多功能并行开发的特性如果处理不好，就会带来诸如丢失代码、合错代码、代码冲突等问题。</p>
<p>所以，在编写代码之前，我们要设计一个合理的开发模式。有因为目前开发者基本都是基于<code>Git</code>开发的，所以需要基于<code>Git</code>设计出一个合理的开发模式</p>
<p>在使用<code>Git</code>开发时，有 <code>4</code> 种常用的工作流，也叫开发模式。按演进顺序分别为 ， <code>集中式工作流</code> ， <code>功能分支工作流</code>， <code>Git Flow工作流</code>，<code>Forking 工作流</code>。</p>
<span id="more"></span>


<h1 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h1><p><code>集中式工作流</code>是最简单的开发模式，但它的缺点也很明显：不同开发人员的提交日志混杂在一起，难以定位问题。如果同时开发多个功能，不同功能同时往<code>master</code>分支合并，<br>代码之间也会相互影响，从而产生代码冲突。</p>
<p>和其他工作流相比，<code>集中式工作流</code>的代码管理较混乱，容易出问题，一次适合用在团队人数少，开发不频繁，不需要同时维护多个版本的小项目中。当我们想要并行开发多个功能时，<br>这种工作流就不适用了。</p>
<h1 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h1><p><code>功能分支工作流</code>基于<code>集中式工作流</code>演进而来，他的工作模式是，在开发新功能时，基于<code>master</code>分支新建一个功能分支，在功能分支上进行开发，而不是直接在本地的 <code>master</code><br>分支开发，开发完成之后合并到 <code>master</code>分支</p>
<p>相对<code>集中式工作流</code>，<code>功能分支工作流</code>这种让不同功能在不同分支进行开发，只在最后一步合并到<code>master</code>分支的方式，不仅可以避免不同功能之间的相互影响，还可以使提交历史<br>看起来更简洁。</p>
<p>在合并到 <code>master</code> 分支时，需要提交 <code>PR (Pull Request)</code> , 而不是直接将代码 <code>merge</code> 到 <code>master</code> 分支。<code>PR</code> 流程不仅可以把分支代码提供给团队其他开发人员进行 <code>CR（Code Review）</code>，还可以在 <code>PR</code> 页面讨论代码。通过 <code>CR</code> ，我们可以确保合并到 <code>master</code> 的代码是健壮的；通过 <code>PR</code> 页面的讨论，可以使开发者充分参与到代码的讨论中，有助于提高代码的质量，并且提供了一个代码变更的历史回顾途径。</p>
<p>那么，功能分支工作流具体的开发流程是什么呢？我们一起来看下。</p>
<ol>
<li>基于 <code>master</code> 分支新建一个功能分支，功能分支可以取一些有意义的名字，便于理解，例如 <code>feature/rate-limiting</code>。</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> feature/rate-limiting<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>在功能分支上进行代码开发，开发完成后 <code>commit</code> 到功能分支。</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> limit.go
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add rate limiting"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="3">
<li>将本地功能分支代码 <code>push</code> 到远程仓库。</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin feature/rate-limiting<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="4">
<li>在远程仓库上创建 <code>PR</code>（例如：<code>GitHub</code>）</li>
</ol>
<h1 id="Git-Flow-工作流"><a href="#Git-Flow-工作流" class="headerlink" title="Git Flow 工作流"></a>Git Flow 工作流</h1><p><code>Git Flow 工作流</code> (<code>Gitflow Workflow</code>)是<code>2010年</code>由<code>Vincent Driessen</code>在他的一篇 <a href="https://nvie.com/posts/a-successful-git-branching-model">博客</a> 里提出来的。它定义了一整套完善的基于<code>Git</code>分支模型的框架，结合了版本发布的研发流程，适合管理具有固定发布周期的大型项目。</p>
<p><code>Git Flow工作流</code>是一个非常成熟的方案，也是非开源项目中最常用到的工作流。它定义了一个围绕项目发布的严格分支模型，通过为代码开发、发布和维护分配独立的分支来让项目的迭代流程更加顺畅，比较适合大型的项目或者迭代速度快的项目。接下来，我会通过介绍 <code>Git Flow</code> 的 5 种分支和工作流程，来给你讲解 <code>GIt Flow</code> 是如何工作的。</p>
<p>这 5 种分支的详细介绍见下表：</p>
<table>
<thead>
<tr>
<th>分支名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td>该分支上的最新代码永远是发布状态，作为唯一一个正式对外发布的分支，是所有分支里最稳定的。只有经过了严格审核和测试，并且在当前发布计划里的特性，才会被合并到<code>master</code> 分支。不能直接在该分支上开发，<code>master</code> 分支每合并一个 <code>hotfix</code> ， <code>release</code> ，都会打上一个版本标签 <code>tag</code></td>
</tr>
<tr>
<td><code>develop</code></td>
<td><code>Develop</code> 分支是根据 <code>master</code> 分支创建出来的，它作为一种集成分支(<code>Integration Branch</code>)，是专门用来集成开发完成的各种特性的。该分支的代码是开发中的最新代码，该分支只做合并操作，不能直接在该分支上开发，<code>develop</code> 分支通常具有更加详细和完整的提交历史，包括一些很细节的提交记录</td>
</tr>
<tr>
<td><code>feature</code></td>
<td><code>Feature</code> 分支是根据 <code>develop</code> 分支创建出来的，在研发阶段用来做功能开发。一个新功能会基于 <code>develop</code> 分支新建一个 <code>feature</code> 分支 <code>feature/xxx-xxx</code> 。功能开发完成之后，会合并到 <code>develop</code> 分支并删除 ，<code>feature</code> 分支从来不会直接和 <code>master</code> 分支打交道。这里有一点你要注意 <code>feature</code> 分支在申请合并之前，最好是先 <code>pull</code> 一下 <code>develop</code> 分支，看一下有没有冲突，如果有，就先解决冲突后在申请合并</td>
</tr>
<tr>
<td><code>release</code></td>
<td><code>Release</code> 分支是根据 <code>develop</code> 分支创建出来的，分支建议建议命名为 <code>release/xxx-xxx</code> ，例如 <code>v1.0.0</code> 版本的功能全部开发测试完成后，提交到 <code>develop</code> 分支，然后基于 <code>develop</code> 分支创建 <code>release/1.0.0</code> 分支，并提交测试，测试中的问题在 <code>release/1.0.0</code> 分支修改。最终通过测试后，将 <code>release/1.0.0</code> 分支合并到 <code>master</code> 和 <code>develop</code> ， 并在 <code>master</code> 分支上打上 <code>v1.0.0</code> 的版本标签 ， 最后删除 <code>release/1.0.0</code> 分支</td>
</tr>
<tr>
<td><code>hotfix</code></td>
<td><code>Hotfix</code> 分支不从是 <code>develop</code> 分支创建出来的，而是直接根据  <code>master</code> 分支创建得到的， 在维护阶段用作紧急 <code>bug</code> 修复分支，修复完成后合并到 <code>master</code> ， 分支名建议命名为 <code>hotfix/xxx-xxx</code> 。例如：当线上某个版本出现 <code>bug</code> 后，从 <code>master</code> 检出对应版本的代码，创建 <code>hotfix</code> 分支， 并在 <code>hotfix</code> 分支上修复问题。问题修复后 ， 将 <code>hotfix</code> 合并到 <code>master</code> 和 <code>develop</code> ，并在 <code>master</code> 上打上修复后的版本标签</td>
</tr>
</tbody></table>
<h2 id="Git-Flow-开发流程"><a href="#Git-Flow-开发流程" class="headerlink" title="Git Flow 开发流程"></a>Git Flow 开发流程</h2><p>这里我们用一个实际的例子来演示下 <code>Git Flow</code> 的开发流程。场景如下：</p>
<p>a. 当前版本为：<code>0.9.0</code> 。</p>
<p>b. 需要新开发一个功能，使程序执行时向标准输出输出 <code>hello world</code> 字符串。</p>
<p>c. 在开发阶段，线上代码有 <code>Bug</code> 需要紧急修复。</p>
<p>假设我们的 <code>Git</code> 项目名为 <code>gitflow-demo</code>，项目目录下有 <code>2</code> 个文件，分别是 <code>README.md</code> 和 <code>main.go</code>，内容如下。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"callmainfunction"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>具体的开发流程有 <code>12</code> 步，你可以跟着以下步骤操作练习。</p>
<p><em><strong><code>1.</code> 创建一个常驻的分支：<code>develop</code></strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> develop master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>2.</code> 基于 <code>develop</code> 分支，新建一个功能分支：<code>feature/print-hello-world</code></strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> feature/print-hello-world develop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>3.</code> <code>feature/print-hello-world</code> 分支中，在 <code>main.go</code> 文件中添加一行代码 <code>fmt.Println(&quot;Hello&quot;)</code>，添加后的代码如下</strong></em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"callmainfunction"</span><span class="token punctuation">)</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong><code>4.</code> 紧急修复 <code>Bug</code></strong></em></p>
<p>我们正处在新功能的开发中（只完成了 <code>fmt.Println(&quot;Hello&quot;)</code>而非 <code>fmt.Println(&quot;Hello World&quot;)</code> ）突然线上代码发现了一个 <code>Bug</code> ，我们要立即停止手上的工作，修复线上的 <code>Bug</code> ，步骤如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash                                       <span class="token comment"># 1. 开发工作只完成了一半，还不想提交，可以临时保存修改至堆栈区</span>
<span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hotfix/print-error master       <span class="token comment"># 2. 从 master 建立 hotfix 分支</span>
<span class="token function">vi</span> main.go                                      <span class="token comment"># 3. 修复 bug，callmainfunction -> call main function</span>
<span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'fix print message error bug'</span>  <span class="token comment"># 4. 提交修复</span>
<span class="token function">git</span> checkout develop                            <span class="token comment"># 5. 切换到 develop 分支</span>
<span class="token function">git</span> merge --no-ff hotfix/print-error            <span class="token comment"># 6. 把 hotfix 分支合并到 develop 分支</span>
<span class="token function">git</span> checkout master                             <span class="token comment"># 7. 切换到 master 分支</span>
<span class="token function">git</span> merge --no-ff hotfix/print-error            <span class="token comment"># 8. 把 hotfix 分支合并到 master</span>
<span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.9.1 <span class="token parameter variable">-m</span> <span class="token string">"fix log bug"</span>              <span class="token comment"># 9. master 分支打 tag</span>
go build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span>                                   <span class="token comment"># 10. 编译代码，并将编译好的二进制更新到生产环境</span>
<span class="token function">git</span> branch <span class="token parameter variable">-d</span> hotfix/print-error                <span class="token comment"># 11. 修复好后，删除 hotfix/xxx 分支</span>
<span class="token function">git</span> checkout feature/print-hello-world          <span class="token comment"># 12. 切换到开发分支下</span>
<span class="token function">git</span> merge --no-ff develop                       <span class="token comment"># 13. 因为 develop 有更新，这里最好同步更新下</span>
<span class="token function">git</span> stash pop                                   <span class="token comment"># 14. 恢复到修复前的工作状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong><code>5.</code>在 <code>main.go</code> 中加入 <code>fmt.Println(&quot;Hello World&quot;)</code></strong></em></p>
<p><em><strong><code>6.</code>提交代码到 <code>feature/print-hello-world</code> 分支</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">"print 'hello world'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>7.</code>在 <code>feature/print-hello-world</code> 分支上做 <code>code review</code></strong></em></p>
<p>首先，我们需要将 <code>feature/print-hello-world</code> <code>push</code> 到代码托管平台，例如 <code>GitHub</code> 上。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin feature/print-hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，我们在 <code>GitHub</code> 上，基于 <code>feature/print-hello-world</code> 创建 <code>pull request</code></p>
<p>创建完 <code>pull request</code> 之后，我们就可以指定 <code>Reviewers</code> 进行 <code>code review</code></p>
<p><em><strong><code>8.</code> <code>code review</code> 通过后，由代码仓库 <code>matainer</code> 将功能分支合并到 <code>develop</code> 分支</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout develop
<span class="token function">git</span> merge --no-ff feature/print-hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong><code>9.</code>基于 <code>develop</code> 分支，创建 <code>release</code> 分支，测试代码</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> release/1.0.0 develop
go build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span> <span class="token comment"># 构建后，部署二进制文件，并测试</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em><strong><code>10.</code>测试失败，因为我们要求打印 “<code>hello world</code>”，但打印的是 “<code>Hello World”</code>，修复的时候，我们直接在 <code>release/1.0.0</code> 分支修改代码，修改完成后，提交并编译部署</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">"fix bug"</span>
go build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong><code>11.</code>测试通过后，将功能分支合并到 <code>master</code> 分支和 <code>develop</code> 分支</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout develop

<span class="token function">git</span> merge --no-ff release/1.0.0

<span class="token function">git</span> checkout master

<span class="token function">git</span> merge --no-ff release/1.0.0

<span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.0.0 <span class="token parameter variable">-m</span> <span class="token string">"add print hello world"</span> <span class="token comment"># master 分支打 tag</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong><code>12.</code>删除 <code>feature/print-hello-world</code> 分支，也可以选择性删除 <code>release/1.0.0</code> 分支</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature/print-hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>亲自操作一遍之后，你应该会更了解这种模式的优缺点。它的缺点，就是你刚才已经体会到的，它有一定的上手难度。不过 <code>Git Flow </code>工作流还是有很多优点的：<code>Git Flow </code>工作流的每个分支分工明确，这可以最大程度减少它们之间的相互影响。因为可以创建多个分支，所以也可以并行开发多个功能。另外，和功能分支工作流一样，它也可以添加 <code>code review</code>，保障代码质量。</p>
<p>因此，<code>Git Flow</code> 工作流比较适合开发团队相对固定，规模较大的项目。</p>
<h1 id="Forking-工作流"><a href="#Forking-工作流" class="headerlink" title="Forking 工作流"></a>Forking 工作流</h1><p>上面讲的 <code>Git Flow</code> 是非开源项目中最常用的，而在开源项目中，最常用到的是 <code>Forking 工作流</code>，例如 <code>Kubernetes</code>、<code>Docker</code> 等项目用的就是这种工作流。这里，我们先来了解下 <code>fork</code> 操作。</p>
<p><code>fork</code> 操作是在个人远程仓库新建一份目标远程仓库的副本，比如在 <code>GitHub</code> 上操作时，在项目的主页点击 <code>fork</code> 按钮（页面右上角），即可拷贝该目标远程仓库</p>
<p>假设 <code>开发者 A</code> 拥有一个远程仓库，如果 <code>开发者 B</code> 也想参与<code>A</code>项目的开发，<code>B</code> 可以 <code>fork</code> 一份 <code>A</code> 的远程仓库到自己的 <code>GitHub</code> 账号下。后续 <code>B</code> 可以在自己的项目进行开发，开发完成后，<code>B</code>可以给 <code>A</code>提交一个<code>PR</code>。这时候 <code>A</code> 会收到通知，得知有新的 <code>PR</code> 被提交，<code>A</code> 会去查看 <code>PR</code> 并 <code>code review</code>。如果有问题，<code>A</code> 会直接在 <code>PR</code> 页面提交评论，<code>B</code> 看到评论后会做进一步的修改。最后 <code>A</code> 通过 <code>B</code> 的 <code>PR</code> 请求，将代码合并进了 <code>A</code> 的仓库。这样就完成了 <code>A</code> 代码仓库新特性的开发。如果有其他开发者想给 <code>A</code> 贡献代码，也会执行相同的操作。</p>
<p><code>GitHub</code> 中的 <code>Forking</code> 工作流详细步骤共有 <code>6</code> 步（假设目标仓库为 <code>gitflow-demo</code>），你可以跟着以下步骤操作练习。</p>
<p><em><strong><code>1.</code> <code>Fork</code> 远程仓库到自己的账号下</strong></em></p>
<p>访问 <code>gitflow-demo</code> ，点击 <code>fork</code> 按钮</p>
<p><em><strong><code>2.</code> 克隆 <code>fork</code> 的仓库到本地</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/fork/gitflow-demo
<span class="token builtin class-name">cd</span> gitflow-demo
<span class="token function">git</span> remote <span class="token function">add</span> upstream https://github.com/from-fork/gitflow-demo
<span class="token function">git</span> remote set-url <span class="token parameter variable">--push</span> upstream no_push      <span class="token comment"># 从不推送到上游 master</span>
<span class="token function">git</span> remote <span class="token parameter variable">-v</span>
origin https://github.com/fork/gitflow-demo <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
origin https://github.com/fork/gitflow-demo <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
upstream https://github.com/from-fork/gitflow-demo <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
upstream https://github.com/from-fork/gitflow-demo <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong><code>3.</code>创建功能分支</strong></em></p>
<p>首先，要同步本地仓库的 <code>master</code> 分支为最新的状态（跟 <code>upstream master</code> 分支一致）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch upstream
<span class="token function">git</span> checkout master
<span class="token function">git</span> rebase upstream/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后，创建功能分支。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> feature/add-function<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>提交 commit。</p>
<p><em><strong><code>4.</code>在 <code>feature/add-function</code> 分支上开发代码，开发完代码后，提交 <code>commit</code></strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch upstream <span class="token comment"># commit 前需要再次同步 feature 跟 upstream/master</span>
<span class="token function">git</span> rebase upstream/master
<span class="token function">git</span> <span class="token function">add</span> <span class="token operator">&lt;</span>file<span class="token operator">></span>
<span class="token function">git</span> status
<span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong><code>5.</code>分支开发完成后，可能会有一堆 <code>commit</code> ，但是合并到主干时，我们往往希望只有一个（或最多两三个）<code>commit</code>，这可以使功能修改都放在一个或几个 <code>commit</code> 中，便于后面的阅读和维护。这个时候，我们可以用 <code>git rebase</code> 来合并和修改我们的 <code>commit</code>，操作如下：</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> rebase <span class="token parameter variable">-i</span> origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>6.</code> <code>push</code>功能分支到个人远程仓库</strong></em></p>
<p>在完成了开发，并 <code>commit</code> 后，需要将功能分支 <code>push</code> 到个人远程代码仓库，代码如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push <span class="token parameter variable">-f</span> origin feature/add-function<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>7.</code>在个人远程仓库页面创建 <code>pull request</code></strong></em></p>
<p>提交到远程仓库以后，我们就可以创建 <code>pull request</code>，然后请求 <code>reviewers</code> 进行代码 <code>review</code>，确认后合并到 <code>master</code>。这里要注意，创建 <code>pull request</code> 时，<code>base</code> 通常选择目标<code>远程仓库的 master 分支</code></p>
<p>结合操作特点，我们来看看它的优点：<code>Forking 工作流中</code>，<code>项目远程仓库</code>和<code>开发者远程仓库</code>完全独立，开发者通过提交 <code>Pull Request</code> 的方式给远程仓库贡献代码，项目维护者选择性地接受任何开发者的提交，通过这种方式，可以避免授予开发者项目远程仓库的权限，从而提高项目远程仓库的安全性，这也使得任意开发者都可以参与项目的开发。</p>
<p><em><strong><code>8.</code>但 <code>Forking 工作流</code> 也有局限性，就是对于职能分工明确且不对外开源的项目优势不大</strong></em></p>
<p>Forking 工作流比较适用于以下三种场景：</p>
<p>（1）开源项目中；</p>
<p>（2）开发者有衍生出自己的衍生版的需求；</p>
<p>（3）开发者不固定，可能是任意一个能访问到项目的开发者。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>集中式工作流</code>：开发者直接在本地 <code>master</code> 分支开发代码，开发完成后 <code>push</code> 到远端仓库 <code>master</code> 分支。</p>
<p><code>功能分支工作流</code>：开发者基于 <code>master</code> 分支创建一个新分支，在新分支进行开发，开发完成后合并到远端仓库 <code>master</code> 分支。</p>
<p><code>Git Flow 工作流</code>：<code>Git Flow 工作流</code>为不同的分支分配一个明确的角色，并定义分支之间什么时候、如何进行交互，比较适合大型项目的开发。</p>
<p><code>Forking 工作流</code>：开发者先 <code>fork</code> 项目到个人仓库，在个人仓库完成开发后，提交 <code>pull request</code> 到目标远程仓库，远程仓库 <code>review</code> 后，合并 <code>pull request</code> 到 <code>master</code> 分支。</p>
<p><code>集中式工作流</code>是最早的 <code>Git</code> 工作流，<code>功能分支工作流</code>以<code>集中式工作流</code>为基础，<code>Git Flow 工作流</code>又是以<code>功能分支工作流</code>为基础，<code>Forking 工作流</code>在 <code>Git Flow 工作流</code>基础上，解耦了个人远端仓库和项目远端仓库。</p>
<hr>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>Git</tag>
        <tag>work</tag>
        <tag>Golang</tag>
        <tag>GitFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>02 | 目录结构</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-03-design-directory.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>目录结构是一个项目的门面。很多时候，根据目录结构就能看出开发者对这门语言的掌握程度。所以，在我看来，遵循一个好的目录规范，把代码目录设计得可维护、可扩展，甚至比文档规范、Commit 规范来得更加重要。</p>
<h2 id="如何规范目录？"><a href="#如何规范目录？" class="headerlink" title="如何规范目录？"></a>如何规范目录？</h2><p>想设计好一个目录结构，我们首先要知道一个好的目录长什么样，也就是目录规范中包含哪些内容。</p>
<p>目录规范，通常是指我们的项目由哪些目录组成，每个目录下存放什么文件、实现什么功能，以及各个目录间的依赖关系是什么等。在我看来，一个好的目录结构至少要满足以下几个要求。</p>
<ul>
<li><strong>命名清晰</strong>：目录命名要清晰、简洁，不要太长，也不要太短，目录名要能清晰地表达出该目录实现的功能，并且目录名最好用单数。一方面是因为单数足以说明这个目录的功能，另一方面可以统一规范，避免单复混用的情况。</li>
<li><strong>功能明确</strong>：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。也就是说，当需要新增一个功能时，我们能够非常清楚地知道把这个功能放在哪个目录下。</li>
<li><strong>全面性</strong>：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。</li>
<li><strong>可观测性</strong>：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</li>
<li><strong>可扩展性</strong>：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。举个例子，有如下目录结构：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> internal/app  pkg  README.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<span id="more"></span>
<p><code>internal</code> 目录用来实现内部代码，<code>app</code> 和 <code>pkg</code> 目录下的所有文件都属于内部代码。如果 i<code>nternal 目录不管项目大小，永远只有 </code>2<code>个文件</code>app<code>和</code>pkg<code>，那么就说明 </code>internal&#96; 目录是不可扩展的。</p>
<p>相反，如果 <code>internal</code> 目录下直接存放每个组件的源码目录（一个项目可以由一个或多个组件组成），当项目变大、组件增多时，可以将新增加的组件代码存放到 <code>internal</code> 目录，这时 <code>internal</code> 目录就是可扩展的。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> internal/apiserver  authzserver  iamctl  pkg  pump  watcher<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="平铺式目录结构"><a href="#平铺式目录结构" class="headerlink" title="平铺式目录结构"></a>平铺式目录结构</h2><p>一个 Go 项目可以是一个应用，也可以是一个代码框架&#x2F;库，当项目是代码框架&#x2F;库时，比较适合采用平铺式目录结构。</p>
<p>平铺方式就是在项目的根目录下存放项目的代码，整个目录结构看起来更像是一层的，这种方式在很多框架&#x2F;库中存在，使用这种方式的好处是引用路径长度明显减少，比如 <code>github.com/marmotedu/log/pkg/options</code>，可缩短为 <code>github.com/marmotedu/log/options</code>。例如 log 包 <code>github.com/golang/glog</code> 就是平铺式的，目录如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> glog/glog_file.go  glog.go  glog_test.go  LICENSE  README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="结构化目录结构"><a href="#结构化目录结构" class="headerlink" title="结构化目录结构"></a>结构化目录结构</h2><p>当前 <code>Go</code> 社区比较推荐的结构化目录结构是 <a href="https://github.com/golang-standards/project-layout">project-layout</a> 。虽然它并不是官方和社区的规范，但因为组织方式比较合理，被很多 <code>Go</code> 开发人员接受。所以，我们可以把它当作是一个事实上的规范。</p>
<p>首先，我们来看下在开发一个 <code>Go</code> 项目时，通常应该包含的功能。这些功能内容比较多，我放在了 <code>GitHub</code> 的 <a href="https://github.com/marmotedu/geekbang-go/blob/master/Go%E9%A1%B9%E7%9B%AE%E9%80%9A%E5%B8%B8%E5%8C%85%E5%90%AB%E7%9A%84%E5%8A%9F%E8%83%BD.md">Go项目通常包含的功能</a> 里，我们设计的目录结构应该能够包含这些功能。</p>
<p>结合 <code>project-layout</code>，以及上面列出的 <code>Go</code> 项目常见功能，总结出了一套 Go 的代码结构组织方式，也就是 <code>IAM</code> 项目使用的目录结构。这种方式保留了 <code>project-layout</code> 优势的同时，还加入了一些我个人的理解，希望为你提供一个拿来即用的目录结构规范。</p>
<p>接下来，我们一起看看这门课的实战项目所采用的 <code>Go</code> 目录结构。因为实战项目目录比较多，这里只列出了一些重要的目录和文件，你可以快速浏览以加深理解。</p>
<pre class="line-numbers language-none"><code class="language-none">├── api
├── openapi
└── swagger
├── build
│    ├── ci
│    ├── docker
│    │   ├── iam-apiserver
│    │   ├── iam-authz-server
│    │   └── iam-pump
│    │   └── iam-watcher
│    ├── package
├── CHANGELOG
├── cmd│
│   ├── iam-apiserver
│   │   └── apiserver.go
│   ├── iam-authz-server
│   │   └── authzserver.go
│   ├── iamctl
│   │   └── iamctl.go
│   └── iam-pump
│   │    └── pump.go
│   └── iam-watcher
│        └── watcher.go
├── configs
├── CONTRIBUTING.md
├── deployments
├── docs
│  ├── devel
│  │   ├── en-US
│  │   └── zh-CN
│  ├── guide
│  │   ├── en-US
│  │   └── zh-CN
│  ├── images
│  └── README.md
├── examples
├── githooks
├── go.mod
├── go.sum
├── init
├── internal
├── apiserver
│   ├── api
│   │   └── v1
│   │       └── user
│   ├── apiserver.go
│   ├── options
│   ├── service
│   ├── store
│   │   ├── mysql
│   │   ├── fake
│   └── testing
├── authzserver
│   ├── api
│   │   └── v1
│   │       └── authorize
│   ├── options
│   ├── store
│   └── testing
├── iamctl
│   ├── cmd│
│   │   ├── completion
│   │   ├── user
│   └── util
├── pkg
│   ├── code
│   ├── options
│   ├── server
│   ├── util
│   └── validation
├── LICENSE
├── Makefile
├── _output
├── platforms
│   └── linux
│       └── amd64
├── pkg
├── util
│   └── genutil
├── README.md
├── scripts
│   ├── lib
├── make-rules
├── test
│    ├── testdata
├── third_party
│    └── forked
└── tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在我看来，一个 <code>Go</code> 项目包含 <code>3</code> 大部分：<code>Go</code> 应用 、项目管理和文档。所以，我们的项目目录也可以分为这 3 大类。同时，<code>Go</code> 应用又贯穿开发阶段、测试阶段和部署阶段，相应的应用类的目录，又可以按开发流程分为更小的子类。当然了，这些是我建议的目录，<code>Go</code> 项目目录中还有一些不建议的目录。所以整体来看，我们的目录结构可以按下图所示的方式来分类：</p>
<p><em><a href="https://static001.geekbang.org/resource/image/94/a3/94e521c6eb884096ea107fc4c36f30a3.png"><img src="https://static001.geekbang.org/resource/image/94/a3/94e521c6eb884096ea107fc4c36f30a3.png"></a></em></p>
<p>接下来你就先专心跟着我走一遍每个目录、每个文件的作用，等你下次组织代码目录的时候，可以再回过头来看看，那时你一定会理解得更深刻。</p>
<h3 id="Go-应用-：主要存放前后端代码"><a href="#Go-应用-：主要存放前后端代码" class="headerlink" title="Go 应用 ：主要存放前后端代码"></a><code>Go</code> 应用 ：主要存放前后端代码</h3><p>首先，我们来说说开发阶段所涉及到的目录。我们开发的代码包含前端代码和后端代码，可以分别存放在前端目录和后端目录中。</p>
<p><em><strong><code>1.</code>  <code>/web</code></strong></em></p>
<p>_前端代码存放目录，主要用来存放Web静态资源，服务端模板和单页应用（SPAs）。</p>
<p><em><strong><code>2.</code>  <code>/cmd</code></strong></em></p>
<p>一个项目有很多组件，可以把组件 main 函数所在的文件夹统一放在<code>/cmd</code> 目录下，例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> cmd/gendocs
geniamdocs  genman  genswaggertypedocs  genyaml  iam-apiserver  iam-authz-server  iamctl  iam-pump
<span class="token function">ls</span> cmd/iam-apiserver/apiserver.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>每个组件的目录名应该跟你期望的可执行文件名是一致的。这里要保证 <code>/cmd/&lt;组件名&gt;</code> 目录下不要存放太多的代码，如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。</p>
<p><em><strong><code>3.</code>  <code>/internal</code></strong></em></p>
<p>存放<strong>私有应用</strong>和库代码。如果一些代码，你不希望在其他应用和库中被导入，可以将这部分代码放在<code>/internal</code> 目录下。</p>
<p>在引入其它项目 internal 下的包时，<code>Go</code> 语言会在编译时报错：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">An <span class="token function">import</span> of a path containing the element “internal” is disallowedif the importing code is outside the tree rooted at the parent of the<span class="token string">"internal"</span> directory.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以通过 <code>Go</code> 语言本身的机制来约束其他项目 import 项目内部的包。<code>/internal</code> 目录建议包含如下目录：</p>
<ul>
<li><code>/internal/apiserver</code>：该目录中存放真实的应用代码。这些应用的共享代码存放在<code>/internal/pkg</code> 目录下。</li>
<li><code>/internal/pkg</code>：存放项目内可共享，项目外不共享的包。这些包提供了比较基础、通用的功能，例如工具、错误码、用户验证等功能。</li>
</ul>
<p>我的建议是，一开始将所有的共享代码存放在&#x2F;<code>internal/pkg</code> 目录下，当该共享代码做好了对外开发的准备后，再转存到<code>/pkg</code>目录下。</p>
<p>下面，我详细介绍下 <code>IAM</code> 项目的 <code>internal</code>目录 ，来加深你对 <code>internal</code> 的理解，目录结构如下：</p>
<pre class="line-numbers language-none"><code class="language-none">├── apiserver│   ├── api│   │   └── v1│   │       └── user│   ├── options│   ├── config│   ├── service│   │   └── user.go│   ├── store│   │   ├── mysql│   │   │   └── user.go│   │   ├── fake│   └── testing├── authzserver│   ├── api│   │   └── v1│   ├── options│   ├── store│   └── testing├── iamctl│   ├── cmd│   │   ├── cmd.go│   │   ├── info└── pkg    ├── code    ├── middleware    ├── options    └── validation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>/internal</code> 目录大概分为 <code>3</code> 类子目录：</p>
<ul>
<li><code>/internal/pkg</code>：内部共享包存放的目录。</li>
<li><code>/internal/authzserver</code>、<code>/internal/apiserver</code>、<code>/internal/pump</code>、<code>/internal/iamctl</code>：应用目录，里面包含应用程序的实现代码。</li>
<li><code>/internal/iamctl</code>：对于一些大型项目，可能还会需要一个客户端工具。</li>
</ul>
<p>在每个应用程序内部，也会有一些目录结构，这些目录结构主要根据功能来划分：</p>
<ul>
<li><code>/internal/apiserver/api/v1</code>：<code>HTTP API</code> 接口的具体实现，主要用来做 <code>HTTP</code> 请求的解包、参数校验、业务逻辑处理、返回。注意这里的业务逻辑处理应该是轻量级的，如果业务逻辑比较复杂，代码量比较多，建议放到 <code>/internal/apiserver/service</code> 目录下。该源码文件主要用来串流程。</li>
<li><code>/internal/apiserver/options</code>：应用的 <code>command flag</code>。</li>
<li><code>/internal/apiserver/config</code>：根据命令行参数创建应用配置。</li>
<li><code>/internal/apiserver/service</code>：存放应用复杂业务处理代码。</li>
<li><code>/internal/apiserver/store/mysql</code>：一个应用可能要持久化的存储一些数据，这里主要存放跟数据库交互的代码，比如 <code>Create</code>、<code>Update</code>、<code>Delete</code>、<code>Get</code>、<code>List</code> 等。</li>
</ul>
<p><code>/internal/pkg</code> 目录存放项目内可共享的包，通常可以包含如下目录：</p>
<ul>
<li><code>/internal/pkg/code</code>：项目业务 <code>Code</code> 码。</li>
<li><code>/internal/pkg/validation</code>：一些通用的验证函数。</li>
<li><code>/internal/pkg/middleware</code>：<code>HTTP</code> 处理链。</li>
</ul>
<p><em><strong><code>4.</code>  <code>/pkg</code></strong></em></p>
<p><code>/pkg</code> 目录是 <code>Go</code> 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影，例如 <code>Kubernetes</code>、<code>Prometheus</code>、<code>Moby</code>、<code>Knative</code> 等。</p>
<p>该目录中存放可以被外部应用使用的代码库，其他项目可以直接通过 <code>import</code> 导入这里的代码。所以，我们在将代码库放入该目录时一定要慎重。</p>
<p><em><strong><code>5.</code>  <code>/vendor</code></strong></em></p>
<p>项目依赖，可通过 <code>go mod vendor</code> 创建。需要注意的是，如果是一个 <code>Go</code> 库，不要提交 <code>vendor</code> 依赖包。</p>
<p><em><strong><code>6.</code>  <code>/third\_party</code></strong></em></p>
<p>外部帮助工具，分支代码或其他第三方应用（例如<code>Swagger UI</code>）。比如我们 <code>fork</code> 了一个第三方 <code>go</code> 包，并做了一些小的改动，我们可以放在目录 <code>/third\_party/forked</code> 下。一方面可以很清楚的知道该包是 <code>fork</code> 第三方的，另一方面又能够方便地和 <code>upstream</code> 同步。</p>
<h3 id="Go-应用：主要存放测试相关的文件和代码"><a href="#Go-应用：主要存放测试相关的文件和代码" class="headerlink" title="Go 应用：主要存放测试相关的文件和代码"></a>Go 应用：主要存放测试相关的文件和代码</h3><p>接着，我们再来看下测试阶段相关的目录，它可以存放测试相关的文件。</p>
<p><em><strong><code>7. </code> <code>/test</code></strong></em></p>
<p>用于存放其他外部测试应用和测试数据。<code>/test</code> 目录的构建方式比较灵活：对于大的项目，有一个数据子目录是有意义的。例如，如果需要 <code>Go</code> 忽略该目录中的内容，可以使用 <code>/test/data</code> 或 <code>/test/testdata</code> 目录。</p>
<p>需要注意的是，<strong>Go 也会忽略以“.”或 “</strong>_<strong>” 开头的目录或文件。</strong>这样在命名测试数据目录方面，可以具有更大的灵活性。</p>
<h3 id="Go-应用：存放跟应用部署相关的文件"><a href="#Go-应用：存放跟应用部署相关的文件" class="headerlink" title="Go 应用：存放跟应用部署相关的文件"></a>Go 应用：存放跟应用部署相关的文件</h3><p>接着，我们再来看下与部署阶段相关的目录，这些目录可以存放部署相关的文件。</p>
<p><em><strong><code>8.</code>  <code>/configs</code></strong></em></p>
<p>这个目录用来配置文件模板或默认配置。例如，可以在这里存放 confd 或 consul-template 模板文件。这里有一点要注意，配置中不能携带敏感信息，这些敏感信息，我们可以用占位符来替代，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: v1    user:      username: $ <span class="token comment"># iam 用户名      password: $ # iam 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong><code>9.</code>  <code>/deployments</code></strong></em></p>
<p>用来存放 <code>Iaas</code>、<code>PaaS</code> 系统 和 <code>容器编排部署配置</code> 和 <code>模板</code>（<code>Docker-Compose</code>，<code>Kubernetes/Helm</code>，<code>Mesos</code>，<code>Terraform</code>，<code>Bosh</code>）。在一些项目，特别是用 <code>Kubernetes</code> 部署的项目中，这个目录可能命名为 <code>deploy</code>。</p>
<p>为什么要将这类跟 <code>Kubernetes</code> 相关的目录放到目录结构中呢？主要是因为当前软件部署基本都在朝着容器化的部署方式去演进。</p>
<p><em><strong><code>10.</code>  <code>/init</code></strong></em></p>
<p>存放初始化系统（<code>systemd</code>，<code>upstart</code>，<code>sysv</code>）和进程管理配置文件（<code>runit</code>，<code>supervisord</code>）。比如 <code>sysemd</code> 的 <code>unit</code> 文件。这类文件，在非容器化部署的项目中会用到。</p>
<h3 id="项目管理：存放用来管理-Go-项目的各类文件"><a href="#项目管理：存放用来管理-Go-项目的各类文件" class="headerlink" title="项目管理：存放用来管理 Go 项目的各类文件"></a>项目管理：存放用来管理 Go 项目的各类文件</h3><p>在做项目开发时，还有些目录用来存放项目管理相关的文件，这里我们一起来看下。</p>
<p><em><strong><code>11.</code>  <code>/Makefile</code></strong></em></p>
<p>虽然 <code>Makefile</code> 是一个很老的项目管理工具，但它仍然是最优秀的项目管理工具。所以，一个 <code>Go</code> 项目在其根目录下应该有一个 <code>Makefile</code> 工具，用来对项目进行管理，<code>Makefile</code> 通常用来执行<code>静态代码检查</code>、<code>单元测试</code>、<code>编译</code>等功能。其他常见功能，你可以参考这里： <a href="https://github.com/marmotedu/geekbang-go/blob/master/Makefile%E5%B8%B8%E8%A7%81%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9.md">Makefile常见管理内容</a> 。</p>
<p>我还有一条建议：直接执行 <code>make</code> 时，执行如下各项 <code>format -&gt; lint -&gt; test -&gt; build</code>，如果是有代码生成的操作，还可能需要首先生成代码 <code>gen -&gt; format -&gt; lint -&gt; test -&gt; build</code>。</p>
<p>在实际开发中，我们可以将一些重复性的工作自动化，并添加到 Makefile 文件中统一管理。</p>
<p><em><strong><code>12.</code>  <code>/scripts</code></strong></em></p>
<p>该目录主要用来存放脚本文件，实现构建、安装、分析等不同功能。不同项目，里面可能存放不同的文件，但通常可以考虑包含以下 3 个目录：</p>
<ul>
<li><code>/scripts/make-rules</code>：用来存放 <code>makefile</code> 文件，实现 <code>/Makefile</code> 文件中的各个功能。<code>Makefile</code> 有很多功能，为了保持它的简洁，我建议你将各个功能的具体实现放在<code>/scripts/make-rules</code> 文件夹下。</li>
<li><code>/scripts/lib</code>：<code>shell</code> 库，用来存放 <code>shell</code> 脚本。一个大型项目中有很多自动化任务，比如发布、更新文档、生成代码等，所以要写很多 <code>shell</code> 脚本，这些 <code>shell</code> 脚本会有一些通用功能，可以抽象成库，存放在<code>/scripts/lib</code> 目录下，比如 <code>logging.sh</code>，<code>util.sh</code> 等。</li>
<li><code>/scripts/install</code>：如果项目支持自动化部署，可以将自动化部署脚本放在此目录下。如果部署脚本简单，也可以直接放在 <code>/scripts</code> 目录下。</li>
</ul>
<p>另外，<code>shell </code>脚本中的函数名，建议采用语义化的命名方式，例如 <code>iam::log::info</code> 这种语义化的命名方式，可以使调用者轻松的辨别出函数的功能类别，便于函数的管理和引用。在<code>Kubernetes</code> 的脚本中，就大量采用了这种命名方式。</p>
<p><em><strong><code>13.</code>  <code>/build</code></strong></em></p>
<p>这里存放安装包和持续集成相关的文件。这个目录下有 3 个大概率会使用到的目录，在设计目录结构时可以考虑进去。</p>
<ul>
<li><code>/build/package</code>：<code>存放容器（Docker）</code>、<code>系统（deb, rpm, pkg）</code>的包配置和脚本。</li>
<li><code>/build/ci</code>：存放 <code>CI（travis，circle，drone）</code>的配置文件和脚本。</li>
<li><code>/build/docker</code>：存放子项目各个组件的 <code>Dockerfile</code> 文件。</li>
</ul>
<p><em><strong><code>14.</code>  <code>/tools</code></strong></em></p>
<p>存放这个项目的支持工具。这些工具可导入来自 <code>/pkg</code> 和 <code>/internal</code> 目录的代码。</p>
<p><em><strong><code>15.</code>  <code>/githooks</code></strong></em></p>
<p>Git 钩子。比如，我们可以将 commit-msg 存放在该目录。</p>
<p><em><strong><code>16.</code>  <code>/assets</code></strong></em></p>
<p>项目使用的其他资源(图片、CSS、JavaScript 等)。</p>
<p><em><strong><code>17.</code>  <code>/website</code></strong></em></p>
<p>如果你不使用 <code>GitHub</code> 页面，那么可以在这里放置项目网站相关的数据。</p>
<h3 id="文档：主要存放项目的各类文档"><a href="#文档：主要存放项目的各类文档" class="headerlink" title="文档：主要存放项目的各类文档"></a>文档：主要存放项目的各类文档</h3><p>一个项目，也包含一些文档，这些文档有很多类别，也需要一些目录来存放这些文档，这里我们也一起来看下。</p>
<p><em><strong><code>18.</code>  <code>/README.md</code></strong></em></p>
<p>项目的 <code>README</code> 文件一般包含了项目的介绍、功能、快速安装和使用指引、详细的文档链接以及开发指引等。有时候 <code>README</code> 文档会比较长，为了能够快速定位到所需内容，需要添加 <code>markdown toc</code> 索引，可以借助工具 <a href="https://github.com/nochso/tocenize">tocenize</a> 来完成索引的添加。</p>
<p>这里还有个建议，前面我们也介绍过 README 是可以规范化的，所以这个 README 文档，可以通过脚本或工具来自动生成。</p>
<p><em><strong><code>19.</code>  <code>/docs</code></strong></em></p>
<p>存放设计文档、开发文档和用户文档等（除了 <code>godoc</code> 生成的文档）。推荐存放以下几个子目录：</p>
<ul>
<li><code>/docs/devel/&#123;en-US,zh-CN&#125;</code>：存放<code>开发文档</code>、<code>hack</code> 文档等。</li>
<li><code>/docs/guide/&#123;en-US,zh-CN&#125;</code>: 存放 <code>用户手册</code>，<code>安装</code>、<code>quickstart</code>、<code>产品文档</code>等，分为 <code>中文文档</code>和 <code>英文文档</code>。</li>
<li><code>/docs/images</code>：存放图片文件。</li>
</ul>
<p><em><strong><code>20.</code>  <code>/CONTRIBUTING.md</code></strong></em></p>
<p>如果是一个开源就绪的项目，最好还要有一个 <code>CONTRIBUTING.md</code> 文件，用来说明如何贡献代码，如何开源协同等等。<code>CONTRIBUTING.md</code> 不仅能够规范协同流程，还能降低第三方开发者贡献代码的难度。</p>
<p><em><strong><code>21.</code>  <code>/api</code></strong></em></p>
<p><code>/api</code> 目录中存放的是当前项目对外提供的各种不同类型的 <code>API</code> 接口定义文件，其中可能包含类似 <code>/api/protobuf-spec</code>、<code>/api/thrift-spec</code>、<code>/api/http-spec</code>、<code>openapi</code>、<code>swagger</code> 的目录，这些目录包含了当前项目对外提供和依赖的所有 <code>API</code> 文件。例如，如下是 <code>IAM</code> 项目的 <code>/api</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── openapi/│   └── README.md└── swagger/    ├── docs/    ├── README.md    └── swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>二级目录的主要作用，就是在一个项目同时提供了多种不同的访问方式时，可以分类存放。用这种方式可以避免潜在的冲突，也能让项目结构更加清晰。</p>
<p><em><strong><code>22.</code>  <code>/LICENSE</code></strong></em></p>
<p>版权文件可以是私有的，也可以是开源的。常用的开源协议有：<code>Apache 2.0</code>、<code>MIT</code>、<code>BSD</code>、<code>GPL</code>、<code>Mozilla</code>、<code>LGPL</code>。有时候，公有云产品为了打造品牌影响力，会对外发布一个本产品的开源版本，所以在项目规划初期最好就能规划下未来产品的走向，选择合适的 <code>LICENSE</code>。</p>
<p>为了声明版权，你可能会需要将 <code>LICENSE</code> 头添加到源码文件或者其他文件中，这部分工作可以通过工具实现自动化，推荐工具： <a href="https://github.com/marmotedu/addlicense">addlicense</a> 。</p>
<p>当代码中引用了其它开源代码时，需要在 <code>LICENSE</code> 中说明对其它源码的引用，这就需要知道代码引用了哪些源码，以及这些源码的开源协议，可以借助工具来进行检查，推荐工具： <a href="https://github.com/ribice/glice">glice</a> 。至于如何说明对其它源码的引用，大家可以参考下 IAM 项目的 <a href="https://github.com/marmotedu/iam/blob/master/LICENSE">LICENSE</a> 文件。</p>
<p><em><strong><code>23.</code>  <code>/CHANGELOG</code></strong></em></p>
<p>当项目有更新时，为了方便了解当前版本的更新内容或者历史更新内容，需要将更新记录存放到 <code>CHANGELOG</code> 目录。编写 <code>CHANGELOG</code> 是一个复杂、繁琐的工作，我们可以结合 <a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular规范</a> 和 <a href="https://github.com/git-chglog/git-chglog">git-chglog</a> 来自动生成 <code>CHANGELOG</code>。</p>
<p><em><strong><code>24.</code>  <code>/examples</code></strong></em></p>
<p>存放应用程序或者公共包的示例代码。这些示例代码可以降低使用者的上手门槛。</p>
<h3 id="不建议的目录"><a href="#不建议的目录" class="headerlink" title="不建议的目录"></a>不建议的目录</h3><p>除了上面这些我们建议的目录，在 <code>Go</code> 项目中，还有一些目录是不建议包含的，这些目录不符合 <code>Go</code> 的设计哲学。</p>
<ol>
<li><code>/src/</code></li>
</ol>
<p>一些开发语言，例如 Java 项目中会有 <code>src</code> 目录。在 <code>Java</code> 项目中， <code>src</code> 目录是一种常见的模式，但在 <code>Go</code> 项目中，不建议使用 <code>src</code> 目录。</p>
<p>其中一个重要的原因是：在默认情况下，<code>Go</code> 语言的项目都会被放置到<code>$GOPATH/src</code> 目录下。这个目录中存放着所有代码，如果我们在自己的项目中使用<code>/src</code> 目录，这个包的导入路径中就会出现两个 <code>src</code>，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$GOPATH</span>/src/github.com/marmotedu/project/src/main.go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这样的目录结构看起来非常怪。</p>
<ol start="2">
<li><code>xxs/</code></li>
</ol>
<p>在 Go 项目中，要避免使用带复数的目录或者包。建议统一使用单数。</p>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><p>上面介绍的目录结构包含很多目录，但一个小型项目用不到这么多目录。对于小型项目，可以考虑先包含 <code>cmd</code>、<code>pkg</code>、<code>internal</code> <code>3</code> 个目录，其他目录后面按需创建，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tree <span class="token parameter variable">--noreport</span> <span class="token parameter variable">-L</span> <span class="token number">2</span> tmstms├── cmd├── internal├── pkg└── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>另外，在设计目录结构时，一些空目录无法提交到 <code>Git</code> 仓库中，但我们又想将这个空目录上传到 <code>Git</code> 仓库中，以保留目录结构。这时候，可以在空目录下加一个 <code>.keep</code> 文件，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-A</span> build/ci/ .keep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们主要学习了怎么设计代码的目录结构。先讲了目录结构的设计思路：在设计目录结构时，要确保目录名是清晰的，功能是明确的，并且设计的目录结构是可扩展的。</p>
<p>然后，我们一起学习了 2 种具体的目录结构：结构化目录结构和平铺式目录结构。结构化目录结构比较适合 Go 应用，平铺式目录结构比较适合框架&#x2F;库。因为这2种目录结构组织比较合理，可以把它们作为目录规范来使用。</p>
<p>你还可以结合实战项目的例子，来加深对这两种目录结构的理解。对于结构化目录结构，你可以参考这门课 <a href="https://github.com/marmotedu/iam">IAM</a> 实战项目的目录结构；对于平铺式的目录结构，你可以参考这门课实战部分设计的 <a href="https://github.com/marmotedu/log">log</a> 包。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
      </tags>
  </entry>
  <entry>
    <title>04 | 研发流程设计</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-04-develop-step.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在Go 项目开发中，我们不仅要完成产品功能的开发，还要确保整个过程是高效的，代码是高质量的。这就离不开一套设计合理的研发流程了。</p>
<p>而一个不合理的研发流程会带来很多问题，例如：</p>
<ul>
<li><strong>代码管理混乱。</strong>合并代码时出现合错、合丢、代码冲突等问题。</li>
<li><strong>研发效率低。</strong>编译、测试、静态代码检查等全靠手动操作，效率低下。甚至，因为没有标准的流程，一些开发者会漏掉测试、静态代码检查等环节。</li>
<li><strong>发布效率低。</strong>发布周期长，以及发布不规范造成的现网问题频发。<span id="more"></span>
所以，<code>Go</code> 项目开发一定要设计一个合理的研发流程，来提高开发效率、减少软件维护成本。研发流程会因为项目、团队和开发模式等的不同而有所不同，但不同的研发流程依然会有一些相似点。</li>
</ul>
<p>那么如何设计研发流程呢？这也是你看到题目中“设计”两个字后，会直接想要问的。看到这俩字，你第一时间可能会觉得我是通过一系列的方法论，来告诉你怎么进行流程设计。但实际情况是，项目研发流程会因为团队、项目、需求等的不同而不同，很难概括出一个方法论让你去设计研发流程。</p>
<p>所以在这一讲中，我会介绍一种业界已经设计好的、相对标准的研发流程，来告诉你怎么设计研发流程。通过学习它，你不仅能够了解到项目研发的通用流程，而且还可以基于这个流程来优化、定制，满足你自己的流程需求。</p>
<h2 id="在设计研发流程时，需要关注哪些点？"><a href="#在设计研发流程时，需要关注哪些点？" class="headerlink" title="在设计研发流程时，需要关注哪些点？"></a>在设计研发流程时，需要关注哪些点？</h2><p>在看具体的研发流程之前，我们需要先思考一个问题：你觉得，一个好的流程应该是什么样子的？</p>
<p>虽然我们刚才说了，不同团队、项目、需求的研发流程不会一成不变，但为了最大限度地提高研发效能，这些不同的流程都会遵循下面这几个原则。</p>
<ul>
<li>发布效率高：研发流程应该能提高发布效率，减少发布时间和人工介入的工作量。</li>
<li>发布质量高：研发流程应该能够提高发布质量，确保发布出去的代码是经过充分测试的，并且完全避免人为因素造成的故障。</li>
<li>迭代速度快：整个研发流程要能支持快速迭代，产品迭代速度越快，意味着产品的竞争力越强，在互联网时代越能把握先机。</li>
<li>明确性：整个研发流程中角色的职责、使用的工具、方法和流程都应该是明确的，这可以增强流程的可执行性。</li>
<li>流程合理：研发流程最终是供产品、开发、测试、运维等人员使用的，所以整个流程设计不能是反人类的，要能够被各类参与人员接受并执行。</li>
<li>柔性扩展：研发流程应该是柔性且可扩展的，能够灵活变通，并适应各类场景。</li>
<li>输入输出：研发流程中的每个阶段都应该有明确的输入和输出，这些输入和输出标志着上一个阶段的完成，下一个阶段的开始。</li>
</ul>
<p>明确了这些关注点，我们就有了设计、优化研发流程的抓手了。接下来，我们就可以一起去学习一套业界相对标准的研发流程了。在学习的过程中，你也能更好地理解我对各个流程的一些经验和建议了。</p>
<h2 id="业界相对标准的研发流程"><a href="#业界相对标准的研发流程" class="headerlink" title="业界相对标准的研发流程"></a>业界相对标准的研发流程</h2><p>一个项目从立项到结项，中间会经历很多阶段。业界相对标准的划分，是把研发流程分为六个阶段，分别是需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段。其中，开发人员需要参与的阶段有4个：设计阶段、开发阶段、测试阶段和发布阶段。下图就是业界相对比较标准的流程：</p>
<p><a href="https://static001.geekbang.org/resource/image/ab/3b/ab6ac57696c0e90cf82624f78a82333b.png"><img src="https://static001.geekbang.org/resource/image/ab/3b/ab6ac57696c0e90cf82624f78a82333b.png"></a></p>
<p>每个阶段结束时，都需要有一个最终的产出物，可以是文档、代码或者部署组件等。这个产出物既是当前阶段的结束里程碑，又是下一阶段的输入。所以说，各个阶段不是割裂的，而是密切联系的整体。每个阶段又细分为很多步骤，这些步骤是需要不同的参与者去完成的工作任务。在完成任务的过程中，可能需要经过多轮的讨论、修改，最终形成定稿。</p>
<p>这里有个点我们一定要注意：研发流程也是一种规范，很难靠开发者的自觉性去遵守。为了让项目参与人员尽可能地遵守规范，需要借助一些工具、系统来对他们进行强约束。所以，在我们设计完整个研发流程之后，需要认真思考下，有哪些地方可以实现自动化，有哪些地方可以靠工具、系统来保障规范的执行。</p>
<h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h3><p>需求阶段是将一个抽象的产品思路具化成一个可实施产品的阶段。在这个阶段，产品人员会讨论产品思路、调研市场需求，并对需求进行分析，整理出一个比较完善的需求文档。最后，产品人员会组织相关人员对需求进行评审，如果评审通过，就会进入设计阶段。</p>
<p><strong>需求阶段，一般不需要研发人员参与。但这里，我还是建议你积极参与产品需求的讨论。</strong>虽然我们是研发，但我们的视野和对团队的贡献，可以不仅仅局限在研发领域。</p>
<p>这里有个点需要提醒你，如果你们团队有测试人员，这个阶段也需要拉测试人员旁听下。因为了解产品设计，对测试阶段测试用例的编写和功能测试等都很有帮助。</p>
<p>需求阶段的产出物是一个通过评审的详细的需求文档。</p>
<h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>设计阶段，是整个产品研发过程中非常重要的阶段，包括的内容也比较多，你可以看一下这张表：</p>
<p><a href="https://static001.geekbang.org/resource/image/81/1b/81296e3f9f0f90e77dd771ee4f61b71b.png"><img src="https://static001.geekbang.org/resource/image/81/1b/81296e3f9f0f90e77dd771ee4f61b71b.png"></a></p>
<p>这里的每一个设计项都应该经过反复的讨论、打磨，最终在团队内达成共识。这样可以确保设计是合理的，并减少返工的概率。<strong>这里想提醒你的是，技术方案和实现都要经过认真讨论，并获得一致通过，否则后面因为技术方案设计不当，需要返工，你要承担大部分责任。</strong></p>
<p>对于后端开发人员，在设计技术方案之前，要做好充足的调研。一个技术方案，不仅要调研业界优秀的实现，还要了解友商相同技术的实现。只有这样，才可以确保我们的技术用最佳的方式实现。</p>
<p>除此之外，在这个阶段一些设计项可以并行，以缩短设计阶段的耗时。例如，产品设计和技术设计可以并行展开。另外，如果你们团队有测试人员，研发阶段最好也拉上测试人员旁听下，有利于后面的测试。</p>
<p>该阶段的产出物是一系列的设计文档，这些文档会指导后面的整个研发流程。</p>
<h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>开发阶段，从它的名字你就知道了，这是开发人员的主战场，同时它可能也是持续时间最长的阶段。在这一阶段，开发人员根据技术设计文档，编码实现产品需求。</p>
<p>开发阶段是整个项目的核心阶段，包含很多工作内容，而且每一个 <code>Go</code> 项目具体的步骤是不同的。我把开发阶段的常见步骤总结在了下图中，帮助你对它进行整体把握。</p>
<p><a href="https://static001.geekbang.org/resource/image/13/57/137a2a20067d1472c9f00c6387a30857.png"><img src="https://static001.geekbang.org/resource/image/13/57/137a2a20067d1472c9f00c6387a30857.png"></a></p>
<p>让我们来详细看下这张图里呈现的步骤。<strong>开发阶段又可以分为“<code>开发</code>”和“<code>构建</code>”两部分</strong>，我们先来看开发。</p>
<p>首先，我们需要制定一个所有研发人员共同遵循的 <code>Git</code> 工作流规范。最常使用的是 <code>Git Flow</code> 工作流或者 <code>Forking</code> 工作流。</p>
<p>为了提高开发效率，越来越多的开发者采用生成代码的方式来生成一部分代码，所以在真正编译之前可能还需要先生成代码，比如生成 <code>.pb.go 文件</code>、<code>API 文档</code>、<code>测试用例</code>、<code>错误码</code>等。<strong>我的建议是，在项目开发中，你要思考怎么尽可能自动生成代码。</strong>这样不仅能提高研发效率，还能减少错误。</p>
<p>对于一个开源项目，我们可能还需要检查新增的文件是否有版权信息。此外，根据项目不同，开发阶段还可能有其它不同的步骤。在流程的最后，通常会进行静态代码检查、单元测试和编译。编译之后，我们就可以启动服务，并进行自测了。</p>
<p>自测之后，我们可以遵循 <code>Git Flow</code> 工作流，将开发分支 <code>push</code> 到代码托管平台进行 <code>code review</code>。<code>code review</code> 通过之后，我们就可以将代码 <code>merge</code> 到 <code>develop</code> 分支上。</p>
<p>接下来进入构建阶段。这一阶段最好借助 <code>CI/CD</code> 平台实现自动化，提高构建效率。</p>
<p>合并到 <code>develop</code> 分支的代码同样需要进行<code>代码扫描</code>、<code>单元测试</code>，并<code>编译打包</code>。最后，我们需要进行归档，也就是将编译后的二进制文件或 <code>Docker</code> 镜像上传到制品库或镜像仓库。</p>
<p>我刚刚带着你完整走了一遍开发阶段的常见步骤。可以看到，整个开发阶段步骤很多，而且都是高频的操作。那<strong>怎么提高效率呢</strong>？这里我推荐你两种方法：</p>
<ul>
<li>将开发阶段的步骤通过 <code>Makefile</code> 实现集中管理；</li>
<li>将构建阶段的步骤通过 <code>CI/CD</code> 平台实现自动化。</li>
</ul>
<p>你还需要特别注意这一点：<strong>在最终合并代码到 <code>master</code> 之前，要确保代码是经过充分测试的</strong>。这就要求我们一定要借助代码管理平台提供的 <code>Webhook</code> 能力，在代码提交时触发 <code>CI/CD</code> 作业，对代码进行扫描、测试，最终编译打包，并以整个作业的成功执行作为合并代码的先决条件。</p>
<p>开发阶段的产出物是满足需求的源代码、开发文档，以及编译后的归档文件。</p>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>测试阶段由测试工程师（也叫质量工程师）负责，这个阶段的主要流程是：测试工程师根据需求文档创建测试计划、编写测试用例，并拉研发同学一起评审测试计划和用例。评审通过后，测试工程师就会根据测试计划和测试用例对服务进行测试。</p>
<p><strong>为了提高整个研发效率，测试计划的创建和测试用例的编写可以跟开发阶段并行。</strong></p>
<p>研发人员在交付给测试时，要提供自测报告、自测用例和安装部署文档。<strong>这里我要强调的是：在测试阶段，为了不阻塞测试，确保项目按时发布，研发人员应该优先解决测试同学的Bug，至少是阻塞类的Bug。为了减少不必要的沟通和排障，安装部署文档要尽可能详尽和准确。</strong></p>
<p>另外，<strong>你也可以及时跟进测试，了解测试同学当前遇到的卡点</strong>。因为实际工作中，一些测试同学在遇到卡点时，不善于或者不会及时地跟你同步卡点，往往研发1分钟就可以解决的问题，可能要花测试同学几个小时或者更久的时间去解决。</p>
<p>当然，测试用例几乎不可能涵盖整个变更分支，所以对于一些难测，隐藏的测试，需要研发人员自己加强测试。</p>
<p>最后，一个大特性测试完，请测试同学吃个饭吧，大家唠唠家常，联络联络感情，下次合作会更顺畅。</p>
<p>测试阶段的产出物是满足产品需求、达到发布条件的源代码，以及编译后的归档文件。</p>
<h3 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h3><p>发布阶段主要是将软件部署上线，为了保证发布的效率和质量，我们需要遵循一定的发布流程，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/37/88/37yy6e0896daa8f97883631624996388.png"><img src="https://static001.geekbang.org/resource/image/37/88/37yy6e0896daa8f97883631624996388.png"></a></p>
<p>发布阶段按照时间线排序又分为代码发布、发布审批和服务发布3个子阶段。接下来，我详细给你介绍下这3个子阶段。我们先来看一下代码发布。</p>
<p><strong>首先，</strong>开发人员首先需要将经过测试后的代码合并到主干，通常是 <code>master</code> 分支，并生成版本号，然后给最新的 <code>commit</code> 打上版本标签。之后，可以将代码 <code>push</code> 到代码托管平台，并触发 <code>CI</code> 流程，<code>CI</code>流程一般会执行<code>代码扫描</code>、<code>单元测试</code>、<code>编译</code>，最后将构建产物发布到制品库。<code>CI</code>流程中，我们可以根据需要添加任意功能。</p>
<p><strong>接着，</strong>进入到发布审批阶段。首先需要申请资源，<strong>资源申请周期可能会比较久，所以申请得越早越好，甚至资源申请可以在测试阶段发起。</strong>在资源申请阶段，可以申请诸如服务器、<code>MySQL</code>、<code>Redis</code>、<code>Kafka</code> 之类资源。</p>
<p>资源申请通常是开发人员向运维人员提需求，由运维人员根据需求，在指定的时间前准备好各类资源。如果是物理机通常申请周期会比较久，但当前越来越多的项目选择容器化部署，这可以极大地缩短资源的申请周期。如果在像腾讯云弹性容器这类Serverless容器平台上部署业务，甚至可以秒申请资源。所以这里，我也建议优先采用容器化部署。</p>
<p>发布之前需要创建发布计划，里面需要详细描述本次的变更详情，例如变更范围、发布方案、测试结果、验证和回滚方案等。这里需要你注意，<strong>在创建发布计划时，一定要全面梳理这次变更的影响点。</strong>例如，是否有不兼容的变更，是否需要变更配置，是否需要变更数据库等。任何一个遗漏，都可能造成现网故障，影响产品声誉和用户使用。</p>
<p>接下来，需要创建发布单，在发布单中可以附上发布计划，并根据团队需求填写其它发布内容，发布计划需要跟相关参与者对齐流程、明确职责。发布单最终提交给审批人（通常是技术 leader）对本次发布进行审批，审批通过后，才可以进行部署。</p>
<p><strong>最后，</strong>就可以进入到服务发布阶段，将服务发布到现网。在正式部署的时候，应用需要先部署到预发环境。在预发环境，产品人员、测试人员和研发人员会分别对产品进行验证。其中，产品人员主要验证产品功能的体验是否流畅，开发和测试人员主要验证产品是否有 <code>Bug</code>。预发环境验证通过，产品才能正式发布到现网。</p>
<p>这里，我强烈建议，<strong>编写一些自动化的测试用例，在服务发布到现网之后，对现网服务做一次比较充分的回归测试。</strong>通过这个自动化测试，可以以最小的代价，最快速地验证现网功能，从而保障发布质量。</p>
<p>另外，我们还要注意，<strong>现网可能有多个地域，每个地域发布完成之后都要进行现网验证。</strong></p>
<p>发布阶段的产出物是正式上线的软件。</p>
<h3 id="运营阶段"><a href="#运营阶段" class="headerlink" title="运营阶段"></a>运营阶段</h3><p>研发流程的最后一个阶段是运营阶段，该阶段主要分为产品运营和运维两个部分。</p>
<ul>
<li><strong>产品运营</strong>：通过一系列的运营活动，比如线下的技术沙龙、线上的免费公开课、提高关键词排名或者输出一些技术推广文章等方式，来推高整个产品的知名度，提高产品的用户数量，并提高月活和日活。</li>
<li><strong>运维</strong>：由运维工程师负责，核心目标是确保系统稳定的运行，如果系统异常，能够及时发现并修复问题。长期目标是通过技术手段或者流程来完善整个系统架构，减少人力投入、提高运维效率，并提高系统的健壮性和恢复能力。</li>
</ul>
<p>从上面可以看到，运维属于技术类，运营属于产品类，这二者不要搞混。为了加深你的理解和记忆，我将这些内容，总结在了下面一张图中。</p>
<p><a href="https://static001.geekbang.org/resource/image/e0/b5/e0a4d8ed5f3a6a8a4bc4035e261881b5.png"><img src="https://static001.geekbang.org/resource/image/e0/b5/e0a4d8ed5f3a6a8a4bc4035e261881b5.png"></a></p>
<p>在运营阶段，研发人员的主要职责就是协助运维解决现网Bug，优化部署架构。当然，研发人员可能也需要配合运营人员开发一些运营接口，供运营人员使用。</p>
<p>到这里，业界相对标准的这套研发流程，我们就学完了。在学习过程中，你肯定也发现了，整个研发流程会涉及很多角色，不同角色参与不同的阶段，负责不同的任务。这里我再给你额外扩展一个点，就是这些核心角色和分工是啥样的。</p>
<p>这些扩展内容，我放在了一张图和一张表里。这些角色和分工比较好理解，也不需要你背下来，只要先有一个大概的印象就可以了。</p>
<p><a href="https://static001.geekbang.org/resource/image/d1/da/d1797845f4105476c99ecc22cc7562da.png"><img src="https://static001.geekbang.org/resource/image/d1/da/d1797845f4105476c99ecc22cc7562da.png"></a></p>
<p>具体分工如下表所示。</p>
<p><a href="https://static001.geekbang.org/resource/image/40/d5/40a1e20b153bb3ba1005cea4aefe62d5.png"><img src="https://static001.geekbang.org/resource/image/40/d5/40a1e20b153bb3ba1005cea4aefe62d5.png"></a></p>
<p>在开发Go项目时，掌握项目的研发流程很重要。掌握研发流程，会让项目研发对我们更加白盒，并且有利于我们制定详细的工作任务。</p>
<p>那么如何设计项目研发流程呢？你可以根据需要自行设计。自行设计时有些点是一定要关注的，例如我们的流程需要支持高的发布效率和发布质量，支持快速迭代，流程是合理、可扩展的，等等。</p>
<p>这套研发流程包含6个阶段：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段和运营阶段。这里我将这些流程和每个流程的核心点总结在下面一张图中。</p>
<p><a href="https://static001.geekbang.org/resource/image/dd/0f/ddb314275ba1bab28413221bc56ac80f.png"><img src="https://static001.geekbang.org/resource/image/dd/0f/ddb314275ba1bab28413221bc56ac80f.png"></a></p>
<h2 id="应用生命周期管理技术有哪些？"><a href="#应用生命周期管理技术有哪些？" class="headerlink" title="应用生命周期管理技术有哪些？"></a>应用生命周期管理技术有哪些？</h2><p>那么，有哪些应用生命周期管理技术呢？</p>
<p>在这里我先整体介绍一下，你先有个大致的印象，一会我们再一个个细讲。我们可以<strong>从两个维度来理解应用生命周期管理技术</strong>。</p>
<p>第一个维度是演进维度。应用生命周期，最开始主要是通过研发模式来管理的，按时间线先后出现了瀑布模式、迭代模式、敏捷模式。接着，为了解决研发模式中的一些痛点出现了另一种管理技术，也就是<code>CI/CD</code>技术。随着<code>CI/CD</code>技术的成熟，又催生了另一种更高级的管理技术<code>DevOps</code>。</p>
<p>第二个维度是管理技术的类别。应用生命周期管理技术可以分为两类：</p>
<ul>
<li>研发模式，用来确保整个研发流程是高效的。</li>
<li>DevOps，主要通过协调各个部门之间的合作，来提高软件的发布效率和质量。DevOps中又包含了很多种技术，主要包括<code>CI/CD</code>和多种<code>Ops</code>，例如<code>AIOps</code>、<code>ChatOps</code>、<code>GitOps</code>、<code>NoOps</code>等。其中，<code>CI/CD</code> 技术提高了软件的发布效率和质量，而<code>Ops</code>技术则提高了软件的运维和运营效率。</li>
</ul>
<p>尽管这些应用生命周期管理技术有很多不同，但是它们彼此支持、相互联系。研发模式专注于<strong>开发过程</strong>，<code>DevOps</code>技术里的<code>CI/CD</code> 专注于<strong>流程</strong>，<code>Ops</code>则专注于<strong>实战。</strong></p>
<p>为了帮助你理解，我总结出了下面这张图供你参考。</p>
<p><a href="https://static001.geekbang.org/resource/image/9a/a3/9a290c28b0c238dd69e24dcc9f5c7ea3.png"><img src="https://static001.geekbang.org/resource/image/9a/a3/9a290c28b0c238dd69e24dcc9f5c7ea3.png"></a></p>
<p>这两个维度涉及的管理技术虽然不少，但一共就是那几类。所以，**为了能够逻辑清晰地给你讲解明白这些技术，我会从演进维度来展开，也就是按照这样的顺序：研发模式（瀑布模式 -&gt; 迭代模式 -&gt; 敏捷模式） -&gt; <code>CI/CD</code> -&gt; <code>DevOps</code>**。</p>
<p>你可能会问了，既然是演进，那这些技术肯定有优劣之分，我应该怎么选择呢，一定是选择后面出现的技术吗？</p>
<p>为了解决你的这个问题，这里，对于研发模式和<code>DevOps</code>这两类技术的选择，我提前给出我的建议：<strong>研发模式建议选择敏捷模式，因为它更能胜任互联网时代快速迭代的诉求。<code>DevOps</code>则要优先确保落地<code>CI/CD</code>技术，接着尝试落地<code>ChatOps</code>技术，如果有条件可以积极探索<code>AIOps</code>和<code>GitOps</code>。</strong></p>
<p>接下来，我们就详细说说这些应用生命周期的管理方法，先来看专注于开发过程的研发模式部分。</p>
<h2 id="研发模式"><a href="#研发模式" class="headerlink" title="研发模式"></a>研发模式</h2><p>研发模式主要有三种，演进顺序为 瀑布模式-&gt;迭代模式-&gt;敏捷模式，现在我们逐一看下。</p>
<h3 id="瀑布模式"><a href="#瀑布模式" class="headerlink" title="瀑布模式"></a>瀑布模式</h3><p>在早期阶段，软件研发普遍采用的是瀑布模式，像我们熟知的<code>RHEL</code>、<code>Fedora</code>等系统就是采用瀑布模式。</p>
<p>瀑布模式按照预先规划好的研发阶段来推进研发进度。比如，按照需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段的顺序串行执行开发任务。每个阶段完美完成之后，才会进入到下一阶段，阶段之间通过文档进行交付。整个过程如下图所示。</p>
<p><a href="https://static001.geekbang.org/resource/image/7c/89/7ccc702a02cf24e2295cc50a506e6289.png"><img src="https://static001.geekbang.org/resource/image/7c/89/7ccc702a02cf24e2295cc50a506e6289.png"></a></p>
<p>瀑布模式最大的优点是简单。它严格按照研发阶段来推进研发进度，流程清晰，适合按项目交付的应用。</p>
<p>但它的缺点也很明显，最突出的就是这两个：</p>
<ul>
<li>只有在项目研发的最后阶段才会交付给客户。交付后，如果客户发现问题，变更就会非常困难，代价很大。</li>
<li>研发周期比较长，很难适应互联网时代对产品快速迭代的诉求。</li>
</ul>
<p>为了解决这两个问题，迭代式研发模式诞生了。</p>
<h3 id="迭代模式"><a href="#迭代模式" class="headerlink" title="迭代模式"></a>迭代模式</h3><p>迭代模式，是一种与瀑布式模式完全相反的开发过程：研发任务被切分为一系列轮次，每一个轮次都是一个迭代，每一次迭代都是一个从设计到实现的完整过程。它<strong>不要求每一个阶段的任务都做到最完美，而是先把主要功能搭建起来，然后再通过客户的反馈信息不断完善</strong>。</p>
<p>迭代开发可以帮助产品改进和把控进度，它的灵活性极大地提升了适应需求变化的能力，克服了高风险、难变更、复用性低的特点。</p>
<p>但是，迭代模式的问题在于比较专注于开发过程，很少从项目管理的视角去加速和优化项目开发过程。接下来要讲的敏捷模式，就弥补了这个缺点。</p>
<h3 id="敏捷模式"><a href="#敏捷模式" class="headerlink" title="敏捷模式"></a>敏捷模式</h3><p>敏捷模式把一个大的需求分成多个、可分阶段完成的小迭代，每个迭代交付的都是一个可使用的软件。在开发过程中，软件要一直处于可使用状态。</p>
<p>敏捷模式中具有代表性的开发模式，是<code>Scrum</code>开发模型。<code>Scrum</code>开发模型网上有很多介绍，你可以去看看。</p>
<p>在敏捷模式中，我们会把一个大的需求拆分成很多小的迭代，这意味着开发过程中会有很多个开发、构建、测试、发布和部署的流程。这种高频度的操作会给研发、运维和测试人员带来很大的工作量，降低了工作效率。为了解决这个问题，<code>CI/CD</code>技术诞生了。</p>
<h2 id="CI-x2F-CD：自动化构建和部署应用"><a href="#CI-x2F-CD：自动化构建和部署应用" class="headerlink" title="CI&#x2F;CD：自动化构建和部署应用"></a>CI&#x2F;CD：自动化构建和部署应用</h2><p><code>CI/CD</code>技术通过自动化的手段，来快速执行代码检查、测试、构建、部署等任务，从而提高研发效率，解决敏捷模式带来的弊端。</p>
<p><code>CI/CD</code>包含了<code>3</code>个核心概念。</p>
<ul>
<li><strong>CI</strong>：<code>Continuous Integration</code>，持续集成。</li>
<li><strong>CD</strong>：<code>Continuous Delivery</code>，持续交付。</li>
<li><strong>CD</strong>：<code>Continuous Deployment</code>，持续部署。</li>
</ul>
<p><code>CI</code>容易理解，但两个<code>CD</code>很多开发者区分不开。这里，我来详细说说这<code>3</code>个核心概念。</p>
<p><strong>首先是持续集成。</strong>它的含义为：频繁地（一天多次）将开发者的代码合并到主干上。它的流程为：在开发人员完成代码开发，并<code>push</code>到<code>Git</code>仓库后，<code>CI</code>工具可以立即对代码进行扫描、（单元）测试和构建，并将结果反馈给开发者。持续集成通过后，会将代码合并到主干。</p>
<p><code>CI</code>流程可以使应用软件的问题在开发阶段就暴露出来，这会让开发人员交付代码时更有信心。因为CI流程内容比较多，而且执行比较频繁，所以<code>CI</code>流程需要有自动化工具来支撑。</p>
<p><strong>其次是持续交付，</strong>它指的是一种能够使软件在较短的循环中可靠发布的软件方法。</p>
<p>持续交付在持续集成的基础上，将构建后的产物自动部署在目标环境中。这里的目标环境，可以是测试环境、预发环境或者现网环境。</p>
<p>通常来说，持续部署可以自动地将服务部署到测试环境或者预发环境。因为部署到现网环境存在一定的风险，所以如果部署到现网环境，需要手工操作。手工操作的好处是，可以使相关人员评估发布风险，确保发布的正确性。</p>
<p><strong>最后是持续部署，</strong>持续部署在持续交付的基础上，将经过充分测试的代码自动部署到生产环境，整个流程不再需要相关人员的审核。持续部署强调的是自动化部署，是交付的最高阶段。</p>
<p>我们可以借助下面这张图，来了解持续集成、持续交付、持续部署的关系。</p>
<p><a href="https://static001.geekbang.org/resource/image/96/d0/963b9983543de3d66379567ba491d7d0.png"><img src="https://static001.geekbang.org/resource/image/96/d0/963b9983543de3d66379567ba491d7d0.png"></a></p>
<p>持续集成、持续交付和持续部署强调的是持续性，也就是能够支持频繁的集成、交付和部署，这离不开自动化工具的支持，离开了这些工具，<code>CI/CD</code>就不再具有可实施性。持续集成的核心点在<strong>代码</strong>，持续交付的核心点在<strong>可交付的产物</strong>，持续部署的核心点在<strong>自动部署。</strong></p>
<h2 id="DevOps：研发运维一体化"><a href="#DevOps：研发运维一体化" class="headerlink" title="DevOps：研发运维一体化"></a>DevOps：研发运维一体化</h2><p><code>CI/CD</code>技术的成熟，加速了<code>DevOps</code>这种应用生命周期管理技术的成熟和落地。</p>
<p><code>DevOps</code>（Development和Operations的组合）是<strong>一组过程、方法与系统的统称</strong>，用于促进开发（应用程序&#x2F;软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。这3个部门的相互协作，可以提高软件质量、快速发布软件。如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/c8/79/c81a361fb98500cec8c866f465f14679.png"><img src="https://static001.geekbang.org/resource/image/c8/79/c81a361fb98500cec8c866f465f14679.png"></a></p>
<p>要实现<code>DevOps</code>，需要一些工具或者流程的支持，<code>CI/CD</code>可以很好地支持<code>DevOps</code>这种软件开发模式，如果没有<code>CI/CD</code>自动化的工具和流程，<code>DevOps</code>就是没有意义的，<code>CI/CD</code>使得<code>DevOps</code>变得可行。</p>
<p>听到这里是不是有些晕？你可能想问，<code>DevOps</code>跟<code>CI/CD</code>到底是啥区别呢？其实，这也是困扰很多开发者的问题。这里，我们可以这么理解：<code>DevOps</code> <code>！=</code> <code>CI/CD</code>。<code>DevOps</code>是一组过程、方法和系统的统称，而<code>CI/CD</code>只是一种软件构建和发布的技术。</p>
<p><code>DevOps</code>技术之前一直有，但是落地不好，因为没有一个好的工具来实现<code>DevOps</code>的理念。但是随着<code>容器</code>、<code>CI/CD</code>技术的诞生和成熟，<code>DevOps</code>变得更加容易落地。也就是说，这几年越来越多的人采用<code>DevOps</code>手段来提高研发效能。</p>
<p>随着技术的发展，目前已经诞生了很多<code>Ops</code>手段，来实现运维和运营的高度自动化。下面，我们就来看看<code>DevOps</code>中的四个<code>Ops</code>手段：<code>AIOps</code>、<code>ChatOps</code>、<code>GitOps</code>、<code>NoOps</code>。</p>
<h3 id="AIOps：智能运维"><a href="#AIOps：智能运维" class="headerlink" title="AIOps：智能运维"></a>AIOps：智能运维</h3><p>在2016年，<code>Gartner</code>提出利用<code>AI</code>技术的新一代<code>IT运维</code>，即<code>AIOps</code>（智能运维）。通过<code>AI</code>手段，来智能化地运维<code>IT</code>系统。<code>AIOps</code>通过搜集海量的运维数据，并利用机器学习算法，智能地定位并修复故障。</p>
<p>也就是说，<code>AIOps</code>在自动化的基础上，增加了智能化，从而进一步推动了<code>IT运维自动化</code>，减少了人力成本。</p>
<p>随着<code>IT</code>基础设施规模和复杂度的倍数增长，企业应用规模、数量的指数级增长，传统的人工&#x2F;自动化运维，已经无法胜任愈加沉重的运维工作，而<code>AIOps</code>提供了一个解决方案。在腾讯、阿里等大厂很多团队已经在尝试和使用<code>AIOps</code>，并享受到了<code>AIOps</code>带来的红利。例如，故障告警更加灵敏、准确，一些常见的故障，可以自动修复，无须运维人员介入等。</p>
<h3 id="ChatOps：聊着天就把事情给办了"><a href="#ChatOps：聊着天就把事情给办了" class="headerlink" title="ChatOps：聊着天就把事情给办了"></a>ChatOps：聊着天就把事情给办了</h3><p>随着企业微信、钉钉等企业内通讯工具的兴起，最近几年出现了一个新的概念<code>ChatOps</code>。</p>
<p>简单来说，<code>ChatOps</code>就是在一个聊天工具中，发送一条命令给 <code>ChatBot</code> 机器人，然后 <code>ChatBot</code>会执行预定义的操作。这些操作可以是执行某个工具、调用某个接口等，并返回执行结果。</p>
<p>这种新型智能工作方式的优势是什么呢？它可以利用 <code>ChatBot</code> 机器人让团队成员和各项辅助工具连接在一起，以沟通驱动的方式完成工作。<code>ChatOps</code>可以解决人与人、人与工具、工具与工具之间的信息孤岛，从而提高协作体验和工作效率。</p>
<p><code>ChatOps</code>的工作流程如下图所示（网图）：</p>
<p><a href="https://static001.geekbang.org/resource/image/29/6e/292372572f1fa8cae9a44891bd233a6e.png"><img src="https://static001.geekbang.org/resource/image/29/6e/292372572f1fa8cae9a44891bd233a6e.png"></a></p>
<p>开发&#x2F;运维&#x2F;测试人员通过@聊天窗口中的机器人Bot来触发任务，机器人后端会通过API接口调用等方式对接不同的系统，完成不同的任务，例如持续集成、测试、发布等工作。机器人可以是我们自己研发的，也可以是开源的。目前，业界有很多流行的机器人可供选择，常用的有<code>Hubot</code>、<code>Lita</code>、<code>Errbot</code>、<code>StackStorm</code>等。</p>
<p>使用<code>ChatOps</code>可以带来以下几点好处。</p>
<ul>
<li><strong>友好、便捷</strong>：所有的操作均在同一个聊天界面中，通过<code>@机器人</code>以聊天的方式发送命令，免去了打开不同系统，执行不同操作的繁琐操作，方式更加友好和便捷。</li>
<li><strong>信息透明</strong>：在同一个聊天界面中的所有同事都能够看到其他同事发送的命令，以及命令执行的结果，可以消除沟通壁垒，工作历史有迹可循，团队合作更加顺畅。</li>
<li><strong>移动友好</strong>：可以在移动端向机器人发送命令、执行任务，让移动办公变为可能。</li>
<li><strong>DevOps 文化打造</strong>：通过与机器人对话，可以降低项目开发中，各参与人员的理解和使用成本，从而使<code>DevOps</code>更容易落地和推广。</li>
</ul>
<h3 id="GitOps：-一种实现云原生的持续交付模型"><a href="#GitOps：-一种实现云原生的持续交付模型" class="headerlink" title="GitOps： 一种实现云原生的持续交付模型"></a>GitOps： 一种实现云原生的持续交付模型</h3><p><code>GitOps</code>是一种持续交付的方式。它的核心思想是将应用系统的声明性基础架构（<code>YAML</code>）和应用程序存放在Git版本库中。将<code>Git</code>作为交付流水线的核心，每个开发人员都可以提交拉取请求（<code>Pull Request</code>），并使用<code>Git</code>来加速和简化<code>Kubernetes</code>的应用程序部署和运维任务。</p>
<p>通过Git这样的工具，开发人员可以将精力聚焦在功能开发，而不是软件运维上，以此提高软件的开发效率和迭代速度。</p>
<p>使用GitOps可以带来很多优点，其中最核心的是：当使用<code>Git</code>变更代码时，<code>GitOps</code>可以自动将这些变更应用到程序的基础架构上。因为整个流程都是自动化的，所以部署时间更短；又因为<code>Git</code>代码是可追溯的，所以我们部署的应用也能够稳定且可重现地回滚。</p>
<p>我们可以从概念和流程上来理解<code>GitOps</code>，它有3个关键概念。</p>
<ul>
<li><strong>声明性容器编排</strong>：通过<code>Kubernetes YAML</code>格式的资源定义文件，来定义如何部署应用。</li>
<li><strong>不可变基础设施</strong>：基础设施中的每个组件都可以自动的部署，组件在部署完成后，不能发生变更。如果需要变更，则需要重新部署一个新的组件。例如，<code>Kubernetes</code>中的<code>Pod</code>就是一个不可变基础设施。</li>
<li><strong>连续同步</strong>：不断地查看<code>Git</code>存储库，将任何状态更改反映到<code>Kubernetes</code>集群中。</li>
</ul>
<p><a href="https://static001.geekbang.org/resource/image/2f/8d/2f1b427674e7da60668b2af42cf7338d.png" title="GitOps的工作流程图"><img src="https://static001.geekbang.org/resource/image/2f/8d/2f1b427674e7da60668b2af42cf7338d.png" title="GitOps的工作流程图"></a></p>
<p><a href="https://static001.geekbang.org/resource/image/2f/8d/2f1b427674e7da60668b2af42cf7338d.png" title="GitOps的工作流程图">GitOps的工作流程图</a></p>
<p><code>GitOps</code>的工作流程如下：</p>
<p><strong>首先，</strong>开发人员开发完代码后推送到<code>Git</code>仓库，触发<code>CI</code>流程，<code>CI</code>流程通过编译构建出<code>Docker</code>镜像，并将镜像<code>push</code>到<code>Docker</code>镜像仓库中。<code>Push</code>动作会触发一个<code>push</code>事件，通过<code>webhook</code>的形式通知到<code>Config Updater</code>服务，<code>Config Updater</code>服务会从 <code>webhook</code> 请求中获取最新 <code>push</code> 的镜像名，并更新<code>Git</code>仓库中的<code>Kubernetes YAML</code>文件。</p>
<p><strong>然后，</strong><code>GitOps</code>的<code>Deploy Operator</code>服务，检测到<code>YAML</code>文件的变动，会重新从<code>Git</code>仓库中提取变更的文件，并将镜像部署到<code>Kubernetes</code>集群中。<code>Config Updater</code> 和 <code>Deploy Operator</code> 两个组件需要开发人员设计开发。</p>
<h3 id="NoOps：无运维"><a href="#NoOps：无运维" class="headerlink" title="NoOps：无运维"></a>NoOps：无运维</h3><p><code>NoOps</code>即无运维，完全自动化的运维。在<code>NoOps</code>中不再需要开发人员、运营运维人员的协同，把微服务、低代码、无服务全都结合了起来，开发者在软件生命周期中只需要聚焦业务开发即可，所有的维护都交由云厂商来完成。</p>
<p>毫无疑问，<code>NoOps</code>是运维的终极形态，在我看来它像<code>DevOps</code>一样，更多的是一种理念，需要很多的技术和手段来支撑。当前整个运维技术的发展，也是朝着<code>NoOps</code>的方向去演进的，例如<code>GitOps</code>、<code>AIOps</code>可以使我们尽可能减少运维，<code>Serverless</code>技术甚至可以使我们免运维。相信未来<code>NoOps</code>会像现在的<code>Serverless</code>一样，成为一种流行的、可落地的理念。</p>
<h2 id="如何选择合适的应用生命周期管理技术？"><a href="#如何选择合适的应用生命周期管理技术？" class="headerlink" title="如何选择合适的应用生命周期管理技术？"></a>如何选择合适的应用生命周期管理技术？</h2><p>好了，到这里我们就把主要的应用生命周期管理技术，学得差不多了。那在实际开发中，如何选择适合自己的呢？在我看来，你可以从这么几个方面考虑。</p>
<p><strong>首先，</strong>根据团队、项目选择一个合适的研发模式。如果项目比较大，需求变更频繁、要求快速迭代，建议选择敏捷开发模式。敏捷开发模式，也是很多大公司选择的研发模式，在互联网时代很受欢迎。</p>
<p><strong>接着，</strong>要建立自己的<code>CI/CD</code>流程。任何变更代码在合并到master分支时，一定要通过<code>CI/CD</code>的流程的验证。我建议，你在<code>CI/CD</code>流程中设置质量红线，确保合并代码的质量。</p>
<p><strong>接着，</strong>除了建立<code>CI/CD</code>系统，我还建议将ChatOps带入工作中，尽可能地将可以自动化的工作实现自动化，并通过<code>ChatOps</code>来触发自动化流程。随着企业微信、钉钉等企业聊天软件成熟和发展，<code>ChatOps</code>变得流行和完善。</p>
<p><strong>最后，</strong><code>GitOps</code>、<code>AIOps</code>可以将部署和运维自动化做到极致，在团队有人力的情况下，值得探索。</p>
<p>到这里你可能会问了，大厂是如何管理应用生命周期的？</p>
<p><strong>大厂普遍采用敏捷开发的模式，来适应互联网对应用快速迭代的诉求。</strong>例如，腾讯的<a href="https://www.tapd.cn/">TAPD</a>、<a href="https://coding.net/">Coding</a>的<code>Scrum</code>敏捷管理就是一个敏捷开发平台。**<code>CI/CD</code>强制落地，<code>ChatOps</code>已经广泛使用，<code>AIOps</code>也有很多落地案例，<code>GitOps</code>目前还在探索阶段，<code>NoOps</code>还处在理论阶段。**</p>
<p>这一讲，我从技术演进的维度介绍了应用生命周期管理技术，这些技术可以提高应用的研发效率和质量。</p>
<p>应用生命周期管理最开始是通过研发模式来管理的。在研发模式中，我按时间线分别介绍了瀑布模式、迭代模式和敏捷模式，其中的敏捷模式适应了互联网时代对应用快速迭代的诉求，所以用得越来越多。</p>
<p>在敏捷模式中，我们需要频繁构建和发布我们的应用，这就给开发人员带来了额外的工作量，为了解决这个问题，出现了<code>CI/CD</code>技术。<code>CI/CD</code>可以将代码的检查、测试、构建和部署等工作自动化，不仅提高了研发效率，还从一定程度上保障了代码的质量。另外，<code>CI/CD</code>技术使得<code>DevOps</code>变得可行，当前越来越多的团队采用<code>DevOps</code>来管理应用的生命周期。</p>
<p>几个容易搞混的概念。</p>
<ul>
<li>持续交付和持续部署。二者都是持续地部署应用，但是持续部署整个过程是自动化的，而持续交付中，应用在发布到现网前需要人工审批是否允许发布。</li>
<li><code>CI/CD</code>和<code>DevOps</code>。<code>DevOps</code>是一组过程、方法与系统的统称，其中也包含了<code>CI/CD</code>技术。而<code>CI/CD</code>是一种自动化的技术，<code>DevOps</code>理念的落地需要<code>CI/CD</code>技术的支持。</li>
</ul>
<p>最后，关于如何管理应用的生命周期，建议：<strong>研发模式建议选择敏捷模式</strong>，因为它更能胜任互联网时代快速迭代的诉求。DevOps则要<strong>优先确保落地<code>CI/CD</code>技术</strong>，接着尝试落地<code>ChatOps</code>技术，如果有条件可以积极探索<code>AIOps</code>和<code>GitOps</code>。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>研发流程</tag>
      </tags>
  </entry>
  <entry>
    <title>05 | 设计方法：怎么写出优雅的 Go 项目</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-05-how-to-go.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<h2 id="如何写出优雅的Go项目？"><a href="#如何写出优雅的Go项目？" class="headerlink" title="如何写出优雅的Go项目？"></a>如何写出优雅的Go项目？</h2><p>那么，如何写出一个<strong>优雅</strong>的**<code>Go</code>项目**呢？在回答这个问题之前，我们先来看另外两个问题：</p>
<p><em><strong>1.  为什么是<code>Go</code>项目，而不是<code>Go</code>应用？</strong></em><br><em><strong>2.  一个优雅的<code>Go</code>项目具有哪些特点？</strong></em></p>
<p>先来看第一个问题。<code>Go</code>项目是一个偏工程化的概念，不仅包含了<code>Go</code>应用，还包含了项目管理和项目文档：</p>
<p><a href="https://static001.geekbang.org/resource/image/24/aa/24ba3548f8574a747b51e291224097aa.png"><img src="https://static001.geekbang.org/resource/image/24/aa/24ba3548f8574a747b51e291224097aa.png"></a></p>
<p>这就来到了第二个问题，一个优雅的<code>Go</code>项目，不仅要求我们的<code>Go</code>应用是优雅的，还要确保我们的项目管理和文档也是优雅的。这样，我们根据前面几讲学到的<code>Go</code>设计规范，很容易就能总结出一个优雅的<code>Go</code>应用需要具备的特点：</p>
<span id="more"></span>
<ul>
<li>符合<code>Go</code>编码规范和最佳实践；</li>
<li>易阅读、易理解，易维护；</li>
<li>易测试、易扩展；</li>
<li>代码质量高。</li>
</ul>
<p>解决了这两个问题，让我们回到这一讲的核心问题：如何写出优雅的<code>Go</code>项目？</p>
<p>写出一个优雅的<code>Go</code>项目，在我看来，就是<strong>用“最佳实践”的方式去实现<code>Go</code>项目中的<code>Go</code>应用、项目管理和项目文档</strong>。具体来说，就是编写高质量的<code>Go</code>应用、高效管理项目、编写高质量的项目文档。</p>
<p>为了协助你理解，我将这些逻辑绘制成了下面一张图。</p>
<p><a href="https://static001.geekbang.org/resource/image/77/03/77d541223576135df4c3d511abbfe603.png"><img src="https://static001.geekbang.org/resource/image/77/03/77d541223576135df4c3d511abbfe603.png"></a></p>
<p>接下来，我们就看看如何根据前面几讲学习的<code>Go</code>项目设计规范，实现一个优雅的<code>Go</code>项目。我们先从编写高质量的<code>Go</code>应用看起。</p>
<h2 id="编写高质量的Go应用"><a href="#编写高质量的Go应用" class="headerlink" title="编写高质量的Go应用"></a>编写高质量的Go应用</h2><p>基于我的研发经验，要编写一个高质量的<code>Go</code>应用，其实可以归纳为5个方面：<code>代码结构</code>、<code>代码规范</code>、<code>代码质量</code>、<code>编程哲学</code>和<code>软件设计</code>方法，见下图。</p>
<p><a href="https://static001.geekbang.org/resource/image/23/69/2392d94feb95d3d64d765abe7d6e5e69.png"><img src="https://static001.geekbang.org/resource/image/23/69/2392d94feb95d3d64d765abe7d6e5e69.png"></a></p>
<p>接下来，我们详细说说这些内容。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>为什么先说代码结构呢？因为组织合理的代码结构是一个项目的门面。我们可以通过两个手段来组织代码结构。</p>
<p>第一个手段是，组织一个好的目录结构。关于如何组合一个好的目录结构，你可以回顾 <a href="https://time.geekbang.org/column/article/381392">06讲</a> 的内容。</p>
<p>第二个手段是，选择一个好的模块拆分方法。做好模块拆分，可以使项目内模块职责分明，做到低耦合高内聚。</p>
<p>那么<code>Go</code>项目开发中，如何拆分模块呢？目前业界有两种拆分方法，分别是按层拆分和按功能拆分。</p>
<p><strong>首先，我们看下按层拆分</strong>，最典型的是<code>MVC</code>架构中的模块拆分方式。在<code>MVC</code>架构中，我们将服务中的不同组件按访问顺序，拆分成了<code>Model</code>、<code>View</code>和<code>Controller</code>三层。</p>
<p><a href="https://static001.geekbang.org/resource/image/ed/46/ed0c3dfyy52ac82539cb602eec9f0146.png"><img src="https://static001.geekbang.org/resource/image/ed/46/ed0c3dfyy52ac82539cb602eec9f0146.png"></a></p>
<p>每层完成不同的功能：</p>
<ul>
<li><code>View</code>（视图）是提供给用户的操作界面，用来处理数据的显示。</li>
<li><code>Controller</code>（控制器），负责根据用户从 <code>View</code> 层输入的指令，选取 <code>Model</code> 层中的数据，然后对其进行相应的操作，产生最终结果。</li>
<li><code>Model</code>（模型），是应用程序中用于处理数据逻辑的部分。</li>
</ul>
<p>我们看一个典型的按层拆分的目录结构：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tree <span class="token parameter variable">--noreport</span> <span class="token parameter variable">-L</span> <span class="token number">2</span> layers
layers
├── controllers│
    ├── billing│
    ├── order│
    └── user
├── models│
    ├── billing.go
│   ├── order.go
│   └── user.go
└── views
└── layouts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>Go</code>项目中，按层拆分会带来很多问题。最大的问题是循环引用：相同功能可能在不同层被使用到，而这些功能又分散在不同的层中，很容易造成循环引用。</p>
<p>所以，<strong>你只要大概知道按层拆分是什么意思就够了，在<code>Go</code>项目中我建议你使用的是按功能拆分的方法，这也是<code>Go</code>项目中最常见的拆分方法。</strong></p>
<p>那什么是按功能拆分呢？我给你看一个例子你就明白了。比如，一个订单系统，我们可以根据不同功能将其拆分成<code>用户（user</code>）、<code>订单（order）</code>和<code>计费（billing）</code>3个模块，每一个模块提供独立的功能，功能更单一：</p>
<p><a href="https://static001.geekbang.org/resource/image/0d/a5/0d65eb1363bf8055e209bc24d1d99ca5.png"><img src="https://static001.geekbang.org/resource/image/0d/a5/0d65eb1363bf8055e209bc24d1d99ca5.png"></a></p>
<p>下面是该订单系统的代码目录结构：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tree pkg
tree <span class="token parameter variable">--noreport</span> <span class="token parameter variable">-L</span> <span class="token number">2</span> pkg
pkg
├── billing
├── order
│   └── order.go
└── user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相较于按层拆分，按功能拆分模块带来的好处也很好理解：</p>
<ul>
<li>不同模块，功能单一，可以实现高内聚低耦合的设计哲学。</li>
<li>因为所有的功能只需要实现一次，引用逻辑清晰，会大大减少出现循环引用的概率。</li>
</ul>
<p>所以，有很多优秀的<code>Go</code>项目采用的都是按功能拆分的模块拆分方式，例如 <code>Kubernetes</code>、<code>Docker</code>、<code>Helm</code>、<code>Prometheus</code>等。</p>
<p>除了组织合理的代码结构这种方式外，编写高质量<code>Go</code>应用的另外一个行之有效的方法，是遵循<code>Go</code>语言代码规范来编写代码。在我看来，这也是最容易出效果的方式。</p>
<h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>那我们要遵循哪些代码规范来编写<code>Go</code>应用呢？在我看来，其实就两类：编码规范和最佳实践。</p>
<p><strong>首先，我们的代码要符合<code>Go</code>编码规范，这是最容易实现的途径</strong>。<code>Go</code>社区有很多这类规范可供参考，其中，比较受欢迎的是<a href="https://github.com/xxjwxc/uber_go_guide_cn">Uber <code>Go</code> 语言编码规范</a>。</p>
<p>阅读这些规范确实有用，也确实花时间、花精力。所以，我在参考了已有的很多规范后，结合自己写<code>Go</code>代码的经验，特地为你整理了一篇<code>Go</code>编码规范作为加餐，也就是“特别放送 | 给你一份清晰、可直接套用的<code>Go</code>编码规范”。</p>
<p>有了可以参考的编码规范之后，我们需要扩展到团队、部门甚至公司层面。只有大家一起参与、遵守，规范才会变得有意义。其实，我们都清楚，要开发者靠自觉来遵守所有的编码规范，不是一件容易的事儿。这时候，我们可以使用静态代码检查工具，来约束开发者的行为。</p>
<p>有了静态代码检查工具后，不仅可以确保开发者写出的每一行代码都是符合<code>Go</code>编码规范的，还可以将静态代码检查集成到<code>CI/CD</code>流程中。这样，在代码提交后自动地检查代码，就保证了只有符合编码规范的代码，才会被合入主干。</p>
<p><code>Go</code>语言的静态代码检查工具有很多，目前用的最多的是<a href="https://github.com/golangci/golangci-lint">golangci-lint</a>，这也是我极力推荐你使用的一个工具。</p>
<p>除了遵循编码规范，<strong>要想成为<code>Go</code>编程高手，你还得学习并遵循一些最佳实践</strong>。“最佳实践”是社区经过多年探索沉淀下来的、符合<code>Go</code>语言特色的经验和共识，它可以帮助你开发出一个高质量的代码。</p>
<p>这里我给你推荐几篇介绍<code>Go</code>语言最佳实践的文章，供你参考：</p>
<ul>
<li><a href="https://golang.org/doc/effective_go">Effective Go</a>：高效<code>Go</code>编程，由<code>Golang</code>官方编写，里面包含了编写<code>Go</code>代码的一些建议，也可以理解为最佳实践。</li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a>：<code>Golang</code>官方编写的<code>Go</code>最佳实践，作为<code>Effective Go</code>的补充。</li>
<li><a href="https://rakyll.org/style-packages/">Style guideline for Go packages</a>：包含了如何组织<code>Go</code>包、如何命名<code>Go</code>包、如何写<code>Go</code>包文档的一些建议。</li>
</ul>
<h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><p>有了组织合理的代码结构、符合<code>Go</code>语言代码规范的<code>Go</code>应用代码之后，我们还需要通过一些手段来确保我们开发出的是一个高质量的代码，这可以通过<code>单元测试</code>和<code>Code Review</code>来实现。</p>
<p><strong>单元测试非常重要。</strong>我们开发完一段代码后，第一个执行的测试就是单元测试。它可以保证我们的代码是符合预期的，一些异常变动能够被及时感知到。进行单元测试，不仅需要编写单元测试用例，还需要我们确保代码是可测试的，以及具有一个高的单元测试覆盖率。</p>
<p>接下来，我就来介绍下如何编写一个可测试的代码。</p>
<p>如果我们要对函数A进行测试，并且A中的所有代码均能够在<code>单元测试环境</code>下按预期被执行，那么<code>函数A</code>的代码块就是可测试的。我们来看下一般的<code>单元测试环境</code>有什么特点：</p>
<ul>
<li>可能无法连接数据库。</li>
<li>可能无法访问第三方服务。</li>
</ul>
<p>如果<code>函数A</code>依赖<code>数据库连接</code>、<code>第三方服务</code>，那么在<code>单元测试环境</code>下执行单元测试就会失败，函数就没法测试，函数是不可测的。</p>
<p>解决方法也很简单：将<code>依赖的数据库</code>、<code>第三方服务</code>等抽象成<code>接口</code>，在被测代码中调用<code>接口</code>的方法，在测试时传入<code>mock</code>类型，从而将<code>数据库</code>、<code>第三方服务</code>等依赖从具体的被测函数中解耦出去。如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/0c/97/0cef423ec1a4f06f6f4715bd0b9f4497.png"><img src="https://static001.geekbang.org/resource/image/0c/97/0cef423ec1a4f06f6f4715bd0b9f4497.png"></a></p>
<p>为了提高代码的可测性，降低单元测试的复杂度，对 <code>function</code> 和 <code>mock</code> 的要求是：</p>
<ul>
<li>要尽可能减少 <code>function</code> 中的依赖，让 <code>function</code> 只依赖必要的模块。编写一个功能单一、职责分明的函数，会有利于减少依赖。</li>
<li>依赖模块应该是易 <code>Mock</code> 的。</li>
</ul>
<p>为了协助你理解，我们先来看一段不可测试的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> post

<span class="token keyword">import</span> <span class="token string">"google.golang.org/grpc"</span>

<span class="token keyword">type</span> Post <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
  Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>
  Address <span class="token builtin">string</span> <span class="token string">`json:"address"`</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">ListPosts</span><span class="token punctuation">(</span>client <span class="token operator">*</span>grpc<span class="token punctuation">.</span>ClientConn<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Post<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> client<span class="token punctuation">.</span><span class="token function">ListPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码中的 <code>ListPosts 函数</code> 是不可测试的。因为 <code>ListPosts 函数</code> 中调用了<code>client.ListPosts()</code>方法，该方法依赖于一个 <code>gRPC</code> 连接。而我们在做<code>单元测试</code>时，可能因为没有配置 <code>gRPC 服务的地址</code>、<code>网络隔离</code> 等原因，导致没法建立 <code>gRPC 连接</code>，从而导致 <code>ListPosts 函数</code> 执行失败。</p>
<p>下面，我们把这段代码改成可测试的，如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> Post <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
  Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>
  Address <span class="token builtin">string</span> <span class="token string">`json:"address"`</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Service <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
  <span class="token function">ListPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Post<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">ListPosts</span><span class="token punctuation">(</span>svc Service<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Post<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> svc<span class="token punctuation">.</span><span class="token function">ListPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>ListPosts 函数</code> 入参为 <code>Service 接口</code> 类型，只要我们传入一个实现了 <code>Service 接口</code> 类型的实例， <code>ListPosts 函数</code> 即可成功运行。因此，我们可以在单元测试中可以实现一个不依赖任何<code>第三方服务的 fake </code>实例，并传给 <code>ListPosts</code> 。上述可测代码的单元测试代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"testing"</span>

<span class="token keyword">type</span> fakeService <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewFakeService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Service <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token operator">&amp;</span>fakeService<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>fakeService<span class="token punctuation">)</span> <span class="token function">ListPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Post<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  posts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Post<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

  posts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>posts<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Post<span class="token punctuation">&#123;</span>
      Name<span class="token punctuation">:</span>    <span class="token string">"colin"</span><span class="token punctuation">,</span>
      Address<span class="token punctuation">:</span> <span class="token string">"Shenzhen"</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  posts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>posts<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Post<span class="token punctuation">&#123;</span>
    Name<span class="token punctuation">:</span>    <span class="token string">"alex"</span><span class="token punctuation">,</span>
    Address<span class="token punctuation">:</span> <span class="token string">"Beijing"</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> posts<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">TestListPosts</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fake <span class="token operator">:=</span> <span class="token function">NewFakeService</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">ListPosts</span><span class="token punctuation">(</span>fake<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    t<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"list posts failed"</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们的代码可测之后，就可以借助一些工具来 <code>Mock</code> 需要的接口了。常用的 <code>Mock</code> 工具，有这么几个：</p>
<ul>
<li><a href="https://github.com/golang/mock">golang&#x2F;mock</a>，是官方提供的 <code>Mock</code> 框架。它实现了基于interface的 <code>Mock</code> 功能，能够与<code>Golang</code>内置的testing包做很好的集成，是最常用的 <code>Mock</code> 工具。golang&#x2F;mock提供了mockgen工具用来生成interface对应的 <code>Mock</code> 源文件。</li>
<li><a href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a>，可以用来模拟数据库连接。数据库是项目中比较常见的依赖，在遇到数据库依赖时都可以用它。</li>
<li><a href="https://github.com/jarcoal/httpmock">httpmock</a>，可以用来 <code>Mock</code>  HTTP请求。</li>
<li><a href="https://github.com/bouk/monkey">bouk&#x2F;monkey</a>，猴子补丁，能够通过替换函数指针的方式来修改任意函数的实现。如果 <code>golang/mock</code>、<code>sqlmock</code> 和 <code>httpmock</code> 这几种方法都不能满足我们的需求，我们可以尝试通过猴子补丁的方式来 <code>Mock</code> 依赖。可以这么说，猴子补丁提供了单元测试  <code>Mock</code>  依赖的最终解决方案。</li>
</ul>
<p>接下来，我们再一起看看<strong>如何提高我们的单元测试覆盖率</strong>。</p>
<p>当我们编写了可测试的代码之后，接下来就需要编写足够的测试用例，用来提高项目的单元测试覆盖率。这里我有以下两个建议供你参考：</p>
<ul>
<li>使用 <code>gotests</code> 工具自动生成单元测试代码，减少编写单元测试用例的工作量，将你从重复的劳动中解放出来。</li>
<li>定期检查单元测试覆盖率。你可以通过以下方法来检查：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token builtin class-name">test</span> <span class="token parameter variable">-race</span> <span class="token parameter variable">-cover</span>  <span class="token parameter variable">-coverprofile</span><span class="token operator">=</span>./coverage.out <span class="token parameter variable">-timeout</span><span class="token operator">=</span>10m <span class="token parameter variable">-short</span> <span class="token parameter variable">-v</span> ./<span class="token punctuation">..</span>.
go tool cover <span class="token parameter variable">-func</span> ./coverage.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>执行结果如下：</p>
<p><a href="https://static001.geekbang.org/resource/image/d2/89/d2fae0aca602c7c33466411e39c49489.png"><img src="https://static001.geekbang.org/resource/image/d2/89/d2fae0aca602c7c33466411e39c49489.png"></a></p>
<p>在提高项目的单元测试覆盖率时，我们可以先提高单元测试覆盖率低的函数，之后再检查项目的单元测试覆盖率；如果项目的单元测试覆盖率仍然低于期望的值，可以再次提高单元测试覆盖率低的函数的覆盖率，然后再检查。以此循环，最终将项目的单元测试覆盖率优化到预期的值为止。</p>
<p>这里要注意，对于一些可能经常会变动的函数单元测试，覆盖率要达到 <code>100%</code> 。</p>
<p>说完了单元测试，我们再看看<strong>如何通过 <code>Code Review</code> 来保证代码质量。</strong></p>
<p> <code>Code Review</code> 可以提高代码质量、交叉排查缺陷，并且促进团队内知识共享，是保障代码质量非常有效的手段。在我们的项目开发中，一定要建立一套持久可行的  <code>Code Review</code>  机制。</p>
<p>但在我的研发生涯中，发现很多团队没有建立有效的 <code>Code Review</code> 机制。这些团队都认可 <code>Code Review</code> 机制带来的好处，但是因为流程难以遵守，慢慢地 <code>Code Review</code> 就变成了形式主义，最终不了了之。其实，建立 <code>Code Review</code> 机制很简单，主要有3点：</p>
<ul>
<li>首先，确保我们使用的代码托管平台有 <code>Code Review</code> 的功能。比如，GitHub、GitLab这类代码托管平台都具备这种能力。</li>
<li>接着，建立一套 <code>Code Review</code> 规范，规定如何进行 <code>Code Review</code> 。</li>
<li>最后，也是最重要的，每次代码变更，相关开发人员都要去落实 <code>Code Review</code> 机制，并形成习惯，直到最后形成团队文化。</li>
</ul>
<p><strong>到这里我们可以小结一下：组织一个合理的代码结构、编写符合<code>Go</code>代码规范的代码、保证代码质量，在我看来都是编写高质量<code>Go</code>代码的外功。那内功是什么呢？就是编程哲学和软件设计方法。</strong></p>
<h3 id="编程哲学"><a href="#编程哲学" class="headerlink" title="编程哲学"></a>编程哲学</h3><p>那编程哲学是什么意思呢？在我看来，编程哲学，其实就是要编写符合<code>Go</code>语言设计哲学的代码。<code>Go</code>语言有很多设计哲学，对代码质量影响比较大的，我认为有两个：面向接口编程和面向“对象”编程。</p>
<p>我们先来看下面向接口编程。</p>
<p><code>Go</code> 接口是一组方法的集合。任何类型，只要实现了该接口中的方法集，那么就属于这个类型，也称为实现了该接口。</p>
<p>接口的作用，其实就是为不同层级的模块提供一个定义好的中间层。这样，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦。很多流行的<code>Go</code>设计模式，就是通过面向接口编程的思想来实现的。</p>
<p>我们看一个面向接口编程的例子。下面这段代码定义了一个<code>Bird</code>接口，<code>Canary</code> 和 <code>Crow</code> 类型均实现了<code>Bird</code>接口。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">// Bird 定义了一个鸟类</span>
<span class="token keyword">type</span> Bird <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Canary 鸟类：金丝雀</span>
<span class="token keyword">type</span> Canary <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Canary<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"我是%s，用黄色的翅膀飞 \n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Canary<span class="token punctuation">)</span> <span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>Name
<span class="token punctuation">&#125;</span>

<span class="token comment">// Crow 鸟类：乌鸦</span>
<span class="token keyword">type</span> Crow <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Crow<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"我是%s，我用黑色的翅膀飞 \n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Crow<span class="token punctuation">)</span> <span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>Name
<span class="token punctuation">&#125;</span>

<span class="token comment">// LetItFly 让鸟类飞一下</span>
<span class="token keyword">func</span> <span class="token function">LetItFly</span><span class="token punctuation">(</span>bird Bird<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Let %s Fly! \n"</span><span class="token punctuation">,</span> bird<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	bird<span class="token punctuation">.</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">LetItFly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Canary<span class="token punctuation">&#123;</span><span class="token string">"金丝雀"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	<span class="token function">LetItFly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Crow<span class="token punctuation">&#123;</span><span class="token string">"乌鸦"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码中，因为<code>Crow</code>和<code>Canary</code>都实现了<code>Bird</code>接口声明的<code>Fly</code>、<code>Type</code>方法，所以可以说<code>Crow</code>、<code>Canary</code>实现了<code>Bird</code>接口，属于<code>Bird</code>类型。在函数调用时，可以传入<code>Bird</code>类型，并在函数内部调用<code>Bird</code>接口提供的方法，以此来解耦<code>Bird</code>的具体实现。</p>
<p>好了，我们总结下使用接口的好处吧：</p>
<ul>
<li>代码扩展性更强了。例如，同样的<code>Bird</code>，可以有不同的实现。在开发中用的更多的是，将数据库的<code>CURD</code>操作抽象成接口，从而可以实现同一份代码对接不同数据库的目的。</li>
<li>可以解耦上下游的实现。例如，<code>LetItFly</code>不用关注<code>Bird</code>是如何<code>Fly</code>的，只需要调用<code>Bird</code>提供的方法即可。</li>
<li>提高了代码的可测性。因为接口可以解耦上下游实现，我们在单元测试需要依赖<code>第三方系统</code>&#x2F;<code>数据库</code>的代码时，可以利用接口将具体实现解耦，实现<code>fake</code>类型。</li>
<li>代码更健壮、更稳定了。例如，如果要更改<code>Fly</code>的方式，只需要更改相关类型的<code>Fly</code>方法即可，完全影响不到<code>LetItFly</code>函数。</li>
</ul>
<p>所以，我建议你，在<code>Go</code>项目开发中，一定要多思考，那些可能有多种实现的地方，要考虑使用接口。</p>
<p>接下来，我们再来看下面向“对象”编程。</p>
<p>面向对象编程（<code>OOP</code>）有很多优点，例如可以使我们的代码变得易维护、易扩展，并能提高开发效率等，所以一个高质量的<code>Go</code>应用在需要时，也应该采用面向对象的方法去编程。那什么叫“在需要时”呢？就是我们在开发代码时，如果一个功能可以通过接近于日常生活和自然的思考方式来实现，这时候就应该考虑使用面向对象的编程方法。</p>
<p><code>Go</code>语言不支持面向对象编程，但是却可以通过一些语言级的特性来实现类似的效果。</p>
<p>面向对象编程中，有几个核心特性：<code>类</code>、<code>实例</code>、<code>抽象</code>，<code>封装</code>、<code>继承</code>、<code>多态</code>、<code>构造函数</code>、<code>析构函数</code>、<code>方法重载</code>、<code>this指针</code>。在<code>Go</code>中可以通过以下几个方式来实现类似的效果：</p>
<ul>
<li>类、抽象、封装通过结构体来实现。</li>
<li>实例通过结构体变量来实现。</li>
<li>继承通过组合来实现。这里解释下什么叫组合：一个结构体嵌到另一个结构体，称作组合。例如一个结构体包含了一个匿名结构体，就说这个结构体组合了该匿名结构体。</li>
<li>多态通过接口来实现。</li>
</ul>
<p>至于<code>构造函数</code>、<code>析构函数</code>、<code>方法重载</code>和<code>this指针</code>等，<code>Go</code>为了保持语言的简洁性去掉了这些特性。</p>
<p><code>Go</code>中面向对象编程方法，见下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/27/b8/27c84757b1f4626e84535d994ca70eb8.png"><img src="https://static001.geekbang.org/resource/image/27/b8/27c84757b1f4626e84535d994ca70eb8.png"></a></p>
<p>我们通过一个示例，来具体看下<code>Go</code>是如何实现面向对象编程中的<code>类</code>、<code>抽象</code>、<code>封装</code>、<code>继承</code>和<code>多态</code>的。代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">// Bird 基类：Bird</span>
<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Type <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Class 鸟的类别</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bird <span class="token operator">*</span>Bird<span class="token punctuation">)</span> <span class="token function">Class</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> bird<span class="token punctuation">.</span>Type
<span class="token punctuation">&#125;</span>

<span class="token comment">// Birds 定义了一个鸟类</span>
<span class="token keyword">type</span> Birds <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
	<span class="token function">Class</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Canary 鸟类：金丝雀</span>
<span class="token keyword">type</span> Canary <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Bird
	name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Canary<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>name
<span class="token punctuation">&#125;</span>

<span class="token comment">// Crow 鸟类：乌鸦</span>
<span class="token keyword">type</span> Crow <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Bird
	name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Crow<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>name
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewCrow</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>Crow <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Crow<span class="token punctuation">&#123;</span>
		Bird<span class="token punctuation">:</span> Bird<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"Crow"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewCanary</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>Canary <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Canary<span class="token punctuation">&#123;</span>
		Bird<span class="token punctuation">:</span> Bird<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"Canary"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">BirdInfo</span><span class="token punctuation">(</span>birds Birds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"I'm %s, I belong to %s bird class! \n"</span><span class="token punctuation">,</span> birds<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birds<span class="token punctuation">.</span><span class="token function">Class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	canary <span class="token operator">:=</span> <span class="token function">NewCanary</span><span class="token punctuation">(</span><span class="token string">"CanaryA"</span><span class="token punctuation">)</span>
	crow <span class="token operator">:=</span> <span class="token function">NewCrow</span><span class="token punctuation">(</span><span class="token string">"CrowA"</span><span class="token punctuation">)</span>
	<span class="token function">BirdInfo</span><span class="token punctuation">(</span>canary<span class="token punctuation">)</span>
	<span class="token function">BirdInfo</span><span class="token punctuation">(</span>crow<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将上述代码保存在<code>oop.go</code>文件中，执行以下代码输出如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run oop.go
I<span class="token string">'m CanaryA, I belong to Canary bird class!
I'</span>m CrowA, I belong to Crow bird class<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中，分别通过<code>Canary</code>和<code>Crow</code>结构体定义了金丝雀和乌鸦两种类别的鸟，其中分别封装了<code>name</code>属性和<code>Name</code>方法。也就是说通过结构体实现了类，该类抽象了鸟类，并封装了该鸟类的属性和方法。</p>
<p>在<code>Canary</code>和<code>Crow</code>结构体中，都有一个<code>Bird</code>匿名字段，<code>Bird</code>字段为<code>Canary</code>和<code>Crow</code>类的父类， <code>Canary</code> 和Crow继承了Bird类的Class属性和方法。也就是说通过匿名字段实现了继承。</p>
<p>在<code>main</code>函数中，通过<code>NewCanary</code>创建了 <code>Canary</code> 鸟类实例，并将其传给<code>BirdInfo</code>函数。也就是说通过结构体变量实现实例。</p>
<p>在<code>BirdInfo</code>函数中，将<code>Birds</code>接口类型作为参数传入，并在函数中调用了<code>birds.Name</code>，<code>birds.Class</code>方法，这两个方法会根据<code>birds</code>类别的不同而返回不同的名字和类别，也就是说通过接口实现了多态。</p>
<h3 id="软件设计方法"><a href="#软件设计方法" class="headerlink" title="软件设计方法"></a>软件设计方法</h3><p>接下来，我们继续学习编写高质量<code>Go</code>代码的第二项内功，也就是让编写的代码遵循一些业界沉淀下来的，优秀的软件设计方法。</p>
<p>优秀的软件设计方法有很多，其中有两类方法对我们代码质量的提升特别有帮助，分别是设计模式（<code>Design</code> <code>pattern</code>）和 <code>SOLID</code> 原则。</p>
<p>在我看来，设计模式可以理解为业界针对一些特定的场景总结出来的最佳实现方式。它的特点是解决的场景比较具体，实施起来会比较简单；而 <code>SOLID</code> 原则更侧重设计原则，需要我们彻底理解，并在编写代码时多思考和落地。</p>
<p>在软件领域，沉淀了一些比较优秀的设计模式，其中最受欢迎的是 <code>GOF</code> 设计模式。 <code>GOF</code> 设计模式中包含了3大类（<code>创建型模式</code>、<code>结构型模式</code>、<code>行为型模式</code>），共25种经典的、可以解决常见软件设计问题的设计方案。这25种设计方案同样也适用于<code>Go</code>语言开发的项目。</p>
<p>这里，我将这25种设计模式总结成了一张图</p>
<p><a href="https://static001.geekbang.org/resource/image/14/9c/1440f4bbcda682c8f5e7a599c8c51f9c.png"><img src="https://static001.geekbang.org/resource/image/14/9c/1440f4bbcda682c8f5e7a599c8c51f9c.png"></a></p>
<p><strong>如果说设计模式解决的是具体的场景，那么 <code>SOLID</code> 原则就是我们设计应用代码时的指导方针。</strong></p>
<p> <code>SOLID</code> 原则，是由<code>罗伯特·C·马丁</code>在21世纪早期引入的，包括了面向对象编程和面向对象设计的五个基本原则：</p>
<p><a href="https://static001.geekbang.org/resource/image/19/3b/19b697bbbe31450d6cc8f222491d3e3b.png"><img src="https://static001.geekbang.org/resource/image/19/3b/19b697bbbe31450d6cc8f222491d3e3b.png"></a></p>
<p>遵循 <code>SOLID</code> 原则可以确保我们设计的代码是易维护、易扩展、易阅读的。 <code>SOLID</code> 原则同样也适用于<code>Go</code>程序设计。</p>
<p>如果你需要更详细地了解 <code>SOLID</code> 原则，可以参考下<a href="https://github.com/marmotedu/geekbang-go/blob/master/SOLID%E5%8E%9F%E5%88%99%E4%BB%8B%E7%BB%8D.md"> <code>SOLID</code> 原则介绍</a>这篇文章。</p>
<p>到这里，我们就学完了“编写高质量的<code>Go</code>应用”这部分内容。接下来，我们再来学习下如何高效管理<code>Go</code>项目，以及如何编写高质量的项目文档。这里面的大部分内容，之前我们都有学习过，因为它们是“如何写出优雅的<code>Go</code>项目”的重要组成部分，所以，这里我仍然会简单介绍下它们。</p>
<h2 id="高效管理项目"><a href="#高效管理项目" class="headerlink" title="高效管理项目"></a>高效管理项目</h2><p>一个优雅的<code>Go</code>项目，还需要具备高效的项目管理特性。那么如何高效管理我们的项目呢？</p>
<p>不同团队、不同项目会采用不同的方法来管理项目，在我看来比较重要的有3点，分别是制定一个高效的开发流程、使用Makefile管理项目和将项目管理自动化。我们可以通过自动生成代码、借助工具、对接<code>CI/CD</code>系统等方法来将项目管理自动化。具体见下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/61/6d/61e022c1b25dab2b0fefb407fc1c776d.png"><img src="https://static001.geekbang.org/resource/image/61/6d/61e022c1b25dab2b0fefb407fc1c776d.png"></a></p>
<h3 id="高效的开发流程"><a href="#高效的开发流程" class="headerlink" title="高效的开发流程"></a>高效的开发流程</h3><p>高效管理项目的第一步，就是要有一个高效的开发流程，这可以提高开发效率、减少软件维护成本。</p>
<h3 id="使用Makefile管理项目"><a href="#使用Makefile管理项目" class="headerlink" title="使用Makefile管理项目"></a>使用Makefile管理项目</h3><p>为了更好地管理项目，除了一个高效的开发流程之外，使用<code>Makefile</code>也很重要。<code>Makefile</code>可以将项目管理的工作通过<code>Makefile</code>依赖的方式实现自动化，除了可以提高管理效率之外，还能够减少人为操作带来的失误，并统一操作方式，使项目更加规范。</p>
<p>IAM项目的所有操作均是通过<code>Makefile</code>来完成的，具体<code>Makefile</code>完成了如下操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">build              Build <span class="token builtin class-name">source</span> code <span class="token keyword">for</span> <span class="token function">host</span> platform.
build.multiarch    Build <span class="token builtin class-name">source</span> code <span class="token keyword">for</span> multiple platforms. See option PLATFORMS.
image              Build <span class="token function">docker</span> images <span class="token keyword">for</span> <span class="token function">host</span> arch.
image.multiarch    Build <span class="token function">docker</span> images <span class="token keyword">for</span> multiple platforms. See option PLATFORMS.
push               Build <span class="token function">docker</span> images <span class="token keyword">for</span> <span class="token function">host</span> arch and push images to registry.
push.multiarch     Build <span class="token function">docker</span> images <span class="token keyword">for</span> multiple platforms and push images to registry.
deploy             Deploy updated components to development env.
clean              Remove all files that are created by building.
lint               Check syntax and styling of go sources.
<span class="token builtin class-name">test</span>               Run unit test.
cover              Run unit <span class="token builtin class-name">test</span> and get <span class="token builtin class-name">test</span> coverage.
release            Release iam
<span class="token function">format</span>             Gofmt <span class="token punctuation">(</span>reformat<span class="token punctuation">)</span> package sources <span class="token punctuation">(</span>exclude vendor <span class="token function">dir</span> <span class="token keyword">if</span> existed<span class="token punctuation">)</span>.
verify-copyright   Verify the boilerplate headers <span class="token keyword">for</span> all files.
add-copyright      Ensures <span class="token builtin class-name">source</span> code files have copyright license headers.
gen                Generate all necessary files, such as error code files.
ca                 Generate CA files <span class="token keyword">for</span> all iam components.
<span class="token function">install</span>            Install iam system with all its components.
swagger            Generate swagger document.
serve-swagger      Serve swagger spec and docs.
dependencies       Install necessary dependencies.
tools              <span class="token function">install</span> dependent tools.
check-updates      Check outdated dependencies of the go projects.
<span class="token builtin class-name">help</span>               Show this <span class="token builtin class-name">help</span> info.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h3><p>低代码的理念现在越来越流行。虽然低代码有很多缺点，但确实有很多优点，例如：</p>
<ul>
<li>自动化生成代码，减少工作量，提高工作效率。</li>
<li>代码有既定的生成规则，相比人工编写代码，准确性更高、更规范。</li>
</ul>
<p>目前来看，自动生成代码现在已经成为趋势，比如 <code>Kubernetes</code>项目有很多代码都是自动生成的。我认为，想写出一个优雅的<code>Go</code>项目，你也应该认真思考哪些地方的代码可以自动生成。在这门课的<code>IAM</code>项目中，就有大量的代码是自动生成的，我放在这里供你参考：</p>
<ul>
<li>错误码、错误码说明文档。</li>
<li>自动生成缺失的<code>doc.go</code>文件。</li>
<li>利用<code>gotests</code>工具，自动生成单元测试用例。</li>
<li>使用<code>Swagger</code>工具，自动生成<code>Swagger</code>文档。</li>
<li>使用 <code>Mock</code> 工具，自动生成接口的 <code>Mock</code> 实例。</li>
</ul>
<h3 id="善于借助工具"><a href="#善于借助工具" class="headerlink" title="善于借助工具"></a>善于借助工具</h3><p>在开发<code>Go</code>项目的过程中，我们也要善于借助工具，来帮助我们完成一部分工作。利用工具可以带来很多好处：</p>
<ul>
<li>解放双手，提高工作效率。</li>
<li>利用工具的确定性，可以确保执行结果的一致性。例如，使用<code>golangci-lint</code>对代码进行检查，可以确保不同开发者开发的代码至少都遵循<code>golangci-lint</code>的代码检查规范。</li>
<li>有利于实现自动化，可以将工具集成到<code>CI/CD</code>流程中，触发流水线自动执行。</li>
</ul>
<p>那么，<code>Go</code>项目中，有哪些工具可以为我们所用呢？这里，我给你整理了一些有用的工具：</p>
<p><a href="https://static001.geekbang.org/resource/image/90/80/90ca527c2863fe642f9ab3d5b90fe980.png"><img src="https://static001.geekbang.org/resource/image/90/80/90ca527c2863fe642f9ab3d5b90fe980.png"></a></p>
<p>所有这些工具都可以通过下面的方式安装。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$IAM_ROOT</span>
<span class="token function">make</span> tools.install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>IAM项目使用了上面这些工具的绝大部分，用来尽可能提高整个项目的自动化程度，提高项目维护效率。</p>
<h3 id="对接CI-x2F-CD"><a href="#对接CI-x2F-CD" class="headerlink" title="对接CI&#x2F;CD"></a>对接CI&#x2F;CD</h3><p>代码在合并入主干时，应该有一套<code>CI/CD</code>流程来自动化地对代码进行检查、编译、单元测试等，只有通过后的代码才可以并入主干。通过<code>CI/CD</code>流程来保证代码的质量。当前比较流行的<code>CI/CD</code>工具有<code>Jenkins</code>、<code>GitLab</code>、<code>Argo</code>、<code>Github Actions</code>、<code>JenkinsX</code>等。</p>
<h2 id="编写高质量的项目文档"><a href="#编写高质量的项目文档" class="headerlink" title="编写高质量的项目文档"></a>编写高质量的项目文档</h2><p>最后，一个优雅的项目，还应该有完善的文档。例如 <code>README.md</code>、<code>安装文档</code>、<code>开发文档</code>、<code>使用文档</code>、<code>API接口文档</code>、<code>设计文档</code>等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>Go</code>语言做项目开发，核心目的其实就是<strong>开发一个优雅的<code>Go</code>项目</strong>。那么如何开发一个优雅的<code>Go</code>项目呢？<code>Go</code>项目包含三大内容，即 <code>Go</code>应用、项目管理、项目文档，因此开发一个优雅的<code>Go</code>项目，其实就是<strong>编写高质量的<code>Go</code>应用</strong>、<strong>高效管理项目</strong>和<strong>编写高质量的项目文档</strong>。针对每一项，我都给出了一些实现方式，这些方式详见下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/b0/cc/b051da025c897996473df44693ea4ecc.png"><img src="https://static001.geekbang.org/resource/image/b0/cc/b051da025c897996473df44693ea4ecc.png"></a></p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title>06 | 设计模式：Go设计模式</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-06-go-design-model-copy.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在软件开发中，经常会遇到各种各样的编码场景，这些场景往往重复发生，因此具有典型性。针对这些典型场景，我们可以自己编码解决，也可以采取更为省时省力的方式：直接采用设计模式。</p>
<p>设计模式是啥呢？简单来说，就是将软件开发中需要重复性解决的编码场景，按最佳实践的方式抽象成一个模型，模型描述的解决方法就是设计模式。使用设计模式，可以使代码更易于理解，保证代码的重用性和可靠性。</p>
<p>在软件领域，<code>GoF</code>（四人帮，全拼 <code>Gang of Four</code>）首次系统化提出了<code>3</code>大类、共25种可复用的经典设计方案，来解决常见的软件设计问题，为可复用软件设计奠定了一定的理论基础。</p>
<p>从总体上说，这些设计模式可以分为<code>创建型模式</code>、<code>结构型模式</code>、<code>行为型模式</code> <code>3</code>大类，用来完成不同的场景。这一讲，我会介绍几个在<code>Go</code>项目开发中比较常用的设计模式，帮助你用更加简单快捷的方法应对不同的编码场景。其中，<code>简单工厂模式</code>、<code>抽象工厂模式</code>和<code>工厂方法模式</code>都属于<code>工厂模式</code>，我会把它们放在一起讲解。</p>
<span id="more"></span>
<p><a href="https://static001.geekbang.org/resource/image/98/20/98fb0ecb8ba65bc83f25bb2504e51d20.png"><img src="https://static001.geekbang.org/resource/image/98/20/98fb0ecb8ba65bc83f25bb2504e51d20.png"></a></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>首先来看<code>创建型模式</code>（<code>Creational Patterns</code>），它提供了一种<strong>在创建对象的同时隐藏创建逻辑</strong>的方式，而不是使用 <code>new</code> 运算符直接实例化对象。</p>
<p>这种类型的设计模式里，<code>单例模式</code>和<code>工厂模式</code>（具体包括简单<code>工厂模式</code>、<code>抽象工厂模式</code>和<code>工厂方法模式</code>三种）在<code>Go</code>项目开发中比较常用。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><code>单例模式</code>（<code>Singleton Pattern</code>），是<strong>最简单的一个模式</strong>。在<code>Go</code>中，单例模式指的是全局只有一个实例，并且它负责创建自己的对象。单例模式不仅有利于<code>减少内存开支</code>，还有<code>减少系统性能开销</code>、<code>防止多个实例产生冲突</code>等优点。</p>
<p>因为单例模式保证了实例的<code>全局唯一性</code>，而且只被<code>初始化一次</code>，所以比较适合<strong>全局共享一个实例，且只需要被初始化一次的场景</strong>，例如<code>数据库实例</code>、<code>全局配置</code>、<code>全局任务池</code>等。</p>
<p>单例模式又分为<strong>饿汉方式</strong>和<strong>懒汉方式</strong>。饿汉方式指全局的单例实例在包被加载时创建，而<code>懒汉方式</code>指全局的单例实例在第一次被使用时创建。你可以看到，这种命名方式非常形象地体现了它们不同的特点。</p>
<p>接下来，我就来分别介绍下这两种方式。先来看<strong>饿汉方式</strong>。</p>
<p>下面是一个<code>饿汉方式</code>的<code>单例模式</code>代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton

<span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> ins <span class="token operator">*</span>singleton <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">GetInsOr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> ins
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>你需要注意，因为实例是在<code>包被导入时初始化</code>的，所以如果初始化耗时，会导致程序加载时间比较长。</p>
<p><strong>懒汉方式是开源项目中使用最多的</strong>，但它的缺点是非并发安全，在实际使用时需要加锁。以下是<code>懒汉方式</code>不加锁的一个实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton

<span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> ins <span class="token operator">*</span>singleton

<span class="token keyword">func</span> <span class="token function">GetInsOr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">&#123;</span>
	 <span class="token keyword">if</span> ins <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		ins <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	 <span class="token punctuation">&#125;</span>
	 <span class="token keyword">return</span> ins
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，在创建<code>ins</code>时，如果 <code>ins==nil</code>，就会再创建一个<code>ins</code>实例，这时候单例就会有多个实例。</p>
<p>为了解决<code>懒汉方式</code>非并发安全的问题，需要对实例进行加锁，下面是<code>带检查锁</code>的一个实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"sync"</span>

<span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> ins <span class="token operator">*</span>singleton
<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex

<span class="token keyword">func</span> <span class="token function">GetIns</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> ins <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> ins <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			ins <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> ins
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码只有在创建时才会加锁，既提高了代码效率，又保证了并发安全。</p>
<p>除了<code>饿汉方式</code>和<code>懒汉方式</code>，在<code>Go</code>开发中，还有一种更优雅的实现方式，我建议你采用这种方式，代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> ins <span class="token operator">*</span>singleton
<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once

<span class="token keyword">func</span> <span class="token function">GetInsOr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">&#123;</span>
	once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ins <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> ins
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用<code>once.Do</code>可以确保<code>ins</code>实例全局只被创建一次，<code>once.Do</code>函数还可以确保当同时有多个创建动作时，只有一个创建动作在被执行。</p>
<p>另外，<code>IAM</code>应用中大量使用了单例模式，如果你想了解更多单例模式的使用方式，可以直接查看<code>IAM</code>项目代码。<code>IAM</code>中单例模式有 <a href="https://github.com/colin404test/iam/blob/IAMTAG/internal/authzserver/store/store.go#L45">GetStoreInsOr</a>、<a href="https://github.com/colin404test/iam/blob/IAMTAG/internal/apiserver/store/etcd/etcd.go#L83">GetEtcdFactoryOr</a>、<a href="https://github.com/colin404test/iam/blob/IAMTAG/internal/apiserver/store/mysql/mysql.go#L55">GetMySQLFactoryOr</a>、<a href="https://github.com/colin404test/iam/blob/IAMTAG/internal/apiserver/api/v1/cache/cache.go#L33">GetCacheInsOr</a>等。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><code>工厂模式</code>（<code>Factory Pattern</code>）是面向对象编程中的常用模式。在<code>Go</code>项目开发中，你可以通过使用多种不同的工厂模式，来使代码更简洁明了。<code>Go</code>中的结构体，可以理解为面向对象编程中的类，例如 <code>Person结构体（类）</code>实现了<code>Greet</code>方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">Greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hi! My name is %s"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有了<code>Person“类”</code>，就可以创建<code>Person实例</code>。我们可以通过<code>简单工厂模式</code>、<code>抽象工厂模式</code>、<code>工厂方法模式</code>这三种方式，来创建一个<code>Person实例</code>。</p>
<p>这三种工厂模式中，<strong>简单工厂模式</strong>是最常用、最简单的。它就是一个接受一些参数，然后返回<code>Person实例</code>的函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">Greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hi! My name is %s"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewPerson</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Person <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">&#123;</span>    Name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>    Age<span class="token punctuation">:</span> age<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和<code>p：=＆Person &#123;&#125;</code>这种创建实例的方式相比，<code>简单工厂模式</code>可以确保我们创建的实例<code>具有需要的参数</code>，进而保证<code>实例的方法</code>可以按预期执行。例如，通过<code>NewPerson</code>创建<code>Person实例</code>时，可以确保实例的<code>name</code>和<code>age</code>属性被设置。</p>
<p>再来看<strong>抽象工厂模式，</strong>它和<code>简单工厂模式</code>的唯一区别，就是它返回的是<code>接口</code>而不是<code>结构体</code>。</p>
<p>通过返回<code>接口</code>，可以<strong>在你不公开内部实现的情况下，让调用者使用你提供的各种功能</strong>，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> person <span class="token keyword">struct</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p person<span class="token punctuation">)</span> <span class="token function">Greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hi! My name is %s"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// NewPerson 返回一个接口， 而不是一个结构体</span>

<span class="token keyword">func</span> <span class="token function">NewPerson</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> age <span class="token builtin">int</span><span class="token punctuation">)</span> Person <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> person<span class="token punctuation">&#123;</span>
		name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
		age<span class="token punctuation">:</span> age<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这个代码，定义了一个不可导出的结构体<code>person</code>，在通过<code>NewPerson``创建实例</code>的时候返回的是<code>接口</code>，而不是<code>结构体</code>。</p>
<p>通过返回接口，我们还可以<strong>实现多个工厂函数，来返回不同的接口实现</strong>，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> design

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"net/http/httptest"</span>
<span class="token punctuation">)</span>

<span class="token comment">// Doer 这里我们定义了一个Doer接口，该接口具有一个Do方法</span>
<span class="token keyword">type</span> Doer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Do</span><span class="token punctuation">(</span>req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>http<span class="token punctuation">.</span>Response<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// NewHTTPClient 返回一个net/http包提供的HTTP客户端</span>
<span class="token keyword">func</span> <span class="token function">NewHTTPClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Doer <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Client<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> mockHTTPClient <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>mockHTTPClient<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>http<span class="token punctuation">.</span>Response<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// httptest 包的 NewRecorder 方法给了我们一个新的模拟请求生成器</span>
	res <span class="token operator">:=</span> httptest<span class="token punctuation">.</span><span class="token function">NewRecorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 调用 Result 方法给我们默认的空 *http.Response 对象</span>
	<span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// NewMockHTTPClient 这给了我们一个模拟的 HTTP 客户端，它对发送给它的任何请求返回一个空响应</span>
<span class="token keyword">func</span> <span class="token function">NewMockHTTPClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Doer <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>mockHTTPClient<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>NewHTTPClient</code>和<code>NewMockHTTPClient</code>都返回了同一个<code>接口类型</code> <code>Doer</code>，这使得二者可以互换使用。当你想测试一段调用了<code>Doer 接口</code> <code>Do 方法</code>的代码时，这一点特别有用。因为你可以使用一个<code>Mock</code>的<code>HTTP客户端</code>，从而避免了<code>调用真实外部接口</code>可能带来的失败。</p>
<p>来看个例子，假设我们想测试下面这段代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">QueryUser</span><span class="token punctuation">(</span>doer Doer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	req<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewRequest</span><span class="token punctuation">(</span><span class="token string">"Get"</span><span class="token punctuation">,</span> <span class="token string">"http://iam.api.marmotedu.com:8080/v1/secrets"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>

	<span class="token boolean">_</span> <span class="token punctuation">,</span> err <span class="token operator">:=</span> doer<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其测试用例为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestQueryUser</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	doer <span class="token operator">:=</span> <span class="token function">NewMockHTTPClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">QueryUser</span><span class="token punctuation">(</span>doer<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"QueryUser failed, err: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，在使用<code>简单工厂模式</code>和<code>抽象工厂模式</code>返回<code>实例对象</code>时，都可以<code>返回指针</code>。例如，<code>简单工厂模式</code>可以这样返回实例对象：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">return</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">&#123;</span>
	Name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
	Age<span class="token punctuation">:</span> age
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>抽象工厂模式</code>可以这样<code>返回实例对象</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">return</span> <span class="token operator">&amp;</span>person<span class="token punctuation">&#123;</span>
	name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
	age<span class="token punctuation">:</span> age
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在实际开发中，我建议返回<code>非指针的实例</code>，因为我们主要是想通过<code>创建实例</code>，<code>调用</code>其<code>提供的方法</code>，而不是<code>对实例做更改</code>。如果需要<code>对实例做更改</code>，可以实现<code>SetXXX</code>的方法。通过返回<code>非指针的实例</code>，可以确保<code>实例的属性</code>，避免属性被<code>意外/任意修改</code>。</p>
<p>在<strong>简单工厂模式</strong>中，依赖于<code>唯一的工厂对象</code>，如果我们需要<code>实例化一个产品</code>，就要向<code>工厂</code>中<code>传入一个参数</code>，获取对应的对象；如果要增加一种产品，就要在<code>工厂</code>中<code>修改创建产品的函数</code>。这会导致耦合性过高，这时我们就可以使用<strong>工厂方法模式</strong>。</p>
<p>在<strong>工厂方法模式</strong>中，依赖<code>工厂函数</code>，我们可以通过实现<code>工厂函数</code>来<code>创建多种工厂</code>，将对象创建从<code>由一个对象负责所有具体类的实例化</code>，变成<code>由一群子类来负责对具体类的实例化</code>，从而将过程解耦。</p>
<p>下面是<strong>工厂方法模式</strong>的一个代码实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span>

<span class="token keyword">func</span> <span class="token function">NewPersonFactory</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> Person <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> Person <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> Person<span class="token punctuation">&#123;</span>
			name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
			age<span class="token punctuation">:</span> age<span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后，我们可以使用<code>此功能</code>来创建<code>具有默认年龄的工厂</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">newBaby <span class="token operator">:=</span> <span class="token function">NewPersonFactory</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
baby <span class="token operator">:=</span> <span class="token function">newBaby</span><span class="token punctuation">(</span><span class="token string">"john"</span><span class="token punctuation">)</span>
newTeenager <span class="token operator">:=</span> <span class="token function">NewPersonFactory</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>
teen <span class="token operator">:=</span> <span class="token function">newTeenager</span><span class="token punctuation">(</span><span class="token string">"jill"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p><code>行为型模式</code>（<code>Behavioral Pattern</code>），它的特点是<strong>关注类和对象的组合</strong>。这一类型里，我想详细讲讲策略模式和模板模式。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><code>策略模式</code>（<code>Strategy Pattern</code>）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>
<p>在什么时候，我们需要用到策略模式呢？</p>
<p>在项目开发中，我们经常要根据不同的场景，采取不同的措施，也就是不同的<strong>策略</strong>。比如，假设我们需要对 <code>a</code> 、<code>b</code> 这两个整数<code>进行计算</code>，根据<code>条件的不同</code>，需要执行<code>不同的计算方式</code>。我们可以把所有的操作<code>都封装在同一个函数中</code>，然后通过 <code>if ... else ...</code> 的形式<code>来调用不同的计算方式</code>，这种方式称之为<strong>硬编码</strong>。</p>
<p>在实际应用中，随着功能和体验的不断增长，我们需要经常<code>添加/修改策略</code>，这样就需要不断<code>修改已有代码</code>，不仅会让这个函数<code>越来越难维护</code>，还可能因为修改带来一些 <code>bug</code>。<code>所以为了解耦</code>，需要使用<code>策略模式</code>，定义一些<code>独立的类</code>来<code>封装不同的算法</code>，每一个类封装一个具体的算法（即策略）。</p>
<p>下面是一个实现策略模式的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> design

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"testing"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 策略模式</span>

<span class="token comment">// IStrategy 定义一个策略类</span>
<span class="token keyword">type</span> IStrategy <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">do</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 策略实现：加</span>
<span class="token keyword">type</span> add <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>add<span class="token punctuation">)</span> <span class="token function">do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">&#125;</span>

<span class="token comment">// 策略实现：减</span>
<span class="token keyword">type</span> reduce <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>reduce<span class="token punctuation">)</span> <span class="token function">do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a <span class="token operator">-</span> b
<span class="token punctuation">&#125;</span>

<span class="token comment">// Operator 具体策略的执行者</span>
<span class="token keyword">type</span> Operator <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	strategy IStrategy
<span class="token punctuation">&#125;</span>

<span class="token comment">// 设置策略</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>operator <span class="token operator">*</span>Operator<span class="token punctuation">)</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy IStrategy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	operator<span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy
<span class="token punctuation">&#125;</span>

<span class="token comment">// 调用策略中的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>operator <span class="token operator">*</span>Operator<span class="token punctuation">)</span> <span class="token function">calculate</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> operator<span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">TestStrategy</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	operator <span class="token operator">:=</span> Operator<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	operator<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>add<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	result <span class="token operator">:=</span> operator<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"add:"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>

	operator<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>reduce<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	result <span class="token operator">=</span> operator<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"reduce:"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，我们定义了<code>策略接口</code> <code>IStrategy</code>，还定义了 <code>add</code> 和 <code>reduce</code> 两种<code>策略</code>。最后定义了一个<code>策略执行者</code>，可以<code>设置不同的策略</code>，并执行，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestStrategy</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	operator <span class="token operator">:=</span> Operator<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	operator<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>add<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	result <span class="token operator">:=</span> operator<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"add:"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>

	operator<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>reduce<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	result <span class="token operator">=</span> operator<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"reduce:"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，我们可以<code>随意更换策略</code>，而不影响 <code>Operator</code> 的所有实现。</p>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p><code>模板模式</code> (<code>Template Pattern</code>)定义<code>一个操作中算法的骨架</code>，而将一些步骤<code>延迟到子类中</code>。这种方法让子类<code>在不改变一个算法结构</code>的情况下，就能<code>重新定义该算法</code>的某些特定步骤。</p>
<p>简单来说，<code>模板模式</code>就是将一个类中<code>能够公共使用的方法</code>放置在<code>抽象类</code>中实现，将<code>不能公共使用的方法</code>作为<code>抽象方法</code>，<code>强制</code>子类去实现，这样就做到了将<code>一个类作为一个模板</code>，让开发者去填充需要填充的地方。</p>
<p>以下是模板模式的一个实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> template

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Cooker <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">cooke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">outfire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 类似于一个抽象类</span>
<span class="token keyword">type</span> CookMenu <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>CookMenu<span class="token punctuation">)</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"打开开关"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>CookMenu<span class="token punctuation">)</span> <span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"开火"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 做菜，交给具体的子类实现</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>CookMenu<span class="token punctuation">)</span> <span class="token function">cooke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>CookMenu<span class="token punctuation">)</span> <span class="token function">outfire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"关火"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>CookMenu<span class="token punctuation">)</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"关闭开关"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 封装具体步骤</span>
<span class="token keyword">func</span> <span class="token function">doCook</span><span class="token punctuation">(</span>cook Cooker<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cook<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    cook<span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    cook<span class="token punctuation">.</span><span class="token function">cooke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    cook<span class="token punctuation">.</span><span class="token function">outfire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    cook<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> XiHongShi <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    CookMenu
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>XiHongShi<span class="token punctuation">)</span> <span class="token function">cooke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"做西红柿"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ChaoJiDan <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    CookMenu
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ChaoJiDan<span class="token punctuation">)</span> <span class="token function">cooke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"做炒鸡蛋"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里来看下测试用例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> template

<span class="token keyword">import</span> <span class="token string">"testing"</span>

<span class="token keyword">func</span> <span class="token function">TestTemplate</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 做西红柿</span>
    xihongshi <span class="token operator">:=</span> <span class="token operator">&amp;</span>XiHongShi<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">doCook</span><span class="token punctuation">(</span>xihongshi<span class="token punctuation">)</span>

    <span class="token comment">// 做炒鸡蛋</span>
    chaojidan <span class="token operator">:=</span> <span class="token operator">&amp;</span>ChaoJiDan<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">doCook</span><span class="token punctuation">(</span>chaojidan<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p><code>结构型模式</code>（<code>Structural Pattern</code>），它的特点是关注<strong>对象之间的通信</strong>。这一类别的设计模式中，我们会讲到<code>代理模式</code>和<code>选项模式</code>。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><code>代理模式</code> (<code>Proxy Pattern</code>)，可以为另一个对象提供一个<code>替身</code>或者<code>占位符</code>，以控制对这个对象的访问。</p>
<p>以下代码是一个代理模式的实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> design

<span class="token comment">// 代理模式</span>
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Seller <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">sell</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Station 火车站</span>
<span class="token keyword">type</span> Station <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	stock <span class="token builtin">int</span> <span class="token comment">//库存</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>station <span class="token operator">*</span>Station<span class="token punctuation">)</span> <span class="token function">sell</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> station<span class="token punctuation">.</span>stock <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		station<span class="token punctuation">.</span>stock<span class="token operator">--</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"代理点中：%s买了一张票,剩余：%d n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> station<span class="token punctuation">.</span>stock<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"票已售空"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// StationProxy 火车代理点</span>
<span class="token keyword">type</span> StationProxy <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	station <span class="token operator">*</span>Station <span class="token comment">// 持有一个火车站对象</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>proxy <span class="token operator">*</span>StationProxy<span class="token punctuation">)</span> <span class="token function">sell</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> proxy<span class="token punctuation">.</span>station<span class="token punctuation">.</span>stock <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		proxy<span class="token punctuation">.</span>station<span class="token punctuation">.</span>stock<span class="token operator">--</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"代理点中：%s买了一张票,剩余：%d n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> proxy<span class="token punctuation">.</span>station<span class="token punctuation">.</span>stock<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"票已售空"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中，<code>StationProxy</code>代理了<code>Station</code>，代理类中持有被代理类对象，并且和被代理类对象实现了同一接口。</p>
<h3 id="选项模式"><a href="#选项模式" class="headerlink" title="选项模式"></a>选项模式</h3><p><code>选项模式</code>（<code>Options Pattern</code>）也是<code>Go</code>项目开发中经常使用到的模式，例如，<br><code>grpc/grpc-go</code>的<a href="https://github.com/grpc/grpc-go/blob/v1.37.0/server.go#L514">NewServer</a>函数</p>
<p><code>uber-go/zap</code>包的<a href="https://github.com/uber-go/zap/blob/v1.16.0/logger.go#L65">New</a>函数都用到了选项模式。</p>
<p>使用选项模式，我们可以创建一个带有默认值的<code>struct</code>变量，并选择性地修改其中一些参数的值。</p>
<p>在<code>Python</code>语言中，创建一个对象时，可以给参数设置默认值，这样在不传入任何参数时，可以返回携带默认值的对象，并在需要时修改对象的属性。这种特性可以大大简化开发者创建一个对象的成本，尤其是在对象拥有众多属性时。</p>
<p>而在<code>Go</code>语言中，因为不支持给参数设置默认值，为了既能够<code>创建带默认值的实例</code>，又能够<code>创建自定义参数的实例</code>，不少开发者会通过以下两种方法来实现：</p>
<p>第一种方法，我们要分别开发<code>两个用来创建实例的函数</code>，一个可以<code>创建带默认值的实例</code>，一个可以<code>定制化创建实例</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> options

<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"time"</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	defaultTimeout <span class="token operator">=</span> <span class="token number">10</span>
	defaultCaching <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Connection <span class="token keyword">struct</span>

<span class="token comment">// NewConnect 创建一个 Connection</span>
<span class="token keyword">func</span> <span class="token function">NewConnect</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Connection<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Connection<span class="token punctuation">&#123;</span>
		addr<span class="token punctuation">:</span>    addr<span class="token punctuation">,</span>
		cache<span class="token punctuation">:</span>   defaultCaching<span class="token punctuation">,</span>
		timeout<span class="token punctuation">:</span> defaultTimeout<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// NewConnectWithOptions 使用 options 创建一个 Connection</span>
<span class="token keyword">func</span> <span class="token function">NewConnectWithOptions</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> cache <span class="token builtin">bool</span><span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Connection<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Connection<span class="token punctuation">&#123;</span>
		addr<span class="token punctuation">:</span>    addr<span class="token punctuation">,</span>
		cache<span class="token punctuation">:</span>   cache<span class="token punctuation">,</span>
		timeout<span class="token punctuation">:</span> timeout<span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用这种方式，创建同一个<code>Connection</code>实例，却要实现两个不同的函数，实现方式很不优雅。</p>
<p>另外一种方法相对优雅些。我们需要创建一个带默认值的选项，并用该选项创建实例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> design

<span class="token keyword">import</span> <span class="token string">"time"</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	defaultTimeout <span class="token operator">=</span> <span class="token number">10</span>
	defaultCaching <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Connection <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	addr    <span class="token builtin">string</span>
	cache   <span class="token builtin">bool</span>
	timeout time<span class="token punctuation">.</span>Duration
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ConnectionOptions <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Caching <span class="token builtin">bool</span>
	Timeout time<span class="token punctuation">.</span>Duration
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewDefaultOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>ConnectionOptions <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>ConnectionOptions<span class="token punctuation">&#123;</span>
		cache<span class="token punctuation">:</span>   defaultCaching<span class="token punctuation">,</span>
		timeout<span class="token punctuation">:</span> defaultTimeout<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">func</span> <span class="token function">NewConnect</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> opts <span class="token operator">*</span>ConnectionOptions<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Connection<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Connection<span class="token punctuation">&#123;</span>
		addr<span class="token punctuation">:</span>    addr<span class="token punctuation">,</span>
		cache<span class="token punctuation">:</span>   opts<span class="token punctuation">.</span>cache<span class="token punctuation">,</span>
		timeout<span class="token punctuation">:</span> opts<span class="token punctuation">.</span>timeout<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用这种方式，虽然只需要实现一个函数来创建实例，但是也有缺点：为了创建<code>Connection</code>实例，每次我们都要创建<code>ConnectionOptions</code>，操作起来比较麻烦。</p>
<p>那么有没有更优雅的解决方法呢？答案当然是有的，就是使用选项模式来创建实例。以下代码通过选项模式实现上述功能：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> design

<span class="token comment">// 选项模式</span>
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Connection <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	addr    <span class="token builtin">string</span>
	cache   <span class="token builtin">bool</span>
	timeout time<span class="token punctuation">.</span>Duration
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	defaultTimeout <span class="token operator">=</span> <span class="token number">10</span>
	defaultCaching <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> options <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	timeout time<span class="token punctuation">.</span>Duration
	caching <span class="token builtin">bool</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Option 选项覆盖 Connect 的行为</span>
<span class="token keyword">type</span> Option <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">*</span>options<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> optionFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>options<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f optionFunc<span class="token punctuation">)</span> <span class="token function">apply</span><span class="token punctuation">(</span>o <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>t time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> Option <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">optionFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>o <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		o<span class="token punctuation">.</span>timeout <span class="token operator">=</span> t
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithCaching</span><span class="token punctuation">(</span>cache <span class="token builtin">bool</span><span class="token punctuation">)</span> Option <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">optionFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>o <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		o<span class="token punctuation">.</span>caching <span class="token operator">=</span> cache
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// NewConnect 连接创建连接</span>
<span class="token keyword">func</span> <span class="token function">NewConnect</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Connection<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	options <span class="token operator">:=</span> options<span class="token punctuation">&#123;</span>
		timeout<span class="token punctuation">:</span> defaultTimeout<span class="token punctuation">,</span>
		caching<span class="token punctuation">:</span> defaultCaching<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> o <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">&#123;</span>
		o<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>options<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Connection<span class="token punctuation">&#123;</span>
		addr<span class="token punctuation">:</span>    addr<span class="token punctuation">,</span>
		cache<span class="token punctuation">:</span>   options<span class="token punctuation">.</span>caching<span class="token punctuation">,</span>
		timeout<span class="token punctuation">:</span> options<span class="token punctuation">.</span>timeout<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中，首先我们定义了<code>options</code>结构体，它携带了<code>timeout</code>、<code>caching</code>两个属性。接下来，我们通过<code>NewConnect</code>创建了一个连接，<code>NewConnect</code>函数中先创建了一个带有默认值的<code>options</code>结构体变量，并通过调用</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> o <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">&#123;</span>
	o<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>options<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>来修改所创建的<code>options</code>结构体变量。</p>
<p>需要修改的属性，是在<code>NewConnect</code>时，通过Option类型的选项参数传递进来的。可以通过<code>WithXXX</code>函数来创建<code>Option</code>类型的选项参数：<code>WithTimeout</code>、<code>WithCaching</code>。</p>
<p><code>Option</code>类型的选项参数需要实现<code>apply(*options)</code>函数，结合<code>WithTimeout</code>、<code>WithCaching</code>函数的返回值和<code>optionFunc</code>的<code>apply</code>方法实现，可以知道<code>o.apply(&amp;options)</code>其实就是把<code>WithTimeout</code>、<code>WithCaching</code>传入的参数赋值给<code>options</code>结构体变量，以此动态地设置<code>options</code>结构体变量的属性。</p>
<p>这里还有一个好处：我们可以在apply函数中自定义赋值逻辑，例如<code>o.timeout = 100 * t</code>。通过这种方式，我们会有更大的灵活性来设置结构体的属性。</p>
<p>选项模式有很多优点，例如：支持传递多个参数，并且在参数发生变化时保持兼容性；支持任意顺序传递参数；支持默认值；方便扩展；通过<code>WithXXX</code>的函数命名，可以使参数意义更加明确，等等。</p>
<p>不过，为了实现选项模式，我们增加了很多代码，所以在开发中，要根据实际场景选择是否使用选项模式。选项模式通常适用于以下场景：</p>
<ul>
<li>结构体参数很多，创建结构体时，我们期望创建一个携带默认值的结构体变量，并选择性修改其中一些参数的值。</li>
<li>结构体参数经常变动，变动时我们又不想修改创建实例的函数。例如：结构体新增一个<code>retry</code>参数，但是又不想在<code>NewConnect</code>入参列表中添加<code>retry int</code>这样的参数声明。</li>
</ul>
<p>如果结构体参数比较少，可以慎重考虑要不要采用选项模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式，是业界沉淀下来的针对特定场景的最佳解决方案。在软件领域，<code>GoF</code>首次系统化提出了3大类设计模式：<code>创建型模式</code>、<code>结构型模式</code>、<code>行为型模式</code>。</p>
<p>这一讲，我介绍了<code>Go</code>项目开发中<code>6</code>种常用的设计模式。每种设计模式解决某一类场景，我给你总结成了一张表格，你可以根据自己的需要进行选择。</p>
<p><a href="https://static001.geekbang.org/resource/image/1e/01/1e32f9d8318c8968b50e9ea7e89bbe01.png"><img src="https://static001.geekbang.org/resource/image/1e/01/1e32f9d8318c8968b50e9ea7e89bbe01.png"></a></p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>07 | 项目管理：如何编写 Makefile</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-07-write-makefile.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在和其他开发同学交流时，我发现大家都认可 <code>Makefile</code> 强大的项目管理能力，也会自己编写 <code>Makefile</code> 。但是其中的一些人项目管理做得并不好，我和他们进一步交流后发现，这些同学在用 <code>Makefile</code> 简单的语法重复编写一些低质量 <code>Makefile</code> 文件，根本没有把 <code>Makefile</code> 的功能充分发挥出来。</p>
<p>下面给你举个例子，你就会理解低质量的 <code>Makefile</code> 文件是什么样的了。</p>
<span id="more"></span>

<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">build</span><span class="token punctuation">:</span> clean vet
	<span class="token operator">@</span>mkdir -p ./Role
	<span class="token operator">@</span><span class="token keyword">export</span> GOOS<span class="token operator">=</span>linux &amp;&amp; go build -v .

<span class="token target symbol">vet</span><span class="token punctuation">:</span>
	go vet ./...

<span class="token target symbol">fmt</span><span class="token punctuation">:</span>
	go fmt ./...

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rf dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这个 <code>Makefile</code> 存在不少问题。例如：功能简单，只能完成最基本的编译、格式化等操作，像构建镜像、自动生成代码等一些高阶的功能都没有；扩展性差，没法编译出可在Mac下运行的二进制文件；没有Help功能，使用难度高；单 <code>Makefile</code> 文件，结构单一，不适合添加一些复杂的管理功能。</p>
<p>所以，我们不光要编写 <code>Makefile</code> ，还要编写高质量的 <code>Makefile</code> 。那么如何编写一个高质量的 <code>Makefile</code> 呢？我觉得，可以通过以下4个方法来实现：</p>
<ol>
<li>打好基础，也就是熟练掌握 <code>Makefile</code> 的语法。</li>
<li>做好准备工作，也就是提前规划 <code>Makefile</code> 要实现的功能。</li>
<li>进行规划，设计一个合理的 <code>Makefile</code> 结构。</li>
<li>掌握方法，用好 <code>Makefile</code> 的编写技巧。</li>
</ol>
<p>那么接下来，我们就详细看看这些方法。</p>
<h2 id="熟练掌握-Makefile-语法"><a href="#熟练掌握-Makefile-语法" class="headerlink" title="熟练掌握 Makefile 语法"></a>熟练掌握 <code>Makefile</code> 语法</h2><p>工欲善其事，必先利其器。编写高质量 <code>Makefile</code> 的第一步，便是熟练掌握 <code>Makefile</code> 的核心语法。</p>
<p>因为 <code>Makefile</code> 的语法比较多，我把一些建议你重点掌握的语法放在了近期会更新的特别放送中，包括 <code>Makefile</code> 规则语法、伪目标、变量赋值、条件语句和 <code>Makefile</code> 常用函数等等。</p>
<p>如果你想更深入、全面地学习 <code>Makefile</code> 的语法，我推荐你学习陈皓老师编写的<a href="https://github.com/seisman/how-to-write-makefile">《跟我一起写  <code>Makefile</code> 》 (PDF 重制版)</a>。</p>
<h2 id="规划-Makefile-要实现的功能"><a href="#规划-Makefile-要实现的功能" class="headerlink" title="规划 Makefile 要实现的功能"></a>规划 <code>Makefile</code> 要实现的功能</h2><p>接着，我们需要规划 <code>Makefile</code> 要实现的功能。提前规划好功能，有利于你设计 <code>Makefile</code> 的整体结构和实现方法。</p>
<p>不同项目拥有不同的 <code>Makefile</code> 功能，这些功能中一小部分是通过目标文件来实现的，但更多的功能是通过伪目标来实现的。对于Go项目来说，虽然不同项目集成的功能不一样，但绝大部分项目都需要实现一些通用的功能。接下来，我们就来看看，在一个大型Go项目中 <code>Makefile</code> 通常可以实现的功能。</p>
<p>下面是IAM项目的 <code>Makefile</code> 所集成的功能，希望会对你日后设计 <code>Makefile</code> 有一些帮助。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">$ make help


<span class="token target symbol">Usage</span><span class="token punctuation">:</span> make &lt;TARGETS> &lt;OPTIONS> ...

<span class="token target symbol">Targets</span><span class="token punctuation">:</span>
		<span class="token comment"># 构建类命令</span>
		build              Build source code for host platform.
		build.multiarch    Build source code for multiple platforms. See option PLATFORMS.

		<span class="token comment"># Docker镜像打包类命令</span>
		image              Build docker images for host arch.
		image.multiarch    Build docker images for multiple platforms. See option PLATFORMS.
		push               Build docker images for host arch and push images to registry.
		push.multiarch     Build docker images for multiple platforms and push images to registry.

		<span class="token comment"># 部署类命令</span>
		deploy             Deploy updated components to development env.
		install						 Install iam system with all its components.

		<span class="token comment"># 清理类命令</span>
		clean              Remove all files that are created by building.

		<span class="token comment"># 静态代码检查</span>
		lint               Check syntax and styling of go sources.

		<span class="token comment"># 测试类命令</span>
		test               Run unit test.
		cover              Run unit test and get test coverage.

		<span class="token comment"># 格式化类命令</span>
		format             Gofmt <span class="token punctuation">(</span>reformat<span class="token punctuation">)</span> package sources <span class="token punctuation">(</span>exclude vendor dir if existed<span class="token punctuation">)</span>.
		verify-copyright   Verify the boilerplate headers for all files.
		add-copyright			 Ensures source code files have copyright license headers.

		<span class="token comment"># 代码生成类命令</span>
		gen                Generate all necessary files, such as error code files.
		ca                 Generate CA files for all iam components.

		<span class="token comment"># 其他命令，不同项目会有区别</span>
		release            Release iam
		swagger            Generate swagger document.
		serve-swagger			 Serve swagger spec and docs.
		dependencies       install dependent tools.
		tools              install dependent tools.
		check-updates      Check outdated dependencies of the go projects

		<span class="token comment"># 帮助命令</span>
		help               Show this help info.
<span class="token comment"># 选项</span>
<span class="token target symbol">Options</span><span class="token punctuation">:</span>
		DEBUG       Whether to generate debug symbols. Default is 0.
		BINS        The binaries to build. Default is all of cmd.
<span class="token target symbol">								This option is available when using</span><span class="token punctuation">:</span> make build/build.multiarch
<span class="token target symbol">								Example</span><span class="token punctuation">:</span> make build BINS<span class="token operator">=</span><span class="token string">"iam-apiserver iam-authz-server"</span>
		...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>更详细的命令，你可以在IAM项目仓库根目录下执行<code>make help</code>查看。</p>
<p>通常而言，Go项目的 <code>Makefile</code> 应该实现以下功能：<code>格式化代码</code>、<code>静态代码检查</code>、<code>单元测试</code>、<code>代码构建</code>、<code>文件清理</code>、<code>帮助</code>等等。如果通过 <code>docker</code> 部署，还需要有 <code>docker</code> 镜像打包功能。因为<code>Go</code>是跨平台的语言，所以<code>构建</code>和 <code>docker 打包</code>命令，还要能够支持不同的<code>CPU架构</code>和<code>平台</code>。为了能够更好地控制 <code>Makefile</code> 命令的行为，还需要支持<code>Options</code>。</p>
<p>为了方便查看 <code>Makefile</code> 集成了哪些功能，我们需要支持 <code>help</code> 命令。 <code>help</code> 命令最好通过解析 <code>Makefile</code> 文件来输出集成的功能，例如：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">## help: Show this help info.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> help
<span class="token target symbol">help</span><span class="token punctuation">:</span>Makefile
	<span class="token operator">@</span>echo -e <span class="token string">"nUsage: make &lt;TARGETS> &lt;OPTIONS> ...nnTargets:"</span>
	<span class="token operator">@</span>sed -n <span class="token string">'s/##//p'</span> <span class="token variable">$&lt;</span> <span class="token operator">|</span> column -t -s <span class="token string">':'</span> <span class="token operator">|</span> sed -e <span class="token string">'s// /'</span>
	<span class="token operator">@</span>echo <span class="token string">"$$USAGE_OPTIONS"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的<code>help</code>命令，通过解析 <code>Makefile</code> 文件中的<code>##</code>注释，获取支持的命令。通过这种方式，我们以后新加命令时，就不用再对 <code>help</code> 命令进行修改了。</p>
<p>你可以参考上面的 <code>Makefile</code> 管理功能，结合自己项目的需求，整理出一个 <code>Makefile</code> 要实现的功能列表，并初步确定实现思路和方法。做完这些，你的编写前准备工作就基本完成了。</p>
<h2 id="设计合理的-Makefile-结构"><a href="#设计合理的-Makefile-结构" class="headerlink" title="设计合理的 Makefile 结构"></a>设计合理的 <code>Makefile</code> 结构</h2><p>设计完 <code>Makefile</code> 需要实现的功能，接下来我们就进入 <code>Makefile</code> 编写阶段。编写阶段的第一步，就是设计一个合理的 <code>Makefile</code> 结构。</p>
<p>对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 <code>Makefile</code> 中，可能会导致 <code>Makefile</code> 很大，难以阅读和维护，所以<strong>建议采用分层的设计方法，根目录下的 <code>Makefile</code> 聚合所有的 <code>Makefile</code> 命令，具体实现则按功能分类，放在另外的 <code>Makefile</code> 中</strong>。</p>
<p>我们经常会在 <code>Makefile</code> 命令中集成 <code>shell</code> 脚本，但如果 <code>shell</code> 脚本过于复杂，也会导致 <code>Makefile</code> 内容过多，难以阅读和维护。并且在 <code>Makefile</code> 中集成复杂的 <code>shell</code> 脚本，编写体验也很差。对于这种情况，<strong>可以将复杂的 <code>shell</code> 命令封装在 <code>shell</code> 脚本中，供 <code>Makefile</code> 直接调用，而一些简单的命令则可以直接集成在 <code>Makefile</code> 中</strong>。</p>
<p>所以，最终我推荐的 <code>Makefile</code> 结构如下：</p>
<p><a href="https://static001.geekbang.org/resource/image/5c/f7/5c524e0297b6d6e4e151643d2e1bbbf7.png"><img src="https://static001.geekbang.org/resource/image/5c/f7/5c524e0297b6d6e4e151643d2e1bbbf7.png"></a></p>
<p>在上面的 <code>Makefile</code> 组织方式中，根目录下的 <code>Makefile</code> 聚合了项目所有的管理功能，这些管理功能通过 <code>Makefile</code> 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 <code>Makefile</code> 中，这样可以使得 <code>Makefile</code> 更容易维护。对于复杂的命令，则编写成独立的 <code>shell</code> 脚本，并在 <code>Makefile</code> 命令中调用这些 <code>shell</code> 脚本。</p>
<p>举个例子，下面是IAM项目的 <code>Makefile</code> 组织结构：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├──  <span class="token variable"><span class="token variable">`</span>Makefile<span class="token variable">`</span></span>
├── scripts
│   ├── gendoc.sh
│   ├── make-rules
│   │   ├── gen.mk
│   │   ├── golang.mk
│   │   ├── image.mk
│   │   └── <span class="token punctuation">..</span>.
		└── <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们将相同类别的操作统一放在<code>scripts/make-rules</code>目录下的 <code>Makefile</code> 文件中。 <code>Makefile</code> 的文件名参考分类命名，例如 <code>golang.mk</code>。最后，在&#x2F; <code>Makefile</code>  中 <code>include</code> 这些  <code>Makefile</code> 。</p>
<p>为了跟 <code>Makefile</code> 的层级相匹配，<code>golang.mk</code>中的所有目标都按<code>go.xxx</code>这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 <code>Makefile</code> 中尤其有用。以下是IAM项目根目录下， <code>Makefile</code> 的内容摘录，你可以看一看，作为参考：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> scripts/make-rules/golang.mk
<span class="token keyword">include</span> scripts/make-rules/image.mk
<span class="token keyword">include</span> scripts/make-rules/gen.mk
<span class="token keyword">include</span> scripts/make-rules/...

<span class="token comment">## build: Build source code for host platform.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> go.build
<span class="token comment">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build.multiarch
<span class="token target symbol">build.multiarch</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> go.build.multiarch

<span class="token comment">## image: Build docker images for host arch.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> image
<span class="token target symbol">image</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> image.build

<span class="token comment">## image.multiarch: Build docker images for multiple platforms. See option PLATFORMS.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> image.multiarch
<span class="token target symbol">image.multiarch</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> image.build.multiarch


<span class="token comment">## push: Build docker images for host arch and push images to registry.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> push
<span class="token target symbol">push</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> image.push

<span class="token comment">## ca: Generate CA files for all iam components.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> ca
<span class="token target symbol">ca</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> gen.ca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，一个合理的 <code>Makefile</code> 结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好 <code>Makefile</code> 当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用 <code>Makefile</code> 编程技巧，编写可扩展的 <code>Makefile</code> 。</p>
<p>这里需要你注意：上面的 <code>Makefile</code> 通过 <code>.PHONY</code> 标识定义了大量的伪目标，定义伪目标一定要加 <code>.PHONY</code> 标识，否则当有同名的文件时，伪目标可能不会被执行。</p>
<h2 id="掌握-Makefile-编写技巧"><a href="#掌握-Makefile-编写技巧" class="headerlink" title="掌握 Makefile 编写技巧"></a>掌握 <code>Makefile</code> 编写技巧</h2><p>最后，在编写过程中，你还需要掌握一些 <code>Makefile</code> 的编写技巧，这些技巧可以使你编写的 <code>Makefile</code> 扩展性更强，功能更强大。</p>
<p>接下来，我会把自己长期开发过程中积累的一些 <code>Makefile</code> 编写经验分享给你。这些技巧，你需要在实际编写中多加练习，并形成编写习惯。</p>
<h3 id="技巧1：善用通配符和自动变量"><a href="#技巧1：善用通配符和自动变量" class="headerlink" title="技巧1：善用通配符和自动变量"></a>技巧1：善用通配符和自动变量</h3><p> <code>Makefile</code> 允许对目标进行类似正则运算的匹配，主要用到的通配符是<code>%</code>。通过使用通配符，可以使不同的目标使用相同的规则，从而使 <code>Makefile</code> 扩展性更强，也更简洁。</p>
<p>我们的IAM实战项目中，就大量使用了通配符<code>%</code>，例如：<code>go.build.%</code>、<code>ca.gen.%</code>、<code>deploy.run.%</code>、<code>tools.verify.%</code>、<code>tools.install.%</code>等。</p>
<p>这里，我们来看一个具体的例子，<code>tools.verify.%</code>（位于<a href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/tools.mk#L17">scripts&#x2F;make-rules&#x2F;tools.mk</a>文件中）定义如下：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>if ! which <span class="token variable">$*</span> &amp;>/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$;</span> fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，<code>%</code>分别代表了<code>swagger</code>和<code>mockgen</code>。</p>
<p>如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p>
<p>另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：<code>tools</code>说明依赖的定义位于<code>scripts/make-rules/tools.mk</code>  <code>Makefile</code> 中；<code>verify</code>说明<code>tools.verify.%</code>伪目标属于<code>verify</code>分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 <code>Makefile</code> 文件中，以及想要完成的功能。</p>
<p>另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger</code>、<code>mockgen</code>。</p>
<h3 id="技巧2：善用函数"><a href="#技巧2：善用函数" class="headerlink" title="技巧2：善用函数"></a>技巧2：善用函数</h3><p> <code>Makefile</code> 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 <code>Makefile</code> 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md"> <code>Makefile</code> 常用函数列表</a> 中，你可以参考下。</p>
<p>IAM的 <code>Makefile</code> 文件中大量使用了上述函数，如果你想查看这些函数的具体使用方法和场景，可以参考IAM项目的 <code>Makefile</code> 文件 <a href="https://github.com/marmotedu/iam/tree/master/scripts/make-rules">make-rules</a>。</p>
<h3 id="技巧3：依赖需要用到的工具"><a href="#技巧3：依赖需要用到的工具" class="headerlink" title="技巧3：依赖需要用到的工具"></a>技巧3：依赖需要用到的工具</h3><p>如果 <code>Makefile</code> 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，<code>/</code> <code>Makefile</code> 文件中，<code>format</code>伪目标，定义如下：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> format
<span class="token target symbol">format</span><span class="token punctuation">:</span> tools.verify.golines tools.verify.goimports
	<span class="token operator">@</span>echo <span class="token string">"===========> Formating codes"</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>FIND<span class="token punctuation">)</span> -type f -name <span class="token string">'.go'</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>XARGS<span class="token punctuation">)</span> gofmt -s -w
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>FIND<span class="token punctuation">)</span> -type f -name <span class="token string">'.go'</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>XARGS<span class="token punctuation">)</span> goimports -w -local <span class="token variable">$</span><span class="token punctuation">(</span>ROOTPACKAGE<span class="token punctuation">)</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>FIND<span class="token punctuation">)</span> -type f -name <span class="token string">'.go'</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>XARGS<span class="token punctuation">)</span> golines -w --max-len<span class="token operator">=</span>120 --reformat-tags --shorten-comments --ignore-generated .
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> mod edit -fmt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>你可以看到，<code>format</code>依赖<code>tools.verify.golines tools.verify.goimports</code>。我们再来看下<code>tools.verify.golines</code>的定义：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>if ! which $ &amp;>/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$;</span> fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>再来看下<code>tools.install.$</code>规则：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> install.golinesinstall.golines<span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> get -u github.com/segmentio/golines<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装golines命令，就会自动调用<code>go get</code>安装，提高了 <code>Makefile</code> 的自动化程度。</p>
<h3 id="技巧4：把常用功能放在-x2F-Makefile-中，不常用的放在分类-Makefile-中"><a href="#技巧4：把常用功能放在-x2F-Makefile-中，不常用的放在分类-Makefile-中" class="headerlink" title="技巧4：把常用功能放在&#x2F; Makefile 中，不常用的放在分类 Makefile 中"></a>技巧4：把常用功能放在&#x2F; <code>Makefile</code> 中，不常用的放在分类 <code>Makefile</code> 中</h3><p>一个项目，尤其是大型项目，有很多需要管理的地方，其中大部分都可以通过 <code>Makefile</code> 实现自动化操作。不过，为了保持&#x2F; <code>Makefile</code> 文件的整洁性，我们不能把所有的命令都添加在&#x2F; <code>Makefile</code> 文件中。</p>
<p>一个比较好的建议是，将常用功能放在&#x2F; <code>Makefile</code> 中，不常用的放在分类 <code>Makefile</code> 中，并在&#x2F; <code>Makefile</code> 中include这些分类 <code>Makefile</code> 。</p>
<p>例如，IAM项目的&#x2F; <code>Makefile</code> 集成了<code>format</code>、<code>lint</code>、<code>test</code>、<code>build</code>等常用命令，而将<code>gen.errcode.code</code>、<code>gen.errcode.doc</code>这类不常用的功能放在<code>scripts/make-rules/gen.mk</code>文件中。当然，我们也可以直接执行 <code>make gen.errcode.code</code>来执行<code>gen.errcode.code</code>伪目标。通过这种方式，既可以保证&#x2F; <code>Makefile</code> 的简洁、易维护，又可以通过<code>make</code>命令来运行伪目标，更加灵活。</p>
<h3 id="技巧5：编写可扩展的-Makefile"><a href="#技巧5：编写可扩展的-Makefile" class="headerlink" title="技巧5：编写可扩展的 Makefile"></a>技巧5：编写可扩展的 <code>Makefile</code></h3><p>什么叫可扩展的 <code>Makefile</code> 呢？在我看来，可扩展的 <code>Makefile</code> 包含两层含义：</p>
<ol>
<li>可以在不改变 <code>Makefile</code> 结构的情况下添加新功能。</li>
<li>扩展项目时，新功能可以自动纳入到 <code>Makefile</code> 现有逻辑中。</li>
</ol>
<p>其中的第一点，我们可以通过设计合理的 <code>Makefile</code> 结构来实现。要实现第二点，就需要我们在编写 <code>Makefile</code> 时采用一定的技巧，例如多用通配符、自动变量、函数等。这里我们来看一个例子，可以让你更好地理解。</p>
<p>在我们IAM实战项目的<a href="https://github.com/marmotedu/iam/blob/v1.0.0/scripts/make-rules/golang.mk#L34">golang.mk</a>中，执行 <code>make go.build</code> 时能够构建cmd&#x2F;目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件，这就实现了上面说的第二点。</p>
<p>具体实现方法如下：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">COMMANDS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter-out</span> %.md, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> <span class="token variable">$/cmd/</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
BINS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> cmd,<span class="token variable">$,$</span><span class="token punctuation">(</span><span class="token function">notdir</span> $<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> go.build
<span class="token target symbol">go.build</span><span class="token punctuation">:</span> go.build.verify <span class="token variable">$</span><span class="token punctuation">(</span>addprefix go.build., <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span>., <span class="token variable">$</span><span class="token punctuation">(</span>BINS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> go.build.%


<span class="token target symbol">go.build.%</span><span class="token punctuation">:</span>
		<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> COMMAND <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 2,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ., ,$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> PLATFORM <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 1,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ., ,$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> OS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 1,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> _, ,<span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> ARCH <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 2,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> _, ,<span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">@</span>echo <span class="token string">"===========> Building binary $(COMMAND) $(VERSION) for $(OS) $(ARCH)"</span>
		<span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_DIR<span class="token punctuation">)</span>/platforms/<span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span>
		<span class="token operator">@</span>CGO_ENABLED<span class="token operator">=</span>0 GOOS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span> GOARCH<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> build <span class="token variable">$</span><span class="token punctuation">(</span>GO_BUILD_FLAGS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_DIR<span class="token punctuation">)</span>/platforms/<span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>COMMAND<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>GO_OUT_EXT<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_PACKAGE<span class="token punctuation">)</span>/cmd/<span class="token variable">$</span><span class="token punctuation">(</span>COMMAND<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当执行<code>make go.build</code> 时，会执行go.build的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))</code> ,<code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code> ，这时候就会执行 <code>go.build.%</code> 伪目标。</p>
<p>在 <code>go.build.%</code> 伪目标中，通过<code>eval</code>、<code>word</code>、<code>subst</code>函数组合，算出了<code>COMMAND</code>的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的<code>main</code>函数所在目录。</p>
<p>上述实现中有两个技巧，你可以注意下。首先，通过</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">COMMANDS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter-out</span> %.md, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> <span class="token variable">$/cmd/*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
BINS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> cmd,<span class="token variable">$,$</span><span class="token punctuation">(</span><span class="token function">notdir</span> $<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>获取到了<code>cmd/</code>目录下的所有组件名。</p>
<p>接着，通过使用通配符和自动变量，自动匹配到<code>go.build.linux_amd64.iam-authz-server</code> 这类伪目标并构建。</p>
<p>可以看到，想要编写一个可扩展的 <code>Makefile</code> ，熟练掌握 <code>Makefile</code> 的用法是基础，更多的是需要我们动脑思考如何去编写 <code>Makefile</code> 。</p>
<h3 id="技巧6：将所有输出存放在一个目录下，方便清理和查找"><a href="#技巧6：将所有输出存放在一个目录下，方便清理和查找" class="headerlink" title="技巧6：将所有输出存放在一个目录下，方便清理和查找"></a>技巧6：将所有输出存放在一个目录下，方便清理和查找</h3><p>在执行 <code>Makefile</code> 的过程中，会输出各种各样的文件，例如 <code>Go</code> 编译后的<code>二进制文件</code>、<code>测试覆盖率数据</code>等，我建议你把这些文件统一放在一个目录下，方便后期的清理和查找。通常我们可以把它们放在<code>_output</code>这类目录下，这样清理时就很方便，只需要清理<code>_output</code>文件夹就可以，例如：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> go.cleango.clean<span class="token punctuation">:</span>
	<span class="token operator">@</span>echo <span class="token string">"===========> Cleaning all build output"</span>
	<span class="token operator">@</span>-rm -vrf <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_DIR<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里要注意，要用<code>-rm</code>，而不是<code>rm</code>，防止在没有<code>_output</code>目录时，执行<code>make go.clean</code>报错。</p>
<h3 id="技巧7：使用带层级的命名方式"><a href="#技巧7：使用带层级的命名方式" class="headerlink" title="技巧7：使用带层级的命名方式"></a>技巧7：使用带层级的命名方式</h3><p>通过使用带层级的命名方式，例如<code>tools.verify.swagger</code> ，我们可以实现<strong>目标分组管理</strong>。这样做的好处有很多。首先，当 <code>Makefile</code> 有大量目标时，通过分组，我们可以更好地管理这些目标。其次，分组也能方便理解，可以通过组名一眼识别出该目标的功能类别。最后，这样做还可以大大减小目标重名的概率。</p>
<p>例如，IAM项目的 <code>Makefile</code> 就大量采用了下面这种命名方式。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.run
<span class="token target symbol">gen.run</span><span class="token punctuation">:</span> gen.clean gen.errcode gen.docgo

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode
<span class="token target symbol">gen.errcode</span><span class="token punctuation">:</span> gen.errcode.code gen.errcode.doc

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode.code
<span class="token target symbol">gen.errcode.code</span><span class="token punctuation">:</span> tools.verify.codegen
		...

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode.doc
<span class="token target symbol">gen.errcode.doc</span><span class="token punctuation">:</span> tools.verify.codegen
		...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="技巧8：做好目标拆分"><a href="#技巧8：做好目标拆分" class="headerlink" title="技巧8：做好目标拆分"></a>技巧8：做好目标拆分</h3><p>还有一个比较实用的技巧：我们要合理地拆分目标。比如，我们可以将安装工具拆分成两个目标：验证工具是否已安装和安装工具。通过这种方式，可以给我们的 <code>Makefile</code> 带来更大的灵活性。例如：我们可以根据需要选择性地执行其中一个操作，也可以两个操作一起执行。</p>
<p>这里来看一个例子：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">gen.errcode.code</span><span class="token punctuation">:</span> tools.verify.codegen

<span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>if ! which <span class="token variable">$*</span> &amp;>/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$;</span> fi

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> install.codegeninstall.codegen<span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> install <span class="token variable">$/tools/codegen/codegen.go</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的 <code>Makefile</code> 中，<code>gen.errcode.code</code>依赖了<code>tools.verify.codegen</code>，<code>tools.verify.codegen</code>会先检查<code>codegen</code>命令是否存在，如果不存在，再调用<code>install.codegen</code>来安装<code>codegen</code>工具。</p>
<p>如果我们的 <code>Makefile</code> 设计是：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">gen.errcode.code</span><span class="token punctuation">:</span> install.codegen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那每次执行<code>gen.errcode.code</code>都要重新安装<code>codegen</code>命令，这种操作是不必要的，还会导致 <code>make gen.errcode.code</code> 执行很慢。</p>
<h3 id="技巧9：设置OPTIONS"><a href="#技巧9：设置OPTIONS" class="headerlink" title="技巧9：设置OPTIONS"></a>技巧9：设置OPTIONS</h3><p>编写 <code>Makefile</code> 时，我们还需要把一些可变的功能通过<code>OPTIONS</code>来控制。为了帮助你理解，这里还是拿<code>IAM项目</code>的 <code>Makefile</code> 来举例。</p>
<p>假设我们需要通过一个选项 <code>V</code> ，来控制是否需要在执行 <code>Makefile</code> 时打印详细的信息。这可以通过下面的步骤来实现。</p>
<ol>
<li>在 <code>/Makefile</code> 中定义 <code>USAGE_OPTIONS</code><br><strong>首先，</strong>在&#x2F; <code>Makefile</code> 中定义 <code>USAGE_OPTIONS</code> 。定义 <code>USAGE_OPTIONS</code> 可以使开发者在执行 <code>make help</code> 后感知到此<code>OPTION</code>，并根据需要进行设置。</li>
</ol>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">define</span> USAGE_OPTIONS

<span class="token target symbol">Options</span><span class="token punctuation">:</span>
	...
	BINS         The binaries to build. Default is all of cmd.
							 ...
	...
	V            Set to 1 enable verbose build. Default is 0.
	<span class="token keyword">endef</span>
	<span class="token keyword">export</span> USAGE_OPTIONS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>根据 <code>V</code> 选项适配不同的行为<br><strong>接着，</strong>在<a href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/common.mk#L70">scripts&#x2F;make-rules&#x2F;common.mk</a>文件中，我们通过判断有没有设置V选项，来选择不同的行为：</li>
</ol>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifndef</span> V
MAKEFLAGS <span class="token operator">+=</span> --no-print-directory
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当然，我们还可以通过下面的方法来使用 <code>V</code> ：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> V<span class="token punctuation">)</span>, undefined<span class="token punctuation">)</span>
MAKEFLAGS <span class="token operator">+=</span> --no-print-directory
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面，我介绍了 <code>V</code> <code>OPTION</code>，我们在 <code>Makefile</code> 中通过判断有没有定义 <code>V</code> ，来执行不同的操作。其实还有一种<code>OPTION</code>，这种<code>OPTION</code>的值我们在 <code>Makefile</code> 中是直接使用的，例如<code>BINS</code>。针对这种<code>OPTION</code>，我们可以通过以下方式来使用：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">BINS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> cmd,<span class="token variable">$,$</span><span class="token punctuation">(</span><span class="token function">notdir</span> $<span class="token punctuation">)</span><span class="token punctuation">)</span>
...
<span class="token target symbol">go.build</span><span class="token punctuation">:</span> go.build.verify <span class="token variable">$</span><span class="token punctuation">(</span>addprefix go.build., <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span>., <span class="token variable">$</span><span class="token punctuation">(</span>BINS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>也就是说，通过 <strong><code>?=</code></strong> 来判断 <code>BINS</code> 变量有没有被赋值，如果没有，则赋予等号后的值。接下来，就可以在 <code>Makefile</code> 规则中使用它。</p>
<h3 id="技巧10：定义环境变量"><a href="#技巧10：定义环境变量" class="headerlink" title="技巧10：定义环境变量"></a>技巧10：定义环境变量</h3><p>我们可以在 <code>Makefile</code> 中定义一些环境变量，例如：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">GO <span class="token operator">:=</span> go
GO_SUPPORTED_VERSIONS <span class="token operator">?=</span> 1.13<span class="token operator">|</span>1.14<span class="token operator">|</span>1.15<span class="token operator">|</span>1.16<span class="token operator">|</span>1.17
GO_LDFLAGS <span class="token operator">+=</span> -X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitVersion<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>VERSION<span class="token punctuation">)</span> \
		-X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitCommit<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GIT_COMMIT<span class="token punctuation">)</span>	\
		-X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitTreeState<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GIT_TREE_STATE<span class="token punctuation">)</span> \
		-X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.BuildDate<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> date -u +<span class="token string">'%Y-%m-%dT%H:%M:%SZ'</span><span class="token punctuation">)</span>

<span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>DLV<span class="token punctuation">)</span>,<span class="token punctuation">)</span>                                                                                                                          					GO_BUILD_FLAGS <span class="token operator">+=</span> -gcflags <span class="token string">"all=-N -l"</span>
LDFLAGS <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">endif</span>

GO_BUILD_FLAGS <span class="token operator">+=</span> -tags<span class="token operator">=</span>jsoniter -ldflags <span class="token string">"$(GO_LDFLAGS)"</span>
...
FIND <span class="token operator">:=</span> find . ! -path <span class="token string">'./third_party/'</span> ! -path <span class="token string">'./vendor/'</span>
XARGS <span class="token operator">:=</span> xargs --no-run-if-empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些环境变量和编程中使用宏定义的作用是一样的：只要修改一处，就可以使很多地方同时生效，避免了重复的工作。</p>
<p>通常，我们可以将<code>GO</code>、<code>GO_BUILD_FLAGS</code>、<code>FIND</code>这类变量定义为环境变量。</p>
<h3 id="技巧11：自己调用自己"><a href="#技巧11：自己调用自己" class="headerlink" title="技巧11：自己调用自己"></a>技巧11：自己调用自己</h3><p>在编写 <code>Makefile</code> 的过程中，你可能会遇到这样一种情况：<code>A-Target</code>目标命令中，需要完成操作<code>B-Action</code>，而操作<code>B-Action</code>我们已经通过伪目标<code>B-Target</code>实现过。为了达到最大的代码复用度，这时候最好的方式是在<code>A-Target</code>的命令中执行<code>B-Target</code>。方法如下：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>if ! which $ &amp;>/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$;</span> fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里，我们通过 <code>$(MAKE)</code> 调用了伪目标 <code>tools.install.$</code> 。要注意的是，默认情况下， <code>Makefile</code> 在切换目录时会输出以下信息：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">$ make tools.install.codegen
<span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span>> Installing codegen
<span class="token target symbol">make[1]</span><span class="token punctuation">:</span> Entering directory /home/colin/workspace/golang/src/github.com/marmotedu/iam'
<span class="token target symbol">make[1]</span><span class="token punctuation">:</span> Leaving directory/home/colin/workspace/golang/src/github.com/marmotedu/iam'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果觉得<strong>Entering directory</strong>这类信息很烦人，可以通过设置 <code>MAKEFLAGS += --no-print-directory</code> 来禁止 <code>Makefile</code> 打印这些信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你想要高效管理项目，使用 <code>Makefile</code> 来管理是目前的最佳实践。我们可以通过下面的几个方法，来编写一个高质量的 <code>Makefile</code> 。</p>
<ol>
<li><p>需要熟练掌握 <code>Makefile</code> 的语法。我建议你重点掌握以下语法： <code>Makefile</code> 规则语法、伪目标、变量赋值、特殊变量、自动化变量。</p>
</li>
<li><p>需要提前规划 <code>Makefile</code> 要实现的功能。一个大型Go项目通常需要实现以下功能：<code>代码生成类命令</code>、<code>格式化类命令</code>、<code>静态代码检查</code>、 <code>测试类命令</code>、<code>构建类命令</code>、<code>Docker镜像打包类命令</code>、<code>部署类命令</code>、<code>清理类命令</code>，等等。</p>
</li>
<li><p>通过 <code>Makefile</code> 功能分类、<code>文件分层</code>、<code>复杂命令脚本化</code>等方式，来设计一个合理的 <code>Makefile</code> 结构。</p>
</li>
<li><p>需要掌握一些 <code>Makefile</code> 编写技巧，例如：<code>善用通配符</code>、<code>自动变量</code>和<code>函数</code>；编写可扩展的 <code>Makefile</code> ；使用带层级的命名方式，等等。通过这些技巧，可以进一步保证我们编写出一个高质量的 <code>Makefile</code> 。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>08 | 研发流程实战：IAM项目是如何进行研发流程管理</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-08-develop-process.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>为了向你演示流程，这里先假设一个场景。我们有一个需求：给<code>IAM</code>客户端工具<code>iamctl</code>增加一个<code>helloworld</code>命令，该命令向终端打印<code>hello world</code>。</p>
<p>接下来，我们就来看下如何具体去执行研发流程中的每一步。首先，我们进入开发阶段。</p>
<span id="more"></span>
<h2 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h2><p>开发阶段是开发者的主战场，完全由开发者来主导，它又可分为代码开发和代码提交两个子阶段。我们先来看下代码开发阶段。</p>
<h3 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h3><p>拿到需求之后，首先需要开发代码。这时，我们就需要选择一个适合团队和项目的<code>Git工作</code>流。因为<code>Git Flow</code>工作流比较适合大型的非开源项目，所以这里我们选择<strong>Git</strong> <strong>Flow工作流</strong>。代码开发的具体步骤如下：</p>
<p><em><strong>1. 基于<code>develop</code>分支，新建一个功能分支 <code>feature/helloworld</code>。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> feature/helloworld develop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>这里需要注意</strong>：新建的<code>branch</code>名要符合<code>Git Flow</code>工作流中的分支命名规则。否则，在<code>git commit</code>阶段，会因为<code>branch</code>不规范导致<code>commit</code>失败。<code>IAM</code>项目的分支命令规则具体如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/15/79/15bb43219269273baf70a27ea94e1279.png"><img src="https://static001.geekbang.org/resource/image/15/79/15bb43219269273baf70a27ea94e1279.png"></a></p>
<p><code>IAM</code>项目通过<code>pre-commit</code> <code>githooks</code>来确保分支名是符合规范的。在<code>IAM</code>项目根目录下执行<code>git commit</code> 命令，<code>git</code>会自动执行<a href="https://github.com/marmotedu/iam/blob/master/githooks/pre-commit">pre-commit</a>脚本，该脚本会检查当前<code>branch</code>的名字是否符合规范。</p>
<p>这里还有一个地方需要你注意：git不会提交 <code>.git/hooks</code> 目录下的<code>githooks</code>脚本，所以我们需要通过以下手段，确保开发者<code>clone</code>仓库之后，仍然能安装我们指定的<code>githooks</code>脚本到 <code>.git/hooks</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Copy githook scripts when execute makefile</span>
COPY_GITHOOK:<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>shell <span class="token function">cp</span> <span class="token parameter variable">-f</span> githooks/* .git/hooks/<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上述代码放在<a href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/common.mk#L74">scripts&#x2F;make-rules&#x2F;common.mk</a>文件中，每次执行make命令时都会执行，可以确保githooks都安装到 <code>.git/hooks</code> 目录下。</p>
<p><em><strong>2. 在<code>feature/helloworld</code>分支中，完成<code>helloworld</code>命令的添加。</strong></em></p>
<p>首先，通过 <code>iamctl new helloworld</code> 命令创建<code>helloworld</code>命令模板：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iamctl new helloworld <span class="token parameter variable">-d</span> internal/iamctl/cmd/helloworld
Command <span class="token function">file</span> generated: internal/iamctl/cmd/helloworld/helloworld.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>接着，编辑<code>internal/iamctl/cmd/cmd.go</code>文件，在源码文件中添加<code>helloworld.NewCmdHelloworld(f, ioStreams),</code>，加载<code>helloworld</code>命令。这里将<code>helloworld</code>命令设置为<code>Troubleshooting and Debugging Commands</code>命令分组：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"github.com/marmotedu/iam/internal/iamctl/cmd/helloworld"</span>
	<span class="token punctuation">)</span>
	    <span class="token operator">...</span>
			<span class="token punctuation">&#123;</span>
					Message<span class="token punctuation">:</span> <span class="token string">"Troubleshooting and Debugging Commands:"</span><span class="token punctuation">,</span>
					Commands<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">&#123;</span>
						  validate<span class="token punctuation">.</span><span class="token function">NewCmdValidate</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> ioStreams<span class="token punctuation">)</span><span class="token punctuation">,</span>
							helloworld<span class="token punctuation">.</span><span class="token function">NewCmdHelloworld</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> ioStreams<span class="token punctuation">)</span><span class="token punctuation">,</span>
					<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
			<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些操作中包含了<code>low code</code>的思想。要尽可能使用代码自动生成这一技术。这样做有两个好处：一方面能够提高我们的代码开发效率；另一方面也能够保证规范，减少手动操作可能带来的错误。所以这里，我将<code>iamctl</code>的命令也模板化，并通过 <code>iamctl new</code> 自动生成。</p>
<p><em><strong>3. 生成代码。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果改动不涉及代码生成，可以不执行<code>make gen</code>操作。 <code>make gen</code> 执行的其实是<code>gen.run</code>伪目标：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">gen.run</span><span class="token punctuation">:</span> gen.clean gen.errcode gen.docgo.doc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到，当执行 <code>make gen.run</code> 时，其实会先清理之前生成的文件，再分别自动生成<code>error code</code>和<code>doc.go</code>文件。</p>
<p>这里需要注意，通过<code>make gen</code> 生成的存量代码要具有幂等性。只有这样，才能确保每次生成的代码是一样的，避免不一致带来的问题。</p>
<p>我们可以将更多的与自动生成代码相关的功能放在 <code>gen.mk</code> <code>Makefile</code> 中。例如：</p>
<ul>
<li><code>gen.docgo.doc</code>，代表自动生成<code>doc.go</code>文件。</li>
<li><code>gen.ca.%</code>，代表自动生成<code>iamctl</code>、<code>iam-apiserver</code>、<code>iam-authz-server</code>证书文件。</li>
</ul>
<p><em><strong>4. 版权检查。</strong></em></p>
<p>如果有新文件添加，我们还需要执行 <code>make verify-copyright</code> ，来检查新文件有没有添加版权头信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> verify-copyright<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果版权检查失败，可以执行<code>make add-copyright</code>自动添加版权头。添加版权信息只针对开源软件，如果你的软件不需要添加，就可以略过这一步。</p>
<p>这里还有个<code>Makefile</code>编写技巧：如果<code>Makefile</code>的<code>command</code>需要某个命令，就可以使该目标依赖类似<code>tools.verify.addlicense</code>这种目标，<code>tools.verify.addlicense</code>会检查该工具是否已安装，如果没有就先安装。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> copyright.verify
<span class="token target symbol">copyright.verify</span><span class="token punctuation">:</span> tools.verify.addlicense
	...
<span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>if ! which $ &amp;>/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$;</span> fi

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> install.addlicense
<span class="token target symbol">install.addlicense</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> get -u github.com/marmotedu/addlicense<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过这种方式，可以使 <code>make copyright.verify</code> 尽可能自动化，减少手动介入的概率。</p>
<p><em><strong>5. 代码格式化。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">format</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>执行<code>make format</code>会依次执行以下格式化操作：</p>
<ol>
<li>调用<code>gofmt</code>格式化你的代码。</li>
<li>调用<code>goimports</code>工具，自动增删依赖的包，并将依赖包按字母序排序并分类。</li>
<li>调用<code>golines</code>工具，把超过<code>120</code>行的代码按<code>golines</code>规则，格式化成&lt;120行的代码。</li>
<li>调用 <code>go mod edit -fmt</code> 格式化<code>go.mod</code>文件。</li>
</ol>
<p><em><strong>6. 静态代码检查。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> lint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>关于静态代码检查，在这里你可以先了解代码开发阶段有这个步骤，至于如何操作，我会在下一讲给你详细介绍。</p>
<p><em><strong>7. 单元测试。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里要注意，并不是所有的包都需要执行单元测试。你可以通过如下命令，排除掉不需要单元测试的包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token builtin class-name">test</span> <span class="token variable"><span class="token variable">`</span>go list ./<span class="token punctuation">..</span>.<span class="token operator">|</span><span class="token function">egrep</span> <span class="token parameter variable">-v</span> <span class="token punctuation">$(</span>subst <span class="token punctuation">$(</span>SPACE<span class="token punctuation">)</span>,<span class="token string">'|'</span>,<span class="token punctuation">$(</span>sort <span class="token punctuation">$(</span>EXCLUDE_TESTS<span class="token punctuation">))</span><span class="token punctuation">)</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在<code>go.test</code>的<code>command</code>中，我们还运行了以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'/mock_.*.go/d'</span> <span class="token variable"><span class="token variable">$(</span>OUTPUT_DIR<span class="token variable">)</span></span>/coverage.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行该命令的目的，是把<code>mock_.*.go</code>文件中的函数单元测试信息从<code>coverage.out</code>中删除。<code>mock_.*.go</code>文件中的函数是不需要单元测试的，如果不删除，就会影响后面的单元测试覆盖率的计算。</p>
<p>如果想检查单元测试覆盖率，请执行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> cover<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>默认测试覆盖率至少为<code>60%</code>，也可以在命令行指定覆盖率阈值为其他值，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> cover <span class="token assign-left variable">COVERAGE</span><span class="token operator">=</span><span class="token number">90</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果测试覆盖率不满足要求，就会返回以下错误信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">test</span> coverage is <span class="token number">62.1</span>%test
coverage does not meet expectations: <span class="token number">90</span>%, please <span class="token function">add</span> <span class="token builtin class-name">test</span> cases<span class="token operator">!</span>
make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: *** <span class="token punctuation">[</span>go.test.cover<span class="token punctuation">]</span> Error <span class="token number">1</span>
make: *** <span class="token punctuation">[</span>cover<span class="token punctuation">]</span> Error <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里make命令的退出码为<code>1</code>。</p>
<p>如果单元测试覆盖率达不到设置的阈值，就需要补充测试用例，否则禁止合并到<code>develop</code>和<code>master</code>分支。<code>IAM</code>项目配置了<code>GitHub Actions CI</code>自动化流水线，<code>CI</code>流水线会自动运行，检查单元测试覆盖率是否达到要求。</p>
<p><em><strong>8. 构建。</strong></em></p>
<p>最后，我们执行<code>make build</code>命令，构建出<code>cmd/</code>目录下所有的二进制安装文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>make build</code> 会自动构建 <code>cmd/</code> 目录下的所有组件，如果只想构建其中的一个或多个组件，可以传入 <code>BINS</code>选项，组件之间用空格隔开，并用双引号引起来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span><span class="token string">"iam-apiserver iamctl"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>到这里，我们就完成了代码开发阶段的全部操作。</p>
<p>如果你觉得手动执行的<code>make</code>命令比较多，可以直接执行<code>make</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Generating iam error code go <span class="token builtin class-name">source</span> files
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Generating error code markdown documentation
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Generating missing doc.go <span class="token keyword">for</span> go packages
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Verifying the boilerplate headers <span class="token keyword">for</span> all files
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Formating codes
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Run golangci to lint <span class="token builtin class-name">source</span> codes
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Run unit test<span class="token punctuation">..</span>.
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Building binary iam-pump v0.7.2-24-g5814e7b <span class="token keyword">for</span> linux amd64
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> Building binary iamctl v0.7.2-24-g5814e7b <span class="token keyword">for</span> linux amd64<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>直接执行<code>make</code>会执行伪目标<code>all</code>所依赖的伪目标 <code>all: tidy gen add-copyright format lint cover build</code>，也即执行以下操作：依赖包添加<code>/</code>删除、生成代码、自动添加版权头、代码格式化、静态代码检查、覆盖率测试、构建。</p>
<p>这里你需要注意一点：<code>all</code>中依赖<code>cover</code>，<code>cover</code>实际执行的是 <code>go.test.cover</code> ，而 <code>go.test.cover</code> 又依赖 <code>go.test</code> ，所以<code>cover</code>实际上是先执行单元测试，再检查单元测试覆盖率是否满足预设的阈值。</p>
<p>最后补充一点，在开发阶段我们可以根据需要随时执行 <code>make gen</code> 、 <code>make format</code> 、 <code>make lint</code> 、 <code>make cover</code> 等操作，为的是能够提前发现问题并改正。</p>
<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><p>代码开发完成之后，我们就需要将代码提交到远程仓库，整个流程分为以下几个步骤。</p>
<p><em><strong>1. 开发完后，将代码提交到<code>feature/helloworld</code>分支，并<code>push</code>到远端仓库。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> internal/iamctl/cmd/helloworld internal/iamctl/cmd/cmd.go
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"feat: add new iamctl command 'helloworld'"</span>
<span class="token function">git</span> push origin feature/helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里我建议你只添加跟<code>feature/helloworld</code>相关的改动，这样就知道一个<code>commit</code>做了哪些变更，方便以后追溯。所以，我不建议直接执行<code>git add .</code>这类方式提交改动。</p>
<p>在提交<code>commit</code>时，<code>commit-msg</code> <code>githooks</code>会检查<code>commit message</code>是否符合<code>Angular Commit Message</code>规范，如果不符合会报错。<code>commit-msage</code>调用了<a href="https://github.com/llorllale/go-gitlint">go-gitlint</a>来检查<code>commit message</code>。<code>go-gitlint</code>会读取 <code>.gitlint</code> 中配置的<code>commit message</code>格式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--subject-regex<span class="token operator">=</span>^<span class="token variable"><span class="token punctuation">((</span>Merge branch.<span class="token operator">*</span>of.<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">((</span>revert<span class="token operator">:</span> <span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>feat<span class="token operator">|</span>fix<span class="token operator">|</span>perf<span class="token operator">|</span>style<span class="token operator">|</span>refactor<span class="token operator">|</span>test<span class="token operator">|</span>ci<span class="token operator">|</span>docs<span class="token operator">|</span>chore<span class="token punctuation">)</span><span class="token punctuation">(</span>\<span class="token punctuation">(</span>.<span class="token operator">+</span>\<span class="token punctuation">))</span></span>?: <span class="token punctuation">[</span>^A-Z<span class="token punctuation">]</span>.*<span class="token punctuation">[</span>^.<span class="token punctuation">]</span>$<span class="token punctuation">))</span>
--subject-maxlen<span class="token operator">=</span><span class="token number">72</span>
--body-regex<span class="token operator">=</span>^<span class="token punctuation">(</span><span class="token punctuation">[</span>^<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">0,72</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">\</span>r?<span class="token punctuation">\</span>n<span class="token operator">|</span>$<span class="token punctuation">))</span>*$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>IAM</code>项目配置了<code>GitHub Actions</code>，当有代码被<code>push</code>后，会触发<code>CI</code>流水线，流水线会执行<code>make all</code>目标。<code>GitHub Actions CI</code>流程执行记录如下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/68/22/6819f96bda8dcb214c3b7eeba2f37022.png"><img src="https://static001.geekbang.org/resource/image/68/22/6819f96bda8dcb214c3b7eeba2f37022.png"></a></p>
<p>如果<code>CI</code>不通过，就需要修改代码，直到<code>CI</code>流水线通过为止。</p>
<p><em><strong>2. 提交<code>pull request</code>。</strong></em></p>
<p>登陆<code>GitHub</code>，基于<code>feature/helloworld</code>创建<code>pull request</code>，并指定<code>Reviewers</code>进行<code>code review</code>。具体操作如下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/53/ab/53f4103f5c8cabb76ef2fddaec3a54ab.png"><img src="https://static001.geekbang.org/resource/image/53/ab/53f4103f5c8cabb76ef2fddaec3a54ab.png"></a></p>
<p>当有新的<code>pull request</code>被创建后，也会触发<code>CI</code>流水线。</p>
<p><em><strong>3. 创建完<code>pull request</code>后，就可以通知<code>reviewers</code> 来 <code>review</code>代码，<code>GitHub</code>也会发站内信。</strong></em></p>
<p><em><strong>4. <code>Reviewers</code> 对代码进行<code>review</code>。</strong></em></p>
<p><code>Reviewer</code>通过<code>review</code> <code>github diff</code>后的内容，并结合<code>CI</code>流程是否通过添加评论，并选择<code>Comment</code>（仅评论）、<code>Approve</code>（通过）、<code>Request Changes</code>（不通过，需要修改），如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/39/ce/39d992c7bdb35848706bce792877e8ce.png"><img src="https://static001.geekbang.org/resource/image/39/ce/39d992c7bdb35848706bce792877e8ce.png"></a></p>
<p>如果<code>review</code>不通过，<code>feature</code>开发者可以直接在<code>feature/helloworld</code>分支修正代码，并<code>push</code>到远端的<code>feature/helloworld</code>分支，然后通知<code>reviewers</code>再次<code>review</code>。因为有<code>push</code>事件发生，所以会触发<code>GitHub Actions CI</code>流水线。</p>
<p><em><strong>5. <code>code review</code>通过后，<code>maintainer</code>就可以将新的代码合并到<code>develop</code>分支。</strong></em></p>
<p>使用<strong>Create a merge commit</strong>的方式，将<code>pull request</code>合并到<code>develop</code>分支，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/30/7d/30de6bb6c8ff431ec56debbc0f5b667d.png"><img src="https://static001.geekbang.org/resource/image/30/7d/30de6bb6c8ff431ec56debbc0f5b667d.png"></a></p>
<p><strong>Create a merge commit</strong>的实际操作是 <code>git merge --no-ff</code>，<code>feature/helloworld</code>分支上所有的 <code>commit</code> 都会加到 <code>develop</code> 分支上，并且会生成一个 <code>merge commit</code>。使用这种方式，可以清晰地知道是谁做了哪些提交，回溯历史的时候也会更加方便。</p>
<p><em><strong>6. 合并到<code>develop</code>分支后，触发<code>CI</code>流程。</strong></em></p>
<p>到这里，开发阶段的操作就全部完成了，整体流程如下：</p>
<p><a href="https://static001.geekbang.org/resource/image/44/73/444b0701f8866b50a49bd0138488c873.png"><img src="https://static001.geekbang.org/resource/image/44/73/444b0701f8866b50a49bd0138488c873.png"></a></p>
<p>合并到<code>develop</code>分支之后，我们就可以进入开发阶段的下一阶段，也就是测试阶段了。</p>
<h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><p>在测试阶段，开发人员主要负责提供测试包和修复测试期间发现的<code>bug</code>，这个过程中也可能会发现一些新的需求或变动点，所以需要合理评估这些新的需求或变动点是否要放在当前迭代修改。</p>
<p>测试阶段的操作流程如下。</p>
<p><em><strong>1. 基于<code>develop</code>分支，创建<code>release</code>分支，测试代码。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> release/1.0.0 develop
<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong>2. 提交测试。</strong></em></p>
<p>将<code>release/1.0.0</code>分支的代码提交给测试同学进行测试。这里假设一个测试失败的场景：我们要求打印<code>“hello world”</code>，但打印的是<code>“Hello World”</code>，需要修复。那具体应该怎么操作呢？</p>
<p>你可以直接在<code>release/1.0.0</code>分支修改代码，修改完成后，本地构建并提交代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span>
<span class="token function">git</span> <span class="token function">add</span> internal/iamctl/cmd/helloworld/
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"fix: fix helloworld print bug"</span>
<span class="token function">git</span> push origin release/1.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>push</code>到<code>release/1.0.0</code>后，<code>GitHub Actions</code>会执行CI流水线。如果流水线执行成功，就将代码提供给测试；如果测试不成功，再重新修改，直到流水线执行成功。</p>
<p>测试同学会对<code>release/1.0.0</code>分支的代码进行充分的测试，例如功能测试、性能测试、集成测试、系统测试等。</p>
<p><em><strong>3. 测试通过后，将功能分支合并到<code>master</code>分支和<code>develop</code>分支。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout develop
<span class="token function">git</span> merge --no-ff release/1.0.0
<span class="token function">git</span> checkout master
<span class="token function">git</span> merge --no-ff release/1.0.0
<span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.0.0 <span class="token parameter variable">-m</span> <span class="token string">"add print hello world"</span> <span class="token comment"># master分支打tag</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>到这里，测试阶段的操作就基本完成了。测试阶段的产物是master&#x2F;develop分支的代码。</p>
<p><em><strong>4. 删除<code>feature/helloworld</code>分支，也可以选择性删除<code>release/1.0.0</code>分支。</strong></em></p>
<p>我们的代码都合并入<code>master/develop</code>分支后，<code>feature</code>开发者可以选择是否要保留<code>feature</code>。不过，如果没有特别的原因，我建议删掉，因为<code>feature</code>分支太多的话，不仅看起来很乱，还会影响性能，删除操作如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature/helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="IAM项目的Makefile项目管理技巧"><a href="#IAM项目的Makefile项目管理技巧" class="headerlink" title="IAM项目的Makefile项目管理技巧"></a>IAM项目的Makefile项目管理技巧</h2><p>在上面的内容中，我们以研发流程为主线，亲身体验了<code>IAM</code>项目的<code>Makefile</code>项目管理功能。这些是你最应该掌握的核心功能，但<code>IAM</code>项目的<code>Makefile</code>还有很多功能和设计技巧。接下来，我会给你分享一些很有价值的<code>Makefile</code>项目管理技巧。</p>
<h3 id="help自动解析"><a href="#help自动解析" class="headerlink" title="help自动解析"></a>help自动解析</h3><p>因为随着项目的扩展，<code>Makefile</code>大概率会不断加入新的管理功能，这些管理功能也需要加入到 <code>make help</code> 输出中。但如果每添加一个目标，都要修改 <code>make help</code> 命令，就比较麻烦，还容易出错。所以这里，我通过自动解析的方式，来生成<code>make help</code>输出：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">## help: Show this help info.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> help
<span class="token target symbol">help</span><span class="token punctuation">:</span> Makefile
	<span class="token operator">@</span>echo -e <span class="token string">"\nUsage: make &lt;TARGETS> &lt;OPTIONS> ...\n\nTargets:"</span>
	<span class="token operator">@</span>sed -n <span class="token string">'s/^##//p'</span> <span class="token variable">$&lt;</span> <span class="token operator">|</span> column -t -s <span class="token string">':'</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^/ /'</span>
	<span class="token operator">@</span>echo <span class="token string">"$$USAGE_OPTIONS"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>目标<code>help</code>的命令中，通过 <code>sed -n &#39;s/^##//p&#39; $&lt; | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39;</code> 命令，自动解析<code>Makefile</code>中 <code>##</code> 开头的注释行，从而自动生成 <code>make help</code> 输出。</p>
<h3 id="Options中指定变量值"><a href="#Options中指定变量值" class="headerlink" title="Options中指定变量值"></a>Options中指定变量值</h3><p>通过以下赋值方式，变量可以在<code>Makefile options</code>中被指定：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> COVERAGE<span class="token punctuation">)</span>,undefined<span class="token punctuation">)</span>
COVERAGE <span class="token operator">:=</span> 60
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例如，如果我们执行<code>make</code> ，则COVERAGE设置为默认值<code>60</code>；如果我们执行<code>make COVERAGE=90</code> ，则<code>COVERAGE</code>值为<code>90</code>。通过这种方式，我们可以更灵活地控制<code>Makefile</code>的行为。</p>
<h3 id="自动生成CHANGELOG"><a href="#自动生成CHANGELOG" class="headerlink" title="自动生成CHANGELOG"></a>自动生成CHANGELOG</h3><p>一个项目最好有<code>CHANGELOG</code>用来展示每个版本之间的变更内容，作为<code>Release Note</code>的一部分。但是，如果每次都要手动编写<code>CHANGELOG</code>，会很麻烦，也不容易坚持，所以这里我们可以借助<a href="https://github.com/git-chglog/git-chglog">git-chglog</a>工具来自动生成。</p>
<p><code>IAM</code>项目的<code>git-chglog</code>工具的配置文件放在<a href="https://github.com/marmotedu/iam/tree/master/.chglog">.chglog</a>目录下，在学习<code>git-chglog</code>工具时，你可以参考下。</p>
<h3 id="自动生成版本号"><a href="#自动生成版本号" class="headerlink" title="自动生成版本号"></a>自动生成版本号</h3><p>一个项目也需要有一个版本号，当前用得比较多的是语义化版本号规范。但如果靠开发者手动打版本号，工作效率低不说，经常还会出现漏打、打的版本号不规范等问题。所以最好的办法是，版本号也通过工具自动生成。在<code>IAM</code>项目中，采用了<a href="https://github.com/arnaud-deprez/gsemver">gsemver</a>工具来自动生成版本号。</p>
<p>整个<code>IAM</code>项目的版本号，都是通过<a href="https://github.com/marmotedu/iam/blob/master/scripts/ensure_tag.sh">scripts&#x2F;ensure_tag.sh</a>脚本来生成的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>vgsemver bump<span class="token variable">`</span></span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">git</span> tag <span class="token parameter variable">-l</span> $version<span class="token variable">`</span></span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
	<span class="token function">git</span> tag <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">"release version <span class="token variable">$version</span>"</span> <span class="token variable">$version</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>scripts/ensure_tag.sh</code>脚本中，通过 <code>gsemver bump</code> 命令来自动化生成语义化的版本号，并执行 <code>git tag -a</code> 给仓库打上版本号标签，<code>gsemver</code> 命令会根据<code>Commit Message</code>自动生成版本号。</p>
<p>之后，<code>Makefile</code>和<code>Shell</code>脚本用到的所有版本号均统一使用<a href="https://github.com/marmotedu/iam/blob/v1.0.0/scripts/make-rules/common.mk#L28">scripts&#x2F;make-rules&#x2F;common.mk</a>文件中的<code>VERSION</code>变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VERSION :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token function">git</span> describe <span class="token parameter variable">--tags</span> <span class="token parameter variable">--always</span> <span class="token parameter variable">--match</span><span class="token operator">=</span><span class="token string">'v*'</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上述的<code>Shell</code>命令通过 <code>git describe</code> 来获取离当前提交最近的<code>tag</code>（版本号）。</p>
<p>在执行 <code>git describe</code> 时，如果符合条件的<code>tag</code>指向最新提交，则只显示<code>tag</code>的名字，否则会有相关的后缀，来描述该<code>tag</code>之后有多少次提交，以及最新的提交<code>commit id</code>。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> describe <span class="token parameter variable">--tags</span> <span class="token parameter variable">--always</span> <span class="token parameter variable">--match</span><span class="token operator">=</span><span class="token string">'v*'</span>
v1.0.0-3-g1909e47<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里解释下版本号中各字符的含义：</p>
<ul>
<li><code>3</code>：表示自打<code>tag</code> <code>v1.0.0</code>以来有<code>3</code>次提交。</li>
<li><code>g1909e47</code>：<code>g</code> 为<code>git</code>的缩写，在多种管理工具并存的环境中很有用处。</li>
<li><code>1909e47</code>：<code>7</code>位字符表示为最新提交的<code>commit id</code> 前<code>7</code>位。</li>
</ul>
<p>最后解释下参数：</p>
<ul>
<li><code>–tags</code>，使用所有的标签，而不是只使用带注释的标签（<code>annotated tag</code>）。<code>git tag &lt;tagname&gt;</code> 生成一个 <code>unannotated tag</code>，<code>git tag -a &lt;tagname&gt; -m &#39;&lt;message&gt;&#39;</code> 生成一个 <code>annotated tag</code>。</li>
<li><code>–always</code>，如果仓库没有可用的标签，那么使用<code>commit</code>缩写来替代标签。</li>
<li><code>–match</code> ，只考虑与给定模式相匹配的标签。</li>
</ul>
<h3 id="保持行为一致"><a href="#保持行为一致" class="headerlink" title="保持行为一致"></a>保持行为一致</h3><p>上面我们介绍了一些管理功能，例如检查<code>Commit Message</code>是否符合规范、自动生成<code>CHANGELOG</code>、自动生成版本号。这些可以通过<code>Makefile</code>来操作，我们也可以手动执行。例如，通过以下命令，检查<code>IAM</code>的所有<code>Commit</code>是否符合<code>Angular Commit Message</code>规范：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go-gitlint
b62db1f: subject does not match regex <span class="token punctuation">[</span>^<span class="token punctuation">(</span>revert: <span class="token punctuation">)</span>?<span class="token punctuation">(</span>feat<span class="token operator">|</span>fix<span class="token operator">|</span>perf<span class="token operator">|</span>style<span class="token operator">|</span>refactor<span class="token operator">|</span><span class="token builtin class-name">test</span><span class="token operator">|</span>ci<span class="token operator">|</span>docs<span class="token operator">|</span>chore<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">(</span>.+<span class="token punctuation">\</span><span class="token punctuation">))</span>?: <span class="token punctuation">[</span>^A-Z<span class="token punctuation">]</span>.*<span class="token punctuation">[</span>^.<span class="token punctuation">]</span>$<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>也可以通过以下命令，手动来生成CHANGELOG：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git-chglog v1.0.0 CHANGELOG/CHANGELOG-1.0.0.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>还可以执行<code>gsemver</code>来生成版本号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gsemver bump
<span class="token number">1.0</span>.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里要强调的是，我们要保证<strong>不管使用手动操作，还是通过Makefile操作</strong>，都要确保<code>git commit message</code>规范检查结果、生成的<code>CHANGELOG</code>、生成的版本号是一致的。这需要我们<strong>采用同一种操作方式</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在整个研发流程中，需要开发人员深度参与的阶段有两个，分别是开发阶段和测试阶段。在开发阶段，开发者完成代码开发之后，通常需要执行生成代码、版权检查、代码格式化、静态代码检查、单元测试、构建等操作。我们可以将这些操作集成在Makefile中，来提高效率，并借此统一操作。</p>
<p>另外，<code>IAM</code>项目在编写<code>Makefile</code>时也采用了一些技巧，例如<code>make help</code> 命令中，<code>help</code>信息是通过解析<code>Makefile</code>文件的注释来完成的；可以通过<code>git-chglog</code>自动生成<code>CHANGELOG</code>；通过<code>gsemver</code>自动生成语义化的版本号等。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>GitFlow</tag>
        <tag>git-chglog</tag>
        <tag>gsemver</tag>
      </tags>
  </entry>
  <entry>
    <title>09 | 代码检查：进行静态代码检查</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-09-static-code.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在做<code>Go</code>项目开发的过程中，我们肯定需要对<code>Go</code>代码做静态代码检查。虽然<code>Go</code>命令提供了<code>go vet</code>和<code>go tool vet</code>，但是它们检查的内容还不够全面，我们需要一种更加强大的静态代码检查工具。</p>
<span id="more"></span>
<p>其实，<code>Go</code>生态中有很多这样的工具，也不乏一些比较优秀的。今天我想给你介绍的<code>golangci-lint</code>，是目前使用最多，也最受欢迎的静态代码检查工具，我们的<code>IAM</code>实战项目也用到了它。</p>
<p>接下来，我就从<code>golangci-lint</code>的优点、<code>golangci-lint</code>提供的命令和选项、<code>golangci-lint</code>的配置这三个方面来向你介绍下它。在你了解这些基础知识后，我会带着你使用<code>golangci-lint</code>进行静态代码检查，让你熟悉操作，在这个基础上，再把我使用<code>golangci-lint</code>时总结的一些经验技巧分享给你。</p>
<h2 id="为什么选择golangci-lint做静态代码检查？"><a href="#为什么选择golangci-lint做静态代码检查？" class="headerlink" title="为什么选择golangci-lint做静态代码检查？"></a>为什么选择golangci-lint做静态代码检查？</h2><p>选择 <code>golangci-lint</code> ，是因为它具有其他静态代码检查工具不具备的一些优点。在我看来，它的核心优点至少有这些：</p>
<ul>
<li><code>速度非常快</code>： <code>golangci-lint</code> 是基于<code>gometalinter</code>开发的，但是平均速度要比<code>gometalinter</code>快<code>5</code>倍。 <code>golangci-lint</code> 速度快的原因有三个：可以并行检查代码；可以复用go build缓存；会缓存分析结果。</li>
<li><code>可配置</code>：支持YAML格式的配置文件，让检查更灵活，更可控。</li>
<li><code>IDE集成</code>：可以集成进多个主流的<code>IDE</code>，例如 <code>VS Code</code>、<code>GNU Emacs</code>、<code>Sublime Text</code>、<code>Goland</code>等。</li>
<li><code>linter聚合器</code>：1.41.1版本的 <code>golangci-lint</code> 集成了76个<code>linter</code>，不需要再单独安装这76个<code>linter</code>。并且 <code>golangci-lint</code> 还支持自定义<code>linter</code>。</li>
<li><code>最小的误报数</code>： <code>golangci-lint</code> 调整了所集成<code>linter</code>的默认设置，大幅度减少了误报。</li>
<li><code>良好的输出</code>：输出的结果带有颜色、代码行号和<code>linter</code>标识，易于查看和定位。</li>
</ul>
<p>下图是一个 <code>golangci-lint</code> 的检查结果：</p>
<p><a href="https://static001.geekbang.org/resource/image/ed/d4/ed9c1d775e31a8a5b60a5a6882d0bed4.png"><img src="https://static001.geekbang.org/resource/image/ed/d4/ed9c1d775e31a8a5b60a5a6882d0bed4.png"></a></p>
<p>你可以看到，输出的检查结果中包括如下信息：</p>
<ul>
<li>检查出问题的源码文件、行号和错误行内容。</li>
<li>出问题的原因，也就是打印出不符合检查规则的原因。</li>
<li>报错的<code>linter</code>。</li>
</ul>
<p>通过查看 <code>golangci-lint</code> 的输出结果，可以准确地定位到报错的位置，快速弄明白报错的原因，方便开发者修复。</p>
<p>除了上述优点之外，在我看来 <code>golangci-lint</code> 还有一个非常大的优点：<strong>当前更新迭代速度很快，不断有新的<code>linter</code>被集成到 <code>golangci-lint</code> 中。</strong>有这么全的<code>linter</code>为你的代码保驾护航，你在交付代码时肯定会更有自信。</p>
<p>目前，有很多公司&#x2F;项目使用了 <code>golangci-lint</code> 工具作为静态代码检查工具，例如 <code>Google</code>、<code>Facebook</code>、<code>Istio</code>、<code>Red Hat OpenShift</code>等。</p>
<h2 id="golangci-lint提供了哪些命令和选项？"><a href="#golangci-lint提供了哪些命令和选项？" class="headerlink" title="golangci-lint提供了哪些命令和选项？"></a>golangci-lint提供了哪些命令和选项？</h2><p>在使用之前，首先需要**安装 <code>golangci-lint</code> **。 <code>golangci-lint</code> 的安装方法也很简单，你只需要执行以下命令，就可以安装了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go get github.com/golangci/golangci-lint/cmd/golangci-lint@v1.41.1
golangci-lint version <span class="token comment"># 输出 golangci-lint 版本号，说明安装成功</span>
golangci-lint has version v1.39.0 built from <span class="token punctuation">(</span>unknown, mod sum: <span class="token string">"h1:aAUjdBxARwkGLd5PU0vKuym281f2rFOyqh3GB4nXcq8="</span><span class="token punctuation">)</span> on <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里注意，为了避免安装失败，强烈建议你安装 <code>golangci-lint</code>  <code>releases page</code>中的指定版本，例如 <code>v1.41.1</code>。</p>
<p>另外，还建议你定期更新  <code>golangci-lint</code>  的版本，因为该项目正在被积极开发并不断改进。</p>
<p>安装之后，就可以使用了。我们可以通过执行 <code>golangci-lint -h</code> 查看其用法， <code>golangci-lint</code> 支持的<strong>子命令</strong>见下表：</p>
<p><a href="https://static001.geekbang.org/resource/image/34/42/34617a68604b7b5613948f89230c7a42.png"><img src="https://static001.geekbang.org/resource/image/34/42/34617a68604b7b5613948f89230c7a42.png"></a></p>
<p>此外， <code>golangci-lint</code> 还支持一些<strong>全局选项</strong>。全局选项是指适用于所有子命令的选项， <code>golangci-lint</code> 支持的全局选项如下：</p>
<p><a href="https://static001.geekbang.org/resource/image/79/88/79e517e6a7fd3882ce30320f28aa7088.png"><img src="https://static001.geekbang.org/resource/image/79/88/79e517e6a7fd3882ce30320f28aa7088.png"></a></p>
<p>接下来，我就详细介绍下 <code>golangci-lint</code> 支持的核心子命令：<code>run</code>、<code>cache</code>、<code>completion</code>、<code>config</code>、<code>linters</code>。</p>
<h3 id="run命令"><a href="#run命令" class="headerlink" title="run命令"></a>run命令</h3><p><code>run</code>命令执行 <code>golangci-lint</code> ，对代码进行检查，是 <code>golangci-lint</code> 最为核心的一个命令。<code>run</code>没有子命令，但有很多选项。<code>run</code>命令的具体使用方法，我会在讲解如何执行静态代码检查的时候详细介绍。</p>
<h3 id="cache命令"><a href="#cache命令" class="headerlink" title="cache命令"></a>cache命令</h3><p><code>cache</code>命令用来进行缓存控制，并打印缓存的信息。它包含两个子命令：</p>
<ul>
<li><code>clean</code> 用来清除<code>cache</code>，当我们觉得<code>cache</code>的内容异常，或者<code>cache</code>占用空间过大时，可以通过<code>golangci-lint cache clean</code>清除<code>cache</code>。</li>
<li><code>status</code> 用来打印<code>cache</code>的状态，比如<code>cache</code>的存放目录和<code>cache</code>的大小，例如：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint cache status
Dir: /home/colin/.cache/golangci-lint
Size: <span class="token number">773</span>.4KiB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="completion命令"><a href="#completion命令" class="headerlink" title="completion命令"></a>completion命令</h3><p><code>completion</code>命令包含<code>4</code>个子命令<code>bash</code>、<code>fish</code>、<code>powershell</code>和<code>zsh</code>，分别用来输出<code>bash</code>、<code>fish</code>、<code>powershell</code>和<code>zsh</code>的自动补全脚本。</p>
<p>下面是一个配置<code>bash</code>自动补全的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint completion <span class="token function">bash</span> <span class="token operator">></span> ~/.golangci-lint.bash
<span class="token builtin class-name">echo</span> <span class="token string">"source '<span class="token environment constant">$HOME</span>/.golangci-lint.bash'"</span> <span class="token operator">>></span> ~/.bashrc
<span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>执行完上面的命令，键入如下命令，即可自动补全子命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint comp<span class="token operator">&lt;</span>TAB<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令行会自动补全为<code>golangci-lint completion</code> 。</p>
<h3 id="config命令"><a href="#config命令" class="headerlink" title="config命令"></a>config命令</h3><p><code>config</code>命令可以打印 <code>golangci-lint</code> 当前使用的配置文件路径，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint config path
.golangci.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="linters命令"><a href="#linters命令" class="headerlink" title="linters命令"></a>linters命令</h3><p><code>linters</code>命令可以打印出 <code>golangci-lint</code> 所支持的<code>linter</code>，并将这些<code>linter</code>分成两类，分别是配置为启用的<code>linter</code>和配置为禁用的<code>linter</code>，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint linters
Enabled by your configuration linters:
<span class="token punctuation">..</span>.
deadcode: Finds unused code <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.
Disabled by your configuration linters:
exportloopref: checks <span class="token keyword">for</span> pointers to enclosing loop variables <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面我介绍了 <code>golangci-lint</code> 提供的命令，接下来，我们再来看下 <code>golangci-lint</code> 的配置。</p>
<h2 id="golangci-lint配置"><a href="#golangci-lint配置" class="headerlink" title="golangci-lint配置"></a>golangci-lint配置</h2><p>和其他linter相比， <code>golangci-lint</code> 一个非常大的优点是使用起来非常灵活，这要得益于它对自定义配置的支持。</p>
<p> <code>golangci-lint</code> 支持两种配置方式，分别是命令行选项和配置文件。如果<code>bool/string/int</code>的选项同时在命令行选项和配置文件中被指定，命令行的选项就会覆盖配置文件中的选项。如果是<code>slice</code>类型的选项，则命令行和配置中的配置会进行合并。</p>
<p><code>golangci-lint run</code> 支持很多<strong>命令行选项</strong>，可通过<code>golangci-lint run -h</code>查看，这里选择一些比较重要的选项进行介绍，见下表：</p>
<p><a href="https://static001.geekbang.org/resource/image/ac/fa/ac6098cf64cde7b8326cfd3508b04dfa.jpg"><img src="https://static001.geekbang.org/resource/image/ac/fa/ac6098cf64cde7b8326cfd3508b04dfa.jpg"></a></p>
<p>此外，我们还可以通过 <code>golangci-lint</code> <strong>配置文件</strong>进行配置，默认的配置文件名为<code>.golangci.yaml</code>、<code>.golangci.toml</code>、<code>.golangci.json</code>，可以通过<code>-c</code>选项指定配置文件名。通过配置文件，可以实现下面几类功能：</p>
<ul>
<li><code>golangci-lint</code>本身的一些选项，比如<code>超时</code>、<code>并发</code>，是否检查<code>__test.go_</code>文件等。</li>
<li>配置需要忽略的文件和文件夹。</li>
<li>配置启用哪些<code>linter</code>，禁用哪些<code>linter</code>。</li>
<li>配置输出格式。</li>
<li><code>golangci-lint</code> 支持很多<code>linter</code>，其中有些<code>linter</code>支持一些配置项，这些配置项可以在配置文件中配置。</li>
<li>配置符合指定正则规则的文件可以忽略的<code>linter</code>。</li>
<li>设置错误严重级别，像日志一样，检查错误也是有严重级别的。</li>
</ul>
<p>更详细的配置内容，你可以参考<a href="https://golangci-lint.run/usage/configuration/">Configuration</a>。另外，你也可以参考IAM项目的 <code>golangci-lint</code> 配置<a href="https://github.com/marmotedu/iam/blob/master/.golangci.yaml">.golangci.yaml</a>。.golangci.yaml里面的一些配置，我建议你一定要设置，具体如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">run</span><span class="token punctuation">:</span>
	<span class="token key atrule">skip-dirs</span><span class="token punctuation">:</span>
	<span class="token comment"># 设置要忽略的目录</span>
		<span class="token punctuation">-</span> util
		<span class="token punctuation">-</span> .~
		<span class="token punctuation">-</span> api/swagger/docs
	<span class="token key atrule">skip-files</span><span class="token punctuation">:</span> <span class="token comment"># 设置不需要检查的go源码文件，支持正则匹配，这里建议包括：_test.go</span>
		<span class="token punctuation">-</span> <span class="token string">".*.my.go$"</span>
		<span class="token punctuation">-</span> _test.go
<span class="token key atrule">linters-settings</span><span class="token punctuation">:</span>
	<span class="token key atrule">errcheck</span><span class="token punctuation">:</span>
		<span class="token key atrule">check-type-assertions</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 这里建议设置为true，如果确实不需要检查，可以写成num, _ := strconv.Atoi(numStr)</span>
		<span class="token key atrule">check-blank</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
	<span class="token key atrule">gci</span><span class="token punctuation">:</span>    <span class="token comment"># 将以github.com/marmotedu/iam开头的包放在第三方包后面</span>
		<span class="token key atrule">local-prefixes</span><span class="token punctuation">:</span> github.com/marmotedu/iam
	<span class="token key atrule">godox</span><span class="token punctuation">:</span>
		<span class="token key atrule">keywords</span><span class="token punctuation">:</span> <span class="token comment"># 建议设置为BUG、FIXME、OPTIMIZE、HACK</span>
			<span class="token punctuation">-</span> BUG
			<span class="token punctuation">-</span> FIXME
			<span class="token punctuation">-</span> OPTIMIZE
			<span class="token punctuation">-</span> HACK
	<span class="token key atrule">goimports</span><span class="token punctuation">:</span>
		<span class="token comment"># 设置哪些包放在第三方包后面，可以设置多个包，逗号隔开</span>
		<span class="token key atrule">local-prefixes</span><span class="token punctuation">:</span> github.com/marmotedu/iam
	<span class="token key atrule">gomoddirectives</span><span class="token punctuation">:</span> <span class="token comment"># 设置允许在go.mod中replace的包</span>
		<span class="token key atrule">replace-local</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
		<span class="token key atrule">replace-allow-list</span><span class="token punctuation">:</span>
			<span class="token punctuation">-</span> github.com/coreos/etcd
			<span class="token punctuation">-</span> google.golang.org/grpc
			<span class="token punctuation">-</span> github.com/marmotedu/api
			<span class="token punctuation">-</span> github.com/marmotedu/component<span class="token punctuation">-</span>base
			<span class="token punctuation">-</span> github.com/marmotedu/marmotedu<span class="token punctuation">-</span>sdk<span class="token punctuation">-</span>go
	<span class="token key atrule">gomodguard</span><span class="token punctuation">:</span> <span class="token comment"># 下面是根据需要选择可以使用的包和版本，建议设置</span>
		<span class="token key atrule">allowed</span><span class="token punctuation">:</span>
			<span class="token key atrule">modules</span><span class="token punctuation">:</span>
				<span class="token punctuation">-</span> gorm.io/gorm
				<span class="token punctuation">-</span> gorm.io/driver/mysql
				<span class="token punctuation">-</span> k8s.io/klog
			<span class="token key atrule">domains</span><span class="token punctuation">:</span> <span class="token comment"># List of allowed module domains</span>
				<span class="token punctuation">-</span> google.golang.org
				<span class="token punctuation">-</span> gopkg.in
				<span class="token punctuation">-</span> golang.org
				<span class="token punctuation">-</span> github.com
				<span class="token punctuation">-</span> go.uber.org
		<span class="token key atrule">blocked</span><span class="token punctuation">:</span>
			<span class="token key atrule">modules</span><span class="token punctuation">:</span>
				<span class="token punctuation">-</span> <span class="token key atrule">github.com/pkg/errors</span><span class="token punctuation">:</span>
						<span class="token key atrule">recommendations</span><span class="token punctuation">:</span>
							<span class="token punctuation">-</span> github.com/marmotedu/errors
						<span class="token key atrule">reason</span><span class="token punctuation">:</span> <span class="token string">"github.com/marmotedu/errors is the log package used by marmotedu projects."</span>
			<span class="token key atrule">versions</span><span class="token punctuation">:</span>
				<span class="token punctuation">-</span> <span class="token key atrule">github.com/MakeNowJust/heredoc</span><span class="token punctuation">:</span>
						<span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"> 2.0.9"</span>
						<span class="token key atrule">reason</span><span class="token punctuation">:</span> <span class="token string">"use the latest version"</span>
			<span class="token key atrule">local_replace_directives</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
	<span class="token key atrule">lll</span><span class="token punctuation">:</span>
		<span class="token key atrule">line-length</span><span class="token punctuation">:</span> <span class="token number">240</span> <span class="token comment"># 这里可以设置为240，240一般是够用的</span>
	<span class="token key atrule">importas</span><span class="token punctuation">:</span> <span class="token comment"># 设置包的alias，根据需要设置</span>
		<span class="token key atrule">jwt</span><span class="token punctuation">:</span> github.com/appleboy/gin<span class="token punctuation">-</span>jwt/v2
		<span class="token key atrule">metav1</span><span class="token punctuation">:</span> github.com/marmotedu/component<span class="token punctuation">-</span>base/pkg/meta/v1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是， <code>golangci-lint</code> 不建议使用 <code>enable-all: true</code> 选项，为了尽可能使用最全的<code>linters</code>，我们可以使用以下配置：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">linters</span><span class="token punctuation">:</span>
	<span class="token key atrule">disable-all</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
	<span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token comment"># enable下列出 &lt;期望的所有linters></span>
		<span class="token punctuation">-</span> typecheck
		<span class="token punctuation">-</span> <span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>&lt;期望的所有linters&gt; = &lt;golangci-lint支持的所有linters&gt; - &lt;不期望执行的linters&gt;</code>，我们可以通过执行以下命令来获取：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./scripts/print_enable_linters.sh
- asciicheck
- bodyclose
- cyclop
- deadcode
- <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将以上输出结果替换掉.golangci.yaml配置文件中的 <code>linters.enable</code> 部分即可。</p>
<p>上面我们介绍了与 <code>golangci-lint</code> 相关的一些基础知识，接下来我就给你详细展示下，如何使用 <code>golangci-lint</code> 进行静态代码检查。</p>
<h2 id="如何使用golangci-lint进行静态代码检查？"><a href="#如何使用golangci-lint进行静态代码检查？" class="headerlink" title="如何使用golangci-lint进行静态代码检查？"></a>如何使用golangci-lint进行静态代码检查？</h2><p>要对代码进行静态检查，只需要执行 <code>golangci-lint run</code> 命令即可。接下来，我会先给你介绍5种常见的 <code>golangci-lint</code> 使用方法。</p>
<p><em><strong>1.  对当前目录及子目录下的所有<code>Go</code>文件进行静态代码检查：</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>命令等效于<code>golangci-lint run ./...</code>。</p>
<p><em><strong>2.  对指定的Go文件或者指定目录下的Go文件进行静态代码检查：</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run dir1 dir2/<span class="token punctuation">..</span>. dir3/file1.go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里需要你注意：上述命令不会检查<code>dir1</code>下子目录的<code>Go</code>文件，如果想递归地检查一个目录，需要在目录后面追加<code>/...</code>，例如：<code>dir2/...</code>。</p>
<p><em><strong>3.  根据指定配置文件，进行静态代码检查：</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run <span class="token parameter variable">-c</span> .golangci.yaml ./<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>4.  运行指定的linter：</strong></em></p>
<p><code>golangci-lint</code> 可以在不指定任何配置文件的情况下运行，这会运行默认启用的<code>linter</code>，你可以通过<code>golangci-lint help linters</code>查看它。</p>
<p>你可以传入参数<code>-E/--enable</code>来使某个<code>linter</code>可用，也可以使用<code>-D/--disable</code>参数来使某个<code>linter</code>不可用。下面的示例仅仅启用了<code>errcheck linter</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run --no-config --disable-all <span class="token parameter variable">-E</span> errcheck ./<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里你需要注意，默认情况下， <code>golangci-lint</code> 会从当前目录一层层往上寻找配置文件名<code>.golangci.yaml</code>、<code>.golangci.toml</code>、<code>.golangci.json</code>直到根<code>（/）</code>目录。如果找到，就以找到的配置文件作为本次运行的配置文件，所以为了防止读取到未知的配置文件，可以用 <code>--no-config</code> 参数使 <code>golangci-lint</code> 不读取任何配置文件。</p>
<p><em><strong>5.  禁止运行指定的liner：</strong></em></p>
<p>如果我们想禁用某些linter，可以使用<code>-D</code>选项。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run --no-config <span class="token parameter variable">-D</span> godot,errcheck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在使用 <code>golangci-lint</code> 进行代码检查时，可能会有很多误报。所谓的误报，其实是我们希望 <code>golangci-lint</code> 的一些linter能够容忍某些<code>issue</code>。那么如何尽可能减少误报呢？ <code>golangci-lint</code> 也提供了一些途径，我建议你使用下面这三种：</p>
<ul>
<li>在命令行中添加<code>-e</code>参数，或者在配置文件的<code>issues.exclude</code>部分设置要排除的检查错误。你也可以使用<code>issues.exclude-rules</code>来配置哪些文件忽略哪些<code>linter</code>。</li>
<li>通过<code>run.skip-dirs</code>、<code>run.skip-files</code>或者<code>issues.exclude-rules</code>配置项，来忽略指定目录下的所有<code>Go</code>文件，或者指定的<code>Go</code>文件。</li>
<li>通过在<code>Go</code>源码文件中添加<code>//nolint</code>注释，来忽略指定的代码行。</li>
</ul>
<p>因为 <code>golangci-lint</code> 设置了很多<code>linters</code>，对于一个大型项目，启用所有的<code>linter</code>会检查出很多问题，并且每个项目对<code>linter</code>检查的粒度要求也不一样，所以<code>glangci-lint</code><strong>使用<code>nolint</code>标记来开关某些检查项</strong>，不同位置的<code>nolint</code>标记效果也会不一样。接下来我想向你介绍<code>nolint</code>的几种用法。</p>
<ol>
<li>忽略某一行所有<code>linter</code>的检查</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> bad_name <span class="token builtin">int</span> <span class="token comment">//nolint</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>忽略某一行指定linter的检查，可以指定多个<code>linter</code>，用逗号 <code>,</code> 隔开。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> bad_name <span class="token builtin">int</span> <span class="token comment">//nolint:golint,unused</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>忽略某个代码块的检查。</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//nolint</span>
<span class="token keyword">func</span> <span class="token function">allIssuesInThisFunctionAreExcluded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//nolint:govet</span>
<span class="token keyword">var</span> <span class="token punctuation">(</span>
	a <span class="token builtin">int</span>
	b <span class="token builtin">int</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>忽略某个文件的指定<code>linter</code>检查。</li>
</ol>
<p>在<code>package xx </code>上面一行添加<code>//nolint</code>注释。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//nolint:unparam</span>
<span class="token keyword">package</span> pkg<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在使用<code>nolint</code>的过程中，有3个地方需要你注意。</p>
<p>首先，如果启用了<code>nolint</code>，你就需要在<code>//nolint</code>后面添加nolint的原因<code>// xxxx</code>。</p>
<p>其次，你使用的应该是<code>//nolint</code>而不是<code>// nolint</code>。因为根据<code>Go</code>的规范，需要程序读取的注释<code>//</code>后面不应该有空格。</p>
<p>最后，如果要忽略所有<code>linter</code>，可以用<code>//nolint</code>；如果要忽略某个指定的<code>linter</code>，可以用<code>//nolint:&lt;linter1&gt;,&lt;linter2&gt;</code>。</p>
<h2 id="golangci-lint使用技巧"><a href="#golangci-lint使用技巧" class="headerlink" title="golangci-lint使用技巧"></a>golangci-lint使用技巧</h2><p>我在使用 <code>golangci-lint</code> 时，总结了一些经验技巧，放在这里供你参考，希望能够帮助你更好地使用 <code>golangci-lint</code> 。</p>
<p><strong>技巧1：第一次修改，可以按目录修改。</strong></p>
<p>如果你第一次使用 <code>golangci-lint</code> 检查你的代码，一定会有很多错误。为了减轻修改的压力，可以按目录检查代码并修改。这样可以有效减少失败条数，减轻修改压力。</p>
<p>当然，如果错误太多，一时半会儿改不完，想以后慢慢修改或者干脆不修复存量的issues，那么你可以使用 <code>golangci-lint</code> 的 <code>--new-from-rev</code> 选项，只检查新增的<code>code</code>，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run --new-from-rev<span class="token operator">=</span>HEAD~1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>技巧2：按文件修改，减少文件切换次数，提高修改效率。</strong></p>
<p>如果有很多检查错误，涉及很多文件，建议先修改一个文件，这样就不用来回切换文件。可以通过<code>grep</code>过滤出某个文件的检查失败项，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run ./<span class="token punctuation">..</span>.<span class="token operator">|</span><span class="token function">grep</span> pkg/storage/redis_cluster.go
pkg/storage/redis_cluster.go:16:2: <span class="token string">"github.com/go-redis/redis/v7"</span> imported but not used <span class="token punctuation">(</span>typecheck<span class="token punctuation">)</span>
pkg/storage/redis_cluster.go:82:28: undeclared name: redis <span class="token punctuation">(</span>typecheck<span class="token punctuation">)</span>
pkg/storage/redis_cluster.go:86:14: undeclared name: redis <span class="token punctuation">(</span>typecheck<span class="token punctuation">)</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>技巧3：把<code>linters-setting.lll.line-length</code>设置得大一些。</strong></p>
<p>在<code>Go</code>项目开发中，为了易于阅读代码，通常会将<code>变量名</code>&#x2F;<code>函数</code>&#x2F;<code>常量</code>等命名得有意义，这样很可能导致每行的代码长度过长，很容易超过<code>lll</code> linter设置的默认最大长度<code>80</code>。这里建议将<code>linters-setting.lll.line-length</code>设置为<code>120</code>&#x2F;<code>240</code>。</p>
<p><strong>技巧4：尽可能多地使用 <code>golangci-lint</code> 提供的<code>linter</code>。</strong></p>
<p> <code>golangci-lint</code> 集成了很多<code>linters</code>，可以通过如下命令查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint linters
Enabled by your configuration linters:
deadcode: Finds unused code <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.
varcheck: Finds unused global variables and constants <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span>

Disabled by your configuration linters:
asciicheck: Simple linter to check that your code does not contain non-ASCII identifiers <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.
wsl: Whitespace Linter - Forces you to use empty lines<span class="token operator">!</span> <span class="token punctuation">[</span>fast: true, auto-fix: false<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些<code>linter</code>分为两类，一类是<code>默认启用</code>的，另一类是<code>默认禁用</code>的。每个<code>linter</code>都有两个属性：</p>
<ul>
<li><code>fast</code> ：<code>true/false</code>，如果为<code>true</code>，说明该<code>linter</code>可以缓存类型信息，支持快速检查。因为第一次缓存了这些信息，所以后续的运行会非常快。</li>
<li><code>auto-fix </code>：<code>true/false</code>，如果为<code>true</code>说明该<code>linter</code>支持自动修复发现的错误；如果为<code>false</code>说明不支持自动修复。</li>
</ul>
<p>如果配置了 <code>golangci-lint</code> 配置文件，则可以通过命令<code>golangci-lint help linters</code>查看在当前配置下启用和禁用了哪些<code>linter</code>。 <code>golangci-lint</code> 也支持自定义<code>linter</code>插件，具体你可以参考：<a href="https://golangci-lint.run/contributing/new-linters">New linters</a>。</p>
<p>在使用 <code>golangci-lint</code> 的时候，我们要尽可能多的使用<code>linter</code>。使用的<code>linter</code>越多，说明检查越严格，意味着代码越规范，质量越高。如果时间和精力允许，建议打开 <code>golangci-lint</code> 提供的所有<code>linter</code>。</p>
<p><strong>技巧5：每次修改代码后，都要执行 <code>golangci-lint</code> 。</strong></p>
<p>每次修改完代码后都要执行 <code>golangci-lint</code> ，一方面可以及时修改不规范的地方，另一方面可以减少错误堆积，减轻后面的修改压力。</p>
<p><strong>技巧6：建议在根目录下放一个通用的 <code>golangci-lint</code> 配置文件。</strong></p>
<p>在<code>/</code>目录下存放通用的 <code>golangci-lint</code> 配置文件，可以让你不用为每一个项目都配置 <code>golangci-lint</code> 。当你需要为某个项目单独配置 <code>golangci-lint</code> 时，只需在该项目根目录下增加一个项目级别的 <code>golangci-lint</code> 配置文件即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go项目开发中，对代码进行静态代码检查是必要的操作。当前有很多优秀的静态代码检查工具，但 <code>golangci-lint</code> 因为具有检查速度快、可配置、少误报、内置了大量linter等优点，成为了目前最受欢迎的静态代码检查工具。</p>
<p> <code>golangci-lint</code> 功能非常强大，支持诸如<code>run</code>、<code>cache</code>、<code>completion</code>、<code>linters</code>等命令。其中最常用的是<code>run</code>命令，<code>run</code>命令可以通过以下方式来进行静态代码检查：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">golangci-lint run <span class="token comment">#  对当前目录及子目录下的所有Go文件进行静态代码检查</span>
golangci-lint run dir1 dir2/<span class="token punctuation">..</span>. dir3/file1.go <span class="token comment"># 对指定的Go文件或者指定目录下的Go文件进行静态代码检查</span>
golangci-lint run <span class="token parameter variable">-c</span> .golangci.yaml ./<span class="token punctuation">..</span>. <span class="token comment"># 根据指定配置文件，进行静态代码检查</span>
golangci-lint run --no-config --disable-all <span class="token parameter variable">-E</span> errcheck ./<span class="token punctuation">..</span>. <span class="token comment"># 运行指定的 errcheck linter</span>
golangci-lint run --no-config <span class="token parameter variable">-D</span> godot,errcheck <span class="token comment"># 禁止运行指定的godot,errcheck liner</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此外， <code>golangci-lint</code> 还支持 <code>//nolint</code> 、<code>//nolint:golint,unused</code> 等方式来减少误报。</p>
<p>最后，我分享了一些自己使用 <code>golangci-lint</code> 时总结的经验。例如：第一次修改，可以按目录修改；按文件修改，减少文件切换次数，提高修改效率；尽可能多地使用 <code>golangci-lint</code> 提供的<code>linter</code>。希望这些建议对你使用 <code>golangci-lint</code> 有一定帮助。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>golangci-lint</tag>
      </tags>
  </entry>
  <entry>
    <title>10 | API 文档：生成 Swagger API 文档</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-10-swagger-api.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>作为一名开发者，我们通常讨厌编写文档，因为这是一件重复和缺乏乐趣的事情。但是在开发过程中，又有一些文档是我们必须要编写的，比如 <code>API</code> 文档。</p>
<p>一个企业级的Go后端项目，通常也会有个配套的前端。为了加快研发进度，通常是后端和前端并行开发，这就需要后端开发者在开发后端代码之前，先设计好 <code>API</code> 接口，提供给前端。所以在设计阶段，我们就需要生成 <code>API</code> 接口文档。</p>
<span id="more"></span>
<p>一个好的 <code>API</code> 文档，可以减少用户上手的复杂度，也意味着更容易留住用户。好的 <code>API</code> 文档也可以减少沟通成本，帮助开发者更好地理解 <code>API</code> 的调用方式，从而节省时间，提高开发效率。这时候，我们一定希望有一个工具能够帮我们自动生成 <code>API</code> 文档，解放我们的双手。 <code>Swagger</code> 就是这么一个工具，可以帮助我们<strong>生成易于共享且具有足够描述性的 <code>API</code> 文档</strong>。</p>
<p>接下来，我们就来看下，如何使用 <code>Swagger</code> 生成 <code>API</code> 文档。</p>
<h2 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a>Swagger介绍</h2><p> <code>Swagger</code> 是一套围绕 <code>OpenAPI</code> 规范构建的开源工具，可以设计、构建、编写和使用<code>REST API</code>。<code>Swagger</code>包含很多工具，其中主要的 <code>Swagger</code> 工具包括：</p>
<ul>
<li><code>Swagger 编辑器</code> ：基于浏览器的编辑器，可以在其中编写 <code>OpenAPI</code> 规范，并实时预览 <code>API</code> 文档。<a href="https://editor.swagger.io/"></a><a href="https://editor.swagger.io/">https://editor.swagger.io</a> 就是一个 <code>Swagger</code> 编辑器，你可以尝试在其中编辑和预览 <code>API</code> 文档。</li>
<li><code>Swagger  UI</code> ：将 <code>OpenAPI</code>  规范呈现为交互式 <code>API</code> 文档，并可以在浏览器中尝试 <code>API</code> 调用。</li>
<li><code>Swagger  Codegen</code> ：根据 <code>OpenAPI</code> 规范，生成服务器存根和客户端代码库，目前已涵盖了<code>40</code>多种语言。</li>
</ul>
<h3 id="Swagger和OpenAPI的区别"><a href="#Swagger和OpenAPI的区别" class="headerlink" title="Swagger和OpenAPI的区别"></a>Swagger和OpenAPI的区别</h3><p>我们在谈到 <code>Swagger</code> 时，也经常会谈到 <code>OpenAPI</code> 。那么二者有什么区别呢？</p>
<p> <code>OpenAPI</code> 是一个 <code>API</code> 规范，它的前身叫 <code>Swagger</code> 规范，通过定义一种用来描述 <code>API</code> 格式或 <code>API</code> 定义的语言，来规范 <code>RESTful</code> 服务开发过程，目前最新的 <code>OpenAPI</code> 规范是<a href="https://swagger.io/docs/specification">OpenAPI 3.0</a>（也就是 <code>Swagger</code>  <code>2.0</code>规范）。</p>
<p> <code>OpenAPI</code> 规范规定了一个 <code>API</code> 必须包含的基本信息，这些信息包括：</p>
<ul>
<li>对 <code>API</code> 的描述，介绍 <code>API</code> 可以实现的功能。</li>
<li>每个 <code>API</code> 上可用的路径（<code>/users</code>）和操作（<code>GET</code> <code>/users</code> ， <code>POST</code> <code>/users</code>）。</li>
<li>每个 <code>API</code> 的输入<code>/</code>返回的参数。</li>
<li>验证方法。</li>
<li>联系信息、许可证、使用条款和其他信息。</li>
</ul>
<p>所以，你可以简单地这么理解： <code>OpenAPI</code> 是一个 <code>API</code> 规范， <code>Swagger</code> 则是实现规范的工具。</p>
<p>另外，要编写 <code>Swagger</code> 文档，首先要会使用 <code>Swagger</code> 文档编写语法，因为语法比较多，这里就不多介绍了，你可以参考 <code>Swagger</code> 官方提供的<a href="https://swagger.io/specification/">OpenAPI Specification</a>来学习。</p>
<h2 id="用go-swagger来生成Swagger-API文档"><a href="#用go-swagger来生成Swagger-API文档" class="headerlink" title="用go-swagger来生成Swagger API文档"></a>用go-swagger来生成Swagger API文档</h2><p>在Go项目开发中，我们可以通过下面两种方法来生成<code>Swagger API</code>文档：</p>
<p>第一，如果你熟悉<code>Swagger</code>语法的话，可以直接编写<code>JSON/YAML</code>格式的<code>Swagger</code>文档。建议选择<code>YAML</code>格式，因为它比<code>JSON</code>格式更简洁直观。</p>
<p>第二，通过工具生成<code>Swagger</code>文档，目前可以通过<a href="https://github.com/swaggo/swag">swag</a>和<a href="https://github.com/go-swagger/go-swagger">go-swagger</a>两个工具来生成。</p>
<p>对比这两种方法，直接编写<code>Swagger</code>文档，不比编写<code>Markdown</code>格式的 <code>API</code> 文档工作量小，我觉得不符合程序员“偷懒”的习惯。所以，本专栏我们就使用<code>go-swagger</code>工具，基于代码注释来自动生成<code>Swagger</code>文档。为什么选<code>go-swagger</code>呢？有这么几个原因：</p>
<ul>
<li><code>go-swagger</code>比<code>swag</code>功能更强大：<code>go-swagger</code>提供了更灵活、更多的功能来描述我们的 <code>API</code> 。</li>
<li>使我们的代码更易读：如果使用<code>swag</code>，我们每一个 <code>API</code> 都需要有一个冗长的注释，有时候代码注释比代码还要长，但是通过<code>go-swagger</code>我们可以将代码和注释分开编写，一方面可以使我们的代码保持简洁，清晰易读，另一方面我们可以在另外一个包中，统一管理这些 <code>Swagger  API</code> 文档定义。</li>
<li>更好的社区支持：<code>go-swagger</code>目前有非常多的<code>Github star</code>数，出现<code>Bug</code>的概率很小，并且处在一个频繁更新的活跃状态。</li>
</ul>
<p>你已经知道了，<code>go-swagger</code>是一个功能强大的、高性能的、可以根据代码注释生成<code>Swagger API</code>文档的工具。除此之外，<code>go-swagger</code>还有很多其他特性：</p>
<ul>
<li>根据 <code>Swagger</code> 定义文件生成服务端代码。</li>
<li>根据 <code>Swagger</code> 定义文件生成客户端代码。</li>
<li>校验 <code>Swagger</code> 定义文件是否正确。</li>
<li>启动一个<code>HTTP服务器</code>，使我们可以通过浏览器访问 <code>API</code> 文档。</li>
<li>根据 <code>Swagger</code> 文档定义的参数生成<code>Go model</code>结构体定义。</li>
</ul>
<p>可以看到，使用<code>go-swagger</code>生成<code>Swagger</code>文档，可以帮助我们减少编写文档的时间，提高开发效率，并能保证文档的及时性和准确性。</p>
<p>这里需要注意，如果我们要对外提供 <code>API</code> 的<code>Go SDK</code>，可以考虑使用<code>go-swagger</code>来生成客户端代码。但是我觉得<code>go-swagger</code>生成的服务端代码不够优雅，所以建议你自行编写服务端代码。</p>
<p>目前，有很多知名公司和组织的项目都使用了<code>go-swagger</code>，例如 <code>Moby</code>、<code>CoreOS</code>、<code>Kubernetes</code>、<code>Cilium</code>等。</p>
<h3 id="安装Swagger工具"><a href="#安装Swagger工具" class="headerlink" title="安装Swagger工具"></a>安装Swagger工具</h3><p><code>go-swagger</code>通过<code>swagger</code>命令行工具来完成其功能，<code>swagger</code>安装方法如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go get <span class="token parameter variable">-u</span> github.com/go-swagger/go-swagger/cmd/swagger
swagger version
dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="swagger命令行工具介绍"><a href="#swagger命令行工具介绍" class="headerlink" title="swagger命令行工具介绍"></a>swagger命令行工具介绍</h3><p><code>swagger</code>命令格式为<code>swagger [OPTIONS] &lt;command&gt;</code>。可以通过<code>swagger -h</code>查看<code>swagger</code>使用帮助。<code>swagger</code>提供的子命令及功能见下表：</p>
<p><a href="https://static001.geekbang.org/resource/image/yy/78/yy3428aa968c7029cb4f6b11f2596678.png"><img src="https://static001.geekbang.org/resource/image/yy/78/yy3428aa968c7029cb4f6b11f2596678.png"></a></p>
<h2 id="如何使用swagger命令生成Swagger文档？"><a href="#如何使用swagger命令生成Swagger文档？" class="headerlink" title="如何使用swagger命令生成Swagger文档？"></a>如何使用swagger命令生成Swagger文档？</h2><p><code>go-swagger</code>通过解析源码中的注释来生成<code>Swagger</code>文档，<code>go-swagger</code>的详细注释语法可参考<a href="https://goswagger.io/">官方文档</a>。常用的有如下几类注释语法：</p>
<p><a href="https://static001.geekbang.org/resource/image/94/b3/947262c5175f6f518ff677063af293b3.png"><img src="https://static001.geekbang.org/resource/image/94/b3/947262c5175f6f518ff677063af293b3.png"></a></p>
<h3 id="解析注释生成Swagger文档"><a href="#解析注释生成Swagger文档" class="headerlink" title="解析注释生成Swagger文档"></a>解析注释生成Swagger文档</h3><p><code>swagger generate</code>命令会找到<code>main函数</code>，然后遍历所有源码文件，解析源码中与<code>Swagger</code>相关的注释，然后自动生成<code>swagger.json/swagger.yaml</code>文件。</p>
<p>这一过程的示例代码为<a href="https://github.com/marmotedu/gopractise-demo/tree/main/swagger">gopractise-demo&#x2F;swagger</a>。目录下有一个<code>main.go</code>文件，定义了如下 <code>API</code> 接口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"log"</span>
	<span class="token string">"net/http"</span>

	<span class="token string">"github.com/gin-gonic/gin"</span>

	<span class="token string">"github.com/marmotedu/gopractise-demo/swagger/api"</span>
	<span class="token comment">// 这个匿名倒入可以让 go-swagger 找到你的文档</span>
	<span class="token boolean">_</span> <span class="token string">"github.com/marmotedu/gopractise-demo/swagger/docs"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> users <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>api<span class="token punctuation">.</span>User

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	r<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/users"</span><span class="token punctuation">,</span> Create<span class="token punctuation">)</span>
	r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/users/:name"</span><span class="token punctuation">,</span> Get<span class="token punctuation">)</span>

	log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":5555"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Create 使用Create在内存中创建一个用户</span>
<span class="token keyword">func</span> <span class="token function">Create</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> user api<span class="token punctuation">.</span>User
	<span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"message"</span><span class="token punctuation">:</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token number">10001</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> users <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> u<span class="token punctuation">.</span>Name <span class="token operator">==</span> user<span class="token punctuation">.</span>Name <span class="token punctuation">&#123;</span>
			c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"message"</span><span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"user %s already exist"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token number">10001</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	users <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>users<span class="token punctuation">,</span> <span class="token operator">&amp;</span>user<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> user<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Get 使用Get返回用户的详细信息</span>
<span class="token keyword">func</span> <span class="token function">Get</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	username <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> users <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> u<span class="token punctuation">.</span>Name <span class="token operator">==</span> username <span class="token punctuation">&#123;</span>
			c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> u<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"message"</span><span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"user %s not exist"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token number">10002</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>main包</code>中引入的<strong>User struct</strong>位于<code>gopractise-demo/swagger/api</code>目录下的<a href="https://github.com/marmotedu/gopractise-demo/blob/main/swagger/api/user.go">user.go</a>文件：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package 接口定义了用户mdoel</span>
<span class="token keyword">package</span> api

<span class="token comment">// User 定义了User资源创建和返回的字段</span>
<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 用户的名字</span>
	<span class="token comment">// Required: true</span>
	Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>

	<span class="token comment">// 用户的昵称</span>
	<span class="token comment">// Required: true</span>
	Nickname <span class="token builtin">string</span> <span class="token string">`json:"nickname"`</span>

	<span class="token comment">// 用户的家庭住址</span>
	Address <span class="token builtin">string</span> <span class="token string">`json:"address"`</span>

	<span class="token comment">// 用户的电子邮件</span>
	Email <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>// Required: true</code>说明字段是必须的，生成<code>Swagger</code>文档时，也会在文档中声明该字段是必须字段。</p>
<p>为了使代码保持简洁，我们在另外一个<code>Go</code>包中编写带<code>go-swagger</code>注释的 <code>API</code> 文档。假设该<code>Go</code>包名字为<code>docs</code>，在开始编写<code>Go API</code>注释之前，需要在<code>main.go</code>文件中导入<code>docs</code>包：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token boolean">_</span> <span class="token string">"github.com/marmotedu/gopractise-demo/swagger/docs"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过导入<code>docs</code>包，可以使<code>go-swagger</code>在递归解析<code>main包</code>的<code>依赖包</code>时，找到<code>docs包</code>，并解析包中的注释。</p>
<p>在<code>gopractise-demo/swagger</code>目录下，创建<code>docs</code>文件夹：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> docs
<span class="token builtin class-name">cd</span> docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在<code>docs</code>目录下，创建一个<code>doc.go</code>文件，在该文件中提供 <code>API</code> 接口的基本信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package docs awesome.</span>
<span class="token comment">//</span>
<span class="token comment">// Documentation of our awesome API.</span>
<span class="token comment">//</span>
<span class="token comment">//     Schemes: http, https</span>
<span class="token comment">//     BasePath: /</span>
<span class="token comment">//     Version: 0.1.0</span>
<span class="token comment">//     Host: some-url.com</span>
<span class="token comment">//</span>
<span class="token comment">//     Consumes:</span>
<span class="token comment">//     - application/json</span>
<span class="token comment">//</span>
<span class="token comment">//     Produces:</span>
<span class="token comment">//     - application/json</span>
<span class="token comment">//</span>
<span class="token comment">//     Security:</span>
<span class="token comment">//     - basic</span>
<span class="token comment">//</span>
<span class="token comment">//    SecurityDefinitions:</span>
<span class="token comment">//    basic:</span>
<span class="token comment">//      type: basic</span>
<span class="token comment">//</span>
<span class="token comment">// swagger:meta</span>

<span class="token keyword">package</span> docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Package docs</strong>后面的字符串 <code>awesome</code> 代表我们的HTTP服务名。<code>Documentation of our awesome API</code>是我们 <code>API</code> 的描述。其他都是<code>go-swagger</code>可识别的注释，代表一定的意义。最后以<code>swagger:meta</code>注释结束。</p>
<p>编写完<code>doc.go</code>文件后，进入<code>gopractise-demo/swagger</code>目录，执行如下命令，生成<code>Swagger API</code>文档，并启动<code>HTTP服务</code>，在浏览器查看<code>Swagger</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger generate spec <span class="token parameter variable">-o</span> swagger.yaml
swagger serve --no-open <span class="token parameter variable">-F</span><span class="token operator">=</span>swagger <span class="token parameter variable">--port</span> <span class="token number">36666</span> swagger.yaml
swagger serve --no-open <span class="token parameter variable">-F</span><span class="token operator">=</span>redoc <span class="token parameter variable">--port</span> <span class="token number">36666</span> swagger.yaml
<span class="token number">2020</span>/10/20 <span class="token number">23</span>:16:47 serving docs at http://localhost:36666/docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>-o</code> ：指定要输出的文件名。<code>swagger</code>会根据文件名后缀<code>.yaml</code>或者<code>.json</code>，决定生成的文件格式为<code>YAML</code>或<code>JSON</code>。</li>
<li><code>-–no-open</code> ：因为是在<code>Linux服务器</code>下执行命令，没有安装浏览器，所以使<code>-–no-open</code>禁止调用浏览器打开<code>URL</code>。</li>
<li><code>-F</code> ：指定文档的风格，可选<code>swagger</code>和<code>redoc</code>。我选用了<code>redoc</code>，因为觉得<code>redoc</code>格式更加易读和清晰。</li>
<li><code>-–port</code> ：指定启动的<code>HTTP服务</code>监听端口。</li>
</ul>
<p>打开浏览器，访问<a href="http://url/"></a><a href="http://localhost:36666/docs">http://localhost:36666/docs</a> ，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/9a/2c/9a9fb7a31d418d8e4dc13b19cefa832c.png"><img src="https://static001.geekbang.org/resource/image/9a/2c/9a9fb7a31d418d8e4dc13b19cefa832c.png"></a></p>
<p>如果我们想要<code>JSON</code>格式的<code>Swagger</code>文档，可执行如下命令，将生成的<code>swagger.yaml</code>转换为<code>swagger.json</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger generate spec <span class="token parameter variable">-i</span> ./swagger.yaml <span class="token parameter variable">-o</span> ./swagger.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接下来，我们就可以编写 <code>API</code> 接口的定义文件（位于<a href="https://github.com/marmotedu/gopractise-demo/blob/main/swagger/docs/user.go">gopractise-demo&#x2F;swagger&#x2F;docs&#x2F;user.go</a>文件中）：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> docs

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"github.com/marmotedu/gopractise-demo/swagger/api"</span>
<span class="token punctuation">)</span>

<span class="token comment">// swagger:route POST /users user createUserRequest</span>
<span class="token comment">// 创建用户</span>
<span class="token comment">// responses:</span>
<span class="token comment">//   200: createUserResponse</span>
<span class="token comment">//   default: errResponse</span>

<span class="token comment">// swagger:route GET /users/&#123;name&#125; user getUserRequest</span>
<span class="token comment">// 获取用户</span>
<span class="token comment">// responses:</span>
<span class="token comment">//   200: getUserResponse</span>
<span class="token comment">//   default: errResponse</span>

<span class="token comment">// swagger:parameters createUserRequest</span>
<span class="token keyword">type</span> userParamsWrapper <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 对请求体的描述</span>
	<span class="token comment">// in:body</span>
	Body api<span class="token punctuation">.</span>User
<span class="token punctuation">&#125;</span>

<span class="token comment">// 对请求 URL 路径的描述</span>
<span class="token comment">// swagger:parameters getUserRequest</span>
<span class="token keyword">type</span> getUserParamsWrapper <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// in:path</span>
	Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 对响应体的描述</span>
<span class="token comment">// swagger:response createUserResponse</span>
<span class="token keyword">type</span> createUserResponseWrapper <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// in:body</span>
	Body api<span class="token punctuation">.</span>User
<span class="token punctuation">&#125;</span>

<span class="token comment">// 对响应体的描述</span>
<span class="token comment">// swagger:response getUserResponse</span>
<span class="token keyword">type</span> getUserResponseWrapper <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// in:body</span>
	Body api<span class="token punctuation">.</span>User
<span class="token punctuation">&#125;</span>

<span class="token comment">// 对错误响应体的描述</span>
<span class="token comment">// swagger:response errResponse</span>
<span class="token keyword">type</span> errResponseWrapper <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 错误代码</span>
	Code <span class="token builtin">int</span> <span class="token string">`json:"code"`</span>

	<span class="token comment">// 错误信息</span>
	Message <span class="token builtin">string</span> <span class="token string">`json:"message"`</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>user.go</code>文件说明：</p>
<ul>
<li><code>swagger:route</code>：<code>swagger:route</code>代表 <code>API</code> 接口描述的开始，后面的字符串格式为<code>HTTP方法 URL Tag ID</code>。可以填写多个tag，相同tag的 <code>API</code> 接口在<code>Swagger</code>文档中会被分为一组。<code>ID</code>是一个标识符，<code>swagger:parameters</code>是具有相同<code>ID</code>的<code>swagger:route</code>的请求参数。<code>swagger:route</code>下面的一行是该 <code>API</code> 接口的描述，需要以英文点号为结尾。<code>responses:</code>定义了 <code>API</code> 接口的返回参数，例如当<code>HTTP</code>状态码是<code>200</code>时，返回<code>createUserResponse</code>，<code>createUserResponse</code>会跟<code>swagger:response</code>进行匹配，匹配成功的<code>swagger:response</code>就是该 <code>API</code> 接口返回<code>200</code>状态码时的返回。</li>
<li><code>swagger:response</code>：<code>swagger:response</code>定义了 <code>API</code> 接口的返回，例如<code>getUserResponseWrapper</code>，关于名字，我们可以根据需要自由命名，并不会带来任何不同。<code>getUserResponseWrapper</code>中有一个<code>Body</code>字段，其注释为<code>// in:body</code>，说明该参数是在<code>HTTP Body</code>中返回。<code>swagger:response</code>之上的注释会被解析为返回参数的描述。<code>api.User</code>自动被<code>go-swagger</code>解析为<code>Example Value</code>和<code>Model</code>。我们不用再去编写重复的返回字段，只需要引用已有的<code>Go结构体</code>即可，这也是通过工具生成<code>Swagger文档</code>的魅力所在。</li>
<li><code>swagger:parameters</code>：<code>swagger:parameters</code>定义了 <code>API</code> 接口的请求参数，例如<code>userParamsWrapper</code>。<code>userParamsWrapper</code>之上的注释会被解析为请求参数的描述，<code>// in:body</code>代表该参数是位于<code>HTTP Body</code>中。同样，<code>userParamsWrapper</code>结构体名我们也可以随意命名，不会带来任何不同。<code>swagger:parameters</code>之后的<code>createUserRequest</code>会跟<code>swagger:route</code>的<code>ID</code>进行匹配，匹配成功则说明是该<code>ID</code>所在 <code>API</code> 接口的请求参数。</li>
</ul>
<p>进入<code>gopractise-demo/swagger</code>目录，执行如下命令，生成<code>Swagger API</code>文档，并启动<code>HTTP</code>服务，在浏览器查看<code>Swagger</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger generate spec <span class="token parameter variable">-o</span> swagger.yaml
swagger serve --no-open <span class="token parameter variable">-F</span><span class="token operator">=</span>swagger <span class="token parameter variable">--port</span> <span class="token number">36666</span> swagger.yaml
<span class="token number">2020</span>/10/20 <span class="token number">23</span>:28:30 serving docs at http://localhost:36666/docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>打开浏览器，访问 <a href="http://localhost:36666/docs"></a><a href="http://localhost:36666/docs">http://localhost:36666/docs</a> ，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/e6/e0/e6d6d138fb890ef219d71671d146d5e0.png"><img src="https://static001.geekbang.org/resource/image/e6/e0/e6d6d138fb890ef219d71671d146d5e0.png"></a></p>
<p>上面我们生成了<code>swagger</code>风格的<code>UI</code>界面，我们也可以使用<code>redoc</code>风格的<code>UI</code>界面，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/dd/48/dd568a44290283861ba5c37f28307d48.png"><img src="https://static001.geekbang.org/resource/image/dd/48/dd568a44290283861ba5c37f28307d48.png"></a></p>
<h3 id="go-swagger其他常用功能介绍"><a href="#go-swagger其他常用功能介绍" class="headerlink" title="go-swagger其他常用功能介绍"></a>go-swagger其他常用功能介绍</h3><p>上面，我介绍了<code>swagger</code>最常用的<code>generate</code>、<code>serve</code>命令，关于<code>swagger</code>其他有用的命令，这里也简单介绍一下。</p>
<p><em><strong>1.  对比<code>Swagger</code>文档</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger <span class="token function">diff</span> <span class="token parameter variable">-d</span> change.log swagger.new.yaml swagger.old.yaml
<span class="token function">cat</span> change.log

BREAKING CHANGES:
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
/users:post Request - Body.Body.nickname.address.email.name.Body <span class="token builtin class-name">:</span> User - Deleted property
compatibility <span class="token builtin class-name">test</span> FAILED: <span class="token number">1</span> breaking changes detected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>2.  生成服务端代码</strong></em></p>
<p>我们也可以先定义<code>Swagger</code>接口文档，再用<code>swagger</code>命令，基于<code>Swagger</code>接口文档生成服务端代码。假设我们的应用名为<code>go-user</code>，进入<code>gopractise-demo/swagger</code>目录，创建<code>go-user</code>目录，并生成服务端代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> go-user
<span class="token builtin class-name">cd</span> go-user
swagger generate server <span class="token parameter variable">-f</span> <span class="token punctuation">..</span>/swagger.yaml <span class="token parameter variable">-A</span> go-user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上述命令会在当前目录生成<code>cmd</code>、<code>restapi</code>、<code>models</code>文件夹，可执行如下命令查看<code>server</code>组件启动方式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run cmd/go-user-server/main.go <span class="token parameter variable">-h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>3.  生成客户端代码</strong></em></p>
<p>在<code>go-user</code>目录下执行如下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger generate client <span class="token parameter variable">-f</span> <span class="token punctuation">..</span>/swagger.yaml <span class="token parameter variable">-A</span> go-user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上述命令会在当前目录生成<code>client</code>，包含了 <code>API</code> 接口的调用函数，也就是 <code>API</code> 接口的<code>Go SDK</code>。</p>
<p><em><strong>4.  验证<code>Swagger</code>文档是否合法</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger validate swagger.yaml
<span class="token number">2020</span>/10/21 09:53:18
The swagger spec at <span class="token string">"swagger.yaml"</span> is valid against swagger specification <span class="token number">2.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><em><strong>5.  合并<code>Swagger</code>文档</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger mixin swagger_part1.yaml swagger_part2.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="IAM-Swagger文档"><a href="#IAM-Swagger文档" class="headerlink" title="IAM Swagger文档"></a>IAM Swagger文档</h2><p><code>IAM</code>的<code>Swagger</code>文档定义在<a href="https://github.com/marmotedu/iam/tree/v1.0.0/api/swagger/docs">iam&#x2F;api&#x2F;swagger&#x2F;docs</a>目录下，遵循<code>go-swagger</code>规范进行定义。</p>
<p><a href="https://github.com/marmotedu/iam/blob/v1.0.0/api/swagger/docs/doc.go">iam&#x2F;api&#x2F;swagger&#x2F;docs&#x2F;doc.go</a>文件定义了更多<code>Swagger</code>文档的基本信息，比如开源协议、联系方式、安全认证等。</p>
<p>更详细的定义，你可以直接查看<code>iam/api/swagger/docs</code>目录下的<code>Go源码</code>文件。</p>
<p>为了便于生成文档和启动<code>HTTP服务</code>查看<code>Swagger</code>文档，该操作被放在<code>Makefile</code>中执行（位于<a href="https://github.com/marmotedu/iam/blob/v1.0.0/scripts/make-rules/swagger.mk">iam&#x2F;scripts&#x2F;make-rules&#x2F;swagger.mk</a>文件中）：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> swagger.run
<span class="token target symbol">swagger.run</span><span class="token punctuation">:</span> tools.verify.swagger
	<span class="token operator">@</span>echo <span class="token string">"===========> Generating swagger API docs"</span>
	<span class="token operator">@</span>swagger generate spec --scan-models -w <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_DIR<span class="token punctuation">)</span>/cmd/genswaggertypedocs -o <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_DIR<span class="token punctuation">)</span>/api/swagger/swagger.yaml

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> swagger.serve
<span class="token target symbol">swagger.serve</span><span class="token punctuation">:</span> tools.verify.swagger
	<span class="token operator">@</span>swagger serve -F<span class="token operator">=</span>redoc --no-open --port 36666 <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_DIR<span class="token punctuation">)</span>/api/swagger/swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Makefile</code>文件说明：</p>
<ul>
<li><code>tools.verify.swagger</code>：检查<code>Linux系统</code>是否安装了<code>go-swagger</code>的命令行工具<code>swagger</code>，如果没有安装则运行<code>go get</code>安装。</li>
<li><code>swagger.run</code>：运行 <code>swagger generate spec</code> 命令生成<code>Swagger</code>文档<code>swagger.yaml</code>，运行前会检查<code>swagger</code>是否安装。 <code>--scan-models</code> 指定生成的文档中包含带有<code>swagger:model</code> 注释的<code>Go Models</code>。<code>-w</code> 指定<code>swagger</code>命令运行的目录。</li>
<li><code>swagger.serve</code>：运行 <code>swagger serve</code> 命令打开<code>Swagger</code>文档<code>swagger.yaml</code>，运行前会检查<code>swagger</code>是否安装。</li>
</ul>
<p>在<code>iam</code>源码根目录下执行如下命令，即可生成并启动<code>HTTP服务</code>查看<code>Swagger</code>文档：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> swagger
<span class="token function">make</span> serve-swagger2020/10/21 06:45:03 serving docs at http://localhost:36666/docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>打开浏览器，打开<code>http://x.x.x.x:36666/docs</code>查看<code>Swagger</code>文档，<code>x.x.x.x</code>是服务器的<code>IP地址</code>，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/6a/3b/6ac3529ed98aa94573862da99434683b.png"><img src="https://static001.geekbang.org/resource/image/6a/3b/6ac3529ed98aa94573862da99434683b.png"></a></p>
<p><code>IAM</code>的<code>Swagger文档</code>，还可以通过在<code>iam源码</code>根目录下执行<code>go generate ./...</code>命令生成，为此，我们需要在<code>iam/cmd/genswaggertypedocs/swagger_type_docs.go</code>文件中，添加<code>//go:generate</code>注释。如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/cc/d7/cc03b896e5403cc55d7e11fe2078d9d7.png"><img src="https://static001.geekbang.org/resource/image/cc/d7/cc03b896e5403cc55d7e11fe2078d9d7.png"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做<code>Go服务</code>开发时，我们要向前端或用户提供 <code>API</code> 文档，手动编写 <code>API</code> 文档工作量大，也难以维护。所以，现在很多项目都是自动生成<code>Swagger</code>格式的 <code>API</code> 文档。提到<code>Swagger</code>，很多开发者不清楚其和 <code>OpenAPI</code> 的区别，所以我也给你总结了： <code>OpenAPI</code> 是一个 <code>API</code> 规范，<code>Swagger</code>则是实现规范的工具。</p>
<p>在<code>Go</code>中，用得最多的是利用<code>go-swagger</code>来生成<code>Swagger</code>格式的 <code>API</code> 文档。<code>go-swagger</code>包含了很多语法，我们可以访问<a href="https://goswagger.io/">Swagger 2.0</a>进行学习。学习完<code>Swagger 2.0</code>的语法之后，就可以编写<code>swagger</code>注释了，之后可以通过</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger generate spec <span class="token parameter variable">-o</span> swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>来生成<code>swagger</code>文档 <code>swagger.yaml</code>。通过</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swagger serve --no-open <span class="token parameter variable">-F</span><span class="token operator">=</span>swagger <span class="token parameter variable">--port</span> <span class="token number">36666</span> swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>来提供一个<code>前端界面</code>，供我们访问<code>swagger文档</code>。</p>
<p>为了方便管理，我们可以将 <code>swagger generate spec</code> 和 <code>swagger serve</code> 命令加入到 <code>Makefile</code> 文件中，通过 <code>Makefile</code> 来生成 <code>Swagger文档</code> ，并提供给<code>前端界面</code>。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>11 | 错误处理：设计一套科学的错误码</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-11-error-code.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>今天我们来聊聊如何设计业务的错误码。</p>
<p>现代的软件架构，很多都是对外暴露 <code>RESTful API</code> 接口，内部系统通信采用 <code>RPC 协议</code>。因为 <code>RESTful API</code> 接口有一些天生的优势，比如规范、调试友好、易懂，所以通常作为直接面向用户的通信规范。</p>
<span id="more"></span>
<p>既然是直接面向用户，那么首先就要求消息返回格式是规范的；其次，如果接口报错，还要能给用户提供一些有用的报错信息，通常需要包含 <code>Code 码</code>（用来唯一定位一次错误）和 <code>Message</code>（用来展示出错的信息）。这就需要我们设计一套规范的、科学的错误码。</p>
<h2 id="期望错误码实现的功能"><a href="#期望错误码实现的功能" class="headerlink" title="期望错误码实现的功能"></a>期望错误码实现的功能</h2><p>要想设计一套错误码，首先就得弄清我们的需求。</p>
<p><code>RESTful API</code> 是基于 <code>HTTP</code> 协议的一系列 <code>API</code> 开发规范，<code>HTTP</code> 请求结束后，无论 <code>API</code> 请求成功或失败，都需要让客户端感知到，以便客户端决定下一步该如何处理。</p>
<p>为了让用户拥有最好的体验，需要有一个比较好的错误码实现方式。这里我介绍下在设计错误码时，期望能够实现的功能。</p>
<p>第一个功能是有<code>业务 Code 码标识</code>。</p>
<p>因为<code> HTTP Code 码</code>有限，并且都是跟<code> HTTP Transport</code> 层相关的 <code>Code 码</code>，所以我们希望能有自己的错误 <code>Code 码</code>。一方面，可以根据需要自行扩展，另一方面也能够精准地定位到具体是哪个错误。同时，因为 <code>Code 码</code>通常是对计算机友好的 <code>10</code> 进制整数，基于 <code>Code 码</code>，计算机也可以很方便地进行一些分支处理。当然了，业务码也要有一定规则，可以通过业务码迅速定位出是哪类错误。</p>
<p>第二个功能，考虑到安全，希望能够对外对内分别展示不同的错误信息。</p>
<p>当开发一个对外的系统，业务出错时，需要一些机制告诉用户出了什么错误，如果能够提供一些帮助文档会更好。但是，我们不可能把所有的错误都暴露给外部用户，这不仅没必要，也不安全。所以也需要能让我们获取到更详细的内部错误信息的机制，这些内部错误信息可能包含一些敏感的数据，不宜对外展示，但可以协助我们进行问题定位。</p>
<p>所以，我们需要设计的错误码应该是规范的，能方便客户端感知到 <code>HTTP</code> 是否请求成功，并带有业务码和出错信息。</p>
<h2 id="常见的错误码设计方式"><a href="#常见的错误码设计方式" class="headerlink" title="常见的错误码设计方式"></a>常见的错误码设计方式</h2><p>在业务中，大致有三种错误码实现方式。我用一次因为用户账号没有找到而请求失败的例子，分别给你解释一下：</p>
<p><em><strong>第一种方式，不论请求成功或失败，始终返回<code>200</code> <code>http status code</code>，在 <code>HTTP Body</code> 中包含用户账号没有找到的错误信息。</strong></em></p>
<p>例如 <code>Facebook API</code> 的错误 <code>Code</code> 设计，始终返回 <code>200</code> <code>http status code</code>：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>

<span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>

<span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Syntax error \"Field picture specified more than once. This is only possible before version 2.1\" at character 23: id,name,picture,picture"</span><span class="token punctuation">,</span>

<span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"OAuthException"</span><span class="token punctuation">,</span>

<span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">2500</span><span class="token punctuation">,</span>

<span class="token property">"fbtrace_id"</span><span class="token operator">:</span> <span class="token string">"xxxxxxxxxxx"</span>

<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>采用固定返回<code>200</code> <code>http status code</code>的方式，有其合理性。比如，<code>HTTP Code</code> 通常代表 <code>HTTP Transport</code> 层的状态信息。当我们收到 <code>HTTP</code> 请求，并返回时，<code>HTTP Transport</code> 层是成功的，所以从这个层面上来看，<code>HTTP Status</code> 固定为 <code>200</code> 也是合理的。</p>
<p>但是这个方式的缺点也很明显：对于每一次请求，我们都要去解析 <code>HTTP Body</code>，从中解析出错误码和错误信息。实际上，大部分情况下，我们对于成功的请求，要么直接转发，要么直接解析到某个结构体中；对于失败的请求，我们也希望能够更直接地感知到请求失败。这种方式对性能会有一定的影响，对客户端不友好。所以我不建议你使用这种方式。</p>
<p><em><strong>第二种方式，返回<code>http 404 Not Found</code>错误码，并在 <code>Body</code> 中返回简单的错误信息。</strong></em></p>
<p>例如：<code>Twitter API</code> 的错误设计，会根据错误类型，返回合适的 <code>HTTP Code</code>，并在 <code>Body</code> 中返回错误信息和自定义业务 <code>Code</code>。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">HTTP/<span class="token number">1.1</span> <span class="token number">400</span> Bad Request

x-connection-hash<span class="token operator">:</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

set-cookie<span class="token operator">:</span> guest_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Date<span class="token operator">:</span> Thu<span class="token punctuation">,</span> <span class="token number">01</span> Jun <span class="token number">2017</span> <span class="token number">03</span><span class="token operator">:</span><span class="token number">04</span><span class="token operator">:</span><span class="token number">23</span> GMT

Content-Length<span class="token operator">:</span> <span class="token number">62</span>

x-response-time<span class="token operator">:</span> <span class="token number">5</span>

strict-transport-security<span class="token operator">:</span> max-age=<span class="token number">631138519</span>

Connection<span class="token operator">:</span> keep-alive

Content-Type<span class="token operator">:</span> application/json; charset=utf<span class="token number">-8</span>

Server<span class="token operator">:</span> tsa_b

<span class="token punctuation">&#123;</span><span class="token property">"errors"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token property">"code"</span><span class="token operator">:</span><span class="token number">215</span><span class="token punctuation">,</span><span class="token property">"message"</span><span class="token operator">:</span><span class="token string">"Bad Authentication data."</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种方式比第一种要好一些，通过<code>http status code</code>可以使客户端非常直接地感知到请求失败，并且提供给客户端一些错误信息供参考。但是仅仅靠这些信息，还不能准确地定位和解决问题。</p>
<p><em><strong>第三种方式，返回<code>http 404 Not Found</code>错误码，并在 <code>Body</code> 中返回详细的错误信息。</strong></em></p>
<p>例如：微软 <code>Bing API</code> 的错误设计，会根据错误类型，返回合适的 <code>HTTP Code</code>，并在 <code>Body</code> 中返回详尽的错误信息。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">HTTP/<span class="token number">1.1</span> <span class="token number">400</span>

Date<span class="token operator">:</span> Thu<span class="token punctuation">,</span> <span class="token number">01</span> Jun <span class="token number">2017</span> <span class="token number">03</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">55</span> GMT

Content-Length<span class="token operator">:</span> <span class="token number">276</span>

Connection<span class="token operator">:</span> keep-alive

Content-Type<span class="token operator">:</span> application/json; charset=utf<span class="token number">-8</span>

Server<span class="token operator">:</span> Microsoft-IIS/<span class="token number">10.0</span>

X-Content-Type-Options<span class="token operator">:</span> nosniff

<span class="token punctuation">&#123;</span><span class="token property">"SearchResponse"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"Version"</span><span class="token operator">:</span><span class="token string">"2.2"</span><span class="token punctuation">,</span><span class="token property">"Query"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"SearchTerms"</span><span class="token operator">:</span><span class="token string">"api error codes"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token property">"Errors"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token property">"Code"</span><span class="token operator">:</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token property">"Message"</span><span class="token operator">:</span><span class="token string">"Required parameter is missing."</span><span class="token punctuation">,</span><span class="token property">"Parameter"</span><span class="token operator">:</span><span class="token string">"SearchRequest.AppId"</span><span class="token punctuation">,</span><span class="token property">"HelpUrl"</span><span class="token operator">:</span><span class="token string">"http\u003a\u002f\u002fmsdn.microsoft.com\u002fen-us\u002flibrary\u002fdd251042.aspx"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>这是我比较推荐的一种方式</strong></em>，既能通过<code>http status code</code>使客户端方便地知道请求出错，又可以<code>使用户根据返回的信息知道哪里出错</code>，以及如何解决问题。同时，返回了机器友好的业务 <code>Code</code> 码，可以在有需要时让程序进一步判断处理。</p>
<h2 id="错误码设计建议"><a href="#错误码设计建议" class="headerlink" title="错误码设计建议"></a>错误码设计建议</h2><p><em><strong>综合刚才讲到的，我们可以总结出一套优秀的错误码设计思路：</strong></em></p>
<p>有区别于<code>http status code</code>的业务码，业务码需要有一定规则，可以通过业务码判断出是哪类错误。</p>
<p>请求出错时，可以通过<code>http status code</code>直接感知到请求出错。</p>
<p>需要在请求出错时，返回详细的信息，通常包括 <code>3</code> 类信息：<code>业务 Code 码</code>、<code>错误信息</code>和<code>参考文档</code>（可选）。</p>
<p>返回的错误信息，需要是可以<code>直接展示给用户的安全信息</code>，也就是说<code>不能包含敏感信息</code>；同时也要有<code>内部更详细的错误信息</code>，方便 <code>debug</code>。</p>
<p><code>返回的数据格式</code>应该是<code>固定的</code>、<code>规范的</code>。</p>
<p>错误信息要保持<code>简洁</code>，并且提供<code>有用的信息</code>。</p>
<p>这里其实还有两个功能点需要我们实现：<code>业务 Code 码设计</code>，以及请求出错时，如何设置 <code>http status code</code>。</p>
<p>接下来，我会详细介绍下如何实现这两个功能点。</p>
<h2 id="业务-Code-码设计"><a href="#业务-Code-码设计" class="headerlink" title="业务 Code 码设计"></a>业务 Code 码设计</h2><p>要解决业务 <code>Code 码</code>如何设计这个问题，我们先来看下为什么要引入业务 <code>Code 码</code>。</p>
<p>在实际开发中，引入业务 <code>Code 码</code>有下面几个好处：</p>
<p>可以非常方便地<code>定位问题</code>和<code>定位代码行</code>（看到错误码知道什么意思、<code>grep 错误码</code>可以<code>定位到错误码所在行</code>、<code>某个错误类型的唯一标识</code>）。</p>
<p><code>错误码</code>包含一定的信息，通过<code>错误码</code>可以判断出<code>错误级别</code>、<code>错误模块</code>和<code>具体错误信息</code>。</p>
<p><code>Go</code> 中的<code> HTTP 服务器</code>开发都是引用 <code>net/http</code> 包，该包中只有 <code>60 个错误码</code>，基本都是跟<code> HTTP 请求</code>相关的错误码</p>
<p>在一个大型系统中，这些错误码完全不够用，而且这些错误码跟业务没有任何关联，满足不了业务的需求。引入<code>业务</code>的 <code>Code 码</code>，则可以解决这些问题。</p>
<p>业务开发过程中，可能需要<code>判断错误是哪种类型</code>，以便做<code>相应的逻辑处理</code>，通过<code>定制的错误</code>可以很容易做到这点，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">==</span> code<span class="token punctuation">.</span>ErrBind <span class="token punctuation">&#123;</span>

<span class="token operator">...</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里要注意，业务 <code>Code 码</code>可以是一个<code>整数</code>，也可以是一个<code>整型字符串</code>，还可以是一个<code>字符型字符串</code>，<strong>它是错误的唯一标识</strong>。</p>
<p><em><strong>通过研究腾讯云、阿里云、新浪的开放 API，我发现新浪的 API <code>Code 码</code>设计更合理些。所以，我参考新浪的 <code>Code 码</code>设计，总结出了我推荐的 <code>Code 码</code>设计规范：纯数字表示，不同部位代表不同的服务，不同的模块。</strong></em></p>
<p>错误代码说明：<code>100101</code></p>
<p><code>10</code> : 服务。</p>
<p><code>01</code> : 某个服务下的某个模块。</p>
<p><code>01</code> : 模块下的<code>错误码序号</code>，每个模块可以注册 <code>100</code> 个错误。</p>
<p>通过<code>100101</code>可以知道这个错误是<code>服务 A</code>，<code>数据库模块</code>下的记录没有找到错误。</p>
<p>你可能会问：按这种设计，每个模块下最多能注册 <code>100</code> 个错误，是不是有点少？其实在我看来，如果每个模块的错误码超过 <code>100</code> 个，要么说明这个模块太大了，建议拆分；要么说明错误码设计得不合理，共享性差，需要重新设计。</p>
<h3 id="如何设置-HTTP-Status-Code"><a href="#如何设置-HTTP-Status-Code" class="headerlink" title="如何设置 HTTP Status Code"></a>如何设置 HTTP Status Code</h3><p><code>Go</code> <code>net/http</code> 包提供了 <code>60</code> 个错误码，大致分为如下 <code>5</code> 类：</p>
<p><code>1XX</code> – （指示信息）表示请求已接收，继续处理。</p>
<p><code>2XX</code> – （请求成功）表示成功处理了请求的状态代码。</p>
<p><code>3XX</code> – （请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</p>
<p><code>4XX</code> – （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理，通常是客户端出错，需要客户端做进一步的处理。</p>
<p><code>5XX</code> – （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是客户端的问题。</p>
<p>可以看到 <code>HTTP Code</code> 有很多种，如果每个 <code>Code</code> 都做错误映射，会面临很多问题。比如，研发同学不太好判断错误属于哪种 <code>http status code</code>，到最后很可能会导致错误或者 <code>http status code</code> 不匹配，变成一种形式。而且，客户端也难以应对这么多的 <code>HTTP</code> 错误码。</p>
<p>所以，这里建议 <code>http status code</code> 不要太多，基本上只需要这 <code>3</code> 个 <code>HTTP Code</code>:</p>
<p><code>200</code> – 表示请求成功执行。</p>
<p><code>400</code> – 表示客户端出问题。</p>
<p><code>500</code> – 表示服务端出问题。</p>
<p>如果觉得这 <code>3</code> 个错误码不够用，最多可以加如下 <code>3</code> 个错误码：</p>
<p><code>401</code> – 表示认证失败。</p>
<p><code>403</code> – 表示授权失败。</p>
<p><code>404</code>– 表示资源找不到，这里的资源可以是 <code>URL</code> 或者 <code>RESTful</code> 资源。</p>
<p>将错误码控制在适当的数目内，客户端比较容易处理和判断，开发也比较容易进行错误码映射。</p>
<h2 id="IAM-项目错误码设计规范"><a href="#IAM-项目错误码设计规范" class="headerlink" title="IAM 项目错误码设计规范"></a>IAM 项目错误码设计规范</h2><p>接下来，我们来看下 <code>IAM</code> 项目的错误码是如何设计的。</p>
<h3 id="Code-设计规范"><a href="#Code-设计规范" class="headerlink" title="Code 设计规范"></a>Code 设计规范</h3><p>先来看下 <code>IAM </code>项目业务的 <code>Code 码</code>设计规范，具体实现可参考<a href="https://juejin.cn/editor/drafts/7136899551679971358">internal&#x2F;pkg&#x2F;code 目录</a>。IAM 项目的错误码设计规范符合上面介绍的错误码设计思路和规范，具体规范见下。</p>
<p><code>Code</code> 代码从 <code>100101</code> 开始，<code>1000</code> 以下为 <code>github.com/marmotedu/errors</code> 保留 <code>code</code>。</p>
<p>错误代码说明：<code>100101</code></p>
<p><img src="https://static001.geekbang.org/resource/image/9c/6e/9c088dcb4c7b2509c2eaa81ed3be3b6e.jpg" alt="GO 语言项目开发实战 – 错误处理（上）：如何设计一套科学的错误码？"></p>
<p>服务和模块说明</p>
<p><img src="https://static001.geekbang.org/resource/image/91/f5/91296aab54da035580e80b6637dd4df5.png" alt="GO 语言项目开发实战 – 错误处理（上）：如何设计一套科学的错误码？"></p>
<p><em><strong>通用：说明所有服务都适用的错误，提高复用性。</strong></em></p>
<p><strong>错误信息规范说明</strong></p>
<p><code>对外暴露的错误，统一大写开头，结尾不要加.</code>。</p>
<p><code>对外暴露的错误要简洁，并能准确说明问题</code>。</p>
<p><code>对外暴露的错误说明，应该是 该怎么做 而不是 哪里错了</code>。</p>
<p><code>这里你需要注意，错误信息是直接暴露给用户的，不能包含敏感信息</code>。</p>
<h3 id="IAM-API-接口返回值说明"><a href="#IAM-API-接口返回值说明" class="headerlink" title="IAM API 接口返回值说明"></a>IAM API 接口返回值说明</h3><p>如果返回结果中存在 <code>code</code> 字段，则表示调用 <code>API</code> 接口失败。例如：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>

<span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">100101</span><span class="token punctuation">,</span>

<span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Database error"</span><span class="token punctuation">,</span>

<span class="token property">"reference"</span><span class="token operator">:</span> <span class="token string">"https://github.com/marmotedu/iam/tree/master/docs/guide/zh-CN/faq/iam-apiserver"</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>code</code> :  表示错误码<br><code>message</code> : 表示该错误的具体信息。每个错误同时也对应一个 HTTP 状态码。比如上述错误码对应了 HTTP 状态码 500(Internal Server Error)<br><code>reference</code> : 在出错时，也返回了字段，该字段包含了可以解决这个错误的文档链接地址</p>
<p>关于 <code>IAM</code> 系统支持的错误码，我给你列了一个表格，你可以看看：</p>
<p><img src="https://static001.geekbang.org/resource/image/b5/95/b58ff5b9455d13fc397fdf5228ea7195.png" alt="GO 语言项目开发实战 – 错误处理（上）：如何设计一套科学的错误码？"></p>
<p><img src="https://static001.geekbang.org/resource/image/c6/d2/c6d356a3f5f2bfc3d6001yy3c05a90d2.png" alt="GO 语言项目开发实战 – 错误处理（上）：如何设计一套科学的错误码？"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对外暴露的 API 接口需要有一套规范的、科学的错误码。目前业界的错误码大概有 3 种设计方式，我用一次因为用户账号没有找到而请求失败的例子，给你做了解释：</p>
<p>不论请求成功失败，始终返回 <code>200</code> <code>http status code</code>，在 <code>HTTP Body</code> 中包含用户账号没有找到的错误信息。</p>
<p>返回<code>http 404 Not Found</code>错误码，并在 <code>Body</code> 中返回简单的错误信息。</p>
<p>这一讲，我参考这 3 个错误码设计，给出了自己的错误码设计建议：错误码包含 <code>HTTP Code</code> 和<code>业务 Code</code>，并且<code>业务 Code</code> 会<code>映射</code>为一个 <code>HTTP Code</code>。</p>
<p>错误码也会对外暴露两种错误信息，一种是直接<code>暴露给用户</code>的，<code>不包含敏感信息的信息</code>；另一种是供<code>内部开发查看</code>，定位问题的错误信息。该错误码还支持返回参考文档，用于在出错时展示给用户，供用户查看解决问题。</p>
<p>建议你重点关注我总结的 <code>Code 码</code>设计规范：纯数字表示，不同部位代表<code>不同的服务</code>，<code>不同的模块</code>。</p>
<p>比如错误代码<code>100101</code>，</p>
<p>其中 <code>10</code> 代表<code>服务</code>；<br>中间的 <code>01</code> 代表<code>某个服务</code>下的<code>某个模块</code>；<br>最后的 <code>01</code> 代表<code>模块</code>下的<code>错误码序号</code>，每个<code>模块</code>可以注册 <code>100</code> 个错误。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>12 | 错误处理：如何设计错误包</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-12-error-code2.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在 <code>Go</code> 项目开发中，错误是我们必须要处理的一个事项。除了我们上一讲学习过的<code>错误码</code>，<code>处理错误</code>也离不开<code>错误包</code>。</p>
<p>业界有很多优秀的、<code>开源的错误包</code>可供选择，例如 <code>Go</code> 标准库自带的<code>errors包</code>、<code>github.com/pkg/errors</code>包。但是这些包目前还<code>不支持业务错误码</code>，很难满足<code>生产级应用</code>的需求。</p>
<p>所以，在实际开发中，我们有必要开发出适合自己错误码设计的错误包。当然，我们也没必要自己从 <code>0</code> 开发，可以基于一些优秀的包来进行<code>二次封装</code>。</p>
<span id="more"></span>
<p>这一讲里，我们就来一起看看，如何设计一个错误包来适配上一讲我们设计的错误码，以及一个错误码的具体实现。</p>
<h2 id="错误包需要具有哪些功能？"><a href="#错误包需要具有哪些功能？" class="headerlink" title="错误包需要具有哪些功能？"></a>错误包需要具有哪些功能？</h2><p>要想设计一个优秀的错误包，我们首先得知道一个优秀的错误包需要具备哪些功能。在我看来，至少需要有下面这<code>六</code>个功能：</p>
<p><em><strong>1. 能支持错误堆栈</strong></em></p>
<p>我们来看下面一段代码，假设保存在<code>bad.go</code>文件中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"log"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"call func got failed: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"call func success"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> err

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"func called error"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"func called error"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run bad.go

<span class="token number">2021</span>/07/02 08:06:55 call func got failed: func called error

<span class="token builtin class-name">exit</span> status <span class="token number">1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>这时我们想<code>定位问题</code>，但不知道具体是<code>哪行代码</code>报的<code>错误</code>，只能靠猜，还不一定能猜到。</p>
<p>为了解决这个问题，我们可以加一些<code>Debug</code>信息，来协助我们定位问题。这样做在<code>测试环境</code>是没问题的，但是在<code>线上环境</code>，一方面<code>修改</code>、<code>发布</code>都比较麻烦，另一方面问题可能比较<code>难重现</code>。这时候我们会想，要是能 <code>打印</code> <code>错误的堆栈</code> 就好了。</p>
<p>例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token number">2021</span>/07/02 <span class="token number">14</span>:17:03 call func got failed: func called error

main.funcB

/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.go:27

main.funcA

/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.go:19

main.main

/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.go:10

runtime.main

/home/colin/go/go1.16.2/src/runtime/proc.go:225

runtime.goexit

/home/colin/go/go1.16.2/src/runtime/asm_amd64.s:1371

<span class="token builtin class-name">exit</span> status <span class="token number">1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的<code>错误输出</code>，我们可以很容易地知道是<code>哪行代码报的错</code>，从而极大<code>提高问题定位的效率</code>，<code>降低定位的难度</code>。</p>
<p>所以，在我看来，一个优秀的 <code>errors 包</code>，首先需要支持<code>错误堆栈</code>。</p>
<p><em><strong>2. 支持不同的打印格式</strong></em></p>
<p>例如<code>%+v</code>、<code>%v</code>、<code>%s</code>等格式，可以根据需要打印不同丰富度的错误信息。</p>
<p><em><strong>3. 支持 Wrap&#x2F;Unwrap 功能</strong></em></p>
<p>也就是在<code>已有的错误上</code>，<code>追加</code>一些新的信息。例如<code>errors.Wrap(err, &quot;open file failed&quot;)</code></p>
<p><code>Wrap</code> 通常用在<code>调用函数</code>中，<code>调用函数</code>可以基于<code>被调函数</code>报错时的<code>错误</code> <code>Wrap</code> 一些自己的信息，丰富报错信息，方便后期的错误定位，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"call funcB failed"</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"func called error"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"func called error"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里要注意，不同的错误类型，<code>Wrap 函数</code>的逻辑也可以不同。</p>
<p>另外，在调用 <code>Wrap</code> 时，也会生成一个<code>错误堆栈节点</code>。我们既然能够<code>嵌套 error</code>，那有时候还可能需要获取<code>被嵌套的 error</code>，这时就需要<code>错误包</code>提供 <code>Unwrap函数</code>。</p>
<p><em><strong>4. 错误包应该有 Is 方法。</strong></em></p>
<p>在实际开发中，我们经常需要判断 <code>某个 error</code> 是否是<code>指定的 error</code>。</p>
<p>在 <code>Go 1.13</code> 之前，也就是没有 <code>wrapping error</code> 的时候，我们要判断 <code>error</code> 是不是同一个，可以使用如下方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">if</span> err <span class="token operator">==</span> os<span class="token punctuation">.</span>ErrNotExist <span class="token punctuation">&#123;</span>

<span class="token comment">// normal code</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>但是现在</strong>，因为<code>有了 wrapping error</code>，这样判断就会有问题。</p>
<p>因为你根本不知道返回的 <code>err</code> 是不是一个<code>嵌套的 error</code>，嵌套了几层。</p>
<p>这种情况下，我们的<code>错误包</code>就需要提供 <code>Is</code>函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> target <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当 <code>err</code> 和 <code>target</code> 是同一个，或者 <code>err</code> 是一个 <code>wrapping error</code> 的时候，如果 <code>target</code> 也包含在这个嵌套 <code>error</code> 链中，返回 <code>true</code>，否则返回 <code>fasle</code>。</p>
<p><em><strong>5. 错误包应该支持 As 函数</strong></em></p>
<p>在 <code>Go 1.13</code> 之前，没有 <code>wrapping error </code>的时候，我们要把 <code>error</code> 转为另外一个 <code>error</code>，一般都是使用 <code>type assertion</code> 或者 <code>type switch</code>，也就是<code>类型断言</code>。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">if</span> perr<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>os<span class="token punctuation">.</span>PathError<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>

  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>perr<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>但是现在</strong>，返回的 <code>err</code> 可能是嵌套的 <code>error</code>，甚至好几层嵌套，这种方式就不能用了。</p>
<p>所以，我们可以通过实现<code>As</code>函数来完成这种功能。现在我们把上面的例子，用 <code>As</code> 函数实现一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> perr <span class="token operator">*</span>os<span class="token punctuation">.</span>PathError

<span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">As</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>perr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>perr<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>这样就可以完全<code>实现类型断言</code>的功能，而且还更强大，因为它可以处理 <code>wrapping error</code>。</strong></p>
<p><em><strong>6. 支持两种错误创建方式：非格式化创建和格式化创建</strong></em></p>
<p>例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"file not found"</span><span class="token punctuation">)</span>

errors<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"file %s not found"</span><span class="token punctuation">,</span> <span class="token string">"iam-apiserver"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面，我们介绍了一个优秀的错误包应该具备的功能。一个好消息是，<code>Github</code> 上有不少实现了这些功能的错误包，其中<code>github.com/pkg/errors</code>包最受欢迎。</p>
<p>所以，我基于<code>github.com/pkg/errors</code>包进行了<code>二次封装</code>，用来支持上一讲所介绍的<code>错误码</code>。</p>
<h2 id="错误包实现"><a href="#错误包实现" class="headerlink" title="错误包实现"></a>错误包实现</h2><p>明确优秀的错误包应该具备的功能后，我们来看下错误包的实现。</p>
<p>实现的源码存放在 <code>github.com/marmotedu/errors</code>。</p>
<p>我通过在文件 <code>github.com/pkg/errors/errors.go</code> 中增加新的 <code>withCode</code> <code>结构体</code>，来引入一种<code>新的错误类型</code>，该<code>错误类型</code>可以 <code>记录</code> <code>错误码</code>、<code>stack</code>、<code>cause</code> 和 <code>具体的错误信息</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> withCode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>

  err <span class="token builtin">error</span> <span class="token comment">// error 错误</span>

  code <span class="token builtin">int</span> <span class="token comment">// 业务错误码</span>

  cause <span class="token builtin">error</span> <span class="token comment">// cause error</span>

  <span class="token operator">*</span>stack <span class="token comment">// 错误堆栈</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>下面，我们通过一个示例，来了解下 <code>github.com/marmotedu/errors</code> 所提供的功能。</p>
<p>假设下述代码保存在<code>errors.go</code>文件中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/marmotedu/errors"</span>

	code <span class="token string">"github.com/marmotedu/sample-code"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">bindUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// %s: Returns the user-safe error string mapped to the error code or the error message if none is specified.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %s &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// %v: Alias for %s.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %v &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// %-v: Output caller details, useful for troubleshooting.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %-v &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%-v\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// %+v: Output full error stack details, useful for debugging.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %+v &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// %#-v: Output caller details, useful for troubleshooting with JSON formatted output.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %#-v &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#-v\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// %#+v: Output full error stack details, useful for debugging with JSON formatted output.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"====================> %#+v &lt;===================="</span><span class="token punctuation">)</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#+v\n\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		<span class="token comment">// do some business process based on the error type</span>

		<span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">IsCode</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> code<span class="token punctuation">.</span>ErrEncodingFailed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"this is a ErrEncodingFailed error"</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">IsCode</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> code<span class="token punctuation">.</span>ErrDatabase<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"this is a ErrDatabase error"</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		<span class="token comment">// we can also find the cause error</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>errors<span class="token punctuation">.</span><span class="token function">Cause</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">bindUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// Step3: Wrap the error with a new error message and a new error code if needed.</span>

		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">WrapC</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> code<span class="token punctuation">.</span>ErrEncodingFailed<span class="token punctuation">,</span> <span class="token string">"encoding user 'Lingfei Kong' failed."</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// Step2: Wrap the error with a new error message.</span>

		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"get user failed."</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// Step1. Create error with specified error code.</span>

	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrDatabase<span class="token punctuation">,</span> <span class="token string">"user 'Lingfei Kong' not found."</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中，通过<code> WithCode 函数</code> 来创建 <code>新的 withCode 类型的错误</code>；</p>
<p>通过 <code>WrapC</code> 来将一个 <code>error</code> <code>封装</code>成一个 <code>withCode 类型的错误</code>；</p>
<p>通过 <code>IsCode</code> 来判断一个 <code>error 链</code>中是否包含指定的 <code>code</code>。</p>
<p><code>withCode 错误</code> 实现了一个 <code>func (w *withCode) Format(state fmt.State, verb rune)</code> 方法，该方法用来打印不同格式的错误信息，见下表：</p>
<p><img src="https://static001.geekbang.org/resource/image/18/5c/18a93313e017d4f3b21370099d011c5c.png" alt="GO 语言项目开发实战 – 错误处理（下）：如何设计错误包？"></p>
<p>例如，<code>%+v</code>会打印以下错误信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
get user failed. - <span class="token comment">#1 [/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/errortrack_errors.go:19 (main.getUser)] (100101) Database error; user 'Lingfei Kong' not found. - #0 [/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/errortrack_errors.go:26 (main.queryDatabase)] (100101) Database error</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>那么你可能会问，这些错误信息中的<code>100101</code>错误码，还有<code>Database error</code>这种对外展示的报错信息等等，是<code>从哪里获取的</code>？</p>
<p>这里我简单解释一下。</p>
<p>首先， <code>withCode</code> 中包含了 <code>int 类型</code>的 <code>错误码</code>，例如 <code>100101</code>。</p>
<p>其次，当使用 <code>github.com/marmotedu/errors</code> 包的时候，需要调用 <code>Register</code> 或者 <code>MustRegister</code> ，将一个 <code>Coder</code> 注册到 <code>github.com/marmotedu/errors</code> 开辟的内存中，数据结构为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> codes <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span>Coder<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><code>Coder</code> 是一个<code>接口</code>，定义为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> Coder <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>

  <span class="token comment">// HTTP status that should be used for the associated error code.</span>

  <span class="token function">HTTPStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   

  <span class="token comment">// External (user) facing error text.</span>

  <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

   

  <span class="token comment">// Reference returns the detail documents for user.</span>

  <span class="token function">Reference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

   

  <span class="token comment">// Code returns the code of the coder</span>

  <span class="token function">Code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样 <code>withCode</code> 的 <code>Format 方法</code> ，就能够通过 <code>withCode</code> 中的 <code>code 字段</code> 获取到对应的 <code>Coder</code> ，并通过 <code>Coder</code> 提供的 <code>HTTPStatus</code>、<code>String</code>、<code>Reference</code>、<code>Code 函数</code>，来获取 <code>withCode</code> 中 <code>code</code> 的详细信息，最后格式化打印。</p>
<p><strong>这里要注意</strong>，我们实现了<code>两个</code>注册函数：<code>Register</code> 和 <code>MustRegister</code> ，二者唯一区别是：当<code>重复定义同一个错误 Code</code> 时，<code>MustRegister</code> 会 <code>panic</code>，这样可以防止<code>后面注册的错误</code>覆盖掉<code>之前注册的错误</code>。在实际开发中，建议使用<code>MustRegister</code>。</p>
<p><code>XXX()</code> 和 <code>MustXXX()</code>的函数命名方式，是一种 <code>Go</code> 代码设计技巧，在 <code>Go</code> 代码中经常使用，例如 <code>Go</code> 标准库中 <code>regexp</code> 包提供的 <code>Compile</code> 和 <code>MustCompile</code> 函数。</p>
<p>和 <code>XXX</code> 相比， <code>MustXXX</code> 会在某种情况不满足时 <code>panic</code>。因此使用 <code>MustXXX</code> 的开发者看到函数名就会有一个心理预期：使用不当，会造成程序 <code>panic</code>。</p>
<p>最后，我还有一个建议：在实际的<code>生产环境</code>中，我们可以使用 <code>JSON 格式</code>打印日志，<code>JSON 格式</code>的日志可以非常方便的供<code>日志系统</code>解析。我们可以根据需要，选择 <code>%#-v</code> 或 <code>%#+v</code> 两种格式。</p>
<p><code>错误包</code>在代码中，经常被调用，所以我们要保证<code>错误包</code>一定要是<code>高性能的</code>，否则很可能会影响接口的性能。</p>
<p>这里，我们再来看下<code>github.com/marmotedu/errors</code>包的性能。</p>
<p>在这里，我们把这个<code>错误包</code>跟 <code>go 标准库</code>的 <code>errors 包</code>，以及 <code>github.com/pkg/errors 包</code> 进行对比，来看看它们的性能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
go <span class="token builtin class-name">test</span> <span class="token parameter variable">-test.bench</span><span class="token operator">=</span>BenchmarkErrors <span class="token parameter variable">-benchtime</span><span class="token operator">=</span><span class="token string">"3s"</span>

goos: linux

goarch: amd64

pkg: github.com/marmotedu/errors

BenchmarkErrors/errors-stack-10-8 <span class="token number">57658672</span> <span class="token number">61.8</span> ns/op <span class="token number">16</span> B/op <span class="token number">1</span> allocs/op

BenchmarkErrors/pkg/errors-stack-10-8 <span class="token number">2265558</span> <span class="token number">1547</span> ns/op <span class="token number">320</span> B/op <span class="token number">3</span> allocs/op

BenchmarkErrors/marmot/errors-stack-10-8 <span class="token number">1903532</span> <span class="token number">1772</span> ns/op <span class="token number">360</span> B/op <span class="token number">5</span> allocs/op

BenchmarkErrors/errors-stack-100-8 <span class="token number">4883659</span> <span class="token number">734</span> ns/op <span class="token number">16</span> B/op <span class="token number">1</span> allocs/op

BenchmarkErrors/pkg/errors-stack-100-8 <span class="token number">1202797</span> <span class="token number">2881</span> ns/op <span class="token number">320</span> B/op <span class="token number">3</span> allocs/op

BenchmarkErrors/marmot/errors-stack-100-8 <span class="token number">1000000</span> <span class="token number">3116</span> ns/op <span class="token number">360</span> B/op <span class="token number">5</span> allocs/op

BenchmarkErrors/errors-stack-1000-8 <span class="token number">505636</span> <span class="token number">7159</span> ns/op <span class="token number">16</span> B/op <span class="token number">1</span> allocs/op

BenchmarkErrors/pkg/errors-stack-1000-8 <span class="token number">327681</span> <span class="token number">10646</span> ns/op <span class="token number">320</span> B/op <span class="token number">3</span> allocs/op

BenchmarkErrors/marmot/errors-stack-1000-8 <span class="token number">304160</span> <span class="token number">11896</span> ns/op <span class="token number">360</span> B/op <span class="token number">5</span> allocs/op

PASS

ok github.com/marmotedu/errors <span class="token number">39</span>.200s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>可以看到 <code>github.com/marmotedu/errors</code> 和 <code>github.com/pkg/errors</code> 包的性能基本持平。</p>
<p>在对比性能时，重点关注 <code>ns/op</code>，也即<code>每次 error 操作</code>耗费的<code>纳秒数</code>。</p>
<p>另外，我们还需要测试不同 <code>error</code> 嵌套深度下的 <code>error</code> 操作性能，嵌套越深，性能越差。</p>
<p>例如：在嵌套深度为 <code>10</code> 的时候， <code>github.com/pkg/errors</code> 包 <code>ns/op</code> 值为 <code>1547</code>， <code>github.com/marmotedu/errors</code> 包 <code>ns/op</code> 值为 <code>1772</code>。可以看到，二者性能基本保持一致。</p>
<p>具体性能数据对比见下表：</p>
<p><img src="https://static001.geekbang.org/resource/image/a6/5e/a6a794d7523bc1edfa459d3a49f9685e.png" alt="GO 语言项目开发实战 – 错误处理（下）：如何设计错误包？"></p>
<p>我们是通过 <code>BenchmarkErrors</code> 测试函数来测试 <code>error</code> 包性能的，你感兴趣可以打开链接看看。</p>
<h2 id="如何记录错误？"><a href="#如何记录错误？" class="headerlink" title="如何记录错误？"></a>如何记录错误？</h2><p>上面，我们一起看了怎么<code>设计</code>一个优秀的<code>错误包</code>，那如何用我们<code>设计的错误包</code>来<code>记录错误</code>呢？</p>
<p>根据我的开发经验，我推荐 <strong><code>两种</code></strong> 记录错误的方式，可以帮你快速定位问题。</p>
<p><em><strong>1. 通过 github.com&#x2F;marmotedu&#x2F;errors 包提供的错误堆栈能力，来跟踪错误。</strong></em></p>
<p>具体你可以看看下面的代码示例。以下代码保存在 <code>errortrack_errors.go</code> 中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"github.com/marmotedu/errors"</span>

	code <span class="token string">"github.com/marmotedu/sample-code"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"get user failed."</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrDatabase<span class="token punctuation">,</span> <span class="token string">"user 'Lingfei Kong' not found."</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上述的代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
go run errortrack_errors.go

get user failed. - <span class="token comment">#1 [/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/errortrack_errors.go:19 (main.getUser)] (100101) Database error; user 'Lingfei Kong' not found. - #0 [/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/errortrack_errors.go:26 (main.queryDatabase)] (100101) Database error</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>可以看到，打印的日志中打印出了详细的<code>错误堆栈</code>，包括<code>错误发生的函数</code>、<code>文件名</code>、<code>行号</code>和<code>错误信息</code>，通过这些<code>错误堆</code>栈，我们可以很方便地定位问题。</p>
<p><strong>你使用这种方法时，我推荐的用法是，在错误最开始处使用 <code>errors.WithCode()</code> 创建一个 <code>withCode</code> 类型的错误。</strong></p>
<p>上层在<code>处理底层返回的错误</code>时，可以根据需要，使用 <code> Wrap 函数</code> 基于该错误封装<code>新的错误信息</code>。</p>
<p>如果要包装的 <code>error</code> 不是用 <code>github.com/marmotedu/errors</code> 包创建的，建议用 <code>errors.WithCode()</code> 新建一个 <code>error</code>。</p>
<p><em><strong>2. 在错误产生的最原始位置调用日志包记录函数，打印错误信息，其他位置直接返回（当然，也可以选择性的追加一些错误信息，方便故障定位）</strong></em></p>
<p>示例代码（保存在<code>errortrack_log.go</code>）如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"github.com/marmotedu/errors"</span>

	<span class="token string">"github.com/marmotedu/log"</span>

	code <span class="token string">"github.com/marmotedu/sample-code"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> err

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">queryDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	opts <span class="token operator">:=</span> <span class="token operator">&amp;</span>log<span class="token punctuation">.</span>Options<span class="token punctuation">&#123;</span>

		Level<span class="token punctuation">:</span> <span class="token string">"info"</span><span class="token punctuation">,</span>

		Format<span class="token punctuation">:</span> <span class="token string">"console"</span><span class="token punctuation">,</span>

		EnableColor<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

		EnableCaller<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

		OutputPaths<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"test.log"</span><span class="token punctuation">,</span> <span class="token string">"stdout"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

		ErrorOutputPaths<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	log<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span>

	<span class="token keyword">defer</span> log<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	err <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrDatabase<span class="token punctuation">,</span> <span class="token string">"user 'Lingfei Kong' not found."</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> err

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>执行以上代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
go run errortrack_log.go

<span class="token number">2021</span>-07-03 <span class="token number">14</span>:37:31.597 ERROR errors/errortrack_log.go:41 Database error

Database error
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当错误发生时，调用 <code>log 包</code>打印错误。通过 <code>log 包</code>的 <code>caller</code> 功能，可以定位到 <code>log</code> 语句的位置，也就是<code>定位到错误发生的位置</code>。</p>
<p><strong>你使用这种方式来打印日志时，我有两个建议。</strong></p>
<p>只在<code>错误产生</code>的 最初位置 打印日志，其他地方 直接返回错误，一般不需要再对错误进行封装。</p>
<p>当代码调用<code>第三方包</code>的<code>函数</code>时，第三方包函数出错时 打印 错误信息。比如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Chdir</span><span class="token punctuation">(</span><span class="token string">"/root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

  log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"change dir failed: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="一个错误码的具体实现"><a href="#一个错误码的具体实现" class="headerlink" title="一个错误码的具体实现"></a>一个错误码的具体实现</h2><p>接下来，我们看一个依据上一讲介绍的错误码规范的具体错误码实现<code>github.com/marmotedu/sample-code</code>。</p>
<p><code>sample-code</code> 实现了<code>两类</code>错误码，分别是<code>通用错误码</code>（<code>sample-code/base.go</code>）和  <code>业务模块相关的错误码</code>（<code>sample-code/apiserver.go</code>）。</p>
<p><strong><code>通用错误码</code>的定义：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
  <span class="token comment">// 通用: 基本错误</span>

  <span class="token comment">// Code must start with 1xxxxx</span>

  <span class="token keyword">const</span> <span class="token punctuation">(</span>

  <span class="token comment">// ErrSuccess - 200: OK.</span>

  ErrSuccess <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">100001</span>

   

  <span class="token comment">// ErrUnknown - 500: Internal server error.</span>

  ErrUnknown

   

  <span class="token comment">// ErrBind - 400: Error occurred while binding the request body to the struct.</span>

  ErrBind

   

  <span class="token comment">// ErrValidation - 400: Validation failed.</span>

  ErrValidation

   

  <span class="token comment">// ErrTokenInvalid - 401: Token invalid.</span>

  ErrTokenInvalid

<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>在代码中，我们通常使用<code>整型常量</code>（<code>ErrSuccess</code>）来代替<code>整型错误码</code>（<code>100001</code>），因为使用 <code>ErrSuccess</code> 时，一看就知道它代表的<code>错误类型</code>，可以方便开发者使用。</p>
<p><code>错误码</code>用来指代一个<code>错误类型</code>，该<code>错误类型</code>需要包含一些有用的信息，例如对应的 <code>HTTP Status Code</code>、对外展示的 <code>Message</code>，以及跟该错误匹配的帮助文档。</p>
<p>所以，我们还需要实现一个 <code>Coder</code> 来承载这些信息。</p>
<p>这里，我们定义了一个实现了 <code>github.com/marmotedu/errors.Coder</code> 接口的 <code>ErrCode 结构体</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// ErrCode implements `github.com/marmotedu/errors`.Coder interface.</span>

<span class="token keyword">type</span> ErrCode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>

  <span class="token comment">// C refers to the code of the ErrCode.</span>

  C <span class="token builtin">int</span>

   

  <span class="token comment">// HTTP status that should be used for the associated error code.</span>

  HTTP <span class="token builtin">int</span>

   

  <span class="token comment">// External (user) facing error text.</span>

  Ext <span class="token builtin">string</span>

   

  <span class="token comment">// Ref specify the reference document.</span>

  Ref <span class="token builtin">string</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong>可以看到 <code>ErrCode</code>结构体 包含了以下信息：</strong></p>
<p><code>int</code> 类型的业务码。</p>
<p>对应的 <code>HTTP Status Code</code>。</p>
<p>暴露给外部用户的消息。</p>
<p>错误的参考文档。</p>
<p><strong>下面是一个具体的 Coder 示例：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
coder <span class="token operator">:=</span> <span class="token operator">&amp;</span>ErrCode<span class="token punctuation">&#123;</span>

  C<span class="token punctuation">:</span> <span class="token number">100001</span><span class="token punctuation">,</span>

  HTTP<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>

  Ext<span class="token punctuation">:</span> <span class="token string">"OK"</span><span class="token punctuation">,</span>

  Ref<span class="token punctuation">:</span> <span class="token string">"https://github.com/marmotedu/sample-code/blob/master/README.md"</span><span class="token punctuation">,</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来，我们就可以调用 <code>github.com/marmotedu/errors</code> 包提供的 <code>Register</code> 或者 <code>MustRegister</code> 函数，将 <code>Coder</code> <code>注册</code>到 <code>github.com/marmotedu/errors 包</code> 维护的内存中。</p>
<p>一个项目有很多个错误码，如果每个错误码都<code>手动</code>调用 <code>MustRegister 函数</code> 会很麻烦，这里我们通过<code>代码自动生成</code>的方法，来生成 <code>register 函数</code> 调用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">//go:generate codegen -type=int</span>

<span class="token comment">//go:generate codegen -type=int -doc -output ./error_code_generated.md</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>//go:generate codegen -type=int</code> 会调用 <code>codegen</code> 工具，生成 <code>sample_code_generated.go</code> 源码文件：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  <span class="token function">register</span><span class="token punctuation">(</span>ErrSuccess<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"OK"</span><span class="token punctuation">)</span>

  <span class="token function">register</span><span class="token punctuation">(</span>ErrUnknown<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"Internal server error"</span><span class="token punctuation">)</span>

  <span class="token function">register</span><span class="token punctuation">(</span>ErrBind<span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"Error occurred while binding the request body to the struct"</span><span class="token punctuation">)</span>

  <span class="token function">register</span><span class="token punctuation">(</span>ErrValidation<span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"Validation failed"</span><span class="token punctuation">)</span>

  <span class="token comment">// other register function call</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些<code>register</code>调用放在 <code>init</code> 函数中，在<code>加载程序</code>的时候被<code>初始化</code>。</p>
<p>这里要注意，在注册的时候，我们会检查 <code>HTTP Status Code</code>，只允许定义 <code>200</code>、<code>400</code>、<code>401</code>、<code>403</code>、<code>404</code>、<code>500</code> 这 <code>6</code> 个 <code>HTTP</code> 错误码。</p>
<p>这里通过程序保证了错误码是符合 <code>HTTP Status Code</code> 使用要求的。</p>
<p><strong><code>//go:generate codegen -type=int -doc -output ./error_code_generated.md</code> 会生成错误码 <code>描述文档</code> <code>error_code_generated.md</code>。</strong></p>
<p><strong>当我们提供 <code>API 文档</code>时，也需要记着提供一份<code>错误码描述文档</code>，这样<code>客户端</code>才可以<code>根据错误码</code>，知道请求<code>是否成功</code>，以及具体发生<code>哪类错误</code>，好针对性地做一些逻辑处理。</strong></p>
<p><strong><code>codegen</code> 工具会根据<code>错误码</code>注释生成 <code>sample_code_generated.go</code> 和 <code>error_code_generated.md</code> 文件</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// ErrSuccess - 200: OK.</span>

ErrSuccess <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">100001</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong><code>codegen</code> 工具之所以能够生成 <code>sample_code_generated.go</code> 和 <code>error_code_generated.md</code>，是因为我们的错误码注释是有规定格式的：<code>// &lt;错误码整型常量&gt; – &lt;对应的HTTP Status Code&gt;: .</code></strong></p>
<p><code>codegen</code> 工具可以在 <code>IAM</code> 项目根目录下，执行以下命令来安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">make</span> tools.install.codegen
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>安装完 <code>codegen</code> 工具后，可以在 <code>github.com/marmotedu/sample-code</code> 包根目录下执行 <code>go generate</code> 命令，来生成 <code>sample_code_generated.go</code> 和 <code>error_code_generated.md</code>。</strong></p>
<p>这里有个技巧需要你注意：生成的文件建议统一用 <code>xxxx_generated.xx</code> 来命名，这样通过 <code>generated</code> ，我们就知道这个文件是代码<code>自动生成</code>的，有助于我们理解和使用。</p>
<p>在实际的开发中，我们可以将<code>错误码独立成一个包</code>，放在 <code>internal/pkg/code/</code> 目录下，这样可以<code>方便整个应用调用</code>。</p>
<p>例如 <code>IAM</code> 的错误码就放在 <code>IAM</code> 项目根目录下的 <code>internal/pkg/code/</code> 目录下。</p>
<p>我们的<code>错误码</code>是分<code>服务</code>和<code>模块</code>的，所以这里建议你把相同的服务放在同一个 <code>Go</code> 源文件中，例如 <code>IAM 的错误码</code>存放文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token function">ls</span> base.go apiserver.go authzserver.go

apiserver.go authzserver.go base.go
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>一个应用中会有多个服务，例如 <code>IAM 应用</code>中，就包含了 <code>iam-apiserver</code>、<code>iam-authz-server</code>、<code>iam-pump</code> 三个服务。</p>
<p>这些服务有一些通用的错误码，为了<code>便于维护</code>，可以将这些通用的错误码统一放在 <code>base.go</code> 源码文件中。</p>
<p>其他的错误码，我们可以<code>按服务</code>分别放在不同的文件中：</p>
<p><code>iam-apiserver</code> 服务的错误码统一放在 <code>apiserver.go</code> 文件中；<br><code>iam-authz-server</code> 的错误码统一存放在 <code>authzserver.go</code> 文件中。<br>其他服务以此类推。</p>
<p>另外，<code>同一个服务</code>中<code>不同模块</code>的<code>错误码</code>，可以按以下格式来组织：</p>
<p><code>相同模块</code>的错误码放在<code>同</code>一个 <code>const 代码块</code>中，<br><code>不同模块</code>的错误码放在<code>不同</code>的 <code>const 代码块</code>中。<br>每个 <code>const 代码块</code>的<code>开头注释</code>就是<code>该模块</code>的<code>错误码定义</code>。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// iam-apiserver: user errors.</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>

  <span class="token comment">// ErrUserNotFound - 404: User not found.</span>

  ErrUserNotFound <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">110001</span>

   

  <span class="token comment">// ErrUserAlreadyExist - 400: User already exist.</span>

  ErrUserAlreadyExist

<span class="token punctuation">)</span>

 

<span class="token comment">// iam-apiserver: secret errors.</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>

  <span class="token comment">// ErrEncrypt - 400: Secret reach the max count.</span>

  ErrReachMaxCount <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">110101</span>

   

  <span class="token comment">// ErrSecretNotFound - 404: Secret not found.</span>

  ErrSecretNotFound

<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后，我们还需要将<code>错误码定义记录</code>在<code>项目的文件中</code>，供<code>开发者</code>查阅、遵守和使用，例如 <code>IAM 项目的错误码定义记录文档</code>为  <code>code_specification.md</code> 。</p>
<p>这个文档中记录了<code>错误码说明</code>、<code>错误描述规范</code>和<code>错误记录规范</code>等。</p>
<h2 id="错误码实际使用方法示例"><a href="#错误码实际使用方法示例" class="headerlink" title="错误码实际使用方法示例"></a>错误码实际使用方法示例</h2><p><em><strong>上面，我讲解了<code>错误包</code>和<code>错误码</code>的实现方式，那你一定想知道在<code>实际开发中</code>我们是<code>如何使用</code>的。</strong></em></p>
<p><strong>这里，我就举一个在 <code>gin web</code> 框架中使用该错误码的例子：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// Response defines project response format which in marmotedu organization.</span>

<span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Code errors<span class="token punctuation">.</span>Code <span class="token string">`json:"code,omitempty"`</span>

	Message <span class="token builtin">string</span> <span class="token string">`json:"message,omitempty"`</span>

	Reference <span class="token builtin">string</span> <span class="token string">`json:"reference,omitempty"`</span>

	Data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token string">`json:"data,omitempty"`</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// WriteResponse used to write an error and JSON data into response.</span>

<span class="token keyword">func</span> <span class="token function">WriteResponse</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">,</span> data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		coder <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">ParseCoder</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>

		c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>coder<span class="token punctuation">.</span><span class="token function">HTTPStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Response<span class="token punctuation">&#123;</span>

			Code<span class="token punctuation">:</span> coder<span class="token punctuation">.</span><span class="token function">Code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

			Message<span class="token punctuation">:</span> coder<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

			Reference<span class="token punctuation">:</span> coder<span class="token punctuation">.</span><span class="token function">Reference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

			Data<span class="token punctuation">:</span> data<span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> Response<span class="token punctuation">&#123;</span>Data<span class="token punctuation">:</span> data<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">GetUser</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	log<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"get user function called."</span><span class="token punctuation">,</span> <span class="token string">"X-Request-Id"</span><span class="token punctuation">,</span> requestid<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// Get the user by the `username` from the database.</span>

	user<span class="token punctuation">,</span> err <span class="token operator">:=</span> store<span class="token punctuation">.</span><span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Users</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">Param</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metav1<span class="token punctuation">.</span>GetOptions<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> code<span class="token punctuation">.</span>ErrUserNotFound<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中，通过<code>WriteResponse</code>统一处理错误。</p>
<p>在 <code>WriteResponse</code> 函数中，如果 <code>err != nil</code>，则从 <code>error</code> 中<code>解析</code>出 <code>Coder</code> ，并<code>调用</code> <code>Coder</code> 提供的方法，<code>获取</code>错误相关的 <code>Http Status Code</code>、<code>int 类型的业务码</code>、<code>暴露给用户的信息</code>、<code>错误的参考文档链接</code>，并返回<code> JSON 格式的信息</code>。</p>
<p>如果 <code>err == nil </code>则返回 <code>200</code> 和 <code>数据</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录错误是应用程序必须要做的一件事情，在实际开发中，我们通常<code>会封装自己的错误包</code>。</p>
<p>一个优秀的错误包，应该能够<code>支持错误堆栈</code>、<code>不同的打印格式</code>、<code>Wrap</code>&#x2F;<code>Unwrap</code>&#x2F;<code>Is</code>&#x2F;<code>As</code> 等函数，并能够支持<code>格式化创建 error</code>。</p>
<p>根据这些错误包设计要点，我基于 <code>github.com/pkg/errors</code> 包设计了 <code>IAM</code> 项目的错误包 <code>github.com/marmotedu/errors</code> ，该包符合我们上一讲设计的错误码规范。</p>
<p>另外，本讲也给出了一个具体的错误码实现 <code>sample-code</code> ， <code>sample-code</code> 支持<code>业务 Code 码</code>、<code>HTTP Status Code</code>、<code>错误参考文档</code>、可以对<code>内</code> 对 <code>外</code> 展示 不同的 <code>错误信息</code>。</p>
<p>最后，因为<code>错误码注释</code>是有<code>固定格式</code>的，所以我们可以通过 <code>codegen</code> 工具 解析 <code>错误码的注释</code>，生成 <code>register 函数调用</code>和 <code>错误码文档</code>。</p>
<p>这种做法也体现了我一直强调的 <code>low code</code> 思想，可以提高开发效率，减少人为失误。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>13 | 日志处理：如何设计日志包并记录日志</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-13-log-pkg.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在做<code>Go</code>项目开发时，除了处理错误之外，我们必须要做的另外一件事是<code>记录日志</code>。通过<code>记录日志</code>，可以完成一些基本功能，比如<code>开发</code>、<code>测试</code>期间的 <code>Debug</code> ，<code>故障排除</code>，<code>数据分析</code>，<code>监控告警</code>，以及<code>记录发生的事件</code>等。</p>
<p>要实现这些功能，首先我们需要一个优秀的日志包。另外，我还发现不少 <code>Go</code> 项目开发者记录日志很随意，输出的日志并不能有效定位到问题。</p>
<p>所以，我们还需要知道怎么更好地记录日志，这就需要一个日志记录规范。</p>
<p>有了优秀的日志包和日志记录规范，我们就能很快地定位到问题，获取足够的信息，并完成后期的数据分析和监控告警，也可以很方便地进行调试了。</p>
<span id="more"></span>
<p>首先，我们来看下如何设计日志包。</p>
<h2 id="如何设计日志包"><a href="#如何设计日志包" class="headerlink" title="如何设计日志包"></a>如何设计日志包</h2><p>目前，虽然有很多优秀的开源日志包可供我们选择，但在一个大型系统中，这些开源日志包很可能无法满足我们定制化的需求，这时候我们就需要自己开发日志包。</p>
<p>这些日志包可能是基于某个，或某几个开源的日志包改造而来，也可能是全新开发的日志包。</p>
<p>那么在开发日志包时，我们需要实现哪些功能，又如何实现呢？接下来，我们就来详细聊聊。</p>
<p>先来看下日志包需要具备哪些功能。根据功能的重要性，我将日志包需要实现的功能分为<strong>基础功能</strong>、<strong>高级功能</strong>和<strong>可选功能</strong>。</p>
<p><code>基础功能</code>是一个日志包必须要具备的功能；</p>
<p><code>高级功能</code>、<code>可选功能</code>都是在<code>特定场景</code>下可增加的功能。我们先来说基础功能。</p>
<h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>基础功能，是优秀日志包必备的功能，能够满足绝大部分的使用场景，适合一些中小型的项目。一个日志包应该具备以下4个基础功能。</p>
<p><em><strong>1.  支持基本的日志信息</strong></em></p>
<p>日志包需要支持基本的日志信息，包括<code>时间戳</code>、<code>文件名</code>、<code>行号</code>、<code>日志级别</code>和<code>日志信息</code>。</p>
<p><code>时间戳</code>可以记录日志发生的时间。在定位问题时，我们往往需要根据<code>时间戳</code>，来复原请求过程，核对相同<code>时间戳下</code>的上下文，从而定位出问题。</p>
<p><code>文件名</code>和<code>行号</code>，可以使我们更快速定位到<code>打印日志的位置</code>，找到问题代码。</p>
<p>一个日志库如果不支持<code>文件名</code>和<code>行号</code>，排查故障就会变得非常困难，基本只能靠 <code>grep</code> 和 <code>记忆</code> 来定位代码。</p>
<p>对于<code>企业级的服务</code>，需要保证服务在故障后能够<code>快速恢复</code>，恢复的时间越久，造成的损失就越大，影响就越大。</p>
<p>这就要求研发人员能够快速定位并解决问题。通过<code>文件名</code>和<code>行号</code>，我们可以<code>精准</code>定位到问题代码，尽快地修复问题并恢复服务。</p>
<p>通过日志级别，可以知道日志的<code>错误类型</code>，最通常的用法是：直接过滤出 <code>Error</code> 级别的日志，这样就可以直接<code>定位出问题出错点</code>，然后再结合其他日志定位出出错的原因。如果不支持<code>日志级别</code>，在定位问题时，可能要查看一大堆<code>无用的日志</code>。</p>
<p>在大型系统中，一次请求的日志量很多，这会大大延长我们定位问题的时间。</p>
<p>而通过日志信息，我们可以知道错误发生的具体原因。</p>
<p><em><strong>2.  支持不同的日志级别</strong></em></p>
<p><strong>不同的日志级别代表不同的日志类型，例如：</strong></p>
<p><code>Error</code>级别的日志，说明日志是<code>错误类型</code>，在排障时，会首先查看错误级别的日志。</p>
<p><code>Warn</code> 级别日志说明出现异常，但还不至于影响程序运行，如果程序执行的结果不符合预期，则可以参考 <code>Warn</code> 级别的日志，定位出异常所在。</p>
<p><code>Info</code> 级别的日志，可以协助我们 <code>Debug</code> ，并记录一些有用的信息，供后期进行分析。</p>
<p><strong>通常一个日志包至少要实现 <code>6</code> 个级别，我给你提供了一张表格，按优先级从低到高排列如下：</strong></p>
<p><a href="https://static001.geekbang.org/resource/image/bb/2b/bb1356bd3cf332ddeb30d3aef8fc8d2b.png"><img src="https://static001.geekbang.org/resource/image/bb/2b/bb1356bd3cf332ddeb30d3aef8fc8d2b.png"></a></p>
<p>有些日志包，例如 <code>logrus</code> ，还支持 <code>Trace</code> 日志级别。</p>
<p><code>Trace</code> 级别比 <code>Debug</code> 级别还低，能够打印更细粒度的日志信息。</p>
<p>在我看来，<code>Trace</code> 级别不是必须的，你可以根据需要自行选择。</p>
<p><strong>打印日志时，一个日志调用其实具有两个属性：</strong></p>
<ul>
<li><code>输出级别</code>：打印日志时，我们期望日志的输出级别。例如，我们调用 <code>glog.Info(&quot;This is info message&quot;)</code> 打印一条日志，则输出日志级别为 <code>Info</code> 。</li>
<li><code>开关级别</code>：启动应用程序时，期望哪些输出级别的日志被打印。例如，使用 <code>glog</code> 时 <code>-v=4</code> ，说明了只有日志级别高于 <code>4</code> 的日志才会被打印。</li>
</ul>
<p>如果开关级别设置为 <code>L</code> ，只有输出级别 <code>&gt;=L</code> 时，日志才会被打印。</p>
<p><strong>例如，开关级别为 <code>Warn</code> ，则只会记录 <code>Warn</code>、<code>Error</code> 、<code>Panic</code> 和 <code>Fatal</code> 级别的日志。具体的输出关系如下图所示：</strong></p>
<p><a href="https://static001.geekbang.org/resource/image/dd/ed/dd4e9c3ed26b254cb5b65ff1fddd40ed.png"><img src="https://static001.geekbang.org/resource/image/dd/ed/dd4e9c3ed26b254cb5b65ff1fddd40ed.png"></a></p>
<p><em><strong>3.  支持自定义配置</strong></em></p>
<p><strong>不同的运行环境，需要不同的日志输出配置，例如：</strong></p>
<p><code>开发测试</code>环境为了能够方便地 <code>Debug</code> ，需要设置日志级别为<code>Debug</code>级别；</p>
<p><code>现网环境</code>为了提高应用程序的性能，则需要设置日志级别为 <code>Info</code> 级别。</p>
<p><code>现网环境</code>为了方便<code>日志采集</code>，通常会输出<code>JSON</code>格式的日志；</p>
<p><code>开发测试</code>环境为了方便查看日志，会输出 <code>TEXT</code> 格式的日志。</p>
<p>所以，我们的日志包需要能够被<code>配置</code>，还要<code>不同环境</code>采用不同的配置。</p>
<p>通过配置，可以在不重新编译代码的情况下，改变记录日志的行为。</p>
<p><em><strong>4.  支持输出到标准输出和文件</strong></em></p>
<p>日志总是要被读的，要么<code>输出到标准输出</code>，供开发者实时读取，要么<code>保存到文件</code>，供开发者日后查看。</p>
<p>输出到 <code>标准输出</code> 和 <code>保存到文件</code> 是一个日志包最基本的功能。</p>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><p>除了上面提到的这些基本功能外，在一些大型系统中，通常还会要求日志包具备一些高级功能。</p>
<p>这些高级功能可以帮我们更好地记录日志，并实现更丰富的功能，例如<code>日志告警</code>。那么一个日志包可以具备哪些高级功能呢？</p>
<p><em><strong>1.  支持多种日志格式</strong></em></p>
<p><code>日志格式</code>也是我们要考虑的一个点，一个好的<code>日志格式</code>，不仅<code>方便查看</code>日志，还能方便一些<code>日志采集组件</code>采集日志，并对接类似 <code>Elasticsearch</code> 这样的<code>日志搜索引擎</code>。</p>
<p><strong>一个日志包至少需要提供以下两种格式：</strong></p>
<ul>
<li><code>TEXT</code> 格式 ：<code>TEXT</code>格式的日志具有良好的可读性，可以方便我们在<code>开发联调阶段</code>查看日志，例如：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2020</span>-12-02T01:16:18+08:00 INFO example.go:11 std log

<span class="token number">2020</span>-12-02T01:16:18+08:00 DEBUG example.go:13 change std log to debug level<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>JSON</code> 格式：<code>JSON</code> 格式的日志可以记录更详细的信息，日志中包含一些<code>通用</code>的或<code>自定义</code>的字段，可供日后的<code>查询</code>、<code>分析</code>使用，而且可以很方便地供 <code>filebeat</code> 、<code>logstash</code> 这类<code>日志采集工具</code> 采集并上报。下面是 <code>JSON</code> 格式的日志：</li>
</ul>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"level"</span><span class="token operator">:</span><span class="token string">"DEBUG"</span><span class="token punctuation">,</span><span class="token property">"time"</span><span class="token operator">:</span><span class="token string">"2020-12-02T01:16:18+08:00"</span><span class="token punctuation">,</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"example.go:15"</span><span class="token punctuation">,</span><span class="token property">"func"</span><span class="token operator">:</span><span class="token string">"main.main"</span><span class="token punctuation">,</span><span class="token property">"message"</span><span class="token operator">:</span><span class="token string">"log in json format"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token property">"level"</span><span class="token operator">:</span><span class="token string">"INFO"</span><span class="token punctuation">,</span><span class="token property">"time"</span><span class="token operator">:</span><span class="token string">"2020-12-02T01:16:18+08:00"</span><span class="token punctuation">,</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"example.go:16"</span><span class="token punctuation">,</span><span class="token property">"func"</span><span class="token operator">:</span><span class="token string">"main.main"</span><span class="token punctuation">,</span><span class="token property">"message"</span><span class="token operator">:</span><span class="token string">"another log in json format"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我建议在<code>开发联调</code>阶段使用TEXT格式的日志</p>
<p><code>现网环境</code>使用<code>JSON</code>格式的日志</p>
<p>一个优秀的日志库，例如 <code>logrus</code>，除了提供基本的输出格式外，还应该允许开发者<code>自定义</code>日志输出格式。</p>
<p><em><strong>2.  能够按级别分类输出</strong></em></p>
<p>为了能够快速定位到需要的日志，一个比较好的做法是将<code>日志按级别</code> <code>分类输出</code>，至少错误级别的日志可以<code>输出到独立的文件</code>中。</p>
<p>这样，出现问题时，可以直接查找错误文件定位问题。例如， <code>glog</code> 就支持<code>分类输出</code>，如下图所示：</p>
<p><a href="https://static001.geekbang.org/resource/image/10/4b/100af3121e8d4e84428979f9d0yydf4b.png"><img src="https://static001.geekbang.org/resource/image/10/4b/100af3121e8d4e84428979f9d0yydf4b.png"></a></p>
<p><em><strong>3.  支持结构化日志</strong></em></p>
<p><code>结构化日志</code>（<code>Structured Logging</code>），就是使用<code>JSON</code>或者<code>其他编码</code>方式使日志结构化，这样可以方便后续使用 <code>Filebeat</code> 、<code>Logstash Shipper</code>等各种工具，对日志进行<code>采集</code>、<code>过滤</code>、<code>分析</code>和 &#96;查找 。</p>
<p><strong>就像下面这个案例，使用 <code>zap</code> 进行日志打印：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"time"</span>

	<span class="token string">"go.uber.org/zap"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	logger<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> zap<span class="token punctuation">.</span><span class="token function">NewProduction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">defer</span> logger<span class="token punctuation">.</span><span class="token function">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// flushes buffer, if any</span>

	url <span class="token operator">:=</span> <span class="token string">"http://marmotedu.com"</span>

	<span class="token comment">// 结构化日志打印</span>

	logger<span class="token punctuation">.</span><span class="token function">Sugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infow</span><span class="token punctuation">(</span><span class="token string">"failed to fetch URL"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token string">"attempt"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"backoff"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>

	<span class="token comment">// 非结构化日志打印</span>

	logger<span class="token punctuation">.</span><span class="token function">Sugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"failed to fetch URL: %s"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>上述代码输出为：</strong></p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"level"</span><span class="token operator">:</span><span class="token string">"info"</span><span class="token punctuation">,</span><span class="token property">"ts"</span><span class="token operator">:</span><span class="token number">1607303966.9903321</span><span class="token punctuation">,</span><span class="token property">"caller"</span><span class="token operator">:</span><span class="token string">"zap/structured_log.go:14"</span><span class="token punctuation">,</span><span class="token property">"msg"</span><span class="token operator">:</span><span class="token string">"failed to fetch URL"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token property">"http://marmotedu.com&amp;quot;,&amp;quot;attempt&amp;quot;:3,&amp;quot;backoff"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token property">"level"</span><span class="token operator">:</span><span class="token string">"info"</span><span class="token punctuation">,</span><span class="token property">"ts"</span><span class="token operator">:</span><span class="token number">1607303966.9904354</span><span class="token punctuation">,</span><span class="token property">"caller"</span><span class="token operator">:</span><span class="token string">"zap/structured_log.go:17"</span><span class="token punctuation">,</span><span class="token property">"msg"</span><span class="token operator">:</span><span class="token string">"failed to fetch URL: http://marmotedu.com"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><em><strong>4.  支持日志轮转</strong></em></p>
<p>在一个大型项目中，一天可能会产生<code>几十个G</code>的日志。</p>
<p>为了防止<code>日志</code>把<code>磁盘</code>空间<code>占满</code>，导致<code>服务器</code>或者<code>程序</code>异常，就需要确保<code>日志大小</code>达到一定<code>量级</code>时，对日志进行<code>切割</code>、<code>压缩</code>，<code>并转存</code>。</p>
<p>如何切割呢？你可以按照<code>日志大小</code>进行切割，也可以按<code>日期切割</code>。</p>
<p>日志的<code>切割</code>、<code>压缩</code>和<code>转存</code>功能可以基于 <code>GitHub</code> 上一些优秀的<code>开源包</code>来<code>封装</code></p>
<p><strong>例如：</strong></p>
<p><a href="https://github.com/natefinch/lumberjack">lumberjack</a> 可以支持按<code>大小</code>和<code>日期</code>归档日志</p>
<p>file-rotatelogs](<a href="https://github.com/lestrrat-go/file-rotatelogs">https://github.com/lestrrat-go/file-rotatelogs</a>) 支持按<code>小时数</code>进行日志切割。</p>
<p>对于<code>日志轮转</code>功能，其实我不建议在日志包中添加，因为这会增加日志包的<code>复杂度</code>，我更建议的做法是借助<code>其他的工具</code>来实现<code>日志轮转</code>。</p>
<p>例如，在 <code>Linux</code> 系统中可以使用 <code>Logrotate</code> 来轮转日志。 <code>Logrotate</code> 功能强大，是一个专业的<code>日志轮转</code>工具。</p>
<p><em><strong>5.  具备 Hook 能力</strong></em></p>
<p><code>Hook</code> 能力可以使我们对<code>日志内容</code>进行<code>自定义处理</code>。</p>
<p>例如，当某个级别的日志产生时，<code>发送邮件</code>或者 <code>调用告警接口</code> 进行告警。</p>
<p>很多优秀的开源日志包提供了 <code>Hook</code> 能力 ，例如 <code>logrus</code> 和 <code>zap</code> 。</p>
<p>在一个大型系统中，<code>日志告警</code>是非常重要的功能，但更好的实现方式是将<code>告警能力</code>做成<code>旁路功能</code>。</p>
<p>通过<code>旁路功能</code>，可以保证日志包功能<code>聚焦</code>、<code>简洁</code>。</p>
<p><strong>例如：</strong> 可以将日志收集到 <code>Elasticsearch</code> ，并通过 <code>ElastAlert</code> 进行日志告警。</p>
<h3 id="可选功能"><a href="#可选功能" class="headerlink" title="可选功能"></a>可选功能</h3><p>除了基础功能和高级功能外，还有一些功能。</p>
<p>这些功能不会影响到日志包的<code>核心功能</code>，但是如果具有这些功能，会使日志包更加<code>易用</code>。比如下面的这三个功能。</p>
<p><em><strong>1.  支持颜色输出</strong></em></p>
<p>在<code>开发</code>、<code>测试</code>时开启<code>颜色输出</code>，不同级别的日志会被不同<code>颜色标识</code>，这样我们可以很轻松地发现一些 <code>Error</code> 、<code>Warn</code> 级别的日志，方便<code>开发调试</code>。</p>
<p>发布到<code>生产环境</code>时，可以关闭颜色输出，以提高性能。</p>
<p><em><strong>2.  兼容标准库 lo g包</strong></em></p>
<p>一些早期的<code>Go</code>项目大量使用了 标准库 <code>log</code>包，如果我们的日志库能够<code>兼容</code> 标准库 <code>log</code>包，我们就可以很容易地替换掉 标准库<code>log</code>包。</p>
<p><strong>例如，<code>logrus</code> 就兼容 标准库 <code>log</code> 包。这里，我们来看一个使用了 标准库 <code>log</code> 包的代码：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>

	<span class="token string">"log"</span>

<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"call Print: line1"</span><span class="token punctuation">)</span>

	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"call Println: line2"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>只需要使用<code>log &quot;github.com/sirupsen/logrus&quot;</code> 替换 <code>&quot;log&quot;</code> 就可以完成 标准库 <code>log</code>包的切换：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>

	log <span class="token string">"github.com/sirupsen/logrus"</span>

<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"call Print: line1"</span><span class="token punctuation">)</span>

	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"call Println: line2"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><em><strong>3.  支持输出到不同的位置</strong></em></p>
<ol>
<li><p>在<code>分布式系统</code>中，一个<code>服务</code>会被部署在<code>多台机器</code>上，这时候如果我们要查看日志，就需要分别登录不同的机器查看，非常麻烦。我们更希望将<code>日志</code>统一<code>投递</code>到 <code>Elasticsearch</code> 上，在 <code>Elasticsearch</code> 上查看日志。</p>
</li>
<li><p>还可能需要从日志中<code>分析某个接口</code>的<code>调用次数</code>、<code>某个用户</code>的<code>请求次数</code>等信息，这就需要我们能够对<code>日志进行处理</code>。 一般的做法是将<code>日志</code> 投递 到 <code>Kafka</code>，数据处理服务消费<code>Kafka</code>中保存的日志，从而分析出<code>调用次数</code>等信息。</p>
</li>
</ol>
<p>以上两种场景，分别需要把<code>日志</code>投递到<code>Elasticsearch</code>、<code>Kafka</code>等<code>组件</code>，如果我们的 <code>日志包</code> 支持将 <code>日志</code> 投递到不同的 <code>目的端</code>，那会是一项非常让人期待的功能：</p>
<p><a href="https://static001.geekbang.org/resource/image/bd/4b/bda7177a7a627b0117bfffdbd129914b.png"><img src="https://static001.geekbang.org/resource/image/bd/4b/bda7177a7a627b0117bfffdbd129914b.png"></a></p>
<p>如果日志<code>不支持</code>投递到不同的<code>下游组件</code>，例如 <code>Elasticsearch</code> 、 <code>Kafka</code> 、 <code>Fluentd</code> 、 <code>Logstash</code> 等位置，也可以通过 <code>Filebeat</code> 采集<code>磁盘</code>上的日志文件，进而投递到<code>下游组件</code>。</p>
<h3 id="设计日志包时需要关注的点"><a href="#设计日志包时需要关注的点" class="headerlink" title="设计日志包时需要关注的点"></a>设计日志包时需要关注的点</h3><p><strong>上面，我们介绍了日志包具备的功能，这些功能可以指导我们完成日志包<code>设计</code>。这里，我们再来看下<code>设计</code>日志包时，我们还需要关注的几个层面：</strong></p>
<ol>
<li><strong>高性能：</strong> 因为我们要在代码中<code>频繁调用</code>日志包，记录日志，所以日志包的性能是首先要考虑的点，一个性能很差的日志包必然会导致整个应用性能很差。</li>
<li><strong>并发安全：</strong> <code>Go</code>应用程序 会 大量使用 <code>Go</code> 语言的<code>并发</code>特性，也就意味着需要 <code>并发地记录日志</code>，这就需要日志包是<code>并发安全</code>的。</li>
<li><strong>插件化能力：</strong> 日志包应该能提供一些<code>插件化</code>的能力，比如<code>允许开发者自定义输出格式</code>，<code>自定义存储位置</code>，<code>自定义错误发生时的行为</code>（例如 <code>告警</code>、<code>发邮件</code>等）。插件化的能力不是必需的，因为日志自身的特性就能满足绝大部分的使用需求，<strong>例如：</strong>输出格式支持 <code>JSON</code> 和 <code>TEXT</code> ，存储位置支持<code>标准输出</code>和<code>文件</code>，<code>日志监控</code>可以通过一些<code>旁路系统</code>来实现。</li>
<li><strong>日志参数控制：</strong>  日志包应该能够灵活地进行配置，初始化时配置或者程序运行时配置。例如：初始化配置可以通过 <code>Init</code> 函数完成，运行时配置可以通过 <code>SetOptions</code> &#x2F; <code>SetLevel</code> 等函数来完成。</li>
</ol>
<h2 id="如何记录日志？"><a href="#如何记录日志？" class="headerlink" title="如何记录日志？"></a>如何记录日志？</h2><p>前面我们介绍了在设计日志包时，要包含的一些<code>功能</code>、<code>实现方法</code>和<code>注意事项</code>。</p>
<p>但在这个过程中，还有一项重要工作需要注意，那就是<code>日志记录问题</code>。</p>
<p>日志并<code>不是越多越好</code>，在<code>实际开发</code>中，经常会遇到一大堆<code>无用的日志</code>，却没有我们<code>需要的日志</code>；或者<code>有效的日志</code>被<code>大量无用的日志淹没</code>，查找起来非常困难。</p>
<p>一个优秀的日志包可以协助我们更好地<code>记录</code>、<code>查看</code>和<code>分析</code>日志，但是<code>如何记录日志</code>决定了我们能否<code>获取到有用的信息</code>。</p>
<p>日志包是工具，日志记录才是灵魂。这里，我就来详细讲讲如何记录日志。</p>
<p><strong>想要更好地记录日志，我们需要解决以下几个问题：</strong></p>
<ol>
<li>在何处打印日志？</li>
<li>在哪个日志级别打印日志？</li>
<li>如何记录日志内容？</li>
</ol>
<h3 id="在何处打印日志？"><a href="#在何处打印日志？" class="headerlink" title="在何处打印日志？"></a>在何处打印日志？</h3><p>日志主要是用来定位问题的，所以整体来说，我们要在有需要的地方打印日志。那么具体是哪些地方呢？我给你几个建议。</p>
<ul>
<li><strong>在分支语句处打印日志。</strong> 在分支语句处打印日志，可以判断出代码走了哪个分支，有助于判断请求的下一跳，继而继续排查问题。</li>
<li><strong>写操作必须打印日志。</strong> 写操作最可能会引起比较严重的业务故障，写操作打印日志，可以在出问题时找到关键信息。</li>
<li><strong>在循环中打印日志要慎重。</strong> 如果循环次数过多，会导致打印大量的日志，严重拖累代码的性能，建议的办法是在循环中记录要点，在循环外面总结打印出来。</li>
<li><strong>在错误产生的最原始位置打印日志。</strong> 对于<code>嵌套的</code> <code>Error</code>，可在 <code>Error</code> 产生的 <code>最初位置</code> 打印 <code>Error</code> 日志，上层如果不需要添加必要的信息，可以直接返回下层的<code>Error</code>。</li>
</ul>
<p><strong>我给你举个例子：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"flag"</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/golang/glog"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">defer</span> glog<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		glog<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token function">decodeConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 直接返回</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">decodeConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"could not decode configuration data for user %s: %v"</span><span class="token punctuation">,</span> <span class="token string">"colin"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token comment">// 添加必要的信息，用户名称</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"read: end of input."</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"read: end of input"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过在<code>最初产生错误</code>的 <code>位置</code> 打印日志，我们可以很方便地<code>追踪到日志的根源</code>，进而在上层追加一些必要的信息。</p>
<p>这可以让我们了解到该错误产生的<code>影响</code>，有助于<code>排障</code>。另外，<code>直接返回</code>下层日志，还可以<code>减少重复</code>的日志打印。</p>
<p><strong>当代码调用<code>第三方包的函数</code>，且<code>第三方包函数</code>出错时，会打印错误信息。比如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Chdir</span><span class="token punctuation">(</span><span class="token string">"/root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

	log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"change dir failed: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="在哪个日志级别打印日志？"><a href="#在哪个日志级别打印日志？" class="headerlink" title="在哪个日志级别打印日志？"></a>在哪个日志级别打印日志？</h3><p>不同级别的日志，具有不同的意义，能实现不同的功能，在开发中，我们应该根据目的，在合适的级别记录日志，这里我同样给你一些建议。</p>
<p><strong>1.  Debug 级别</strong></p>
<p>为了获取足够的信息进行 <code>Debug</code> ，通常会在 <code>Debug</code> 级别打印很多日志。</p>
<p>例如，可以打印整个 <code>HTTP</code> 请求的请求 <code>Body</code> 或者 响应 <code>Body</code> 。</p>
<p><code>Debug</code> 级别需要打印大量的日志，这会严重拖累程序的性能。并且， <code>Debug</code> 级别的日志，主要是为了能在开发测试阶段更好地 <code>Debug</code> ，多是一些不影响现网业务的日志信息。</p>
<p>所以，对于 <code>Debug</code> 级别的日志，在<code>服务上线</code>时我们一定要<code>禁止掉</code>。否则，就可能会因为大量的日志导致<code>硬盘空间快速用完</code>，从而造成<code>服务宕机</code>，也可能会影响<code>服务</code>的<code>性能</code>和<code>产品体验</code>。</p>
<p><code>Debug</code> 这个级别的日志可以随意输出，任何你觉得有助于开发、测试阶段调试的日志，都可以在这个级别打印。</p>
<p><strong>2.  Info 级别</strong></p>
<p><code>Info</code> 级别的日志可以记录一些有用的信息，供以后的运营分析，所以 <code>Info</code> 级别的日志不是越多越好，也不是越少越好，应以满足需求为主要目标。</p>
<p>一些关键日志，可以在 <code>Info</code> 级别记录，但如果日志量大、输出频度过高，则要考虑在 <code>Debug</code> 级别记录。</p>
<p>现网的日志级别一般是 <code>Info</code> 级别，为了不使日志文件<code>占满</code>整个磁盘空间，在记录日志时，要注意避免产生过多的 <code>Info</code> 级别的日志。</p>
<p>例如，在 <code>for</code> 循环中，就要慎用 <code>Info</code> 级别的日志。</p>
<p><strong>3.  Warn 级别</strong></p>
<p>一些警告类的日志可以记录在 <code>Warn</code> 级别， <code>Warn</code> 级别的日志往往说明程序运行异常，不符合预期，但又不影响程序的继续运行，或者是暂时影响，但后续会恢复。像这些日志，就需要你关注起来。 <code>Warn</code> 更多的是业务级别的警告日志。</p>
<p><strong>4.  Error 级别</strong></p>
<p><code>Error</code> 级别的日志告诉我们程序执行出错，这些错误肯定会影响到程序的执行结果，例如请求失败、创建资源失败等。要记录每一个发生错误的日志，避免日后排障过程中这些错误被忽略掉。大部分的错误可以归在 <code>Error</code> 级别。</p>
<p><strong>5.  Panic 级别</strong></p>
<p>Panic级别的日志在实际开发中很少用，通常只在需要错误堆栈，或者不想因为发生严重错误导致程序退出，而采用defer处理错误时使用。</p>
<p><strong>6.  Fatal 级别</strong></p>
<p><code>Fatal</code> 是最高级别的日志，这个级别的日志说明问题已经相当严重，严重到程序无法继续运行，通常是系统级的错误。在开发中也很少使用，除非我们觉得某个错误发生时，整个程序无法继续运行。</p>
<p>这里用一张图来总结下，如何选择Debug、Info、Warn、Error、Panic、Fatal这几种日志级别。</p>
<p><a href="https://static001.geekbang.org/resource/image/75/35/75e8c71a791f279a68c35734f2451035.png"><img src="https://static001.geekbang.org/resource/image/75/35/75e8c71a791f279a68c35734f2451035.png"></a></p>
<h3 id="如何记录日志内容？"><a href="#如何记录日志内容？" class="headerlink" title="如何记录日志内容？"></a>如何记录日志内容？</h3><p><strong>关于如何记录日志内容，我有几条建议：</strong></p>
<ul>
<li>在记录日志时，不要输出一些<code>敏感信息</code>，<strong>例如</strong>  <code>密码</code>、<code>密钥</code>等。</li>
<li>为了方便调试，通常会在 <code>Debug</code> 级别记录一些<code>临时日志</code>，这些日志内容可以用一些<code>特殊的字符</code>开头，<strong>例如</strong> <code>log.Debugf(&quot;XXXXXXXXXXXX-1:Input key was: %s&quot;, setKeyName)</code> 。这样，在完成调试后，可以通过查找 <code>XXXXXXXXXXXX</code> 字符串，找到这些临时日志，在 <code>commit</code> 前删除。</li>
<li>日志内容应该<code>小写字母</code>开头，以英文点号 <code>.</code> 结尾，<strong>例如</strong> <code>log.Info(&quot;update user function called.&quot;)</code> 。</li>
<li>为了<code>提高性</code>能，尽可能使用<code>明确的类型</code>，<strong>例如</strong>使用 <code>log.Warnf(&quot;init datastore: %s&quot;, err.Error())</code> 而非 <code>log.Warnf(&quot;init datastore: %v&quot;, err)</code> 。</li>
<li>根据需要，日志最好包含<code>两个</code>信息。一个是<code>请求ID</code>（<code>RequestID</code>），是每次请求的<code>唯一ID</code>，便于从海量日志中<code>过滤</code>出<code>某次请求</code>的日志，可以将<code>请求ID</code>放在请求的<code>通用日志字段</code>中。另一个是<code>用户</code>和<code>行为</code>，用于<code>标识谁做了什么</code>。</li>
<li>不要将 日志 <code>记录</code> 在 <code>错误的日志级别</code>上。<strong>例如</strong>，我在项目开发中，经常会发现有同事将<code>正常</code>的日志信息 打印在 <code>Error</code> 级别，将 <code>错误的</code> 日志信息 打印在 <code>Info</code> 级别。</li>
</ul>
<h3 id="记录日志的“最佳”实践总结"><a href="#记录日志的“最佳”实践总结" class="headerlink" title="记录日志的“最佳”实践总结"></a>记录日志的“最佳”实践总结</h3><p>关于日志记录问题，我从以上<code>三</code>个层面给你讲解了。</p>
<p><em><strong>综合来说，对于日志记录的最佳实践，你在平时都可以注意或进行尝试，我把这些重点放在这里，方便你后续查阅。</strong></em></p>
<ul>
<li><code>开发调试</code>、<code>现网故障</code> <code>排障</code>时，不要遗忘一件事情：根据排障的过程<code>优化日志打印</code>。好的日志，可能不是一次就可以写好的，可以在<code>实际开发</code>测试，还有<code>现网定位</code>问题时，不断优化。但这需要你重视日志，而不是把日志仅仅当成记录信息的一种方式，甚至不知道为什么打印一条 <code>Info</code> 日志。</li>
<li>打印日志要“<code>不多不少</code>”，避免打印没有作用的日志，也不要遗漏关键的日志信息。最好的信息是，仅凭借这些关键的日志就能定位到问题。</li>
<li>支持动态日志输出，方便线上问题定位。</li>
<li>总是将日志记录在本地文件：通过将日志记录在本地文件，可以和日志中心化平台进行解耦，这样当网络不可用，或者日志中心化平台故障时，仍然能够正常的记录日志。</li>
<li>集中化日志存储处理：因为应用可能包含<code>多个服务</code>，<code>一个服务</code>包含<code>多个实例</code>，为了查看日志方便，最好将这些日志统一存储在<code>同一个日志平台</code>上，例如 <code>Elasticsearch</code> ，方便<code>集中管理</code>和<code>查看日志</code>。</li>
<li>结构化日志记录：添加一些默认通用的字段到<code>每行日志</code>，方便日志<code>查询</code>和<code>分析</code>。</li>
<li>支持<code>RequestID</code>：使用<code>RequestID</code>串联一次请求的所有日志，这些日志可能分布在不同的组件，不同的机器上。支持<code>RequestID</code>可以大大提高排障的效率，降低排障难度。在一些大型<code>分布式系统</code>中，没有<code>RequestID</code>排障简直就是<code>灾难</code>。</li>
<li>支持动态开关 <code>Debug</code> 日志：对于定位一些隐藏得比较深的问题，可能需要更多的信息，这时候可能需要打印 <code>Debug</code> 日志。但现网的日志级别会设置为 <code>Info</code> 级别，为了获取 <code>Debug</code> 日志，我们可能会修改日志级别为 <code>Debug</code> 级别并重启服务，定位完问题后，再修改日志级别为 <code>Info</code> 级别，然后再<code>重启服务</code>，这种方式不仅麻烦而且还可能会对现网业务造成影响，最好的办法是能够在请求中通过 <code>debug=true</code> 这类参数<code>动态控制</code>某次请求是否开启<code>Debug</code>日志。</li>
</ul>
<h2 id="拓展内容：分布式日志解决方案（EFK-x2F-ELK）"><a href="#拓展内容：分布式日志解决方案（EFK-x2F-ELK）" class="headerlink" title="拓展内容：分布式日志解决方案（EFK&#x2F;ELK）"></a>拓展内容：分布式日志解决方案（EFK&#x2F;ELK）</h2><p>前面我们介绍了设计日志包和记录日志的规范，除此之外，还有一个问题你应该了解，那就是：我们记录的日志如何收集、处理和展示。</p>
<p>在实际<code>Go</code>项目开发中，为了实现高可用，同一个服务至少需要部署两个实例，通过<code>轮询</code>的<code>负载均衡策略</code>转发请求。</p>
<p>另外，一个应用又可能包含多个服务。假设我们的应用包含<code>两个服务</code>，每个服务部署<code>两个实例</code>，如果应用出故障，我们可能需要登陆 <code>4</code>（<code>2 x 2</code>）台服务器查看本地的日志文件，定位问题，非常麻烦，会增加故障恢复时间。</p>
<p>所以在真实的企业场景中，我们会将这些日志统一收集并展示。</p>
<p>在业界，日志的<code>收集</code>、<code>处理</code>和<code>展示</code>，早已经有了一套十分流行的日志解决方案： <code>EFK</code> （<code>Elasticsearch</code> + <code>Filebeat</code> + <code>Kibana</code>）或者<code>ELK</code>（<code>Elasticsearch</code> + <code>Logstash</code> + <code>Kibana</code>），<code>EFK</code>可以理解为<code>ELK</code>的演进版，把日志收集组件从<code>Logstash</code>替换成了<code>Filebeat</code>。</p>
<p>用 <code>Filebeat</code> 替换 <code>Logstash</code> ，主要原因是 <code>Filebeat</code> 更轻量级，占用的<code>资源</code>更少。</p>
<p>关于日志处理架构，你可以参考这张图。</p>
<p><a href="https://static001.geekbang.org/resource/image/5d/c8/5daabdfea213c05fc0387aa735e54ec8.png"><img src="https://static001.geekbang.org/resource/image/5d/c8/5daabdfea213c05fc0387aa735e54ec8.png"></a></p>
<p>通过 <code>log</code> 包将日志 <code>记录</code> 在 <code>本地文件</code> 中（<code>*.log</code>文件），再通过 <code>Shipper</code> 收集到 <code>Kafka</code> 中。</p>
<p><code>Shipper</code> 可以根据需要灵活选择，常见的 <code>Shipper</code> 有 <code>Logstash Shipper</code> 、 <code>Flume</code> 、 <code>Fluentd</code> 、 <code>Filebeat</code> 。</p>
<p>其中 <code>ilebeat</code> 和<code>Logstash Shipper</code>用得最多。</p>
<p><code>Shipper</code> 没有直接将日志投递到 <code>Logstash indexer</code>，或者 <code>Elasticsearch</code>，是因为 <code>Kafka</code> 能够支持更大的<code>吞吐量</code>，起到<code>削峰填谷</code>的作用。</p>
<p><code>Kafka</code> 中的日志消息会被 <code>Logstash indexer</code> 消费，处理后投递到 <code>Elasticsearch</code> 中存储起来。</p>
<p><code>Elasticsearch</code> 是 实时全文 <code>搜索</code>和<code>分析</code>引擎，提供<code>搜集</code>、<code>分析</code>、<code>存储数据</code>三大功能。</p>
<p><code>Elasticsearch</code> 中存储的日志，可以通过 <code>Kibana</code> 提供的<code>图形界面</code>来展示。</p>
<p><code>Kibana</code> 是一个基于 <code>Web</code> 的图形界面，用于<code>搜索</code>、<code>分析</code>和<code>可视化</code>存储在 <code>Elasticsearch</code> 中的日志数据。</p>
<p><code>Logstash</code> 负责 <code>采集</code>、<code>转换</code>和<code>过滤</code>日志。它支持几乎任何<code>类型</code>的日志，包括<code>系统日志</code>、<code>错误日志</code>和<code>自定义应用程序</code>日志。<code>Logstash</code>又分为<code>Logstash Shipper</code>和 <code>Logstash indexer</code> 。其中，<code>Logstash Shipper</code>监控并收集日志，并将日志内容发送到 <code>Logstash indexer</code> ，然后 <code>Logstash indexer</code> 过滤日志，并将日志提交给 <code>Elasticsearch</code> 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录日志，是应用程序必备的功能。记录日志最大的作用是排障，如果想更好地排障，我们需要一个优秀的工具，日志包。那么如何设计日志包呢？首先我们需要知道日志包的功能，在我看来日志包需要具备以下功能：</p>
<ul>
<li><code>基础功能</code>：支持基本的日志信息、支持不同的日志级别、支持自定义配置、支持输出到标准输出和文件。</li>
<li><code>高级功能</code>：支持多种日志格式、能够按级别分类输出、支持结构化日志、支持日志轮转、具备Hook能力。</li>
<li><code>可选功能</code>：支持颜色输出、兼容标准库log包、支持输出到不同的位置。</li>
</ul>
<p>另外，一个日志包还需要支持不同级别的日志，按日志级别优先级从<code>低</code>到<code>高</code>分别是： <code>Trace</code> &lt; <code>Debug</code> &lt; <code>Info</code> &lt; <code>Warn/Warning</code> &lt; <code>Error</code> &lt; <code>Panic</code> &lt; <code>Fatal</code>。</p>
<p>其中 <code>Debug</code> 、 <code>Info</code> 、 <code>Warn</code> 、 <code>Error</code> 、 <code>Fatal</code> 是比较基础的级别，建议在开发一个日志包时包含这些级别。 <code>Trace</code> 、 <code>Panic</code> 是可选的级别。</p>
<p>在我们掌握了日志包的功能之后，就可以设计、开发日志包了。但我们在开发过程中，还需要确保我们的日志包具有比较<code>高的性能</code>、<code>并发安全</code>、支持<code>插件化</code>的能力，并支持<code>日志参数</code>控制。</p>
<p>有了日志包，我们还需要知道如何更好地使用日志包，也就是如何记录日志。在文中，我给出了一些记录建议，内容比较多，你可以返回文中查看。</p>
<p>最后，我还给出了分布式日志解决方案：<code>EFK/ELK</code>。 <code>EFK</code> 是 <code>ELK</code> 的升级版，在实际项目开发中，我们可以直接选择 <code>EFK</code>。在<code>EFK</code>方案中，通过<code>Filebeat</code>将日志上传到 <code>Kafka</code> ，<code>Logstash indexer</code>消费 <code>Kafka</code> 中的日志，并投递到 <code>Elasticsearch</code> 中存储起来，最后通过 <code>Kibana</code> 图形界面来查看日志。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>15 | 应用构建：Pflag、Viper、Cobra 核心功能</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-15-pflag-viper-cobra.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>这一讲我们来聊聊构建应用时常用的 <code>Go</code> 包。</p>
<p>因为 <code>IAM</code> 项目使用了 <code>Pflag</code>、<code>Viper</code> 和 <code>Cobra</code> 包来构建 <code>IAM</code> 的应用框架，为了让你后面学习更加容易，这里简单介绍下这 <code>3</code> 个包的核心功能和使用方式。其实如果单独讲每个包的话，还是有很多功能可讲的，但我们这一讲的目的是减小你后面学习 <code>IAM</code> 源码的难度，所以我会主要介绍跟 <code>IAM</code> 相关的功能。</p>
<p>在正式介绍这三个包之前，我们先来看下如何构建应用的框架。</p>
<span id="more"></span>
<h2 id="如何构建应用框架"><a href="#如何构建应用框架" class="headerlink" title="如何构建应用框架"></a>如何构建应用框架</h2><p>想知道如何构建应用框架，首先你要明白，一个应用框架包含哪些部分。在我看来，一个应用框架需要包含以下 <code>3</code> 个部分：</p>
<p><code>命令行参数解析</code>：主要用来解析命令行参数，这些命令行参数可以影响命令的运行效果。</p>
<p><code>配置文件解析</code>：一个大型应用，通常具有很多参数，为了便于管理和配置这些参数，通常会将这些参数放在一个配置文件中，供程序读取并解析。</p>
<p><code>应用的命令行框架</code>：应用最终是通过命令来启动的。这里有 <code>3</code> 个需求点，<code>一</code>是命令需要具备 <code>Help</code> 功能，这样才能告诉使用者如何去使用；<code>二</code>是命令需要能够解析命令行参数和配置文件；<code>三</code>是命令需要能够初始化业务代码，并最终启动业务进程。也就是说，我们的命令需要具备框架的能力，来纳管这 <code>3</code> 个部分。</p>
<p>这 <code>3</code> 个部分的功能，你可以自己开发，也可以借助业界已有的成熟实现。跟之前的想法一样，我不建议你自己开发，更建议你采用业界已有的成熟实现。命令行参数可以通过 <code>Flag</code> 来解析，配置文件可以通过 <code>Viper</code> 来解析，应用的命令行框架则可以通过<code>Cobra</code>来实现。这 <code>3</code> 个包目前也是最受欢迎的包，并且这 <code>3</code> 个包不是割裂的，而是有联系的，我们可以有机地组合这 <code>3</code> 个包，从而实现一个非常强大、优秀的应用命令行框架。</p>
<h2 id="命令行参数解析工具：Pflag-使用介绍"><a href="#命令行参数解析工具：Pflag-使用介绍" class="headerlink" title="命令行参数解析工具：Pflag 使用介绍"></a>命令行参数解析工具：Pflag 使用介绍</h2><p>Go 服务开发中，经常需要给开发的组件加上各种启动参数来配置服务进程，影响服务的行为。像 <code>kube-apiserver</code> 就有多达 <code>200</code> 多个启动参数，而且这些参数的类型各不相同（例如：<code>string</code>、<code>int</code>、<code>ip</code> 类型等），使用方式也不相同（例如：需要支持–长选项，-短选项等），所以我们需要一个强大的命令行参数解析工具。</p>
<p>虽然 Go 源码中提供了一个标准库 <code>Flag</code> 包，用来对命令行参数进行解析，但在大型项目中应用更广泛的是另外一个包：<code>Pflag</code>。<code>Pflag</code> 提供了很多强大的特性，非常适合用来构建大型项目，一些耳熟能详的开源项目都是用 <code>Pflag</code> 来进行命令行参数解析的，例如：<code>Kubernetes</code>、<code>Istio</code>、<code>Helm</code>、<code>Docker</code>、<code>Etcd</code> 等。</p>
<p>接下来，我们就来介绍下如何使用 <code>Pflag</code>。<code>Pflag</code> 主要是通过创建 <code>Flag</code> 和 <code>FlagSet</code> 来使用的。我们先来看下 <code>Flag</code>。</p>
<h3 id="Pflag-包-Flag-定义"><a href="#Pflag-包-Flag-定义" class="headerlink" title="Pflag 包 Flag 定义"></a>Pflag 包 Flag 定义</h3><p><code>Pflag</code> 可以对命令行参数进行处理，一个命令行参数在 <code>Pflag</code> 包中会解析为一个 <code>Flag</code> 类型的变量。<code>Flag</code> 是一个结构体，定义如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Flag <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span> <span class="token comment">// flag长选项的名称</span>

	Shorthand <span class="token builtin">string</span> <span class="token comment">// flag短选项的名称，一个缩写的字符</span>

	Usage <span class="token builtin">string</span> <span class="token comment">// flag的使用文本</span>

	Value Value <span class="token comment">// flag的值</span>

	DefValue <span class="token builtin">string</span> <span class="token comment">// flag的默认值</span>

	Changed <span class="token builtin">bool</span> <span class="token comment">// 记录flag的值是否有被设置过</span>

	NoOptDefVal <span class="token builtin">string</span> <span class="token comment">// 当flag出现在命令行，但是没有指定选项值时的默认值</span>

	Deprecated <span class="token builtin">string</span> <span class="token comment">// 记录该flag是否被放弃</span>

	Hidden <span class="token builtin">bool</span> <span class="token comment">// 如果值为true，则从help/usage输出信息中隐藏该flag</span>

	ShorthandDeprecated <span class="token builtin">string</span> <span class="token comment">// 如果flag的短选项被废弃，当使用flag的短选项时打印该信息</span>

	Annotations <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment">// 给flag设置注解</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Flag</code> 的值是一个 <code>Value</code> 类型的接口，<code>Value</code> 定义如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Value <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token comment">// 将flag类型的值转换为string类型的值，并返回string的内容</span>

	<span class="token function">Set</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token comment">// 将string类型的值转换为flag类型的值，转换失败报错</span>

	<span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token comment">// 返回flag的类型，例如：string、int、ip等</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过将 <code>Flag</code> 的值抽象成一个 <code>interface</code> 接口，我们就可以自定义 <code>Flag</code> 的类型了。只要实现了 <code>Value</code> 接口的结构体，就是一个新类型。</p>
<h3 id="Pflag-包-FlagSet-定义"><a href="#Pflag-包-FlagSet-定义" class="headerlink" title="Pflag 包 FlagSet 定义"></a>Pflag 包 FlagSet 定义</h3><p><code>Pflag</code> 除了支持单个的 <code>Flag</code> 之外，还支持 <code>FlagSet</code>。<code>FlagSet</code> 是一些预先定义好的 <code>Flag</code> 的集合，几乎所有的 <code>Pflag</code> 操作，都需要借助 <code>FlagSet</code> 提供的方法来完成。</p>
<p>在实际开发中，我们可以使用两种方法来获取并使用 <code>FlagSet</code>：</p>
<p><code>方法一</code>，调用 <code>NewFlagSet</code> 创建一个 <code>FlagSet</code>。</p>
<p><code>方法二</code>，使用 <code>Pflag</code> 包定义的全局 <code>FlagSet</code>：<code>CommandLine</code>。实际上 <code>CommandLine</code> 也是由 <code>NewFlagSet</code> 函数创建的。</p>
<p>先来看下<code>第一种方法</code>，<code>自定义 FlagSet</code>。下面是一个 <code>自定义 FlagSet</code> 的示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> version <span class="token builtin">bool</span>

flagSet <span class="token operator">:=</span> pflag<span class="token punctuation">.</span><span class="token function">NewFlagSet</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> pflag<span class="token punctuation">.</span>ContinueOnError<span class="token punctuation">)</span>

flagSet<span class="token punctuation">.</span><span class="token function">BoolVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>version<span class="token punctuation">,</span> <span class="token string">"version"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Print version information and quit."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们可以通过定义一个新的 <code>FlagSet</code> 来定义<code>命令</code>及其<code>子命令</code>的 <code>Flag</code>。</p>
<p>再来看下<code>第二种方法</code>，使用<code>全局 FlagSet</code>。下面是一个使用<code>全局 FlagSet</code> 的示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
<span class="token string">"github.com/spf13/pflag"</span>
<span class="token punctuation">)</span>

pflag<span class="token punctuation">.</span><span class="token function">BoolVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>version<span class="token punctuation">,</span> <span class="token string">"version"</span><span class="token punctuation">,</span> <span class="token string">"v"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Print version information and quit."</span><span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这其中，<code>pflag.BoolVarP</code> 函数定义如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BoolVarP</span><span class="token punctuation">(</span>p <span class="token operator">*</span><span class="token builtin">bool</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> shorthand <span class="token builtin">string</span><span class="token punctuation">,</span> value <span class="token builtin">bool</span><span class="token punctuation">,</span> usage <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	flag <span class="token operator">:=</span> CommandLine<span class="token punctuation">.</span><span class="token function">VarPF</span><span class="token punctuation">(</span><span class="token function">newBoolValue</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> shorthand<span class="token punctuation">,</span> usage<span class="token punctuation">)</span>
	flag<span class="token punctuation">.</span>NoOptDefVal <span class="token operator">=</span> <span class="token string">"true"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 <code>pflag.BoolVarP</code> 最终调用了 <code>CommandLine</code>，<code>CommandLine</code> 是一个<code>包级别</code>的变量，定义为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CommandLine is the default set of command-line flags, parsed from os.Args.</span>
<span class="token keyword">var</span> CommandLine <span class="token operator">=</span> <span class="token function">NewFlagSet</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ExitOnError<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在一些不需要定义<code>子命令</code>的<code>命令行工具</code>中，我们可以直接使用<code>全局的 FlagSet</code>，更加简单方便。</p>
<h3 id="Pflag-使用方法"><a href="#Pflag-使用方法" class="headerlink" title="Pflag 使用方法"></a>Pflag 使用方法</h3><p>上面，我们介绍了使用 <code>Pflag</code> 包的两个核心结构体。</p>
<p>接下来，我来详细介绍下 <code>Pflag</code> 的常见使用方法。</p>
<p><code>Pflag</code> 有很多强大的功能，我这里介绍 <code>7</code> 个常见的使用方法。</p>
<p><em><strong>支持<code>多种命令行参数定义</code>方式。</strong></em></p>
<p><code>Pflag</code> 支持以下 <code>4</code> 种 <code>命令行参数定义</code> 方式：</p>
<p>支持<code>长选项</code>、<code>默认值</code>和<code>使用文本</code>，并将标志的值<code>存储</code>在<code>指针</code>中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token operator">=</span> pflag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"colin"</span><span class="token punctuation">,</span> <span class="token string">"Input Your Name"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>支持<code>长选项</code>、<code>短选项</code>、<code>默认值</code>和<code>使用文本</code>，并将标志的值<code>存储</code>在<code>指针</code>中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token operator">=</span> pflag<span class="token punctuation">.</span><span class="token function">StringP</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token string">"colin"</span><span class="token punctuation">,</span> <span class="token string">"Input Your Name"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>支持<code>长选项</code>、<code>默认值</code>和<code>使用文本</code>，并将标志的值<code>绑定</code>到<code>变量</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span>

pflag<span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"colin"</span><span class="token punctuation">,</span> <span class="token string">"Input Your Name"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>支持<code>长选项</code>、<code>短选项</code>、<code>默认值</code>和<code>使用文本</code>，并将标志的值<code>绑定</code>到<code>变量</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span>

pflag<span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"n"</span><span class="token punctuation">,</span><span class="token string">"colin"</span><span class="token punctuation">,</span> <span class="token string">"Input Your Name"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的函数命名是有规则的：</p>
<p>函数名带<code>Var</code>说明是将标志的值绑定到变量，否则是将标志的值存储在<code>指针</code>中。</p>
<p>函数名带<code>P</code>说明支持<code>短选项</code>，否则不支持<code>短选项</code>。</p>
<p><em><strong>使用<code>Get</code>获取参数的值。</strong></em></p>
<p>可以使用Get来获取标志的值，代表 <code>Pflag</code> 所支持的类型。例如：有一个 <code>pflag.FlagSet</code>，带有一个名为 <code>flagname</code> 的 <code>int</code> 类型的标志，可以使用 <code>GetInt()</code> 来获取 <code>int</code> 值。需要注意 <code>flagname</code> 必须存在且必须是 <code>int</code>，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
i<span class="token punctuation">,</span> err <span class="token operator">:=</span> flagset<span class="token punctuation">.</span><span class="token function">GetInt</span><span class="token punctuation">(</span><span class="token string">"flagname"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong>获取非选项参数。</strong></em></p>
<p>代码示例如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/spf13/pflag"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	flagvar <span class="token operator">=</span> pflag<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"flagname"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">,</span> <span class="token string">"help message for flagname"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	pflag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"argument number is: %v\n"</span><span class="token punctuation">,</span> pflag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"argument list is: %v\n"</span><span class="token punctuation">,</span> pflag<span class="token punctuation">.</span><span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"the first argument is: %v\n"</span><span class="token punctuation">,</span> pflag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上述代码，输出如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ go run example1.go arg1 arg2

argument number is: <span class="token number">2</span>

argument list is: <span class="token punctuation">[</span>arg1 arg2<span class="token punctuation">]</span>

the first argument is: arg1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在定义完标志之后，可以调用<code>pflag.Parse()</code>来解析定义的标志。</p>
<p>解析后，可通过 <code>pflag.Args()</code> 返回所有的非选项参数，通过 <code>flag.Arg(i)</code> 返回第 <code>i</code> 个非选项参数。</p>
<p>参数下标 <code>0</code> 到 <code>pflag.NArg() – 1</code>。</p>
<p><em><strong>指定了选项但是没有指定选项值时的默认值。</strong></em></p>
<p>创建一个 <code>Flag</code> 后，可以为这个 <code>Flag</code> 设置 <code>pflag.NoOptDefVal</code> 。如果一个 <code>Flag</code> 具有 <code>NoOptDefVal</code>，并且该 <code>Flag</code> 在命令行上没有设置这个 <code>Flag</code> 的值，则该标志将设置为 <code>NoOptDefVal</code> 指定的值。<br>例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> ip <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">IntP</span><span class="token punctuation">(</span><span class="token string">"flagname"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">,</span> <span class="token string">"help message"</span><span class="token punctuation">)</span>

flag<span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"flagname"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>NoOptDefVal <span class="token operator">=</span> <span class="token string">"4321"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>弃用标志或者标志的简写。</strong></em></p>
<p><code>Pflag</code> 可以弃用标志或者标志的简写。弃用的标志或标志简写在帮助文本中会被隐藏，并在使用不推荐的标志或简写时打印正确的用法提示。例如，弃用名为 logmode 的标志，并告知用户应该使用哪个标志代替：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// deprecate a flag by specifying its name and a usage message</span>
pflag<span class="token punctuation">.</span>CommandLine<span class="token punctuation">.</span><span class="token function">MarkDeprecated</span><span class="token punctuation">(</span><span class="token string">"logmode"</span><span class="token punctuation">,</span> <span class="token string">"please use --log-mode instead"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这样隐藏了帮助文本中的 <code>logmode</code>，并且当使用 <code>logmode</code> 时，打印了 <code>Flag –logmode has been deprecated, please use –log-mode instead</code>。</p>
<p><em><strong>保留名为 <code>port</code> 的标志，但是弃用它的简写形式。</strong></em></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">pflag<span class="token punctuation">.</span><span class="token function">IntVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>port<span class="token punctuation">,</span> <span class="token string">"port"</span><span class="token punctuation">,</span> <span class="token string">"P"</span><span class="token punctuation">,</span> <span class="token number">3306</span><span class="token punctuation">,</span> <span class="token string">"MySQL service host port."</span><span class="token punctuation">)</span>
<span class="token comment">// deprecate a flag shorthand by specifying its flag name and a usage message</span>
pflag<span class="token punctuation">.</span>CommandLine<span class="token punctuation">.</span><span class="token function">MarkShorthandDeprecated</span><span class="token punctuation">(</span><span class="token string">"port"</span><span class="token punctuation">,</span> <span class="token string">"please use --port only"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这样隐藏了帮助文本中的简写 <code>P</code>，并且当使用简写 <code>P</code> 时，打印了<code>Flag shorthand -P has been deprecated, please use –port only</code>。<code>usage message</code> 在此处必不可少，并且不应为空。</p>
<p><em><strong>隐藏标志。</strong></em></p>
<p>可以将 <code>Flag</code> 标记为隐藏的，这意味着它仍将正常运行，但不会显示在 <code>usage/help</code> 文本中。例如：隐藏名为 <code>secretFlag</code> 的标志，只在内部使用，并且不希望它显示在帮助文本或者使用文本中。代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// hide a flag by specifying its name</span>
pflag<span class="token punctuation">.</span>CommandLine<span class="token punctuation">.</span><span class="token function">MarkHidden</span><span class="token punctuation">(</span><span class="token string">"secretFlag"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>




<h2 id="配置解析神器：Viper-使用介绍"><a href="#配置解析神器：Viper-使用介绍" class="headerlink" title="配置解析神器：Viper 使用介绍"></a>配置解析神器：Viper 使用介绍</h2><p>几乎所有的后端服务，都需要一些配置项来配置我们的服务，一些小型的项目，配置不是很多，可以选择只通过命令行参数来传递配置。但是大型项目配置很多，通过命令行参数传递就变得很麻烦，不好维护。标准的解决方案是将这些配置信息保存在配置文件中，由程序启动时加载和解析。<code>Go</code> 生态中有很多包可以加载并解析配置文件，目前最受欢迎的是 <code>Viper</code> 包。</p>
<p><code>Viper</code> 是 <code>Go</code> 应用程序现代化的、完整的解决方案，能够处理不同格式的配置文件，让我们在构建现代应用程序时，不必担心配置文件格式。<code>Viper</code> 也能够满足我们对应用配置的各种需求。</p>
<p><code>Viper</code> 可以从不同的位置读取配置，不同位置的配置具有不同的优先级，高优先级的配置会覆盖低优先级相同的配置，按优先级从高到低排列如下：</p>
<p>通过 <code>viper.Set</code> 函数显示设置的配置</p>
<p><code>命令行参数</code></p>
<p><code>环境变量</code></p>
<p><code>配置文件</code></p>
<p><code>Key/Value 存储</code></p>
<p><code>默认值</code></p>
<p>这里需要注意，<code>Viper</code> 配置键<code>不区分大小写</code>。</p>
<p><code>Viper</code> 有很多功能，最重要的两类功能是读入配置和读取配置，<code>Viper</code> 提供不同的方式来实现这两类功能。接下来，我们就来详细介绍下 <code>Viper</code> 如何读入配置和读取配置。</p>
<h3 id="读入配置"><a href="#读入配置" class="headerlink" title="读入配置"></a>读入配置</h3><p>读入配置，就是将配置读入到 <code>Viper</code> 中，有如下读入方式：<br><code>设置默认的配置文件名</code>,<code>读取配置文件</code>,<code>监听和重新读取配置文件</code>,<code>从 io.Reader 读取配置</code>,<code>从环境变量读取</code>,<code>从命令行标志读取</code>,<code>从远程 Key/Value 存储读取</code></p>
<p>这几个方法的具体读入方式，你可以看下面的展示。</p>
<p><em><strong>1. 设置默认值</strong></em></p>
<p>一个好的配置系统应该支持<code>默认值</code>。<code>Viper</code> 支持对 <code>key</code> 设置默认值，当没有通过<code>配置文件</code>、<code>环境变量</code>、<code>远程配置</code>或<code>命令行标志</code>设置 <code>key</code> 时，设置默认值通常是很有用的，可以让程序在没有明确指定配置时也能够正常运行。例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
viper<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"ContentDir"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">)</span>

viper<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"LayoutDir"</span><span class="token punctuation">,</span> <span class="token string">"layouts"</span><span class="token punctuation">)</span>

viper<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"Taxonomies"</span><span class="token punctuation">,</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"tag"</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">,</span> <span class="token string">"category"</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>2. 读取配置文件</strong></em></p>
<p><code>Viper</code> 可以读取配置文件来解析配置，支持 <code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>YML</code>、<code>Properties</code>、<code>Props</code>、<code>Prop</code>、<code>HCL</code>、<code>Dotenv</code>、<code>Env</code> 格式的配置文件。</p>
<p><code>Viper</code> 支持搜索多个路径，并且默认不配置任何搜索路径，将默认决策留给应用程序。</p>
<p>以下是如何使用 <code>Viper</code> 搜索和读取配置文件的示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/spf13/pflag"</span>
	<span class="token string">"github.com/spf13/viper"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	cfg <span class="token operator">=</span> pflag<span class="token punctuation">.</span><span class="token function">StringP</span><span class="token punctuation">(</span><span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"Configuration file."</span><span class="token punctuation">)</span>

	help <span class="token operator">=</span> pflag<span class="token punctuation">.</span><span class="token function">BoolP</span><span class="token punctuation">(</span><span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"Show this help message."</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	pflag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token operator">*</span>help <span class="token punctuation">&#123;</span>

		pflag<span class="token punctuation">.</span><span class="token function">Usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 从配置文件中读取配置</span>

	<span class="token keyword">if</span> <span class="token operator">*</span>cfg <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigFile</span><span class="token punctuation">(</span><span class="token operator">*</span>cfg<span class="token punctuation">)</span> <span class="token comment">// 指定配置文件名</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigType</span><span class="token punctuation">(</span><span class="token string">"yaml"</span><span class="token punctuation">)</span> <span class="token comment">// 如果配置文件名中没有文件扩展名，则需要指定配置文件的格式，告诉viper以何种格式解析文件</span>

	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

		viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token comment">// 把当前目录加入到配置文件的搜索路径中</span>

		viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span><span class="token string">"$HOME/.iam"</span><span class="token punctuation">)</span> <span class="token comment">// 配置文件搜索路径，可以设置多个配置文件搜索路径</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigName</span><span class="token punctuation">(</span><span class="token string">"config"</span><span class="token punctuation">)</span> <span class="token comment">// 配置文件名称（没有文件扩展名）</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">ReadInConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 读取配置文件。如果指定了配置文件名，则使用指定的配置文件，否则在注册的搜索路径中搜索</span>

		<span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Fatal error config file: %s \n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Used configuration file is: %s\n"</span><span class="token punctuation">,</span> viper<span class="token punctuation">.</span><span class="token function">ConfigFileUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Viper</code> 支持设置多个配置文件搜索路径，需要注意添加搜索路径的顺序，<code>Viper</code> 会根据添加的路径顺序搜索配置文件，如果找到则停止搜索。如果调用 <code>SetConfigFile</code> 直接指定了配置文件名，并且配置文件名没有文件扩展名时，需要显式指定配置文件的格式，以使 <code>Viper</code> 能够正确解析配置文件。</p>
<p>如果通过搜索的方式查找配置文件，则需要注意，SetConfigName 设置的配置文件名是不带扩展名的，在搜索时 <code>Viper</code> 会在文件名之后追加文件扩展名，并尝试搜索所有支持的扩展类型。</p>
<p><em><strong>3. 监听和重新读取配置文件。</strong></em></p>
<p><code>Viper</code> 支持在运行时让应用程序实时读取配置文件，也就是热加载配置。可以通过 <code>WatchConfig</code> 函数热加载配置。在调用 <code>WatchConfig</code> 函数之前，需要确保已经添加了配置文件的搜索路径。</p>
<p>另外，还可以为 <code>Viper</code> 提供一个回调函数，以便在每次发生更改时运行。这里我也给你个示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
viper<span class="token punctuation">.</span><span class="token function">WatchConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

viper<span class="token punctuation">.</span><span class="token function">OnConfigChange</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>e fsnotify<span class="token punctuation">.</span>Event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// 配置文件发生变更之后会调用的回调函数</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Config file changed:"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我不建议在实际开发中使用热加载功能，因为即使配置热加载了，程序中的代码也不一定会热加载。例如：修改了服务监听端口，但是服务没有重启，这时候服务还是监听在老的端口上，会造成不一致。</p>
<p><em><strong>4.  设置配置值。</strong></em></p>
<p>我们可以通过 <code>viper.Set()</code> 函数来显式设置配置：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">viper<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"user.username"</span><span class="token punctuation">,</span> <span class="token string">"colin"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>5. 使用环境变量。</strong></em></p>
<p><code>Viper</code> 还支持环境变量，通过如下 <code>5</code> 个函数来支持环境变量：</p>
<p><code>AutomaticEnv()</code></p>
<p><code>BindEnv(input …string) error</code></p>
<p><code>SetEnvPrefix(in string)</code></p>
<p><code>SetEnvKeyReplacer(r *strings.Replacer)</code></p>
<p><code>AllowEmptyEnv(allowEmptyEnv bool)</code></p>
<p>这里要注意：<code>Viper</code> 读取环境变量是区分大小写的。<code>Viper</code> 提供了一种机制来确保 <code>Env</code> 变量是唯一的。</p>
<p>通过使用 <code>SetEnvPrefix</code> ，可以告诉 <code>Viper</code> 在读取环境变量时使用前缀。</p>
<p><code>BindEnv</code> 和 <code>AutomaticEnv</code> 都将使用此前缀。</p>
<p>比如，我们设置了 <code>viper.SetEnvPrefix(&quot;VIPER&quot;)</code>，当使用 <code>viper.Get(&quot;apiversion&quot;)</code> 时，实际读取的环境变量是 <code>VIPER_APIVERSION</code> 。</p>
<p><code>BindEnv</code> 需要<code>一个</code>或<code>两个</code>参数。第一个参数是<code>键名</code>，第二个是<code>环境变量的名称</code>，环境变量的名称区分大小写。如果未提供 <code>Env</code> 变量名，则 <code>Viper</code> 将假定 <code>Env</code> 变量名为：环境变量<code>前缀_键名</code>全大写。例如：前缀为 <code>VIPER</code>，<code>key</code> 为 <code>username</code>，则 <code>Env</code> <code>变量名为VIPER_USERNAME</code> 。</p>
<p>当显示提供 <code>Env</code> 变量名（第二个参数）时，它不会自动添加前缀。例如，如果第二个参数是 <code>ID</code>，<code>Viper</code> 将查找环境变量 <code>ID</code>。</p>
<p>在使用 <code>Env</code> 变量时，需要注意的一件重要事情是：每次访问该值时都将读取它。<code>Viper</code> 在调用 <code>BindEnv</code> 时不固定该值。</p>
<p>还有一个魔法函数 <code>SetEnvKeyReplacer</code>，<code>SetEnvKeyReplacer</code> 允许你使用 <code>strings.Replacer</code> 对象来重写 <code>Env</code> 键。</p>
<p>如果你想在 <code>Get()</code> 调用中使用 <code>-</code> 或者 <code>.</code> ，但希望你的环境变量使用 <code>_</code> 分隔符，可以通过 <code>SetEnvKeyReplacer</code> 来实现。</p>
<p>比如，我们设置了环境变量 <code>USER_SECRET_KEY = bVix2WBv0VPfrDrvlLWrhEdzjLpPCNYb</code> ，但我们想用<code>viper.Get(“user.secret-key”)</code>，那我们就调用函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">viper<span class="token punctuation">.</span><span class="token function">SetEnvKeyReplacer</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReplacer</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的代码，在调用 <code>viper.Get()</code> 函数时，会用 <code>_</code> 替换 <code>.</code> 和 <code>-</code> 。</p>
<p>默认情况下，空环境变量被认为是未设置的，并将返回到下一个配置源。若要将空环境变量视为已设置，可以使用 <code>AllowEmptyEnv</code> 方法。</p>
<p>使用环境变量示例如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 使用环境变量</span>
os<span class="token punctuation">.</span><span class="token function">Setenv</span><span class="token punctuation">(</span><span class="token string">"VIPER_USER_SECRET_ID"</span><span class="token punctuation">,</span> <span class="token string">"QLdywI2MrmDVjSSv6e95weNRvmteRjfKAuNV"</span><span class="token punctuation">)</span>
os<span class="token punctuation">.</span><span class="token function">Setenv</span><span class="token punctuation">(</span><span class="token string">"VIPER_USER_SECRET_KEY"</span><span class="token punctuation">,</span> <span class="token string">"bVix2WBv0VPfrDrvlLWrhEdzjLpPCNYb"</span><span class="token punctuation">)</span>

viper<span class="token punctuation">.</span><span class="token function">AutomaticEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 读取环境变量</span>
viper<span class="token punctuation">.</span><span class="token function">SetEnvPrefix</span><span class="token punctuation">(</span><span class="token string">"VIPER"</span><span class="token punctuation">)</span> <span class="token comment">// 设置环境变量前缀：VIPER_，如果是viper，将自动转变为大写。</span>
viper<span class="token punctuation">.</span><span class="token function">SetEnvKeyReplacer</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReplacer</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 将viper.Get(key) key字符串中'.'和'-'替换为'_'</span>
viper<span class="token punctuation">.</span><span class="token function">BindEnv</span><span class="token punctuation">(</span><span class="token string">"user.secret-key"</span><span class="token punctuation">)</span>
viper<span class="token punctuation">.</span><span class="token function">BindEnv</span><span class="token punctuation">(</span><span class="token string">"user.secret-id"</span><span class="token punctuation">,</span> <span class="token string">"USER_SECRET_ID"</span><span class="token punctuation">)</span> <span class="token comment">// 绑定环境变量名到key</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>6. 使用标志。</strong></em></p>
<p><code>Viper</code> 支持 <code>Pflag</code> 包，能够绑定 <code>key</code> 到 <code>Flag</code>。与 <code>BindEnv</code> 类似，在调用绑定方法时，不会设置该值，但在访问它时会设置。对于单个标志，可以调用 <code>BindPFlag()</code> 进行绑定：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
viper<span class="token punctuation">.</span><span class="token function">BindPFlag</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">,</span> pflag<span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 绑定单个标志</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>还可以绑定一组现有的 <code>pflags（pflag.FlagSet）</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">viper<span class="token punctuation">.</span><span class="token function">BindPFlags</span><span class="token punctuation">(</span>pflag<span class="token punctuation">.</span>CommandLine<span class="token punctuation">)</span> <span class="token comment">//绑定标志集</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p><code>Viper</code> 提供了如下方法来读取配置：</p>
<p><code>Get(key string) interface&#123;&#125;</code></p>
<p><code>Get(key string)</code></p>
<p><code>AllSettings() map[string]interface&#123;&#125;</code></p>
<p><code>IsSet(key string) : bool</code></p>
<p>每一个 <code>Get</code> 方法在找不到值的时候都会返回<code>零</code>值。</p>
<p>为了检查给定的键<code>是否存在</code>，可以使用 <code>IsSet()</code> 方法。</p>
<p>可以是 <code>Viper</code> 支持的类型，首字母大写：<code>Bool</code>、<code>Float64</code>、<code>Int</code>、<code>IntSlice</code>、<code>String</code>、<code>StringMap</code>、<code>StringMapString</code>、<code>StringSlice</code>、<code>Time</code>、<code>Duration</code>。例如：<code>GetInt()</code>。</p>
<p>常见的读取配置方法有以下几种。</p>
<p><em><strong>1. 访问嵌套的键。</strong></em></p>
<p>例如，加载下面的 JSON 文件：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">
<span class="token punctuation">&#123;</span>

	<span class="token property">"host"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
	<span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>
	<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">5799</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token property">"datastore"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token property">"metric"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>
			<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">3099</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		<span class="token property">"warehouse"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"198.0.0.1"</span><span class="token punctuation">,</span>
			<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">2112</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Viper</code> 可以通过传入<code>.</code>分隔的路径来访问嵌套字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
viper<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span><span class="token string">"datastore.metric.host"</span><span class="token punctuation">)</span> <span class="token comment">// (返回 "127.0.0.1")</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果<code>datastore.metric</code>被直接赋值覆盖（被 <code>Flag</code>、<code>环境变量</code>、<code>set()</code> 方法等等），那么<code>datastore.metric</code>的所有子键都将变为<code>未定义状态</code>，它们被<code>高优先级配置级别</code>覆盖了。</p>
<p>如果存在与<code>分隔的键路径</code>匹配的键，则直接返回其值。例如：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">
<span class="token punctuation">&#123;</span>
	<span class="token property">"datastore.metric.host"</span><span class="token operator">:</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span>
	<span class="token property">"host"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>
		<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">5799</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token property">"datastore"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token property">"metric"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>
			<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">3099</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		<span class="token property">"warehouse"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"198.0.0.1"</span><span class="token punctuation">,</span>
			<span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">2112</span>

		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过 <code>viper.GetString</code> 获取值：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">viper<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span><span class="token string">"datastore.metric.host"</span><span class="token punctuation">)</span> <span class="token comment">// 返回 "0.0.0.0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>2. 反序列化。</strong></em></p>
<p><code>Viper</code> 可以支持将所有或特定的值解析到<code>结构体</code>、<code>map</code> 等。</p>
<p>可以通过两个函数来实现：<br><code>Unmarshal(rawVal interface&#123;&#125;) error</code><br><code>UnmarshalKey(key string, rawVal interface&#123;&#125;) error</code></p>
<p>一个示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> config <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Port <span class="token builtin">int</span>
	Name <span class="token builtin">string</span>
	PathMap <span class="token builtin">string</span> <span class="token string">`mapstructure:"path_map"`</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> C config

err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>C<span class="token punctuation">)</span>

<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	t<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"unable to decode into struct, %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想要解析那些键本身就包含<code>.</code>(默认的键分隔符）的配置，则需要修改分隔符：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">NewWithOptions</span><span class="token punctuation">(</span>viper<span class="token punctuation">.</span><span class="token function">KeyDelimiter</span><span class="token punctuation">(</span><span class="token string">"::"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
v<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"chart::values"</span><span class="token punctuation">,</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
		<span class="token string">"ingress"</span><span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
			<span class="token string">"annotations"</span><span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
				<span class="token string">"traefik.frontend.rule.type"</span><span class="token punctuation">:</span> <span class="token string">"PathPrefix"</span><span class="token punctuation">,</span>
				<span class="token string">"traefik.ingress.kubernetes.io/ssl-redirect"</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token punctuation">,</span>

			<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

 

<span class="token keyword">type</span> config <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Chart <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>
		Values <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

 

<span class="token keyword">var</span> C config
 

v<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>C<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Viper</code> 在后台使用 <code>github.com/mitchellh/mapstructure</code> 来解析值，其默认情况下使用 <code>mapstructure</code> <code>tags</code>。</p>
<p>当我们需要将 <code>Viper</code> 读取的配置反序列到我们定义的结构体变量中时，一定要使用 <code>mapstructure</code> <code>tags</code>。</p>
<p><em><strong>3. 序列化成字符串。</strong></em></p>
<p>有时候我们需要将 <code>Viper</code> 中保存的所有设置序列化到一个字符串中，而不是将它们写入到一个文件中，示例如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">import</span> <span class="token punctuation">(</span>

	yaml <span class="token string">"gopkg.in/yaml.v2"</span>
<span class="token comment">// ...</span>
<span class="token punctuation">)</span>

 

<span class="token keyword">func</span> <span class="token function">yamlStringSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>

	c <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">AllSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	bs<span class="token punctuation">,</span> err <span class="token operator">:=</span> yaml<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"unable to marshal config to YAML: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="现代化的命令行框架：Cobra-全解"><a href="#现代化的命令行框架：Cobra-全解" class="headerlink" title="现代化的命令行框架：Cobra 全解"></a>现代化的命令行框架：Cobra 全解</h2><p><code>Cobra</code> 既是一个可以创建强大的现代 <code>CLI</code> 应用程序的库，也是一个可以生成<code>应用</code>和<code>命令文件</code>的程序。</p>
<p>有许多大型项目都是用 <code>Cobra</code> 来构建应用程序的，例如 <code>Kubernetes</code>、<code>Docker</code>、<code>etcd</code>、<code>Rkt</code>、<code>Hugo</code>等。</p>
<p><code>Cobra</code> 建立在 <code>commands</code>、<code>arguments</code> 和 <code>flags</code> 结构之上。</p>
<p><code>commands</code> 代表命令，<code>arguments</code> 代表非选项参数，<code>flags</code> 代表选项参数（也叫标志）。</p>
<p>一个好的应用程序应该是易懂的，用户可以清晰地知道如何去使用这个应用程序。</p>
<p>应用程序通常遵循如下模式：<code>APPNAME VERB NOUN –ADJECTIVE</code> 或者 <code>APPNAME COMMAND ARG –FLAG</code>，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone URL <span class="token parameter variable">--bare</span> <span class="token comment"># clone 是一个命令，URL是一个非选项参数，bare是一个选项参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里，<code>VERB</code> 代表<code>动词</code>，<code>NOUN</code> 代码<code>名词</code>，<code>ADJECTIVE</code> 代表<code>形容词</code>。</p>
<p><code>Cobra</code> 提供了两种方式来创建命令：<code>Cobra 命令</code> 和  <code>Cobra 库</code>。</p>
<p><code>Cobra 命令</code> 可以生成一个 <code>Cobra 命令模板</code>，而 <code>命令模板</code> 也是通过引用 <code>Cobra 库</code>来构建命令的。</p>
<p>所以，这里我直接介绍如何使用 <code>Cobra 库</code>来创建命令。</p>
<h3 id="使用-Cobra-库创建命令"><a href="#使用-Cobra-库创建命令" class="headerlink" title="使用 Cobra 库创建命令"></a>使用 Cobra 库创建命令</h3><p>如果要用 <code>Cobra</code> 库编码实现一个应用程序，需要首先创建一个空的 <code>main.go</code> 文件和一个 <code>rootCmd</code> 文件，之后可以根据需要添加其他命令。具体步骤如下：</p>
<p><em><strong>1. 创建 rootCmd。</strong></em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> newApp2 <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> newApp2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通常情况下，我们会将 <code>rootCmd</code> 放在文件 <code>cmd/root.go</code> 中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> rootCmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">&#123;</span>
	Use<span class="token punctuation">:</span> <span class="token string">"hugo"</span><span class="token punctuation">,</span>

	Short<span class="token punctuation">:</span> <span class="token string">"Hugo is a very fast static site generator"</span><span class="token punctuation">,</span>

	Long<span class="token punctuation">:</span> <span class="token string">`A Fast and Flexible Static Site Generator built with

	love by spf13 and friends in Go.

	Complete documentation is available at http://hugo.spf13.com`</span><span class="token punctuation">,</span>

	Run<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// Do Stuff Here</span>

	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

 

<span class="token keyword">func</span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> rootCmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>

		os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以在 <code>init()</code> 函数中定义<code>标志</code>和<code>处理配置</code>，例如 <code>cmd/root.go</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"os"</span>

	homedir <span class="token string">"github.com/mitchellh/go-homedir"</span>
	<span class="token string">"github.com/spf13/cobra"</span>
	<span class="token string">"github.com/spf13/viper"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	cfgFile <span class="token builtin">string</span>

	projectBase <span class="token builtin">string</span>

	userLicense <span class="token builtin">string</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	cobra<span class="token punctuation">.</span><span class="token function">OnInitialize</span><span class="token punctuation">(</span>initConfig<span class="token punctuation">)</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfgFile<span class="token punctuation">,</span> <span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"config file (default is $HOME/.cobra.yaml)"</span><span class="token punctuation">)</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>projectBase<span class="token punctuation">,</span> <span class="token string">"projectbase"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"base project directory eg. github.com/spf13/"</span><span class="token punctuation">)</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringP</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"YOUR NAME"</span><span class="token punctuation">,</span> <span class="token string">"Author name for copyright attribution"</span><span class="token punctuation">)</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>userLicense<span class="token punctuation">,</span> <span class="token string">"license"</span><span class="token punctuation">,</span> <span class="token string">"l"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"Name of license for the project (can provide `licensetext` in config)"</span><span class="token punctuation">)</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token string">"viper"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Use Viper for configuration"</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">BindPFlag</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span> rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">BindPFlag</span><span class="token punctuation">(</span><span class="token string">"projectbase"</span><span class="token punctuation">,</span> rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"projectbase"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">BindPFlag</span><span class="token punctuation">(</span><span class="token string">"useViper"</span><span class="token punctuation">,</span> rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"viper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span> <span class="token string">"NAME HERE &lt;EMAIL ADDRESS>"</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">SetDefault</span><span class="token punctuation">(</span><span class="token string">"license"</span><span class="token punctuation">,</span> <span class="token string">"apache"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">initConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// Don't forget to read config either from cfgFile or from home directory!</span>

	<span class="token keyword">if</span> cfgFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// Use config file from the flag.</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigFile</span><span class="token punctuation">(</span>cfgFile<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// Find home directory.</span>

		home<span class="token punctuation">,</span> err <span class="token operator">:=</span> homedir<span class="token punctuation">.</span><span class="token function">Dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>

			os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		<span class="token comment">// Search config in home directory with name ".cobra" (without extension).</span>

		viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span>home<span class="token punctuation">)</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigName</span><span class="token punctuation">(</span><span class="token string">".cobra"</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">ReadInConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Can't read config:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>2. 创建 main.go。</strong></em></p>
<p>我们还需要一个 <code>main</code> 函数来调用 <code>rootCmd</code>，通常我们会创建一个 <code>main.go</code> 文件，在 <code>main.go</code> 中调用 <code>rootCmd.Execute()</code> 来执行命令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"&#123;pathToYourApp&#125;/cmd"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意，<code>main.go</code> 中不建议放很多代码，通常只需要调用 <code>cmd.Execute()</code> 即可。</p>
<p><em><strong>3. 添加命令。</strong></em></p>
<p>除了 <code>rootCmd</code>，我们还可以调用 <code>AddCommand</code> 添加其他命令，通常情况下，我们会把其他命令的源码文件放在 <code>cmd/</code> 目录下，例如，我们添加一个 <code>version</code> 命令，可以创建 <code>cmd/version.go</code> 文件，内容为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> cmd

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>

	<span class="token string">"github.com/spf13/cobra"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">AddCommand</span><span class="token punctuation">(</span>versionCmd<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> versionCmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">&#123;</span>

	Use<span class="token punctuation">:</span> <span class="token string">"version"</span><span class="token punctuation">,</span>

	Short<span class="token punctuation">:</span> <span class="token string">"Print the version number of Hugo"</span><span class="token punctuation">,</span>

	Long<span class="token punctuation">:</span> <span class="token string">`All software has versions. This is Hugo's`</span><span class="token punctuation">,</span>

	Run<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hugo Static Site Generator v0.9 -- HEAD"</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本示例中，我们通过调用<code>rootCmd.AddCommand(versionCmd)</code>给 <code>rootCmd</code> 命令添加了一个 <code>versionCmd</code> 命令。</p>
<p>编译并运行。</p>
<p>将 <code>main.go</code> 中 <code>&#123;pathToYourApp&#125;</code> 替换为对应的路径，例如本示例中 <code>pathToYourApp</code> 为<code>github.com/marmotedu/gopractise-demo/cobra/newApp2</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ go mod init github.com/marmotedu/gopractise-demo/cobra/newApp2

$ go build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span>

$ ./newApp2 <span class="token parameter variable">-h</span>

A Fast and Flexible Static Site Generator built with

love by spf13 and friends <span class="token keyword">in</span> Go.

Complete documentation is available at http://hugo.spf13.com

 

Usage:

hugo <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

hugo <span class="token punctuation">[</span>command<span class="token punctuation">]</span>

 

Available Commands:

<span class="token builtin class-name">help</span> Help about any <span class="token builtin class-name">command</span>

version Print the version number of Hugo

 

Flags:

-a, <span class="token parameter variable">--author</span> string Author name <span class="token keyword">for</span> copyright attribution <span class="token punctuation">(</span>default <span class="token string">"YOUR NAME"</span><span class="token punctuation">)</span>

<span class="token parameter variable">--config</span> string config <span class="token function">file</span> <span class="token punctuation">(</span>default is <span class="token environment constant">$HOME</span>/.cobra.yaml<span class="token punctuation">)</span>

-h, <span class="token parameter variable">--help</span> <span class="token builtin class-name">help</span> <span class="token keyword">for</span> hugo

-l, <span class="token parameter variable">--license</span> licensetext Name of license <span class="token keyword">for</span> the project <span class="token punctuation">(</span>can provide licensetext <span class="token keyword">in</span> config<span class="token punctuation">)</span>

-b, <span class="token parameter variable">--projectbase</span> string base project directory eg. github.com/spf13/

<span class="token parameter variable">--viper</span> Use Viper <span class="token keyword">for</span> configuration <span class="token punctuation">(</span>default <span class="token boolean">true</span><span class="token punctuation">)</span>

 

Use <span class="token string">"hugo [command] --help"</span> <span class="token keyword">for</span> <span class="token function">more</span> information about a command.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>步骤一</code>、<code>步骤二</code>、<code>步骤三</code>，我们就成<code>功创建</code>和<code>添加</code>了 <code>Cobra 应用程序</code> 及其 <code>命令</code>。</p>
<p>接下来，我再来详细介绍下 <code>Cobra</code> 的核心特性。</p>
<h3 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h3><p><code>Cobra</code> 可以跟 <code>Pflag</code> 结合使用，实现强大的标志功能。使用步骤如下：</p>
<p><em><strong>使用持久化的标志。</strong></em></p>
<p>标志可以是“持久的”，这意味着该标志可用于它所分配的命令以及该命令下的每个子命令。可以在 <code>rootCmd</code> 上定义持久标志：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">BoolVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Verbose<span class="token punctuation">,</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> <span class="token string">"v"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"verbose output"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><em><strong>使用本地标志。</strong></em></p>
<p>也可以分配一个本地标志，本地标志只能在它所绑定的命令上使用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Source<span class="token punctuation">,</span> <span class="token string">"source"</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"Source directory to read from"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>–source</code>标志只能在 <code>rootCmd</code> 上引用，而不能在 <code>rootCmd</code> 的<code>子命令</code>上引用。</p>
<p><em><strong>将标志绑定到 Viper。</strong></em></p>
<p>我们可以将标志绑定到 <code>Viper</code> ，这样就可以使用 <code>viper.Get()</code> 获取标志的值。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> author <span class="token builtin">string</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>author<span class="token punctuation">,</span> <span class="token string">"author"</span><span class="token punctuation">,</span> <span class="token string">"YOUR NAME"</span><span class="token punctuation">,</span> <span class="token string">"Author name for copyright attribution"</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">BindPFlag</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span> rootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>设置标志为必选。</strong></em></p>
<p>默认情况下，标志是<code>可选</code>的，我们也可以设置标志为<code>必选</code>，当设置标志为<code>必选</code>，但是没有提供标志时，<code>Cobra</code> 会报错。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Region<span class="token punctuation">,</span> <span class="token string">"region"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"AWS region (required)"</span><span class="token punctuation">)</span>
rootCmd<span class="token punctuation">.</span><span class="token function">MarkFlagRequired</span><span class="token punctuation">(</span><span class="token string">"region"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="非选项参数验证"><a href="#非选项参数验证" class="headerlink" title="非选项参数验证"></a>非选项参数验证</h3><p>在命令的过程中，经常会传入非选项参数，并且需要对这些非选项参数进行验证，<code>Cobra</code> 提供了机制来对非选项参数进行验证。可以使用 <code>Command</code> 的 <code>Args</code> 字段来验证非选项参数。</p>
<p><code>Cobra</code> 也内置了一些验证函数：</p>
<p><code>NoArgs</code>：如果存在任何非选项参数，该命令将报错。</p>
<p><code>ArbitraryArgs</code>：该命令将接受任何非选项参数。</p>
<p><code>OnlyValidArgs</code>：如果有任何非选项参数不在 <code>Command</code> 的 <code>ValidArgs</code> 字段中，该命令将报错。</p>
<p><code>MinimumNArgs(int)</code>：如果没有至少 <code>N</code> 个非选项参数，该命令将报错。</p>
<p><code>MaximumNArgs(int)</code>：如果有多于 <code>N</code> 个非选项参数，该命令将报错。</p>
<p><code>ExactArgs(int)</code>：如果非选项参数个数不为 N，该命令将报错。</p>
<p><code>ExactValidArgs(int)</code>：如果非选项参数的个数不为 <code>N</code>，或者非选项参数不在 <code>Command</code> 的 <code>ValidArgs</code> 字段中，该命令将报错。</p>
<p><code>RangeArgs(min, max)</code>：如果非选项参数的个数不在 <code>min</code> 和 <code>max</code> 之间，该命令将报错。</p>
<p>使用<code>预定义验证函数</code>，示例如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> cmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">&#123;</span>

	Short<span class="token punctuation">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>

	Args<span class="token punctuation">:</span> cobra<span class="token punctuation">.</span><span class="token function">MinimumNArgs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 使用内置的验证函数</span>

	Run<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然你也可以<code>自定义验证函数</code>，示例如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> cmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">&#123;</span>

	Short<span class="token punctuation">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
	<span class="token comment">// Args: cobra.MinimumNArgs(10), // 使用内置的验证函数</span>
	Args<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自定义验证函数</span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"requires at least one arg"</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> myapp<span class="token punctuation">.</span><span class="token function">IsValidColor</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"invalid color specified: %s"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	Run<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="PreRun-and-PostRun-Hooks"><a href="#PreRun-and-PostRun-Hooks" class="headerlink" title="PreRun and PostRun Hooks"></a>PreRun and PostRun Hooks</h3><p>在运行 <code>Run</code> 函数时，我们可以运行一些钩子函数，比如 <code>PersistentPreRun</code> 和 <code>PreRun</code> 函数在 <code>Run</code> 函数之前执行，<code>PersistentPostRun</code> 和 <code>PostRun</code> 在 <code>Run</code> 函数之后执行。</p>
<p>如果<code>子命令</code>没有指定 <code>Persistent_Run</code> 函数，则 <code>子命令</code> 将会继承 <code>父命令</code> 的 <code>Persistent_Run</code> 函数。这些函数的运行顺序如下：</p>
<p><code>PersistentPreRun</code></p>
<p><code>PreRun</code></p>
<p><code>Run</code></p>
<p><code>PostRun</code></p>
<p><code>PersistentPostRun</code></p>
<p>注意，父级的 <code>PreRun</code> 只会在<code>父级命令</code>运行时调用，<code>子命令</code>是不会调用的。</p>
<p><code>Cobra</code> 还支持很多其他有用的特性，</p>
<p>比如：<br>自定义 <code>Help</code> 命令；<br>可以自动添加<code>–version</code>标志，输出程序版本信息；<br>当用户提供无效标志或无效命令时，<code>Cobra</code> 可以打印出 usage 信息；<br>当我们输入的命令有误时，<code>Cobra</code> 会根据注册的命令，推算出可能的命令，等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发 <code>Go</code> 项目时，我们可以通过 <code>Pflag</code> 来解析命令行参数，通过 <code>Viper</code> 来解析配置文件，用 <code>Cobra</code> 来实现命令行框架。</p>
<p>你可以通过 <code>pflag.String()</code>、 <code>pflag.StringP()</code>、<code>pflag.StringVar()</code>、<code>pflag.StringVarP()</code> 方法来设置命令行参数，并使用 <code>Get</code> 来获取参数的值。</p>
<p>同时，你也可以使用 <code>Viper</code> 从 <code>命令行参数</code>、<code>环境变量</code>、<code>配置文件</code>等位置<code>读取配置项</code>。</p>
<p>最常用的是从 <code>配置文件</code> 中读取，可以通过 <code>viper.AddConfigPath</code> 来设置<code>配置文件</code>搜索路径，通过 <code>viper.SetConfigFile</code> 和 <code>viper.SetConfigType</code> 来设置配置文件名，通过 <code>viper.ReadInConfig</code> 来读取配置文件。</p>
<p>读取完配置文件，然后在程序中使用 <code>Get/Get</code> 来读取配置项的值。</p>
<p>最后，你可以使用 <code>Cobra</code> 来构建一个命令行框架，<code>Cobra</code> 可以很好地集成 <code>Pflag</code> 和 <code>Viper</code>。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>Pflag</tag>
        <tag>Viper</tag>
        <tag>Cobra</tag>
      </tags>
  </entry>
  <entry>
    <title>14 | 日志处理：手把手教你从 0 编写一个日志包</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-14-log-pkg2.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<p>在实际开发中，我们可以选择一些优秀的开源日志包，不加修改直接拿来使用。</p>
<p>但更多时候，是基于一个或某几个优秀的开源日志包进行二次开发。</p>
<p>想要开发或者二次开发一个日志包，就要掌握日志包的实现方式。</p>
<p>那么这一讲中，我来带你从<code>0</code>到<code>1</code>，实现一个具备基本功能的日志包，让你从中一窥日志包的实现原理和实现方法。</p>
<p>在开始实战之前，我们先来看下目前业界有哪些优秀的开源日志包。</p>
<span id="more"></span>

<h2 id="有哪些优秀的开源日志包？"><a href="#有哪些优秀的开源日志包？" class="headerlink" title="有哪些优秀的开源日志包？"></a>有哪些优秀的开源日志包？</h2><p>在<code>Go</code>项目开发中，我们可以通过修改一些优秀的开源日志包，来实现项目的日志包。</p>
<p><code>Go</code>生态中有很多优秀的开源日志包，例如<code>标准库log包</code>、<code>glog</code>、<code>logrus</code>、<code>zap</code>、<code>seelog</code>、<code>zerolog</code>、<code>log15</code>、<code>apex/log</code>、<code>go-logging</code>等。</p>
<p>其中，用得比较多的是<code>标准库log包</code>、<code>glog</code>、<code>logrus</code> 和 <code>zap</code>。</p>
<p>为了使你了解开源日志包的现状，接下来我会简单介绍下这几个常用的日志包。</p>
<p>至于它们的具体使用方法，你可以参考我整理的一篇文章：<a href="https://github.com/marmotedu/geekbang-go/blob/master/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%97%A5%E5%BF%97%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.md">优秀开源日志包使用教程</a>。</p>
<h3 id="标准库log包"><a href="#标准库log包" class="headerlink" title="标准库log包"></a>标准库log包</h3><p><code>标准库log包</code>的功能非常简单，只提供了 <code>Print</code> 、 <code>Panic</code> 和 <code>Fatal</code> <code>三类函数</code>用于日志输出。因为是标准库自带的，所以不需要我们下载安装，使用起来非常方便。</p>
<p><code>标准库log包</code>只有不到<code>400</code>行的代码量，如果你想研究如何实现一个日志包，阅读<code>标准库log包</code>是一个不错的开始。</p>
<p><code>Go</code>的标准库大量使用了<code>log</code>包，例如<code>net/http</code> 、 <code>net/rpc</code> 等。</p>
<h3 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h3><p><a href="https://github.com/golang/glog">glog</a>是<code>Google</code>推出的日志包，跟<code>标准库log包</code>一样，它是一个<code>轻量级</code>的日志包，使用起来简单方便。</p>
<p>但<code>glog</code>比<code>标准库log包</code>提供了更多的功能，它具有如下特性：</p>
<ul>
<li>支持<code>4</code>种日志级别：<code>Info</code> 、 <code>Warning</code> 、 <code>Error</code> 、 <code>Fatal</code> 。</li>
<li>支持命令行选项，例如<code>-alsologtostderr</code>、<code>-log_backtrace_at</code>、<code>-log_dir</code>、<code>-logtostderr</code>、<code>-v</code>等，每个参数实现某种功能。</li>
<li>支持根据文件大小切割日志文件。</li>
<li>支持日志按级别分类输出。</li>
<li>支持 <code>V level</code>。<code>V level</code>特性可以使开发者自定义日志级别。</li>
<li>支持 <code>vmodule</code> 。 <code>vmodule</code> 可以使开发者对不同的文件使用不同的日志级别。</li>
<li>支持 <code>traceLocation</code> 。 <code>traceLocation</code> 可以打印出指定位置的栈信息。</li>
</ul>
<p><code>Kubernetes</code> 项目就使用了基于 <code>glog</code> 封装的 <code>klog</code> ，作为其日志库。</p>
<h3 id="logrus"><a href="#logrus" class="headerlink" title="logrus"></a>logrus</h3><p><a href="https://github.com/sirupsen/logrus">logrus</a>是目前GitHub上star数量最多的日志包，它的优点是功能强大、性能高效、高度灵活，还提供了自定义插件的功能。很多优秀的开源项目，例如Docker、Prometheus等，都使用了logrus。除了具有日志的基本功能外，logrus还具有如下特性：</p>
<ul>
<li>支持常用的日志级。<code>logrus</code>支持<code>Debug</code>、<code>Info</code>、<code>Warn</code>、<code>Error</code>、<code>Fatal</code>和 <code>Panic</code> 这些日志级别。</li>
<li>可扩展。<code>logrus</code>的 <code>Hook</code> 机制允许使用者通过 <code>Hook</code> 的方式，将日志分发到任意地方，例如<code>本地文件</code>、<code>标准输出</code>、<code>Elasticsearch</code>、<code>Logstash</code>、<code>Kafka</code>等。</li>
<li>支持自定义日志格式。<code>logrus</code> 内置了 <code>JSONFormatter</code> 和 <code>TextFormatter</code> 两种格式。除此之外，<code>logrus</code>还允许使用者通过实现<code>Formatter</code>接口，来自定义日志格式。</li>
<li>结构化日志记录。<code>logrus</code>的<code>Field</code>机制允许使用者自定义日志字段，而不是通过冗长的消息来记录日志。</li>
<li>预设日志字段。<code>logrus</code>的<code>Default Fields</code>机制，可以给一部分或者全部日志统一添加共同的日志字段，例如给某次<code>HTTP</code>请求的所有日志添加<code>X-Request-ID</code>字段。</li>
<li>Fatal handlers。<code>logrus</code>允许注册一个或多个<code>handler</code>，当产生<code>Fatal</code>级别的日志时调用。当我们的程序需要优雅关闭时，这个特性会非常有用。</li>
</ul>
<h3 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h3><p><a href="https://github.com/uber-go/zap">zap</a>是uber开源的日志包，以高性能著称，很多公司的日志包都是基于zap改造而来。除了具有日志基本的功能之外，zap还具有很多强大的特性：</p>
<ul>
<li>支持常用的日志级别，例如：<code>Debug</code> 、 <code>Info</code> 、 <code>Warn</code> 、 <code>Error</code> 、 <code>DPanic</code> 、 <code>Panic</code> 、 <code>Fatal</code> 。</li>
<li>性能非常高。 <code>zap</code> 具有非常高的性能，适合对性能要求比较高的场景。</li>
<li>支持针对特定的日志级别，输出调用堆栈。</li>
<li>像 <code>logrus</code> 一样， <code>zap</code> 也支持结构化的目录日志、预设日志字段，也因为支持Hook而具有可扩展性。</li>
</ul>
<h3 id="开源日志包选择"><a href="#开源日志包选择" class="headerlink" title="开源日志包选择"></a>开源日志包选择</h3><p>上面我介绍了很多日志包，每种日志包使用的场景不同，你可以根据自己的需求，结合日志包的特性进行选择：</p>
<ul>
<li><strong>标准库log包：</strong> 标准库log包不支持日志级别、日志分割、日志格式等功能，所以在大型项目中很少直接使用，通常用于一些短小的程序，比如用于生成<code>JWT Token</code>的<code>main.go</code>文件中。标准库日志包也很适合一些简短的代码，用于快速调试和验证。</li>
<li><strong>glog：</strong> <code>glog</code> 实现了日志包的基本功能，非常适合一些对日志功能要求不多的小型项目。</li>
<li><strong>logrus：</strong> <code>logrus</code> 功能强大，不仅实现了日志包的基本功能，还有很多高级特性，适合一些大型项目，尤其是需要结构化日志记录的项目。</li>
<li><strong>zap：</strong> <code>zap</code> 提供了很强大的日志功能，性能高，内存分配次数少，适合对日志性能要求很高的项目。另外， <code>zap</code> 包中的子包 <code>zapcore</code> ，提供了很多底层的日志接口，适合用来做二次封装。</li>
</ul>
<p>举个我自己选择日志包来进行二次开发的例子：我在做容器云平台开发时，发现 <code>Kubernetes</code> 源码中大量使用了 <code>glog</code> ，这时就需要日志包能够兼容 <code>glog</code> 。</p>
<p>于是，我基于 <code>zap</code> 和 <code>zapcore</code> 封装了<a href="https://github.com/marmotedu/iam/tree/master/pkg/log">github.com&#x2F;marmotedu&#x2F;iam&#x2F;pkg&#x2F;log</a>日志包，这个日志包可以很好地兼容 <code>glog</code> 。</p>
<p>在实际项目开发中，你可以根据项目需要，从上面几个日志包中进行选择，直接使用，但更多时候，你还需要基于这些包来进行定制开发。为了使你更深入地掌握日志包的设计和开发，接下来，我会从0到1带你开发一个日志包。</p>
<h2 id="从0编写一个日志包"><a href="#从0编写一个日志包" class="headerlink" title="从0编写一个日志包"></a>从0编写一个日志包</h2><p><strong>接下来，我会向你展示如何快速编写一个具备基本功能的日志包，让你通过这个简短的日志包实现掌握日志包的核心设计思路。该日志包主要实现以下几个功能：</strong></p>
<ul>
<li>支持自定义配置。</li>
<li>支持文件名和行号。</li>
<li>支持日志级别 <code>Debug</code> 、 <code>Info</code> 、 <code>Warn</code> 、 <code>Error</code> 、 <code>Panic</code> 、 <code>Fatal</code> 。</li>
<li>支持输出到本地文件和标准输出。</li>
<li>支持 <code>JSON</code> 和 <code>TEXT</code> 格式的日志输出，支持自定义日志格式。</li>
<li>支持选项模式。</li>
</ul>
<p>日志包名称为<code>cuslog</code>，示例项目完整代码存放在 <a href="https://github.com/marmotedu/gopractise-demo/tree/main/log/cuslog">cuslog</a>。</p>
<p>具体实现分为以下四个步骤：</p>
<ol>
<li>定义：定义日志级别和日志选项。</li>
<li>创建：创建<code>Logger</code>及各级别日志打印方法。</li>
<li>写入：将日志输出到支持的输出中。</li>
<li>自定义：自定义日志输出格式。</li>
</ol>
<h3 id="定义日志级别和日志选项"><a href="#定义日志级别和日志选项" class="headerlink" title="定义日志级别和日志选项"></a>定义日志级别和日志选项</h3><p>一个基本的日志包，首先需要定义好日志级别和日志选项。本示例将定义代码保存在<a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/options.go">options.go</a>文件中。</p>
<p><strong>可以通过如下方式定义日志级别：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Level <span class="token builtin">uint8</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	DebugLevel Level <span class="token operator">=</span> <span class="token boolean">iota</span>

	InfoLevel

	WarnLevel

	ErrorLevel

	PanicLevel

	FatalLevel
<span class="token punctuation">)</span>

<span class="token keyword">var</span> LevelNameMapping <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span>Level<span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>

	DebugLevel<span class="token punctuation">:</span> <span class="token string">"DEBUG"</span><span class="token punctuation">,</span>

	InfoLevel<span class="token punctuation">:</span> <span class="token string">"INFO"</span><span class="token punctuation">,</span>

	WarnLevel<span class="token punctuation">:</span> <span class="token string">"WARN"</span><span class="token punctuation">,</span>

	ErrorLevel<span class="token punctuation">:</span> <span class="token string">"ERROR"</span><span class="token punctuation">,</span>

	PanicLevel<span class="token punctuation">:</span> <span class="token string">"PANIC"</span><span class="token punctuation">,</span>

	FatalLevel<span class="token punctuation">:</span> <span class="token string">"FATAL"</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>在日志输出时，要通过 对比 <code>开关级别</code> 和 <code>输出级别</code> 的 <code>大小</code>，来决定是否输出，所以日志级别 <code>Level</code> 要定义成方便比较的<code>数值类型</code>。</p>
<p>几乎所有的日志包都是用常量计数器<code>iota</code>来定义日志级别。</p>
<p>另外，因为要在日志输出中，输出可读的日志级别（例如输出<code>INFO</code>而不是<code>1</code>），所以需要有 <code>Level</code> 到 <code>Level Name</code> 的映射 <code>LevelNameMapping</code> ， <code>LevelNameMapping</code> 会在格式化时用到。</p>
<p>接下来看定义日志选项。日志需要是可配置的，方便开发者根据不同的环境设置不同的日志行为，比较常见的配置选项为：</p>
<ul>
<li>日志级别。</li>
<li>输出位置，例如<code>标准输出</code>或者<code>文件</code>。</li>
<li>输出格式，例如<code>JSON</code>或者<code>Text</code>。</li>
<li>是否开启<code>文件名</code>和<code>行号</code>。</li>
</ul>
<p><strong>本示例的日志选项定义如下：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> options <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	output io<span class="token punctuation">.</span>Writer

	level Level

	stdLevel Level

	formatter Formatter

	disableCaller <span class="token builtin">bool</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>为了灵活地设置日志的选项，你可以通过选项模式，来对日志选项进行设置：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> Option <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>options<span class="token punctuation">)</span>



<span class="token keyword">func</span> <span class="token function">initOptions</span><span class="token punctuation">(</span>opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	o <span class="token operator">=</span> <span class="token operator">&amp;</span>options<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">&#123;</span>

		<span class="token function">opt</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>



	<span class="token keyword">if</span> o<span class="token punctuation">.</span>output <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		o<span class="token punctuation">.</span>output <span class="token operator">=</span> os<span class="token punctuation">.</span>Stderr

	<span class="token punctuation">&#125;</span>



	<span class="token keyword">if</span> o<span class="token punctuation">.</span>formatter <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		o<span class="token punctuation">.</span>formatter <span class="token operator">=</span> <span class="token operator">&amp;</span>TextFormatter<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	<span class="token punctuation">&#125;</span>



	<span class="token keyword">return</span>

<span class="token punctuation">&#125;</span>



<span class="token keyword">func</span> <span class="token function">WithLevel</span><span class="token punctuation">(</span>level Level<span class="token punctuation">)</span> Option <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>o <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		o<span class="token punctuation">.</span>level <span class="token operator">=</span> level

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token operator">...</span>

<span class="token keyword">func</span> <span class="token function">SetOptions</span><span class="token punctuation">(</span>opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	std<span class="token punctuation">.</span><span class="token function">SetOptions</span><span class="token punctuation">(</span>opts<span class="token operator">...</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>



<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>logger<span class="token punctuation">)</span> <span class="token function">SetOptions</span><span class="token punctuation">(</span>opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">defer</span> l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>



	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">&#123;</span>

		<span class="token function">opt</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>opt<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>具有选项模式的日志包，可通过以下方式，来动态地修改日志的选项：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">cuslog<span class="token punctuation">.</span><span class="token function">SetOptions</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span><span class="token function">WithLevel</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span>DebugLevel<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>你可以根据需要，对每一个日志选项创建设置函数 <code>WithXXXX</code> 。这个示例日志包支持如下选项设置函数：</strong></p>
<ul>
<li><code>WithOutput</code>（output io.Writer）：设置输出位置。</li>
<li><code>WithLevel</code>（level Level）：设置输出级别。</li>
<li><code>WithFormatter</code>（formatter Formatter）：设置输出格式。</li>
<li><code>WithDisableCaller</code>（caller bool）：设置是否打印文件名和行号。</li>
</ul>
<h3 id="创建Logger及各级别日志打印方法"><a href="#创建Logger及各级别日志打印方法" class="headerlink" title="创建Logger及各级别日志打印方法"></a>创建Logger及各级别日志打印方法</h3><p>为了打印日志，我们需要根据日志配置，创建一个 <code>Logger</code> ，然后通过调用 <code>Logger</code> 的日志打印方法，完成各级别日志的输出。</p>
<p>本示例将创建代码保存在<a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/logger.go">logger.go</a>文件中。</p>
<p><strong>可以通过如下方式创建Logger：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> std <span class="token operator">=</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> logger <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	opt <span class="token operator">*</span>options

	mu sync<span class="token punctuation">.</span>Mutex

	entryPool <span class="token operator">*</span>sync<span class="token punctuation">.</span>Pool
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token operator">*</span>logger <span class="token punctuation">&#123;</span>

	logger <span class="token operator">:=</span> <span class="token operator">&amp;</span>logger<span class="token punctuation">&#123;</span>opt<span class="token punctuation">:</span> <span class="token function">initOptions</span><span class="token punctuation">(</span>opts<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>

	logger<span class="token punctuation">.</span>entryPool <span class="token operator">=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>Pool<span class="token punctuation">&#123;</span>New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">entry</span><span class="token punctuation">(</span>logger<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> logger

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>上述代码中，定义了一个<code>Logger</code>，并实现了创建<code>Logger</code>的<code>New</code>函数。日志包都会有一个 <code>默认的全局</code> <code>Logger</code>，本示例通过 <code>var std = New()</code> 创建了一个<code>全局的默认 Logger</code>。</p>
<p><code>cuslog.Debug</code>、<code>cuslog.Info</code> 和 <code>cuslog.Warnf</code> 等函数，则是通过调用 <code>std Logger</code> 所提供的方法来打印日志的。</p>
<p>定义了一个 <code>Logger</code> 之后，还需要给该 <code>Logger</code> 添加最核心的日志打印方法，要提供所有支持级别的日志打印方法。</p>
<p><strong>如果日志级别是 <code>Xyz</code> ，则通常需要提供<code>两类</code>方法，分别是 <code>非格式化方法</code> <code>Xyz(args ...interface&#123;&#125;)</code> 和 <code>格式化方法</code> <code>Xyzf(format string, args ...interface&#123;&#125;)</code>，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>logger<span class="token punctuation">)</span> <span class="token function">Debug</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

l<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>DebugLevel<span class="token punctuation">,</span> FmtEmptySeparate<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>logger<span class="token punctuation">)</span> <span class="token function">Debugf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

l<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>DebugLevel<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本示例实现了如下方法： <code>Debug</code> 、 <code>Debugf</code> 、 <code>Info</code> 、 <code>Infof</code> 、 <code>Warn</code> 、 <code>Warnf</code> 、 <code>Error</code> 、 <code>Errorf</code> 、 <code>Panic</code> 、 <code>Panicf</code> 、 <code>Fatal</code> 、 <code>Fatalf</code> 。</p>
<p>更详细的实现，你可以参考 <a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/logger.go">cuslog&#x2F;logger.go</a>。</p>
<p>这里要注意， <code>Panic</code> 、 <code>Panicf</code> 要调用 <code>panic()</code> 函数， <code>Fatal</code> 、 <code>Fatalf</code> 函数要调用 <code>os.Exit(1)</code> 函数。</p>
<h3 id="将日志输出到支持的输出中"><a href="#将日志输出到支持的输出中" class="headerlink" title="将日志输出到支持的输出中"></a>将日志输出到支持的输出中</h3><p><strong>调用日志打印函数之后，还需要将这些日志输出到支持的输出中，所以需要实现 <code>write</code> 函数，它的写入逻辑保存在<a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/entry.go">entry.go</a>文件中。实现方式如下：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Entry <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	logger <span class="token operator">*</span>logger

	Buffer <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer

	Map <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	Level Level

	Time time<span class="token punctuation">.</span>Time

	File <span class="token builtin">string</span>

	Line <span class="token builtin">int</span>

	Func <span class="token builtin">string</span>

	Format <span class="token builtin">string</span>

	Args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>Entry<span class="token punctuation">)</span> <span class="token function">write</span><span class="token punctuation">(</span>level Level<span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>opt<span class="token punctuation">.</span>level <span class="token operator">></span> level <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	e<span class="token punctuation">.</span>Time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	e<span class="token punctuation">.</span>Level <span class="token operator">=</span> level

	e<span class="token punctuation">.</span>Format <span class="token operator">=</span> format

	e<span class="token punctuation">.</span>Args <span class="token operator">=</span> args

	<span class="token keyword">if</span> <span class="token operator">!</span>e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>opt<span class="token punctuation">.</span>disableCaller <span class="token punctuation">&#123;</span>

		<span class="token keyword">if</span> pc<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> ok <span class="token operator">:=</span> runtime<span class="token punctuation">.</span><span class="token function">Caller</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

			e<span class="token punctuation">.</span>File <span class="token operator">=</span> <span class="token string">"???"</span>

			e<span class="token punctuation">.</span>Func <span class="token operator">=</span> <span class="token string">"???"</span>

		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

			e<span class="token punctuation">.</span>File<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Line<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Func <span class="token operator">=</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> runtime<span class="token punctuation">.</span><span class="token function">FuncForPC</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			e<span class="token punctuation">.</span>Func <span class="token operator">=</span> e<span class="token punctuation">.</span>Func<span class="token punctuation">[</span>strings<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Func<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>

		<span class="token punctuation">&#125;</span>

	<span class="token punctuation">&#125;</span>

	e<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	e<span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	e<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>Entry<span class="token punctuation">)</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token boolean">_</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>opt<span class="token punctuation">.</span>formatter<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>Entry<span class="token punctuation">)</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token boolean">_</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>opt<span class="token punctuation">.</span>output<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Buffer<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>Entry<span class="token punctuation">)</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	e<span class="token punctuation">.</span>Args<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Line<span class="token punctuation">,</span> e<span class="token punctuation">.</span>File<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Format<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Func <span class="token operator">=</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span>

	e<span class="token punctuation">.</span>Buffer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	e<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>entryPool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码，首先定义了一个<code>Entry``结构体</code>类型，该类型用来保存所有的日志信息，即<code>日志配置</code>和<code>日志内容</code>。</p>
<p><code>写入逻辑</code>都是围绕<code>Entry类型</code>的<code>实例</code>来完成的。</p>
<p>用<code>Entry</code>的<code>write</code>方法来完成日志的写入，在<code>write</code>方法中，会首先判断日志的<code>输出级别</code>和<code>开关级别</code>，如果<code>输出级别</code>小于<code>开关级别</code>，则直接返回，不做任何记录。</p>
<p>在<code>write</code>中，还会判断是否需要记录<code>文件名</code>和<code>行号</code>，如果需要则调用 <code>runtime.Caller()</code> 来获取<code>文件名</code>和<code>行号</code>，调用 <code>runtime.Caller()</code> 时，要注意传入正确的栈深度。</p>
<p><strong><code>write</code>函数中调用 <code>e.format</code> 来格式化日志，调用 <code>e.writer</code> 来写入日志，在创建<code>Logger</code>传入的日志配置中，指定了输出位置 <code>output io.Writer</code> ，<code>output</code>类型为 <code>io.Writer</code> ，示例如下：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>

	<span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>io.Writer</code>实现了<code>Write</code>方法可供写入，所以只需要调用<code>e.logger.opt.output.Write(e.Buffer.Bytes())</code>即可将日志写入到指定的位置中。最后，会调用<code>release()</code>方法来<code>清空缓存</code>和<code>对象池</code>。</p>
<p>至此，我们就完成了日志的记录和写入。</p>
<h3 id="自定义日志输出格式"><a href="#自定义日志输出格式" class="headerlink" title="自定义日志输出格式"></a>自定义日志输出格式</h3><p><strong><code>cuslog</code>包支持自定义输出格式，并且内置了<code>JSON</code>和<code>Text</code>格式的<code>Formatter</code>。<code>Formatter</code>接口定义为：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Formatter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Format</span><span class="token punctuation">(</span>entry <span class="token operator">*</span>Entry<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>cuslog</code>内置的<code>Formatter</code>有两个：<a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/formatter_json.go">JSON</a>和<a href="https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/formatter_text.go">TEXT</a>。</p>
<h3 id="测试日志包"><a href="#测试日志包" class="headerlink" title="测试日志包"></a>测试日志包</h3><p><strong><code>cuslog</code>日志包开发完成之后，可以编写测试代码，调用<code>cuslog</code>包来测试<code>cuslog</code>包，代码如下：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"log"</span>
	<span class="token string">"os"</span>

	<span class="token string">"github.com/marmotedu/gopractise-demo/log/cuslog"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	cuslog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"std log"</span><span class="token punctuation">)</span>

	cuslog<span class="token punctuation">.</span><span class="token function">SetOptions</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span><span class="token function">WithLevel</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span>DebugLevel<span class="token punctuation">)</span><span class="token punctuation">)</span>

	cuslog<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"change std log to debug level"</span><span class="token punctuation">)</span>

	cuslog<span class="token punctuation">.</span><span class="token function">SetOptions</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span><span class="token function">WithFormatter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cuslog<span class="token punctuation">.</span>JsonFormatter<span class="token punctuation">&#123;</span>IgnoreBasicFields<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	cuslog<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"log in json format"</span><span class="token punctuation">)</span>

	cuslog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"another log in json format"</span><span class="token punctuation">)</span>

	<span class="token comment">// 输出到文件</span>

	fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"test.log"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_APPEND<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span><span class="token string">"create file test.log failed"</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	l <span class="token operator">:=</span> cuslog<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span><span class="token function">WithLevel</span><span class="token punctuation">(</span>cuslog<span class="token punctuation">.</span>InfoLevel<span class="token punctuation">)</span><span class="token punctuation">,</span>

		cuslog<span class="token punctuation">.</span><span class="token function">WithOutput</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">,</span>

		cuslog<span class="token punctuation">.</span><span class="token function">WithFormatter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cuslog<span class="token punctuation">.</span>JsonFormatter<span class="token punctuation">&#123;</span>IgnoreBasicFields<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token punctuation">)</span>

	l<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"custom log with json formatter"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong>将上述代码保存在<code>main.go</code>文件中，运行：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run example.go

<span class="token number">2020</span>-12-04T10:32:12+08:00 INFO example.go:11 std log

<span class="token number">2020</span>-12-04T10:32:12+08:00 DEBUG example.go:13 change std log to debug level

<span class="token punctuation">&#123;</span><span class="token string">"file"</span><span class="token builtin class-name">:</span><span class="token string">"/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/log/cuslog/example/example.go:15"</span>,<span class="token string">"func"</span><span class="token builtin class-name">:</span><span class="token string">"main.main"</span>,<span class="token string">"message"</span><span class="token builtin class-name">:</span><span class="token string">"log in json format"</span>,<span class="token string">"level"</span><span class="token builtin class-name">:</span><span class="token string">"DEBUG"</span>,<span class="token string">"time"</span><span class="token builtin class-name">:</span><span class="token string">"2020-12-04T10:32:12+08:00"</span><span class="token punctuation">&#125;</span>

<span class="token punctuation">&#123;</span><span class="token string">"level"</span><span class="token builtin class-name">:</span><span class="token string">"INFO"</span>,<span class="token string">"time"</span><span class="token builtin class-name">:</span><span class="token string">"2020-12-04T10:32:12+08:00"</span>,<span class="token string">"file"</span><span class="token builtin class-name">:</span><span class="token string">"/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/log/cuslog/example/example.go:16"</span>,<span class="token string">"func"</span><span class="token builtin class-name">:</span><span class="token string">"main.main"</span>,<span class="token string">"message"</span><span class="token builtin class-name">:</span><span class="token string">"another log in json format"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>到这里日志包就开发完成了，完整包见 <a href="https://github.com/marmotedu/gopractise-demo/tree/main/log/cuslog">log&#x2F;cuslog</a>。</p>
<h2 id="IAM项目日志包设计"><a href="#IAM项目日志包设计" class="headerlink" title="IAM项目日志包设计"></a>IAM项目日志包设计</h2><p>这一讲的最后，我们再来看下我们的<code>IAM</code>项目中，日志包是怎么设计的。</p>
<p>先来看一下<code>IAM</code>项目<code>log</code>包的存放位置：<a href="https://github.com/marmotedu/iam/tree/v1.0.0/pkg/log">pkg&#x2F;log</a>。</p>
<p>放在这个位置，主要有两个原因：</p>
<p>第一个，<code>log包</code>属于IAM项目，有定制开发的内容；</p>
<p>第二个，<code>log包</code>功能完备、成熟，外部项目也可以使用。</p>
<p>该<code>log包</code>是基于 <code>go.uber.org/zap</code> 包封装而来的，根据需要添加了更丰富的功能。</p>
<p>接下来，我们通过log包的<a href="https://github.com/marmotedu/iam/blob/master/pkg/log/options.go#L47">Options</a>，来看下<code>log包</code>所实现的功能：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Options <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	OutputPaths <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"output-paths" mapstructure:"output-paths"`</span>

	ErrorOutputPaths <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"error-output-paths" mapstructure:"error-output-paths"`</span>

	Level <span class="token builtin">string</span> <span class="token string">`json:"level" mapstructure:"level"`</span>

	Format <span class="token builtin">string</span> <span class="token string">`json:"format" mapstructure:"format"`</span>

	DisableCaller <span class="token builtin">bool</span> <span class="token string">`json:"disable-caller" mapstructure:"disable-caller"`</span>

	DisableStacktrace <span class="token builtin">bool</span> <span class="token string">`json:"disable-stacktrace" mapstructure:"disable-stacktrace"`</span>

	EnableColor <span class="token builtin">bool</span> <span class="token string">`json:"enable-color" mapstructure:"enable-color"`</span>

	Development <span class="token builtin">bool</span> <span class="token string">`json:"development" mapstructure:"development"`</span>

	Name <span class="token builtin">string</span> <span class="token string">`json:"name" mapstructure:"name"`</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Options</code>各配置项含义如下：</strong></p>
<ul>
<li><code>development</code> ：是否是开发模式。如果是开发模式，会对<code>DPanicLevel</code>进行堆栈跟踪。</li>
<li><code>name</code> ：<code>Logger</code> 的名字。</li>
<li><code>disable-caller</code> ：是否开启 <code>caller</code>，如果开启会在日志中显示调用日志所在的文件、函数和行号。</li>
<li><code>disable-stacktrace</code> ：是否在<code>Panic</code>及以上级别禁止打印堆栈信息。</li>
<li><code>enable-color</code> ：是否开启颜色输出，<code>true</code> ，是；<code>false</code>，否。</li>
<li><code>level</code> ：日志级别，优先级从低到高依次为：<code>Debug</code> , <code>Info</code> , <code>Warn</code> , <code>Error</code> , <code>Dpanic</code> , <code>Panic</code> , <code>Fatal</code> 。</li>
<li><code>format</code> ：支持的日志输出格式，目前支持 <code>Console</code> 和 <code>JSON</code> 两种。 <code>Console</code> 其实就是 <code>Text</code> 格式。</li>
<li><code>output-paths</code> ：支持输出到<code>多个输出</code>，用逗号分开。支持输出到标准输出（<code>stdout</code>）和<code>文件</code>。</li>
<li><code>error-output-paths</code> ：<code>zap</code>内部(非业务)错误日志输出路径，多个输出，用<code>逗号</code>分开。</li>
</ul>
<p><strong>log包的Options结构体支持以下3个方法：</strong></p>
<ul>
<li><code>Build</code> 方法。 <code>Build</code> 方法可以根据Options构建一个全局的Logger。</li>
<li><code>AddFlags</code> 方法。 <code>AddFlags</code> 方法可以将 <code>Options</code> 的各个字段追加到传入的 <code>pflag.FlagSet</code>变量中。</li>
<li><code>String</code> 方法。 <code>String</code> 方法可以将 <code>Options</code> 的值以 <code>JSON</code> 格式字符串返回。</li>
</ul>
<p><strong>log包实现了以下3种日志记录方法：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
log<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"This is a info message"</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">Int32</span><span class="token punctuation">(</span><span class="token string">"int_key"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

log<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"This is a formatted %s message"</span><span class="token punctuation">,</span> <span class="token string">"info"</span><span class="token punctuation">)</span>

log<span class="token punctuation">.</span><span class="token function">Infow</span><span class="token punctuation">(</span><span class="token string">"Message printed with Infow"</span><span class="token punctuation">,</span> <span class="token string">"X-Request-ID"</span><span class="token punctuation">,</span> <span class="token string">"fbf54504-64da-4088-9b86-67824a7fb508"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Info</code> 使用指定的<code>key/value</code>记录日志。<code>Infof</code> 格式化记录日志。</p>
<p><code>Infow</code> 也是使用指定的<code>key/value</code>记录日志，跟 <code>Info</code> 的区别是：使用 <code>Info</code> 需要指定值的类型，通过指定值的日志类型，日志库底层不需要进行反射操作，所以使用 <code>Info</code> 记录日志性能<code>最高</code>。</p>
<p><code>log包</code>支持非常丰富的类型，具体你可以参考 <a href="https://github.com/marmotedu/iam/blob/master/pkg/log/types.go#L56">types.go</a>。</p>
<p>上述日志输出为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2021</span>-07-06 <span class="token number">14</span>:02:07.070 INFO This is a info message <span class="token punctuation">&#123;</span><span class="token string">"int_key"</span><span class="token builtin class-name">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token number">2021</span>-07-06 <span class="token number">14</span>:02:07.071 INFO This is a formatted info message2021-07-06 <span class="token number">14</span>:02:07.071 INFO Message printed with Infow <span class="token punctuation">&#123;</span><span class="token string">"X-Request-ID"</span><span class="token builtin class-name">:</span> <span class="token string">"fbf54504-64da-4088-9b86-67824a7fb508"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>log包</code>为每种级别的日志都提供了<code>3</code>种日志记录方式，举个例子：假设日志格式为 <code>Xyz</code> ，则分别提供了 <code>Xyz(msg string, fields ...Field)</code> ，<code>Xyzf(format string, v ...interface&#123;&#125;)</code> ，<code>Xyzw(msg string, keysAndValues ...interface&#123;&#125;)</code> <code>3</code>种日志记录方法。</p>
<p>另外，<code>log包</code>相较于一般的日志包，还提供了众多记录日志的方法。</p>
<p><strong>第一个方法，</strong> <strong><code>log包</code>支持<code>V Level</code>，可以通过整型数值来灵活指定<code>日志级别</code>，数值越大，优先级越低。例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// V level使用</span>

log<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"This is a V level message"</span><span class="token punctuation">)</span>

log<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"This is a %s V level message"</span><span class="token punctuation">,</span> <span class="token string">"formatted"</span><span class="token punctuation">)</span>

log<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infow</span><span class="token punctuation">(</span><span class="token string">"This is a V level message with fields"</span><span class="token punctuation">,</span> <span class="token string">"X-Request-ID"</span><span class="token punctuation">,</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里要注意，<code>Log.V</code>只支持 <code>Info</code> 、<code>Infof</code> 、<code>Infow</code>三种日志记录方法。</p>
<p><strong>第二个方法，</strong> <strong>log包支持WithValues函数，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// WithValues使用</span>

lv <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">WithValues</span><span class="token punctuation">(</span><span class="token string">"X-Request-ID"</span><span class="token punctuation">,</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">)</span>

lv<span class="token punctuation">.</span><span class="token function">Infow</span><span class="token punctuation">(</span><span class="token string">"Info message printed with [WithValues] logger"</span><span class="token punctuation">)</span>

lv<span class="token punctuation">.</span><span class="token function">Infow</span><span class="token punctuation">(</span><span class="token string">"Debug message printed with [WithValues] logger"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>上述日志输出如下：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token number">2021</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">06</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">28.555</span> INFO Info message printed with <span class="token punctuation">[</span>WithValues<span class="token punctuation">]</span> logger <span class="token punctuation">&#123;</span><span class="token string">"X-Request-ID"</span><span class="token punctuation">:</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">&#125;</span>

<span class="token number">2021</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">06</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">28.556</span> INFO Debug message printed with <span class="token punctuation">[</span>WithValues<span class="token punctuation">]</span> logger <span class="token punctuation">&#123;</span><span class="token string">"X-Request-ID"</span><span class="token punctuation">:</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>WithValues</code> 可以返回一个携带指定 <code>key-value</code> 的 <code>Logger</code> ，供后面使用。</p>
<p><strong>第三个方法，</strong> <strong><code>log包</code>提供 <code>WithContext</code> 和 <code>FromContext</code> 用来将指定的<code>Logger</code>添加到某个<code>Context</code>中，以及从某个<code>Context</code>中获取<code>Logger</code>，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// Context使用</span>

ctx <span class="token operator">:=</span> lv<span class="token punctuation">.</span><span class="token function">WithContext</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

lc <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">FromContext</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>

lc<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"Message printed with [WithContext] logger"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>WithContext</code>和<code>FromContext</code>非常适合用在以<code>context.Context</code>传递的函数中，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token operator">...</span>

	<span class="token comment">// WithValues使用</span>

	lv <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">WithValues</span><span class="token punctuation">(</span><span class="token string">"X-Request-ID"</span><span class="token punctuation">,</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">)</span>

	<span class="token comment">// Context使用</span>

	lv<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Start to call pirntString"</span><span class="token punctuation">)</span>

	ctx <span class="token operator">:=</span> lv<span class="token punctuation">.</span><span class="token function">WithContext</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token function">pirntString</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">pirntString</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	lc <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">FromContext</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>

	lc<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Hello %s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>上述代码输出如下：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2021</span>-07-06 <span class="token number">14</span>:38:02.050 INFO Start to call pirntString <span class="token punctuation">&#123;</span><span class="token string">"X-Request-ID"</span><span class="token builtin class-name">:</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">&#125;</span>
<span class="token number">2021</span>-07-06 <span class="token number">14</span>:38:02.050 INFO Hello World <span class="token punctuation">&#123;</span><span class="token string">"X-Request-ID"</span><span class="token builtin class-name">:</span> <span class="token string">"7a7b9f24-4cae-4b2a-9464-69088b45b904"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>将 <code>Logger</code> 添加到 <code>Context</code> 中，并通过 <code>Context</code> 在不同函数间传递，可以使<code>key-value</code>在不同函数间传递。</p>
<p>例如上述代码中， <code>X-Request-ID</code> 在 <code>main 数</code>、<code>printString 函数</code>中的日志输出中均有记录，从而实现了一种调用链的效果。</p>
<p><strong>第四个方法，</strong> <strong>可以很方便地从<code>Context</code>中提取出指定的<code>key-value</code>，作为上下文添加到日志输出中，例如 <a href="https://github.com/marmotedu/iam/blob/v1.0.0/internal/apiserver/api/v1/user/create.go#L20">internal&#x2F;apiserver&#x2F;api&#x2F;v1&#x2F;user&#x2F;create.go</a>文件中的日志调用：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">log<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"user create function called."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过调用 <code>Log.L()</code> 函数，实现如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// L method output with specified context value.</span>

<span class="token keyword">func</span> <span class="token function">L</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">*</span>zapLogger <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> std<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>zapLogger<span class="token punctuation">)</span> <span class="token function">L</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">*</span>zapLogger <span class="token punctuation">&#123;</span>

	lg <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	requestID<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ctx<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>KeyRequestID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>

	username<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ctx<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>KeyUsername<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>

	lg<span class="token punctuation">.</span>zapLogger <span class="token operator">=</span> lg<span class="token punctuation">.</span>zapLogger<span class="token punctuation">.</span><span class="token function">With</span><span class="token punctuation">(</span>zap<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>KeyRequestID<span class="token punctuation">,</span> requestID<span class="token punctuation">)</span><span class="token punctuation">,</span> zap<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>KeyUsername<span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> lg

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>L()</code> 方法会从传入的Context中提取出 <code>requestID</code> 和 <code>username</code> ，追加到<code>Logger</code>中，并返回<code>Logger</code>。这时候调用该<code>Logger</code>的<code>Info</code>、<code>Infof</code>、<code>Infow</code>等方法记录日志，输出的日志中均包含 <code>requestID</code> 和 <code>username</code> 字段，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">2021</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">06</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">46</span><span class="token punctuation">:</span><span class="token number">00.743</span> INFO    apiserver       secret<span class="token operator">/</span>create<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">23</span>     create secret function called<span class="token punctuation">.</span>  <span class="token punctuation">&#123;</span><span class="token string">"requestID"</span><span class="token punctuation">:</span> <span class="token string">"73144bed-534d-4f68-8e8d-dc8a8ed48507"</span><span class="token punctuation">,</span> <span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"admin"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>通过将<code>Context</code>在函数间传递，很容易就能实现<code>调用链</code>效果，例如：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Create add new secret key pairs to the storage.</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>SecretHandler<span class="token punctuation">)</span> <span class="token function">Create</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

log<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"create secret function called."</span><span class="token punctuation">)</span>


<span class="token operator">...</span>


sec<span class="token punctuation">,</span> err <span class="token operator">:=</span> s<span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">Secrets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> username<span class="token punctuation">,</span> metav1<span class="token punctuation">.</span>ListOptions<span class="token punctuation">&#123;</span>

Offset<span class="token punctuation">:</span> pointer<span class="token punctuation">.</span><span class="token function">ToInt64</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

Limit<span class="token punctuation">:</span> pointer<span class="token punctuation">.</span><span class="token function">ToInt64</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>


<span class="token operator">...</span>


<span class="token keyword">if</span> err <span class="token operator">:=</span> s<span class="token punctuation">.</span>srv<span class="token punctuation">.</span><span class="token function">Secrets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">,</span> metav1<span class="token punctuation">.</span>CreateOptions<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>


<span class="token keyword">return</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>上述代码输出为：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token number">2021</span>-07-06 <span class="token number">14</span>:46:00.743 INFO apiserver secret/create.go:23 create secret <span class="token keyword">function</span> called. <span class="token punctuation">&#123;</span><span class="token string">"requestID"</span><span class="token builtin class-name">:</span> <span class="token string">"73144bed-534d-4f68-8e8d-dc8a8ed48507"</span>, <span class="token string">"username"</span><span class="token builtin class-name">:</span> <span class="token string">"admin"</span><span class="token punctuation">&#125;</span>

<span class="token number">2021</span>-07-06 <span class="token number">14</span>:46:00.744 INFO apiserver secret/create.go:23 list secret from storage. <span class="token punctuation">&#123;</span><span class="token string">"requestID"</span><span class="token builtin class-name">:</span> <span class="token string">"73144bed-534d-4f68-8e8d-dc8a8ed48507"</span>, <span class="token string">"username"</span><span class="token builtin class-name">:</span> <span class="token string">"admin"</span><span class="token punctuation">&#125;</span>

<span class="token number">2021</span>-07-06 <span class="token number">14</span>:46:00.745 INFO apiserver secret/create.go:23 insert secret to storage. <span class="token punctuation">&#123;</span><span class="token string">"requestID"</span><span class="token builtin class-name">:</span> <span class="token string">"73144bed-534d-4f68-8e8d-dc8a8ed48507"</span>, <span class="token string">"username"</span><span class="token builtin class-name">:</span> <span class="token string">"admin"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里要注意， <code>log.L</code> 函数默认会从<code>Context</code>中取 <code>requestID</code> 和 <code>username</code> 键，这跟<code>IAM项目</code>有<code>耦合度</code>，但这不影响<code>log包</code>供<code>第三方项目</code>使用。</p>
<p>这也是我建议你自己封装日志包的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开发一个日志包，我们很多时候需要基于一些业界优秀的开源日志包进行二次开发。</p>
<p>当前很多项目的日志包都是基于<code>zap</code>日志包来封装的，如果你有封装的需要，我建议你优先选择<code>zap</code>日志包。</p>
<p>这一讲中，我先给你介绍了<code>标准库log包</code>、<code>glog</code>、<code>logrus</code>和 <code>zap</code> 这四种常用的日志包，然后向你展现了开发一个日志包的四个步骤，步骤如下：</p>
<ol>
<li>定义日志级别和日志选项。</li>
<li>创建<code>Logger</code>及各级别日志打印方法。</li>
<li>将日志输出到支持的输出中。</li>
<li>自定义日志输出格式。</li>
</ol>
<p>最后，我介绍了<code>IAM项目</code>封装的<code>log包</code>的设计和使用方式。</p>
<p><code>log包</code>基于 <code>go.uber.org/zap</code>封装，并提供了以下强大特性：</p>
<ul>
<li><code>log包</code>支持V Level，可以灵活的通过整型数值来指定日志级别。</li>
<li><code>log包</code>支持 <code>WithValues</code> 函数， <code>WithValues</code> 可以返回一个携带指定<code>key-value</code>对的<code>Logger</code>，供后面使用。</li>
<li><code>log包</code>提供 <code>WithContext</code> 和 <code>FromContext</code> 用来将指定的<code>Logger</code>添加到某个<code>Context</code>中和从某个<code>Context</code>中获取<code>Logger</code>。</li>
<li><code>log包</code>提供了 <code>Log.L()</code> 函数，可以很方便的从<code>Context</code>中提取出指定的<code>key-value</code>对，作为<code>上下文</code>添加到日志输出中。</li>
</ul>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>16 | 应用构建：构建一个优秀的企业应用框架</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-16-build-app-cobra.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<h2 id="构建应用的基础：应用的三大基本功能"><a href="#构建应用的基础：应用的三大基本功能" class="headerlink" title="构建应用的基础：应用的三大基本功能"></a>构建应用的基础：应用的三大基本功能</h2><p>我们目前见到的 <code>Go</code> 后端服务，基本上可以分为 <code>API 服务</code>和<code>非 API 服务</code>两类。</p>
<p><code>API 服务</code>：通过对外提供 <code>HTTP/RPC</code> 接口来完成指定的功能。比如<code>订单服务</code>，通过调用<code>创建订单的 API 接口</code>，来创建<code>商品订单</code>。</p>
<p><code>非 API 服务</code>：通过<code>监听</code>、<code>定时运行</code>等方式，而不是通过 <code>API</code> 调用来完成某些任务。比如<code>数据处理服务</code>，<code>定时从 Redis 中获取数据</code>，<code>处理后存入后端存储中</code>。再比如<code>消息处理服务</code>，<code>监听消息队列</code>（如 <code>NSQ</code>&#x2F;<code>Kafka</code>&#x2F;<code>RabbitMQ</code>），收到消息后进行处理。</p>
<span id="more"></span>
<p>对于<code> API 服务</code>和<code>非 API 服务</code>来说，它们的启动流程基本一致，都可以分为三步：</p>
<p><code>应用框架的构建</code>，这是最基础的一步。</p>
<p><code>应用初始化</code>。</p>
<p><code>服务启动</code>。</p>
<p>如下图所示：</p>
<p><img src="https://i.imgloc.com/2023/06/28/VrLZoc.png" alt="GO 语言项目开发实战 – 应用构建实战：如何构建一个优秀的企业应用框架？"></p>
<p>图中，<code>命令行程序</code>、<code>命令行参数解析</code>和<code>配置文件解析</code>，是所有服务都需要具备的功能，这些功能有机结合到一起，共同构成了<code>应用框架</code>。</p>
<p>所以，我们要构建的任何一个应用程序，至少要具备<code>命令行程序</code>、<code>命令行参数解析</code>和<code>配置文件解析</code>这 <code>3</code> 种功能。</p>
<p><code>命令行程序</code>：用来启动一个应用。命令行程序需要实现诸如<code>应用描述</code>、<code>help</code>、<code>参数校验</code>等功能。根据需要，还可以实现<code>命令自动补全</code>、<code>打印命令行参数</code>等高级功能。</p>
<p><code>命令行参数解析</code>：用来在启动时指定应用程序的<code>命令行参数</code>，以控制应用的行为。</p>
<p><code>配置文件解析</code>：用来解析不同格式的配置文件。</p>
<p>另外，上述 <code>3</code> 类功能跟<code>业务</code>关系不大，可以抽象成一个统一的框架。</p>
<p><code>应用初始化</code>、<code>创建 API/ 非 API 服务</code>、<code>启动服务</code>，跟业务联系比较紧密，难以抽象成一个统一的框架。</p>
<h2 id="iam-apiserver-是如何构建应用框架的？"><a href="#iam-apiserver-是如何构建应用框架的？" class="headerlink" title="iam-apiserver 是如何构建应用框架的？"></a>iam-apiserver 是如何构建应用框架的？</h2><p>这里，我通过讲解 <code>iam-apiserver</code> 的应用构建方式，来给你讲解下如何构建应用。</p>
<p><code>iam-apiserver</code> 程序的 <code>main</code> 函数位于 <code>apiserver.go</code> 文件中，其构建代码可以简化为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token operator">...</span>
	<span class="token string">"github.com/marmotedu/iam/internal/apiserver"</span>
	<span class="token string">"github.com/marmotedu/iam/pkg/app"</span>
<span class="token punctuation">)</span>

 

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token operator">...</span>

	apiserver<span class="token punctuation">.</span><span class="token function">NewApp</span><span class="token punctuation">(</span><span class="token string">"iam-apiserver"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

 

<span class="token keyword">const</span> commandDesc <span class="token operator">=</span> <span class="token string">`The IAM API server validates and configures data ...`</span>

 

<span class="token comment">// NewApp creates a App object with default parameters.</span>

<span class="token keyword">func</span> <span class="token function">NewApp</span><span class="token punctuation">(</span>basename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>app<span class="token punctuation">.</span>App <span class="token punctuation">&#123;</span>

	opts <span class="token operator">:=</span> options<span class="token punctuation">.</span><span class="token function">NewOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	application <span class="token operator">:=</span> app<span class="token punctuation">.</span><span class="token function">NewApp</span><span class="token punctuation">(</span><span class="token string">"IAM API Server"</span><span class="token punctuation">,</span>
		basename<span class="token punctuation">,</span>
		app<span class="token punctuation">.</span><span class="token function">WithOptions</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">,</span>
		app<span class="token punctuation">.</span><span class="token function">WithDescription</span><span class="token punctuation">(</span>commandDesc<span class="token punctuation">)</span><span class="token punctuation">,</span>
		app<span class="token punctuation">.</span><span class="token function">WithDefaultValidArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		app<span class="token punctuation">.</span><span class="token function">WithRunFunc</span><span class="token punctuation">(</span><span class="token function">run</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>

	<span class="token keyword">return</span> application

<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">run</span><span class="token punctuation">(</span>opts <span class="token operator">*</span>options<span class="token punctuation">.</span>Options<span class="token punctuation">)</span> app<span class="token punctuation">.</span>RunFunc <span class="token punctuation">&#123;</span>

<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>basename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
		log<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Log<span class="token punctuation">)</span>
		<span class="token keyword">defer</span> log<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		cfg<span class="token punctuation">,</span> err <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">CreateConfigFromOptions</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token function">Run</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，我们是通过调用包 <code>github.com/marmotedu/iam/pkg/app</code> 来构建应用的。</p>
<p>也就是说，我们将构建应用的功能抽象成了一个 <code>Go 包</code>，通过 <code>Go 包</code>可以提高代码的封装性和复用性。</p>
<p><code>iam-authz-server</code> 和 <code>iam-pump</code> 组件也都是通过 <code>github.com/marmotedu/iam/pkg/app</code> 来构建应用的。</p>
<p>构建应用的流程也很简单，只需要创建一个 <code>application</code> 实例即可：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
opts <span class="token operator">:=</span> options<span class="token punctuation">.</span><span class="token function">NewOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

application <span class="token operator">:=</span> app<span class="token punctuation">.</span><span class="token function">NewApp</span><span class="token punctuation">(</span><span class="token string">"IAM API Server"</span><span class="token punctuation">,</span>
	basename<span class="token punctuation">,</span>
	app<span class="token punctuation">.</span><span class="token function">WithOptions</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">,</span>
	app<span class="token punctuation">.</span><span class="token function">WithDescription</span><span class="token punctuation">(</span>commandDesc<span class="token punctuation">)</span><span class="token punctuation">,</span>
	app<span class="token punctuation">.</span><span class="token function">WithDefaultValidArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	app<span class="token punctuation">.</span><span class="token function">WithRunFunc</span><span class="token punctuation">(</span><span class="token function">run</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在创建应用实例时，我传入了下面这些参数。</p>
<p><code>IAM API Server</code>：应用的简短描述。</p>
<p><code>basename</code>：应用的二进制文件名。</p>
<p><code>opts</code>：应用的命令行选项。</p>
<p><code>commandDesc</code>：应用的详细描述。</p>
<p><code>run(opts)</code>：应用的启动函数，初始化应用，并最终启动 <code>HTTP</code> 和 <code>GRPC</code> <code>Web</code> 服务。</p>
<p>创建应用时，你还可以根据需要来配置应用实例，比如 <code>iam-apiserver</code> 组件在创建应用时，指定了 <code>WithDefaultValidArgs</code> 来校验命令行非选项参数的默认校验逻辑。</p>
<p>可以看到，<code>iam-apiserver</code> 通过简单的几行代码，就创建出了一个应用。</p>
<p>之所以这么方便，是因为应用框架的构建代码都封装在了 <code>github.com/marmotedu/iam/pkg/app</code> 包中。</p>
<h2 id="App-包设计和实现"><a href="#App-包设计和实现" class="headerlink" title="App 包设计和实现"></a>App 包设计和实现</h2><p>我们先来看下 <code>App</code> 包目录下的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token punctuation">[</span>colin@dev iam<span class="token punctuation">]</span>$ <span class="token function">ls</span> pkg/app/

app.go cmd.go config.go doc.go flag.go help.go options.go
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>pkg/app</code> 目录下的 <code>5</code> 个主要文件是 <code>app.go</code>、<code>cmd.go</code>、<code>config.go</code>、<code>flag.go</code>、<code>options.go</code></p>
<p>分别实现了应用程序框架中的<code>应用</code>、<code>命令行程序</code>、<code>命令行参数解析</code>、<code>配置文件解析</code>和<code>命令行选项</code> <code>5</code> 个部分，具体关系如下图所示：</p>
<p><img src="https://i.imgloc.com/2023/06/28/VrKuRJ.png" alt="GO 语言项目开发实战 – 应用构建实战：如何构建一个优秀的企业应用框架？"></p>
<p>我再来解释下这张图。<code>应用</code>由<code>命令行程序</code>、<code>命令行参数解析</code>、<code>配置文件解析</code> 三部分组成，<code>命令行参数解析</code>功能通过<code>命令行选项</code>来构建，二者通过<code>接口</code>解耦合：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> CliOptions <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// AddFlags adds flags to the specified FlagSet object.</span>
	<span class="token comment">// AddFlags(fs *pflag.FlagSet)</span>
	<span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>fss cliflag<span class="token punctuation">.</span>NamedFlagSets<span class="token punctuation">)</span>
	<span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">error</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过接口，应用可以定制自己独有的<code>命令行参数</code>。接下来，我们再来看下如何具体构建应用的每一部分。</p>
<h3 id="第-1-步：构建应用"><a href="#第-1-步：构建应用" class="headerlink" title="第 1 步：构建应用"></a>第 1 步：构建应用</h3><p><code>APP</code> 包提供了 <code>NewApp</code> 函数来创建一个应用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">NewApp</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> basename <span class="token builtin">string</span><span class="token punctuation">,</span> opts <span class="token operator">...</span>Option<span class="token punctuation">)</span> <span class="token operator">*</span>App <span class="token punctuation">&#123;</span>

	a <span class="token operator">:=</span> <span class="token operator">&amp;</span>App<span class="token punctuation">&#123;</span>
		name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
		basename<span class="token punctuation">:</span> basename<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> o <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">&#123;</span>
		<span class="token function">o</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	a<span class="token punctuation">.</span><span class="token function">buildCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> a

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>NewApp</code> 中使用了<code>设计模式</code>中的<code>选项模式</code>，来动态地配置 <code>APP</code>，支持 <code>WithRunFunc</code>、<code>WithDescription</code>、<code>WithValidArgs</code> 等选项。</p>
<h3 id="第-2-步：命令行程序构建"><a href="#第-2-步：命令行程序构建" class="headerlink" title="第 2 步：命令行程序构建"></a>第 2 步：命令行程序构建</h3><p>这一步，我们会使用 <code>Cobra</code> 包来构建应用的命令行程序。</p>
<p><code>NewApp</code> 最终会调用 <code>buildCommand</code> 方法来创建 <code>Cobra Command</code> 类型的命令，命令的功能通过指定 <code>Cobra Command</code> 类型的各个字段来实现。</p>
<p>通常可以指定：<code>Use</code>、<code>Short</code>、<code>Long</code>、<code>SilenceUsage</code>、<code>SilenceErrors</code>、<code>RunE</code>、<code>Args</code> 等字段。</p>
<p>在 <code>buildCommand</code> 函数中，也会根据应用的设置添加不同的<code>命令行参数</code>，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">if</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>noConfig <span class="token punctuation">&#123;</span>
	<span class="token function">addConfigFlag</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>basename<span class="token punctuation">,</span> namedFlagSets<span class="token punctuation">.</span><span class="token function">FlagSet</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码的意思是：如果我们设置了 <code>noConfig=false</code>，那么就会在命令行参数 <code>global</code> 分组中添加以下<code>命令行选项</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-c, <span class="token parameter variable">--config</span> FILE Read configuration from specified FILE, support JSON, TOML, YAML, HCL, or Java properties formats.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为了更加易用和人性化，命令还具有如下 <code>3</code> 个功能。</p>
<p><code>帮助信息</code>：执行<code> -h/–help</code> 时，输出的帮助信息。通过 <code>cmd.SetHelpFunc</code> 函数可以指定帮助信息。</p>
<p><code>使用信息（可选）</code>：当用户提供无效的标志或命令时，向用户显示 “使用信息” 。通过 <code>cmd.SetUsageFunc</code> 函数，可以指定使用信息。如果不想每次输错命令打印一大堆 <code>usage</code> 信息，你可以通过设置 <code>SilenceUsage: true</code> 来关闭掉 <code>usage</code>。</p>
<p><code>版本信息</code>：打印应用的版本。知道应用的版本号，对故障排查非常有帮助。通过 <code>verflag.AddFlags</code> 可以指定版本信息。例如，<code>App</code> 包通过 <code>github.com/marmotedu/component-base/pkg/version</code> 指定了以下版本信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ ./iam-apiserver <span class="token parameter variable">--version</span>

gitVersion: v0.3.0

gitCommit: ccc31e292f66e6bad94efb1406b5ced84e64675c

gitTreeState: dirty

buildDate: <span class="token number">2020</span>-12-17T12:24:37Z

goVersion: go1.15.1

compiler: gc

platform: linux/amd64

$ ./iam-apiserver <span class="token parameter variable">--version</span><span class="token operator">=</span>raw

version.Info<span class="token punctuation">&#123;</span>GitVersion:<span class="token string">"v0.3.0"</span>, GitCommit:<span class="token string">"ccc31e292f66e6bad94efb1406b5ced84e64675c"</span>, GitTreeState:<span class="token string">"dirty"</span>, BuildDate:<span class="token string">"2020-12-17T12:24:37Z"</span>, GoVersion:<span class="token string">"go1.15.1"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"linux/amd64"</span><span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来，再来看下应用需要实现的另外一个重要功能，也就是<code>命令行参数解析</code>。</p>
<h3 id="第-3-步：命令行参数解析"><a href="#第-3-步：命令行参数解析" class="headerlink" title="第 3 步：命令行参数解析"></a>第 3 步：命令行参数解析</h3><p><code>App</code> 包在<code>构建应用</code>和<code>执行应用</code>两个阶段来实现<code>命令行参数解析</code>。</p>
<h4 id="我们先看构建应用这个阶段。"><a href="#我们先看构建应用这个阶段。" class="headerlink" title="我们先看构建应用这个阶段。"></a>我们先看<code>构建应用</code>这个阶段。</h4><p><code>App</code> 包在 <code>buildCommand</code> 方法中通过以下代码段，给<code>应用</code>添加了<code>命令行参数</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">var</span> namedFlagSets cliflag<span class="token punctuation">.</span>NamedFlagSets

<span class="token keyword">if</span> a<span class="token punctuation">.</span>options <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

	namedFlagSets <span class="token operator">=</span> a<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	fs <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> f <span class="token operator">:=</span> <span class="token keyword">range</span> namedFlagSets<span class="token punctuation">.</span>FlagSets <span class="token punctuation">&#123;</span>
		fs<span class="token punctuation">.</span><span class="token function">AddFlagSet</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>noVersion <span class="token punctuation">&#123;</span>
	verflag<span class="token punctuation">.</span><span class="token function">AddFlags</span><span class="token punctuation">(</span>namedFlagSets<span class="token punctuation">.</span><span class="token function">FlagSet</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>noConfig <span class="token punctuation">&#123;</span>
	<span class="token function">addConfigFlag</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>basename<span class="token punctuation">,</span> namedFlagSets<span class="token punctuation">.</span><span class="token function">FlagSet</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

globalflag<span class="token punctuation">.</span><span class="token function">AddGlobalFlags</span><span class="token punctuation">(</span>namedFlagSets<span class="token punctuation">.</span><span class="token function">FlagSet</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmd<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>namedFlagSets</code> 中引用了 <code>Pflag</code> 包，上述代码先通过 <code>a.options.Flags()</code> 创建并返回了一批 <code>FlagSet</code>，<code>a.options.Flags()</code> 函数会将 <code>FlagSet</code> 进行分组。</p>
<p>通过一个 <code>for</code> 循环，将 <code>namedFlagSets</code> 中保存的 <code>FlagSet</code> 添加到 <code>Cobra</code> 应用框架中的 <code>FlagSet</code> 中。</p>
<p><code>buildCommand</code> 还会根据<code>应用的配置</code>，选择性添加一些 <code>flag</code>。</p>
<p>例如，在 <code>global</code> 分组下添加 <code>–version</code> 和 <code>–config</code> 选项。</p>
<p>执行 <code>-h</code> 打印命令行参数如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>

Usage:

iam-apiserver <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

Generic flags:

<span class="token parameter variable">--server.healthz</span> Add self readiness check and <span class="token function">install</span> /healthz router. <span class="token punctuation">(</span>default <span class="token boolean">true</span><span class="token punctuation">)</span>

--server.max-ping-count int The max number of <span class="token function">ping</span> attempts when server failed to startup. <span class="token punctuation">(</span>default <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token punctuation">..</span>.

Global flags:

-h, <span class="token parameter variable">--help</span> <span class="token builtin class-name">help</span> <span class="token keyword">for</span> iam-apiserver

<span class="token parameter variable">--version</span> version<span class="token punctuation">[</span><span class="token operator">=</span>true<span class="token punctuation">]</span> Print version information and quit.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里有两个技巧，你可以借鉴。</p>
<p><em><strong>第一个技巧，将 flag 分组。</strong></em></p>
<p>一个大型系统，可能会有很多个 <code>flag</code>，例如 <code>kube-apiserver</code> 就有 <code>200</code> 多个 <code>flag</code>，这时对 <code>flag</code> 分组就很有必要了。</p>
<p>通过分组，我们可以很快地定位到需要的分组及该分组具有的标志。例如，我们想了解 <code>MySQL</code> 有哪些标志，可以找到 <code>MySQL</code> 分组：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
Mysql flags:

<span class="token parameter variable">--mysql.database</span> string

Database name <span class="token keyword">for</span> the server to use.

<span class="token parameter variable">--mysql.host</span> string

MySQL <span class="token function">service</span> <span class="token function">host</span> address. If left blank, the following related mysql options will be ignored. <span class="token punctuation">(</span>default <span class="token string">"127.0.0.1:3306"</span><span class="token punctuation">)</span>

--mysql.log-mode int

Specify gorm log level. <span class="token punctuation">(</span>default <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em><strong>第二个技巧，flag 的名字带有层级关系。</strong></em></p>
<p>这样不仅可以知道该 <code>flag</code> 属于哪个分组，而且能够避免<code>重名</code>。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ ./iam-apiserver <span class="token parameter variable">-h</span> <span class="token operator">|</span><span class="token function">grep</span> <span class="token function">host</span>

<span class="token parameter variable">--mysql.host</span> string MySQL <span class="token function">service</span> <span class="token function">host</span> address. If left blank, the following related mysql options will be ignored. <span class="token punctuation">(</span>default <span class="token string">"127.0.0.1:3306"</span><span class="token punctuation">)</span>

<span class="token parameter variable">--redis.host</span> string Hostname of your Redis server. <span class="token punctuation">(</span>default <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于 <code>MySQL</code> 和 <code>Redis</code>， 都可以指定相同的 <code>host</code> 标志，通过 <code>–mysql.host</code> 也可以知道该 <code>flag</code> 隶属于 <code>mysql</code> 分组，代表的是 <code>MySQL</code> 的 <code>host</code>。</p>
<h4 id="我们再看应用执行阶段。"><a href="#我们再看应用执行阶段。" class="headerlink" title="我们再看应用执行阶段。"></a>我们再看<code>应用执行阶段</code>。</h4><p>这时会通过 <code>viper.Unmarshal</code>，将配置 <code>Unmarshal</code> 到 <code>Options</code> 变量中。</p>
<p>这样我们就可以使用 <code>Options</code> 变量中的值，来执行后面的业务逻辑。</p>
<p>我们传入的 <code>Options</code> 是一个实现了 <code>CliOptions</code> 接口的结构体变量，<code>CliOptions</code> 接口定义为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> CliOptions <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>fss cliflag<span class="token punctuation">.</span>NamedFlagSets<span class="token punctuation">)</span>
	<span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">error</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为 <code>Options</code> 实现了 <code>Validate</code> 方法，所以我们就可以在应用框架中调用 <code>Validate</code> 方法来校验参数是否合法。</p>
<p>另外，我们还可以通过以下代码，来判断选项是否可补全和打印：如果可以补全，则补全选项；如果可以打印，则打印选项的内容。实现代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>App<span class="token punctuation">)</span> <span class="token function">applyOptionRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> completeableOptions<span class="token punctuation">,</span> ok <span class="token operator">:=</span> a<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token punctuation">(</span>CompleteableOptions<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> completeableOptions<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> errs <span class="token operator">:=</span> a<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>errs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">NewAggregate</span><span class="token punctuation">(</span>errs<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> printableOptions<span class="token punctuation">,</span> ok <span class="token operator">:=</span> a<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token punctuation">(</span>PrintableOptions<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>silence <span class="token punctuation">&#123;</span>
		log<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"%v Config: `%s`"</span><span class="token punctuation">,</span> progressMessage<span class="token punctuation">,</span> printableOptions<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过配置补全，可以确保一些重要的配置项具有默认值，当这些配置项没有被配置时，程序也仍然能够正常启动。</p>
<p>一个大型项目，有很多配置项，我们不可能对每一个配置项都进行配置。所以，给重要配置项设置默认值，就显得很重要了。</p>
<p>这里，我们来看下 <code>iam-apiserver</code> 提供的 <code>Validate</code> 方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>ServerRunOptions<span class="token punctuation">)</span> <span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">error</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">var</span> errs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">error</span>
	 
	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>GenericServerRunOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>GrpcOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>InsecureServing<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>SecureServing<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>MySQLOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>RedisOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>JwtOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>Log<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	errs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>errs<span class="token punctuation">,</span> s<span class="token punctuation">.</span>FeatureOptions<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> errs

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，每个配置分组，都实现了 <code>Validate()</code> 函数，对自己负责的配置进行校验。</p>
<p>通过这种方式，程序会更加清晰。因为只有配置提供者才更清楚如何校验自己的配置项，所以最好的做法是将配置的校验放权给配置提供者（分组）。</p>
<h3 id="第-4-步：配置文件解析"><a href="#第-4-步：配置文件解析" class="headerlink" title="第 4 步：配置文件解析"></a>第 4 步：配置文件解析</h3><p>在 <code>buildCommand</code> 函数中，通过 <code>addConfigFlag</code> 调用，添加了 <code>-c</code>, <code>–config FILE</code> 命令行参数，用来指定配置文件：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">addConfigFlag</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>basename<span class="token punctuation">,</span> namedFlagSets<span class="token punctuation">.</span><span class="token function">FlagSet</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>addConfigFlag</code> 函数代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">addConfigFlag</span><span class="token punctuation">(</span>basename <span class="token builtin">string</span><span class="token punctuation">,</span> fs <span class="token operator">*</span>pflag<span class="token punctuation">.</span>FlagSet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	fs<span class="token punctuation">.</span><span class="token function">AddFlag</span><span class="token punctuation">(</span>pflag<span class="token punctuation">.</span><span class="token function">Lookup</span><span class="token punctuation">(</span>configFlagName<span class="token punctuation">)</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">AutomaticEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">SetEnvPrefix</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>basename<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	viper<span class="token punctuation">.</span><span class="token function">SetEnvKeyReplacer</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReplacer</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	cobra<span class="token punctuation">.</span><span class="token function">OnInitialize</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">if</span> cfgFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>

			viper<span class="token punctuation">.</span><span class="token function">SetConfigFile</span><span class="token punctuation">(</span>cfgFile<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

			viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>

			<span class="token keyword">if</span> names <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>basename<span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
				viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span>filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>homedir<span class="token punctuation">.</span><span class="token function">HomeDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token operator">+</span>names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>

			viper<span class="token punctuation">.</span><span class="token function">SetConfigName</span><span class="token punctuation">(</span>basename<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">ReadInConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			<span class="token boolean">_</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"Error: failed to read configuration file(%s): %v\n"</span><span class="token punctuation">,</span> cfgFile<span class="token punctuation">,</span> err<span class="token punctuation">)</span>

			os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>addConfigFlag</code> 函数中，指定了 <code>Cobra Command</code> 在执行命令之前，需要做的初始化工作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> cfgFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigFile</span><span class="token punctuation">(</span>cfgFile<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

		viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> names <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>basename<span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>

			viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span>filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>homedir<span class="token punctuation">.</span><span class="token function">HomeDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token operator">+</span>names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		viper<span class="token punctuation">.</span><span class="token function">SetConfigName</span><span class="token punctuation">(</span>basename<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>


	<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">ReadInConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token boolean">_</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"Error: failed to read configuration file(%s): %v\n"</span><span class="token punctuation">,</span> cfgFile<span class="token punctuation">,</span> err<span class="token punctuation">)</span>

		os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码实现了以下功能：</p>
<p>如果命令行参数中没有指定配置文件的路径，则加载默认路径下的配置文件，通过 <code>viper.AddConfigPath</code>、<code>viper.SetConfigName</code> 来设<code>置配置文件搜索路径</code>和<code>配置文件名</code>。</p>
<p>通过设置默认的配置文件，可以使我们不用携带任何命令行参数，即可运行程序。</p>
<p>支持环境变量，通过 <code>viper.SetEnvPrefix</code> 来设置环境变量<code>前缀</code>，避免跟系统中的环境变量重名。</p>
<p>通过 <code>viper.SetEnvKeyReplacer</code> 重写了 <code>Env</code> 键。</p>
<p>上面，我们给<code>应用</code>添加了<code>配置文件的命令行参数</code>，并设置在命令<code>执行前</code>，<code>读取配置文件</code>。</p>
<p>在命令<code>执行时</code>，会将<code>配置文件</code>中的<code>配置项</code>和<code>命令行参数</code>绑定，并将 <code>Viper</code> 的<code>配置</code> <code>Unmarshal</code> 到<code>传入</code>的 <code>Options</code> 中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">if</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>noConfig <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">BindPFlags</span><span class="token punctuation">(</span>cmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Viper</code> 的配置是<code>命令行参数</code>和<code>配置文件配置</code> <code>merge</code> 后的配置。</p>
<p>如果在<code>配置文件</code>中指定了 <code>MySQL</code> 的 <code>host</code> 配置，并且也同时指定了 <code>–mysql.host</code> 参数，则会优先取<code>命令行参数</code>设置的值。</p>
<p>这里需要注意的是，不同于 <code>YAML</code> 格式的分级方式，配置项是通过点号<code>.</code>来分级的。</p>
<p>至此，我们已经成功构建了一个优秀的应用框架，接下来我们看下这个应用框架具有哪些优点吧。</p>
<h2 id="这样构建的应用程序，有哪些优秀特性？"><a href="#这样构建的应用程序，有哪些优秀特性？" class="headerlink" title="这样构建的应用程序，有哪些优秀特性？"></a>这样构建的应用程序，有哪些优秀特性？</h2><p>借助 <code>Cobra</code> 自带的能力，构建出的<code>应用</code>天然具备<code>帮助信息</code>、<code>使用信息</code>、<code>子命令</code>、<code>子命令自动补全</code>、<code>非选项参数校验</code>、<code>命令别名</code>、<code>PreRun</code>、<code>PostRun</code> 等功能，这些功能对于一个<code>应用</code>来说是非常有用的。</p>
<p><code>Cobra</code> 可以集成 <code>Pflag</code>，通过将创建的 <code>Pflag FlagSet</code> 绑定到 <code>Cobra 命令</code> 的 <code>FlagSet</code> 中，使得 <code>Pflag</code> 支持的<code>标志</code>能直接<code>集成</code>到 <code>Cobra 命令</code>中。</p>
<p><code>集成</code>到<code>命令</code>中有很多好处，例如：<code>cobra -h</code> 可以打印出所有设置的 <code>flag</code>，<code>Cobra Command</code> 命令提供的 <code>GenBashCompletion</code> 方法，可以实现<code>命令行选项</code>的自动补全。</p>
<p>通过 <code>viper.BindPFlags</code> 和 <code>viper.ReadInConfig</code> 函数，可以<code>统一</code> <code>配置文件</code>、<code>命令行参数</code>的配置项，使得<code>应用</code>的<code>配置项</code>更加清晰好记。</p>
<p>面对不同场景可以选择不同的配置方式，使<code>配置</code>更加灵活。例如：配置 <code>HTTPS</code> 的绑定端口，可以通过 <code>–secure.bind-port</code> 配置，也可以通过<code>配置文件</code>配置（<code>命令行参数</code>优先于<code>配置文件</code>）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">secure:
bind-address: <span class="token number">0.0</span>.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以通过 <code>viper.GetString(&quot;secure.bind-port&quot;)</code> 这类方式<code>获取</code> <code>应用</code>的<code>配置</code>，获取方式更加灵活，而且<code>全局</code>可用。</p>
<p>将应用框架的构建方法实现成了一个 <code>Go 包</code>，通过 <code>Go 包</code> 可以提高 <code>应用构建代码</code> 的 <code>封装性</code> 和 <code>复用性</code>。</p>
<h2 id="如果你想自己构建应用，需要注意些什么？"><a href="#如果你想自己构建应用，需要注意些什么？" class="headerlink" title="如果你想自己构建应用，需要注意些什么？"></a>如果你想自己构建应用，需要注意些什么？</h2><p>当然，你也可以使用其他方式构建你的应用程序。比如，我就见过很多开发者使用如下方式来构建应用：直接在 <code>main.go</code> 文件中通过 <code>gopkg.in/yaml.v3</code> 包解析配置，通过 <code>Go</code> 标准库的 <code>flag</code> 包简单地添加一些命令行参数，例如 <code>–help</code>、<code>–config</code>、<code>–version</code>。</p>
<p>但是，在你自己独立构建应用程序时，很可能会踩这么 <code>3</code> 个坑：</p>
<ol>
<li><p>构建的应用功能简单，扩展性差，导致后期扩展复杂。</p>
</li>
<li><p>构建的应用没有帮助信息和使用信息，或者信息格式杂乱，增加应用的使用难度。</p>
</li>
<li><p>命令行选项和配置文件支持的配置项相互独立，导致配合应用程序的时候，不知道该使用哪种方式来配置。</p>
</li>
</ol>
<p>在我看来，对于小的应用，自己根据需要构建没什么问题，但是对于一个大型项目的话，还是在应用开发之初，就采用一些功能多、扩展性强的优秀包。</p>
<p>这样，以后随着应用的迭代，可以零成本地进行功能添加和扩展，同时也能体现我们的专业性和技术深度，提高代码质量。</p>
<p>如果你有特殊需求，一定要自己构建应用框架，那么我有以下几个建议：</p>
<ol>
<li><p>应用框架应该清晰易读、扩展性强。</p>
</li>
<li><p>应用程序应该至少支持如下命令行选项：<code>-h</code> 打印帮助信息；<code>-v</code> 打印应用程序的版本；<code>-c</code> 支持指定配置文件的路径。</p>
</li>
<li><p>如果你的应用有很多命令行选项，那么建议支持 <code>–secure.bind-port</code> 这样的长选项，通过选项名字，就可以知道选项的作用。</p>
</li>
<li><p>配置文件使用 <code>yaml</code> 格式，<code>yaml</code> 格式的配置文件，能支持复杂的配置，还清晰易读。</p>
</li>
<li><p>如果你有多个服务，那么要保持所有服务的应用构建方式是一致的。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个<code>应用框架</code>由<code>命令</code>、<code>命令行参数解析</code>、<code>配置文件解析</code> <code>3</code> 部分功能组成，</p>
<p>我们可以通过 <code>Cobra</code> 来构建命令，</p>
<p>通过 <code>Pflag</code> 来解析命令行参数，</p>
<p>通过 <code>Viper</code> 来解析配置文件。</p>
<p>一个项目，可能包含多个应用，这些应用都需要通过 <code>Cobra</code>、<code>Viper</code>、<code>Pflag</code> 来构建。</p>
<p>为了不重复造轮子，简化应用的构建，我们可以将这些功能实现为一个 <code>Go 包</code>，方便直接调用<code>构建应用</code>。</p>
<p><code>IAM</code> 项目的应用都是通过 <code>github.com/marmotedu/iam/pkg/app</code> 包来构建的，在构建时，调用 <code>App 包</code>提供的 <code>NewApp</code> 函数，来构建一个应用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">NewApp</span><span class="token punctuation">(</span>basename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>app<span class="token punctuation">.</span>App <span class="token punctuation">&#123;</span>

	opts <span class="token operator">:=</span> options<span class="token punctuation">.</span><span class="token function">NewOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	application <span class="token operator">:=</span> app<span class="token punctuation">.</span><span class="token function">NewApp</span><span class="token punctuation">(</span><span class="token string">"IAM API Server"</span><span class="token punctuation">,</span>

		basename<span class="token punctuation">,</span>

		app<span class="token punctuation">.</span><span class="token function">WithOptions</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">,</span>

		app<span class="token punctuation">.</span><span class="token function">WithDescription</span><span class="token punctuation">(</span>commandDesc<span class="token punctuation">)</span><span class="token punctuation">,</span>

		app<span class="token punctuation">.</span><span class="token function">WithDefaultValidArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

		app<span class="token punctuation">.</span><span class="token function">WithRunFunc</span><span class="token punctuation">(</span><span class="token function">run</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token punctuation">)</span>

	<span class="token keyword">return</span> application

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在构建应用时，只需要提供应用简短 <code>/</code> <code>详细描述</code>、<code>应用二进制文件名称</code>和<code>命令行选项</code>即可。</p>
<p><code>App</code> 包会根据 <code>Options</code> 提供的 <code>Flags()</code> 方法，来给应用添加<code>命令行选项</code>。</p>
<p><code>命令行选项</code>中提供了 <code>-c</code>, <code>–config</code> 选项来指定配置文件，<code>App 包</code>也会<code>加载</code>并<code>解析</code>这个<code>配置文件</code>，并将<code>配置文件</code>和<code>命令行选项</code> 的 <code>相同配置项</code>进行 <code>Merge</code>，最终将<code>配置项的值</code>保存在传入的 <code>Options</code> 变量中，供业务代码使用。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>Pflag</tag>
        <tag>Viper</tag>
        <tag>Cobra</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title>17 | 访问认证： IAM项目设计和实现访问认证功能</title>
    <url>//post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-17-iam-app-bearer.html</url>
    <content><![CDATA[<p><strong>摘自《企业级 Go 项目开发实战》图书</strong></p>
<h2 id="如何设计-IAM-项目的认证功能？"><a href="#如何设计-IAM-项目的认证功能？" class="headerlink" title="如何设计 IAM 项目的认证功能？"></a>如何设计 IAM 项目的认证功能？</h2><p>在认证功能开发之前，我们要根据需求，认真考虑下如何设计认证功能，并在设计阶段通过技术评审。那么我们先来看下，如何设计 <code>IAM 项目</code>的认证功能。</p>
<p>首先，我们要梳理清楚认证功能的使用场景和需求。</p>
<span id="more"></span>
<p><code>IAM 项目</code>的 <code>iam-apiserver</code> 服务，提供了 <code>IAM</code> 系统的管理流功能接口，它的客户端可以是前端（这里也叫控制台），也可以是 <code>App</code> 端。</p>
<p>为了方便用户在 <code>Linux</code> 系统下调用，<code>IAM 项目</code>还提供了 <code>iamctl</code> 命令行工具。</p>
<p>为了支持在第三方代码中调用 <code>iam-apiserver</code> 提供的 <code>API</code> 接口，还支持了 <code>API</code> 调用。</p>
<p>为了提高用户在代码中调用 <code>API</code> 接口的效率，<code>IAM 项目</code>提供了 <code>Go SDK</code>。</p>
<p>可以看到，<code>iam-apiserver</code> 有很多客户端，每种客户端适用的认证方式是有区别的。</p>
<p><code>控制台</code>、<code>App 端</code> <code>需要登录</code>系统，所以需要使用<code>用户名：密码</code>这种认证方式，也即 <code>Basic</code> 认证。</p>
<p><code>iamctl</code>、<code>API 调用</code>、<code>Go SDK</code> 因为可以<code>不用登录</code>系统，所以可以采用更安全的认证方式：<code>Bearer 认证</code>。</p>
<p>同时，<code>Basic 认证</code>作为 <code>iam-apiserver</code> 已经集成的认证方式，仍然可以供 <code>iamctl</code>、<code>API 调用</code>、<code>Go SDK</code> 使用。</p>
<p>这里有个地方需要注意：如果 <code>iam-apiserver</code> 采用 <code>Bearer Token</code> 的认证方式，目前最受欢迎的 <code>Token</code> 格式是 <code>JWT Token</code>。</p>
<p>而 <code>JWT Token</code> 需要<code>密钥</code>（后面统一用 <code>secretKey</code> 来指代），因此需要在 <code>iam-apiserver</code> 服务中为每个用户维护一个密钥，这样会增加开发和维护成本。</p>
<p>业界有一个更好的实现方式：将 <code>iam-apiserver</code> 提供的 <code>API 接口</code>注册到 <code>API 网关</code>中，通过 <code>API 网关</code>中的 <code>Token 认证</code>功能，来实现对 <code>iam-apiserver</code> <code>API 接口</code>的认证。</p>
<p>有很多 <code>API 网关</code>可供选择，例如<code>腾讯云 API 网关</code>、<code>Tyk</code>、<code>Kong</code> 等。</p>
<p>这里需要你注意：通过 <code>iam-apiserver</code> 创建的<code>密钥对</code>是提供给 <code>iam-authz-server</code> 使用的。</p>
<p>另外，我们还需要调用 <code>iam-authz-server</code> 提供的 <code>RESTful API</code> 接口：<code>/v1/authz</code>，来进行资源授权。</p>
<p><code>API 调用</code>比较适合采用的认证方式是 <code>Bearer</code> 认证。</p>
<p>当然，<code>/v1/authz</code> 也可以直接注册到 <code>API 网关</code>中。在实际的 <code>Go 项目</code>开发中，也是我推荐的一种方式。</p>
<p>但在这里，为了展示实现 <code>Bearer</code> 认证的过程，<code>iam-authz-server</code> 自己实现了 <code>Bearer</code> 认证。</p>
<p>讲到 <code>iam-authz-server</code> <code>Bearer</code> 认证实现的时候，我会详细介绍这一点。</p>
<p><code>Basic</code> 认证需要<code>用户名</code>和<code>密码</code>，<code>Bearer</code> 认证则需要<code>密钥</code>，所以 <code>iam-apiserver</code> 需要将<code>用户名 / 密码</code>、<code>密钥</code>等信息<code>保存</code>在<code>后端</code>的 <code>MySQL</code> 中，持久存储起来。</p>
<p>在进行认证的时候，需要获取<code>密码</code>或<code>密钥</code>进行反加密，这就需要查询<code>密码</code>或<code>密钥</code>。</p>
<p>查询<code>密码</code>或<code>密钥</code>有两种方式。一种是在<code>请求到达时</code>查询数据库。因为数据库的<code>查询操作延时</code>高，会导致<code> API 接口延时</code>较高，所以不太适合用在<code>数据流组件</code>中。</p>
<p>另外一种是将<code>密码</code>或<code>密钥</code>缓存在<code>内存</code>中，这样请求到来时，就可以直接从<code>内存</code>中<code>查询</code>，从而提升<code>查询速度</code>，提高<code>接口性能</code>。</p>
<p>但是，将<code>密码</code>或<code>密钥</code>缓存在<code>内存</code>中时，就要考虑<code>内存</code>和<code>数据库</code>的数据<code>一致性</code>，这会增加代码实现的复杂度。</p>
<p>因为<code>管控流组件</code>对<code>性能延时</code>要求不那么敏感，而<code>数据流组件</code>则一定要实现<code>非常高的接口性能</code>，所以 <code>iam-apiserver</code> 在请求到来时<code>查询数据库</code>，而 <code>iam-authz-server</code> 则将<code>密钥信息</code>缓存在<code>内存</code>中。</p>
<p>那在这里，可以总结出一张 <code>IAM 项目</code>的认证设计图：</p>
<p><img src="https://i.imgloc.com/2023/06/29/V3RwLw.jpeg" alt="GO 语言项目开发实战 – IAM项目是如何设计和实现访问认证功能的？"></p>
<p>另外，为了将<code>控制流</code>和<code>数据流</code>区分开来，<code>密钥</code>的 <code>CURD</code> 操作也放在了 <code>iam-apiserver</code> 中，但是 <code>iam-authz-server</code> 需要用到这些<code>密钥</code>信息。</p>
<p>为了解决这个问题，目前的做法是：<code>iam-authz-server</code> 通过 <code>gRPC API</code> 请求 <code>iam-apiserver</code>，获取所有的<code>密钥</code>信息；</p>
<p>当 <code>iam-apiserver</code> 有密钥<code>更新</code>时，会 <code>Pub</code> 一条消息到 <code>Redis Channel</code> 中。因为 <code>iam-authz-server</code> <code>订阅</code>了同一个 <code>Redis Channel</code>，<code>iam-authz-searver</code> 监听到 <code>channel</code> 有 <code>新消息</code> 时，会<code>获取</code>、<code>解析</code>消息，并<code>更新</code>它<code>缓存</code>的<code>密钥</code>信息。</p>
<p>这样，我们就能确保 <code>iam-authz-server</code> 内存中<code>缓存的密钥</code>和 <code>iam-apiserver</code> 中的<code>密钥</code>保持一致。</p>
<p>学到这里，你可能会问：将所有<code>密钥</code>都缓存在 <code>iam-authz-server</code> 中，那岂不是要占用很大的<code>内存</code>？别担心，这个问题我也想过，并且替你计算好了：<code>8G 的内存</code>大概能保存约 <code>8 千万</code>个密钥信息，完全够用。后期不够用的话，可以<code>加大内存</code>。</p>
<p>不过这里还是有个小缺陷：如果 <code>Redis down</code> 掉，或者出现<code>网络抖动</code>，可能会造成 <code>iam-apiserver</code> 中和 <code>iam-authz-server</code> 内存中保存的<code>密钥</code>数据不一致，但这不妨碍我们学习认证功能的设计和实现。</p>
<p>至于如何保证<code>缓存系统</code>的数据一致性，我会在新一期的特别放送里专门介绍下。</p>
<p>最后注意一点：<code>Basic 认证</code>请求和 <code>Bearer 认证</code>请求都可能被<code>截获</code>并<code>重放</code>。所以，为了确保 <code>Basic 认证</code>和 <code>Bearer 认证</code>的安全性，和<code>服务端</code> <code>通信</code>时都需要配合使用 <code>HTTPS</code> 协议。</p>
<h2 id="IAM-项目是如何实现-Basic-认证的？"><a href="#IAM-项目是如何实现-Basic-认证的？" class="headerlink" title="IAM 项目是如何实现 Basic 认证的？"></a>IAM 项目是如何实现 Basic 认证的？</h2><p>我们已经知道，<code>IAM 项目</code>中主要用了 <code>Basic</code> 和 <code>Bearer</code> 这两种认证方式。我们要支持 <code>Basic</code> 认证和 <code>Bearer</code> 认证，并根据需要选择不同的认证方式，这很容易让我们想到使用设计模式中的策略模式来实现。</p>
<p>所以，在 <code>IAM 项目</code>中，我将每一种<code>认证方式</code>都视作一个<code>策略</code>，通过选择不同的<code>策略</code>，来使用不同的<code>认证方法</code>。</p>
<p><code>IAM 项目</code>实现了如下策略：</p>
<ol>
<li><p><code>auto 策略</code>：该策略会根据 <code>HTTP</code> 头 <code>Authorization: Basic XX.YY.ZZ</code> 和 <code>Authorization: Bearer XX.YY.ZZ</code> 自动选择使用 <code>Basic 认证</code>还是 <code>Bearer 认证</code>。</p>
</li>
<li><p><code>basic 策略</code>：该策略实现了 <code>Basic 认证</code>。</p>
</li>
<li><p><code>jwt 策略</code>：该策略实现了 <code>Bearer 认证</code>，<code>JWT</code> 是 <code>Bearer 认证</code>的具体实现。</p>
</li>
<li><p><code>cache 策略</code>：该策略其实是一个 <code>Bearer 认证</code>的实现，<code>Token</code> 采用了 <code>JWT</code> 格式，因为 <code>Token</code> 中的 <code>密钥 ID</code> 是从 <code>内存</code> 中获取的，所以叫 <code>Cache 认证</code>。这一点后面会详细介绍。</p>
</li>
</ol>
<p><code>iam-apiserver</code> 通过创建需要的<code>认证策略</code>，并 <code>加载</code> 到需要认证的 <code>API 路由</code>上，来实现 <code>API 认证</code>。具体代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">jwtStrategy<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">newJWTAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>auth<span class="token punctuation">.</span>JWTStrategy<span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">,</span> jwtStrategy<span class="token punctuation">.</span>LoginHandler<span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">,</span> jwtStrategy<span class="token punctuation">.</span>LogoutHandler<span class="token punctuation">)</span>

<span class="token comment">// Refresh time can be longer than token timeout</span>

g<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/refresh"</span><span class="token punctuation">,</span> jwtStrategy<span class="token punctuation">.</span>RefreshHandler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中，我们通过 <code>newJWTAuth</code> 函数创建了 <code>auth.JWTStrategy</code> 类型的变量，该变量包含了一些认证相关函数。</p>
<p><code>LoginHandler</code>：实现了 <code>Basic</code> 认证，完成<code>登陆认证</code>。</p>
<p><code>RefreshHandler</code>：重新刷新 <code>Token</code> 的过期时间。</p>
<p><code>LogoutHandler</code>：用户注销时调用。登陆成功后，如果在 <code>Cookie</code> 中设置了认证相关的信息，执行 <code>LogoutHandler</code> 则会清空这些信息。</p>
<p>下面，我来分别介绍下 <code>LoginHandler</code>、<code>RefreshHandler</code> 和 <code>LogoutHandler</code>。</p>
<p><code>LoginHandler</code></p>
<p>这里，我们来看下 <code>LoginHandler</code> <code>Gin</code> 中间件，该函数定义位于 <code>github.com/appleboy/gin-jwt</code> 包的 <code>auth_jwt.go</code> 文件中。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>mw <span class="token operator">*</span>GinJWTMiddleware<span class="token punctuation">)</span> <span class="token function">LoginHandler</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> mw<span class="token punctuation">.</span>Authenticator <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrMissingAuthenticatorFunc<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>

	data<span class="token punctuation">,</span> err <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">Authenticator</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// Create the token</span>
	token <span class="token operator">:=</span> jwt<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>jwt<span class="token punctuation">.</span><span class="token function">GetSigningMethod</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>SigningAlgorithm<span class="token punctuation">)</span><span class="token punctuation">)</span>

	claims <span class="token operator">:=</span> token<span class="token punctuation">.</span>Claims<span class="token punctuation">.</span><span class="token punctuation">(</span>jwt<span class="token punctuation">.</span>MapClaims<span class="token punctuation">)</span>

	<span class="token keyword">if</span> mw<span class="token punctuation">.</span>PayloadFunc <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> mw<span class="token punctuation">.</span><span class="token function">PayloadFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			claims<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
		<span class="token punctuation">&#125;</span>

	<span class="token punctuation">&#125;</span>

	expire <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">TimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>Timeout<span class="token punctuation">)</span>

	claims<span class="token punctuation">[</span><span class="token string">"exp"</span><span class="token punctuation">]</span> <span class="token operator">=</span> expire<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	claims<span class="token punctuation">[</span><span class="token string">"orig_iat"</span><span class="token punctuation">]</span> <span class="token operator">=</span> mw<span class="token punctuation">.</span><span class="token function">TimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	tokenString<span class="token punctuation">,</span> err <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">signedString</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrFailedTokenCreation<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	<span class="token comment">// set cookie</span>
	<span class="token keyword">if</span> mw<span class="token punctuation">.</span>SendCookie <span class="token punctuation">&#123;</span>

		expireCookie <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">TimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>CookieMaxAge<span class="token punctuation">)</span>

		maxage <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>expireCookie<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> mw<span class="token punctuation">.</span><span class="token function">TimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> mw<span class="token punctuation">.</span>CookieSameSite <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>

			c<span class="token punctuation">.</span><span class="token function">SetSameSite</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>CookieSameSite<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		c<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>

			mw<span class="token punctuation">.</span>CookieName<span class="token punctuation">,</span>

			tokenString<span class="token punctuation">,</span>

			maxage<span class="token punctuation">,</span>

			<span class="token string">"/"</span><span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>CookieDomain<span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>SecureCookie<span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>CookieHTTPOnly<span class="token punctuation">,</span>
		<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	mw<span class="token punctuation">.</span><span class="token function">LoginResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> tokenString<span class="token punctuation">,</span> expire<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从 <code>LoginHandler</code> 函数的代码实现中，我们可以知道，<code>LoginHandler</code> 函数会执行 <code>Authenticator</code> 函数，来完成 <code>Basic</code> 认证。</p>
<p>如果认证通过，则会签发 <code>JWT Token</code>，并执行 <code>PayloadFunc</code> 函数设置 <code>Token Payload</code>。</p>
<p>如果我们设置了 <code>SendCookie=true</code> ，还会在 <code>Cookie</code> 中添加认证相关的信息，例如 <code>Token</code>、<code>Token 的生命周期</code>等，最后执行 <code>LoginResponse</code> 方法返回 <code>Token</code> 和 <code>Token</code> 的过期时间。</p>
<p><code>Authenticator</code>、<code>PayloadFunc</code>、<code>LoginResponse</code>这三个函数，是我们在创建 <code>JWT 认证策略</code>时指定的。</p>
<p>下面我来分别介绍下。</p>
<p><strong>先来看下 <code>Authenticator</code> 函数 。</strong></p>
<p><code>Authenticator</code> 函数从 <code>HTTP Authorization Header</code> 中获取<code>用户名</code>和<code>密码</code>，并校验<code>密码</code>是否合法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">authenticator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">var</span> login loginInfo

		<span class="token keyword">var</span> err <span class="token builtin">error</span>

		<span class="token comment">// support header and body both</span>

		<span class="token keyword">if</span> c<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>

			login<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">parseWithHeader</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>

			login<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">parseWithBody</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> jwt<span class="token punctuation">.</span>ErrFailedAuthentication

		<span class="token punctuation">&#125;</span>

		<span class="token comment">// Get the user information by the login username.</span>

		user<span class="token punctuation">,</span> err <span class="token operator">:=</span> store<span class="token punctuation">.</span><span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Users</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> login<span class="token punctuation">.</span>Username<span class="token punctuation">,</span> metav1<span class="token punctuation">.</span>GetOptions<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"get user information failed: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> jwt<span class="token punctuation">.</span>ErrFailedAuthentication

		<span class="token punctuation">&#125;</span>

		<span class="token comment">// Compare the login password with the user password.</span>

		<span class="token keyword">if</span> err <span class="token operator">:=</span> user<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>login<span class="token punctuation">.</span>Password<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> jwt<span class="token punctuation">.</span>ErrFailedAuthentication

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">return</span> user<span class="token punctuation">,</span> <span class="token boolean">nil</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Authenticator</code> 函数需要获取<code>用户名</code>和<code>密码</code>。它首先会判断是否有 <code>Authorization</code> 请求头，如果有，则调用 <code>parseWithHeader</code> 函数获取<code>用户名</code>和<code>密码</code>，否则调用<code>parseWithBody</code>从 <code>Body</code> 中获取<code>用户名</code>和<code>密码</code>。</p>
<p>如果都获取失败，则返回<code>认证失败</code>错误。</p>
<p>所以，<code>IAM 项目</code>的 <code>Basic</code> 支持以下两种请求方式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 用户名:密码通过base64加码后，通过HTTP Authorization Header进行传递，因为密码非明文，建议使用这种方式。</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">"Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ=="</span> http://127.0.0.1:8080/login
<span class="token comment"># 用户名和密码在HTTP Body中传递，因为密码是明文，所以这里不建议实际开发中，使用这种方式。</span>
$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">'Content-Type: application/json'</span> -d<span class="token string">'&#123;"username":"admin","password":"Admin@2021"&#125;'</span> http://127.0.0.1:8080/login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>我们来看下 <code>parseWithHeader</code> 是如何获取<code>用户名</code>和<code>密码</code>的。</strong></p>
<p>假设我们的请求为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">"Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ=="</span> http://127.0.0.1:8080/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，<code>YWRtaW46QWRtaW5AMjAyMQ==</code>值由以下命令生成：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">'admin:Admin@2021'</span><span class="token operator">|</span>base64
<span class="token assign-left variable">YWRtaW46QWRtaW5AMjAyMQ</span><span class="token operator">==</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>parseWithHeader</code> 实际上执行的是上述命令的逆向步骤：</p>
<p>获取 <code>Authorization</code> 头的值，并调用 <code>strings.SplitN</code> 函数，获取一个切片变量 <code>auth</code>，其值为 <code>[&quot;Basic&quot;,&quot;YWRtaW46QWRtaW5AMjAyMQ==&quot;]</code> 。</p>
<p>将 <code>YWRtaW46QWRtaW5AMjAyMQ==</code> 进行 <code>base64</code> 解码，得到 <code>admin:Admin@2021</code> 。</p>
<p>调用 <code>strings.SplitN</code> 函数获取<code> admin:Admin@2021</code> ，得到用户名为 <code>admin</code>，密码为 <code>Admin@2021</code>。</p>
<p><code>parseWithBody</code> 则是调用了 <code>Gin</code> 的 <code>ShouldBindJSON</code> 函数，来从 <code>Body</code> 中解析出<code>用户名</code>和<code>密码</code>。</p>
<p>获取到<code>用户名</code>和<code>密码</code>之后，程序会从数据库中查询出该用户对应的加密后的密码，这里我们假设是<code>xxxx</code>。</p>
<p>最后 <code>authenticator</code> 函数调用 <code>user.Compare</code> 来判断 <code>xxxx</code> 是否和通过 <code>user.Compare</code> 加密后的字符串相匹配，如果匹配则认证成功，否则返回认证失败。</p>
<p><strong>再来看下 <code>PayloadFunc</code> 函数</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">payloadFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> jwt<span class="token punctuation">.</span>MapClaims <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> jwt<span class="token punctuation">.</span>MapClaims <span class="token punctuation">&#123;</span>

		claims <span class="token operator">:=</span> jwt<span class="token punctuation">.</span>MapClaims<span class="token punctuation">&#123;</span>

			<span class="token string">"iss"</span><span class="token punctuation">:</span> APIServerIssuer<span class="token punctuation">,</span>

			<span class="token string">"aud"</span><span class="token punctuation">:</span> APIServerAudience<span class="token punctuation">,</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> u<span class="token punctuation">,</span> ok <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>User<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>

			claims<span class="token punctuation">[</span>jwt<span class="token punctuation">.</span>IdentityKey<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">.</span>Name

			claims<span class="token punctuation">[</span><span class="token string">"sub"</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">.</span>Name

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">return</span> claims

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>PayloadFunc</code> 函数会设置 <code>JWT Token</code> 中 <code>Payload</code> 部分的 <code>iss</code>、<code>aud</code>、<code>sub</code>、<code>identity</code> 字段，供后面使用。</p>
<p><strong>再来看下我们刚才说的第三个函数，<code>LoginResponse</code> 函数：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">loginResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> code <span class="token builtin">int</span><span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">,</span> expire time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> code <span class="token builtin">int</span><span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">,</span> expire time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span>

			<span class="token string">"token"</span><span class="token punctuation">:</span> token<span class="token punctuation">,</span>

			<span class="token string">"expire"</span><span class="token punctuation">:</span> expire<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>RFC3339<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数用来在 <code>Basic</code> 认证成功之后，返回 <code>Token</code> 和 <code>Token</code> 的<code>过期时间</code>给调用者：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> <span class="token parameter variable">-XPOST</span> -H<span class="token string">"Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ=="</span> http://127.0.0.1:8080/login
<span class="token punctuation">&#123;</span><span class="token string">"expire"</span><span class="token builtin class-name">:</span><span class="token string">"2021-09-29T01:38:49+08:00"</span>,<span class="token string">"token"</span><span class="token builtin class-name">:</span><span class="token string">"XX.YY.ZZ"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>登陆成功</code>后，<code>iam-apiserver</code> 会返回 <code>Token</code> 和 <code>Token</code> 的<code>过期时间</code>，前端可以将这些信息缓存在 <code>Cookie</code> 中或 <code>LocalStorage</code> 中，之后的请求都可以使用 <code>Token</code> 来进行认证。</p>
<p>使用 <code>Token</code> 进行认证，不仅能够提高认证的安全性，还能够避免查询数据库，从而提高认证效率。</p>
<p><strong><code>RefreshHandler</code></strong></p>
<p><code>RefreshHandler</code> 函数会先执行 <code>Bearer</code> 认证，如果认证通过，则会重新签发 <code>Token</code>。</p>
<p><code>LogoutHandler</code></p>
<p><strong>最后，来看下 <code>LogoutHandler</code> 函数：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mw <span class="token operator">*</span>GinJWTMiddleware<span class="token punctuation">)</span> <span class="token function">LogoutHandler</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// delete auth cookie</span>

	<span class="token keyword">if</span> mw<span class="token punctuation">.</span>SendCookie <span class="token punctuation">&#123;</span>

		<span class="token keyword">if</span> mw<span class="token punctuation">.</span>CookieSameSite <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>

			c<span class="token punctuation">.</span><span class="token function">SetSameSite</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>CookieSameSite<span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>

		c<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>

			mw<span class="token punctuation">.</span>CookieName<span class="token punctuation">,</span>

			<span class="token string">""</span><span class="token punctuation">,</span>

			<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>

			<span class="token string">"/"</span><span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>CookieDomain<span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>SecureCookie<span class="token punctuation">,</span>

			mw<span class="token punctuation">.</span>CookieHTTPOnly<span class="token punctuation">,</span>
		<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>
	mw<span class="token punctuation">.</span><span class="token function">LogoutResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，<code>LogoutHandler</code> 其实是用来清空 <code>Cookie</code> 中 <code>Bearer</code> 认证相关信息的。</p>
<p><em><strong>最后，我们来做个总结</strong></em>：</p>
<p><code>Basic 认证</code>通过 <code>用户名</code> 和 <code>密码</code> 来进行认证，通常用在登陆接口 <code>/login</code> 中。</p>
<p>用户登陆成功后，会返回 <code>JWT Token</code>，前端会保存该 <code>JWT Token</code> 在浏览器的 <code>Cookie</code> 或 <code>LocalStorage</code> 中，供后续请求使用。</p>
<p>后续请求时，均会携带该 <code>Token</code>，以完成 <code>Bearer</code> 认证。</p>
<p>另外，有了登陆接口，一般还会配套 <code>/logout</code> 接口和 <code>/refresh</code> 接口，分别用来进行 <code>注销</code> 和 <code>刷新 Token</code>。</p>
<p>这里你可能会问，为什么要刷新 <code>Token</code>？</p>
<p>因为通过登陆接口签发的 <code>Token</code> 有<code>过期时间</code>，有了<code>刷新</code>接口，<code>前端</code>就可以<code>根据需要</code>，自行刷新 <code>Token</code> 的<code>过期时间</code>。</p>
<p><code>过期时间</code>可以通过 <code>iam-apiserver</code> 配置文件的 <code>jwt.timeout</code> 配置项来指定。</p>
<p>登陆后签发 <code>Token</code> 时，使用的密钥（<code>secretKey</code>）由 <code>jwt.key</code> 配置项来指定。</p>
<h2 id="IAM-项目是如何实现-Bearer-认证的？"><a href="#IAM-项目是如何实现-Bearer-认证的？" class="headerlink" title="IAM 项目是如何实现 Bearer 认证的？"></a>IAM 项目是如何实现 Bearer 认证的？</h2><p>上面我们介绍了 Basic 认证。这里，我再来介绍下 <code>IAM 项目</code>中 Bearer 认证的实现方式。</p>
<p><code>IAM 项目</code>中有两个地方实现了 Bearer 认证，分别是 iam-apiserver 和 iam-authz-server。下面我来分别介绍下它们是如何实现 Bearer 认证的。</p>
<h3 id="iam-authz-server-Bearer-认证实现"><a href="#iam-authz-server-Bearer-认证实现" class="headerlink" title="iam-authz-server Bearer 认证实现"></a>iam-authz-server Bearer 认证实现</h3><p>先来看下 <code>iam-authz-server</code> 是如何实现 <code>Bearer 认证</code>的。</p>
<p><code>iam-authz-server</code> 通过在 <code>/v1</code> 路由分组中加载 <code>cache</code> 认证<code>中间件</code>来使用 <code>cache 认证策略</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
auth <span class="token operator">:=</span> <span class="token function">newCacheAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

apiv1 <span class="token operator">:=</span> g<span class="token punctuation">.</span><span class="token function">Group</span><span class="token punctuation">(</span><span class="token string">"/v1"</span><span class="token punctuation">,</span> auth<span class="token punctuation">.</span><span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>来看下<code>newCacheAuth</code>函数：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newCacheAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> middleware<span class="token punctuation">.</span>AuthStrategy <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> auth<span class="token punctuation">.</span><span class="token function">NewCacheStrategy</span><span class="token punctuation">(</span><span class="token function">getSecretFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>



<span class="token keyword">func</span> <span class="token function">getSecretFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>auth<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>kid <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>auth<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		cli<span class="token punctuation">,</span> err <span class="token operator">:=</span> store<span class="token punctuation">.</span><span class="token function">GetStoreInsOr</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			<span class="token keyword">return</span> auth<span class="token punctuation">.</span>Secret<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"get store instance failed"</span><span class="token punctuation">)</span>

		<span class="token punctuation">&#125;</span>


		secret<span class="token punctuation">,</span> err <span class="token operator">:=</span> cli<span class="token punctuation">.</span><span class="token function">GetSecret</span><span class="token punctuation">(</span>kid<span class="token punctuation">)</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

			<span class="token keyword">return</span> auth<span class="token punctuation">.</span>Secret<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> err

		<span class="token punctuation">&#125;</span>


		<span class="token keyword">return</span> auth<span class="token punctuation">.</span>Secret<span class="token punctuation">&#123;</span>

			Username<span class="token punctuation">:</span> secret<span class="token punctuation">.</span>Username<span class="token punctuation">,</span>

			ID<span class="token punctuation">:</span> secret<span class="token punctuation">.</span>SecretId<span class="token punctuation">,</span>

			Key<span class="token punctuation">:</span> secret<span class="token punctuation">.</span>SecretKey<span class="token punctuation">,</span>

			Expires<span class="token punctuation">:</span> secret<span class="token punctuation">.</span>Expires<span class="token punctuation">,</span>

		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>newCacheAuth</code> 函数调用 <code>auth.NewCacheStrategy</code> 创建了一个 <code>cache 认证策略</code>，创建时传入了 <code>getSecretFunc</code> 函数，该函数会返回<code>密钥的信息</code>。<code>密钥信息</code>包含了以下字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> Secret <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>

	Username <span class="token builtin">string</span>

	ID <span class="token builtin">string</span>

	Key <span class="token builtin">string</span>

	Expires <span class="token builtin">int64</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>再来看下 <code>cache 认证策略</code> 实现的 <code>AuthFunc</code> 方法：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>cache CacheStrategy<span class="token punctuation">)</span> <span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		header <span class="token operator">:=</span> c<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrMissingHeader<span class="token punctuation">,</span> <span class="token string">"Authorization header cannot be empty."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">var</span> rawJWT <span class="token builtin">string</span>

		<span class="token comment">// Parse the header to get the token part.</span>

		fmt<span class="token punctuation">.</span><span class="token function">Sscanf</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> <span class="token string">"Bearer %s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rawJWT<span class="token punctuation">)</span>

		<span class="token comment">// Use own validation logic, see below</span>

		<span class="token keyword">var</span> secret Secret

		claims <span class="token operator">:=</span> <span class="token operator">&amp;</span>jwt<span class="token punctuation">.</span>MapClaims<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

		<span class="token comment">// Verify the token</span>

		parsedT<span class="token punctuation">,</span> err <span class="token operator">:=</span> jwt<span class="token punctuation">.</span><span class="token function">ParseWithClaims</span><span class="token punctuation">(</span>rawJWT<span class="token punctuation">,</span> claims<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>token <span class="token operator">*</span>jwt<span class="token punctuation">.</span>Token<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

			<span class="token comment">// Validate the alg is HMAC signature</span>

			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> token<span class="token punctuation">.</span>Method<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>jwt<span class="token punctuation">.</span>SigningMethodHMAC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

				<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected signing method: %v"</span><span class="token punctuation">,</span> token<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"alg"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

			<span class="token punctuation">&#125;</span>

			kid<span class="token punctuation">,</span> ok <span class="token operator">:=</span> token<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"kid"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>

			<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

				<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrMissingKID

			<span class="token punctuation">&#125;</span>

			<span class="token keyword">var</span> err <span class="token builtin">error</span>

			secret<span class="token punctuation">,</span> err <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>kid<span class="token punctuation">)</span>

			<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

				<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrMissingSecret

			<span class="token punctuation">&#125;</span>

			<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span>Key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>

		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> jwt<span class="token punctuation">.</span><span class="token function">WithAudience</span><span class="token punctuation">(</span>AuthzAudience<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token operator">!</span>parsedT<span class="token punctuation">.</span>Valid <span class="token punctuation">&#123;</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrSignatureInvalid<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> <span class="token function">KeyExpired</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span>Expires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

			tm <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span>Expires<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrExpired<span class="token punctuation">,</span> <span class="token string">"expired at: %s"</span><span class="token punctuation">,</span> tm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>CtxUsername<span class="token punctuation">,</span> secret<span class="token punctuation">.</span>Username<span class="token punctuation">)</span>

		c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">// KeyExpired checks if a key has expired, if the value of user.SessionState.Expires is 0, it will be ignored.</span>

<span class="token keyword">func</span> <span class="token function">KeyExpired</span><span class="token punctuation">(</span>expires <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">if</span> expires <span class="token operator">>=</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span>expires<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>AuthFunc</code> 函数依次执行了以下<code>四</code>大步来完成 <code>JWT</code> 认证，每一步中又有一些<code>小步骤</code>，下面我们来一起看看。</p>
<ol>
<li><p>从 <code>Authorization: Bearer XX.YY.ZZ</code> 请求头中获取 <code>XX.YY.ZZ</code>，<code>XX.YY.ZZ</code> 即为 <code>JWT Token</code>。</p>
</li>
<li><p>调用 <code>github.com/dgrijalva/jwt-go</code> 包提供的 <code>ParseWithClaims</code> 函数，该函数会依次执行下面四步操作。</p>
</li>
</ol>
<p>调用 <code>ParseUnverified</code> 函数，依次执行以下操作：</p>
<p><em><strong>1)</strong></em> 从 <code>Token</code> 中获取第一段 <code>XX</code>，<code>base64 解码</code>后得到 <code>JWT Token</code> 的 <code>Header&#123;“alg”:“HS256”,“kid”:“a45yPqUnQ8gljH43jAGQdRo0bXzNLjlU0hxa”,“typ”:“JWT”&#125;</code>。</p>
<p><em><strong>2)</strong></em> 从 <code>Token</code> 中获取第一段 <code>YY</code>，<code>base64 解码</code>后得到 JWT Token 的 <code>Payload</code> <code>&#123;“aud”:“iam.authz.marmotedu.com”,“exp”:1625104314,“iat”:1625097114,“iss”:“iamctl”,“nbf”:1625097114&#125;</code>。</p>
<p><em><strong>3)</strong></em> 根据 <code>Token Header</code> 中的 <code>alg</code> 字段，获取 <code>Token</code> 加密函数。</p>
<p><em><strong>4)</strong></em> 最终 <code>ParseUnverified</code> 函数会返回 <code>Token</code> 类型的变量，<code>Token</code> 类型包含 <code>Method</code>、<code>Header</code>、<code>Claims</code>、<code>Valid</code> 这些重要字段，这些字段会用于后续的认证步骤中。</p>
<p>调用传入的 <code>keyFunc</code> 获取密钥，这里来看下 <code>keyFunc</code> 的实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>token <span class="token operator">*</span>jwt<span class="token punctuation">.</span>Token<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token comment">// Validate the alg is HMAC signature</span>

	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> token<span class="token punctuation">.</span>Method<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>jwt<span class="token punctuation">.</span>SigningMethodHMAC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected signing method: %v"</span><span class="token punctuation">,</span> token<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"alg"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>


	kid<span class="token punctuation">,</span> ok <span class="token operator">:=</span> token<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"kid"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrMissingKID

	<span class="token punctuation">&#125;</span>


	<span class="token keyword">var</span> err <span class="token builtin">error</span>

	secret<span class="token punctuation">,</span> err <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>kid<span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrMissingSecret

	<span class="token punctuation">&#125;</span>


	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span>Key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，<code>keyFunc</code> 接受 <code>*Token</code> 类型的变量，并获取 <code>Token Header</code> 中的 <code>kid</code>，<code>kid</code> 即为<code>密钥 ID</code>：<code>secretID</code>。</p>
<p>接着，调用 <code>cache.get(kid)</code> 获取密钥 <code>secretKey</code>。</p>
<p><code>cache.get</code> 函数即为 <code>getSecretFunc</code>，<code>getSecretFunc</code> 函数会根据 <code>kid</code>，从内存中查找密钥信息，密钥信息中包含了 <code>secretKey</code>。</p>
<p>从 <code>Token</code> 中获取 <code>Signature</code> 签名字符串 <code>ZZZ</code>，也即 <code>Token</code> 的第三段。</p>
<p>获取到 <code>secretKey</code> 之后，<code>token.Method.Verify</code> 验证 <code>Signature</code> 签名字符串 <code>ZZZ</code>，也即 <code>Token</code> 的第三段是否合法。</p>
<p><code>token.Method.Verify</code> 实际上是使用了相同的加密算法和相同的 <code>secretKey</code> 加密 <code>XX.YY</code> 字符串。</p>
<p>假设加密之后的字符串为 <code>WW</code>，接下来会用 <code>WW</code> 和 <code>ZZ</code> <code>base64 解码</code>后的字符串进行比较，如果相等则认证通过，如果不相等则认证失败。</p>
<p>第三步，调用 <code>KeyExpired</code>，验证 <code>secret</code> 是否过期。<code>secret</code> 信息中包含<code>过期时间</code>，你只需要拿该<code>过期时间</code>和<code>当前时间</code>对比就行。</p>
<p>第四步，设置 <code>HTTP Header username: colin</code>。</p>
<p>到这里，<code>iam-authz-server</code> 的 <code>Bearer</code> 认证分析就完成了。</p>
<p>我们来做个总结：<code>iam-authz-server</code> 通过加载 <code>Gin</code> 中间件的方式，在请求 <code>/v1/authz</code> 接口时进行访问认证。</p>
<p>因为 <code>Bearer</code> 认证具有过期时间，而且可以在认证字符串中携带更多有用信息，还具有不可逆加密等优点，所以 <code>/v1/authz</code> 采用了 <code>Bearer</code> 认证，<code>Token</code> 格式采用了 <code>JWT</code> 格式，这也是业界在 <code>API 认证</code>中最受欢迎的认证方式。</p>
<p><code>Bearer</code> 认证需要 <code>secretID</code> 和 <code>secretKey</code>，这些信息会通过 <code>gRPC 接口</code>调用，从 <code>iam-apisaerver</code> 中获取，并缓存在 <code>iam-authz-server</code> 的<code>内存</code>中供认证时查询使用。</p>
<p>当请求来临时，<code>iam-authz-server</code> <code>Bearer 认证中间件</code>从 <code>JWT Token</code> 中解析出 <code>Header</code>，并从 <code>Header</code> 的 <code>kid</code> 字段中获取到 <code>secretID</code>，根据 <code>secretID</code> 查找到 <code>secretKey</code>，最后使用 <code>secretKey</code> 加密 <code>JWT Token</code> 的 <code>Header</code> 和 <code>Payload</code>，并与 <code>Signature</code> 部分进行对比。如果相等，则认证通过；如果不等，则认证失败。</p>
<h3 id="iam-apiserver-Bearer-认证实现"><a href="#iam-apiserver-Bearer-认证实现" class="headerlink" title="iam-apiserver Bearer 认证实现"></a>iam-apiserver Bearer 认证实现</h3><p>再来看下 <code>iam-apiserver</code> 的 <code>Bearer</code> 认证。</p>
<p><code>iam-apiserver</code> 的 <code>Bearer</code> 认证通过以下代码（位于<code>router.go</code>文件中）指定使用了 <code>auto 认证策略</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
v1<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span>auto<span class="token punctuation">.</span><span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>我们来看下 <code>auto.AuthFunc()</code> 的实现：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a AutoStrategy<span class="token punctuation">)</span> <span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		operator <span class="token operator">:=</span> middleware<span class="token punctuation">.</span>AuthOperator<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

		authHeader <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">SplitN</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>authHeader<span class="token punctuation">)</span> <span class="token operator">!=</span> authHeaderCount <span class="token punctuation">&#123;</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>

				c<span class="token punctuation">,</span>

				errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrInvalidAuthHeader<span class="token punctuation">,</span> <span class="token string">"Authorization header format is wrong."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

				<span class="token boolean">nil</span><span class="token punctuation">,</span>
			<span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">switch</span> authHeader<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">case</span> <span class="token string">"Basic"</span><span class="token punctuation">:</span>

			operator<span class="token punctuation">.</span><span class="token function">SetStrategy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>basic<span class="token punctuation">)</span>

		<span class="token keyword">case</span> <span class="token string">"Bearer"</span><span class="token punctuation">:</span>

			operator<span class="token punctuation">.</span><span class="token function">SetStrategy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>jwt<span class="token punctuation">)</span>

			<span class="token comment">// a.JWT.MiddlewareFunc()(c)</span>

		<span class="token keyword">default</span><span class="token punctuation">:</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrSignatureInvalid<span class="token punctuation">,</span> <span class="token string">"unrecognized Authorization header."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		operator<span class="token punctuation">.</span><span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

		c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上面代码中可以看到，<code>AuthFunc</code> 函数会从 <code>Authorization Header</code> 中解析出认证方式是 <code>Basic</code> 还是 <code>Bearer</code>。</p>
<p>如果是 <code>Bearer</code>，就会使用 <code>JWT 认证策略</code>；如果是 <code>Basic</code>，就会使用 <code>Basic 认证策略</code>。</p>
<p><strong>我们再来看下 <code>JWT 认证策略</code>的 <code>AuthFunc</code> 函数实现：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>j JWTStrategy<span class="token punctuation">)</span> <span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> j<span class="token punctuation">.</span><span class="token function">MiddlewareFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们跟随代码，可以定位到 <code>MiddlewareFunc</code> 函数最终调用了 <code>github.com/appleboy/gin-jwt</code> 包 <code>GinJWTMiddleware</code> 结构体的 <code>middlewareImpl</code> 方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>mw <span class="token operator">*</span>GinJWTMiddleware<span class="token punctuation">)</span> <span class="token function">middlewareImpl</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	claims<span class="token punctuation">,</span> err <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">GetClaimsFromJWT</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> claims<span class="token punctuation">[</span><span class="token string">"exp"</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrMissingExpField<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> claims<span class="token punctuation">[</span><span class="token string">"exp"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrWrongFormatOfExp<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token function">int64</span><span class="token punctuation">(</span>claims<span class="token punctuation">[</span><span class="token string">"exp"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> mw<span class="token punctuation">.</span><span class="token function">TimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrExpiredToken<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"JWT_PAYLOAD"</span><span class="token punctuation">,</span> claims<span class="token punctuation">)</span>

	identity <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">IdentityHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

	<span class="token keyword">if</span> identity <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>

		c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>IdentityKey<span class="token punctuation">,</span> identity<span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token operator">!</span>mw<span class="token punctuation">.</span><span class="token function">Authorizator</span><span class="token punctuation">(</span>identity<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		mw<span class="token punctuation">.</span><span class="token function">unauthorized</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusForbidden<span class="token punctuation">,</span> mw<span class="token punctuation">.</span><span class="token function">HTTPStatusMessageFunc</span><span class="token punctuation">(</span>ErrForbidden<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">return</span>

	<span class="token punctuation">&#125;</span>

	c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分析上面的代码，我们可以知道，<code>middlewareImpl</code> 的 <code>Bearer</code> 认证流程为：</p>
<p><code>第一步</code>：调用 <code>GetClaimsFromJWT</code> 函数，从 <code>HTTP</code> 请求中获取 <code>Authorization Header</code>，并解析出 <code>Token</code> 字符串，进行认证，最后返回 <code>Token Payload</code>。</p>
<p><code>第二步</code>：校验 <code>Payload</code> 中的 <code>exp</code> 是否超过当前时间，如果超过就说明 <code>Token</code> 过期，校验不通过。</p>
<p><code>第三步</code>：给 <code>gin.Context</code> 中添加 <code>JWT_PAYLOAD</code> 键，供后续程序使用（当然也可能用不到）。</p>
<p><code>第四步</code>：通过以下代码，在 <code>gin.Context</code> 中添加 <code>IdentityKey</code> 键，<code>IdentityKey</code> 键可以在创建 <code>GinJWTMiddleware</code> 结构体时指定，这里我们设置为 <code>middleware.UsernameKey</code> ，也就是 <code>username</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
identity <span class="token operator">:=</span> mw<span class="token punctuation">.</span><span class="token function">IdentityHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

<span class="token keyword">if</span> identity <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>mw<span class="token punctuation">.</span>IdentityKey<span class="token punctuation">,</span> identity<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><code>IdentityKey</code> 键的值由 <code>IdentityHandler</code> 函数返回，<code>IdentityHandler</code> 函数为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>

	claims <span class="token operator">:=</span> jwt<span class="token punctuation">.</span><span class="token function">ExtractClaims</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token keyword">return</span> claims<span class="token punctuation">[</span>jwt<span class="token punctuation">.</span>IdentityKey<span class="token punctuation">]</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述函数会从 <code>Token</code> 的 <code>Payload</code> 中获取 <code>identity</code> 域的值，<code>identity</code> 域的值是在签发 <code>Token</code> 时指定的，它的值其实是<code>用户名</code>，你可以查看 <code>payloadFunc</code> 函数了解。</p>
<p><code>第五步</code>：接下来，会调用 <code>Authorizator</code> 方法， <code>Authorizator</code> 是一个 <code>callback</code> 函数，成功时必须返回<code>真</code>，失败时必须返回<code>假</code>。</p>
<p><code>Authorizator</code>也是在创建 <code>GinJWTMiddleware</code> 时指定的，例如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">authorizator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>

		<span class="token comment">// add username to header</span>

		<span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>

			<span class="token comment">// c.Request.Header.Add(log.KeyUsername, v)</span>

			c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>CtxUsername<span class="token punctuation">,</span> v<span class="token punctuation">)</span>

			<span class="token keyword">return</span> <span class="token boolean">true</span>

		<span class="token punctuation">&#125;</span>

		<span class="token keyword">return</span> <span class="token boolean">false</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>authorizator</code> 函数返回了一个<code>匿名函数</code>，<code>匿名函数</code>在认证成功后，会打印一条<code>认证成功日志</code>。</p>
<h2 id="IAM-项目认证功能设计技巧"><a href="#IAM-项目认证功能设计技巧" class="headerlink" title="IAM 项目认证功能设计技巧"></a>IAM 项目认证功能设计技巧</h2><p>我在设计 <code>IAM 项目</code>的认证功能时，也运用了一些技巧，这里分享给你。</p>
<h3 id="技巧-1：面向接口编程"><a href="#技巧-1：面向接口编程" class="headerlink" title="技巧 1：面向接口编程"></a>技巧 1：面向接口编程</h3><p>在使用 <code>NewAutoStrategy</code> 函数创建 <code>auto 认证策略</code>时，传入了 <code>BasicStrategy</code> 、 <code>JWTStrategy</code> 接口类型的参数，这意味着 <code>Basic 认证</code>和 <code>Bearer 认证</code>都可以有不同的实现，这样后期可以根据需要<code>扩展</code>新的认证方式。</p>
<h3 id="技巧-2：使用抽象工厂模式"><a href="#技巧-2：使用抽象工厂模式" class="headerlink" title="技巧 2：使用抽象工厂模式"></a>技巧 2：使用抽象工厂模式</h3><p><code>auth.go</code> 文件中，通过 <code>newBasicAuth</code> 、 <code>newJWTAuth</code> 、 <code>newAutoAuth</code> 创建<code>认证策略</code>时，返回的都是<code>接口</code>。通过返回<code>接口</code>，可以在<code>不公开内部实现</code>的情况下，让调用者使用你提供的各种认证功能。</p>
<h3 id="技巧-3：使用策略模式"><a href="#技巧-3：使用策略模式" class="headerlink" title="技巧 3：使用策略模式"></a>技巧 3：使用策略模式</h3><p>在 <code>auto 认证策略</code>中，我们会根据 <code>HTTP</code> 请求头 <code>Authorization: XXX X.Y.X</code> 中的 <code>XXX</code> 来选择并设置 <code>认证策略</code>（ <code>Basic</code> 或 <code>Bearer</code> ）。具体可以查看 <code>AutoStrategy</code> 的 <code>AuthFunc</code> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a AutoStrategy<span class="token punctuation">)</span> <span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">&#123;</span>

	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

		operator <span class="token operator">:=</span> middleware<span class="token punctuation">.</span>AuthOperator<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

		authHeader <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">SplitN</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

		<span class="token operator">...</span>

		<span class="token keyword">switch</span> authHeader<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>

		<span class="token keyword">case</span> <span class="token string">"Basic"</span><span class="token punctuation">:</span>

			operator<span class="token punctuation">.</span><span class="token function">SetStrategy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>basic<span class="token punctuation">)</span>

		<span class="token keyword">case</span> <span class="token string">"Bearer"</span><span class="token punctuation">:</span>

			operator<span class="token punctuation">.</span><span class="token function">SetStrategy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>jwt<span class="token punctuation">)</span>

			<span class="token comment">// a.JWT.MiddlewareFunc()(c)</span>

		<span class="token keyword">default</span><span class="token punctuation">:</span>

			core<span class="token punctuation">.</span><span class="token function">WriteResponse</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">WithCode</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>ErrSignatureInvalid<span class="token punctuation">,</span> <span class="token string">"unrecognized Authorization header."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

			c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			<span class="token keyword">return</span>

		<span class="token punctuation">&#125;</span>

		operator<span class="token punctuation">.</span><span class="token function">AuthFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

		c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中，</p>
<p>如果是 <code>Basic</code>，则设置为 <code>Basic 认证方法</code>  <code>operator.SetStrategy(a.basic)</code>  ；</p>
<p>如果是 <code>Bearer</code> ，则设置为 <code>Bearer 认证方法</code>  <code>operator.SetStrategy(a.jwt)</code> 。</p>
<p><code>SetStrategy</code> 方法的入参是 <code>AuthStrategy </code>类型的接口，都实现了 <code>AuthFunc()</code> <code>gin.HandlerFunc</code>函数，用来进行认证，所以最后我们调用 <code>operator.AuthFunc()(c)</code> 即可完成认证。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 <code>IAM 项目</code>中，<code>iam-apiserver</code> 实现了 <code>Basic 认证</code>和 <code>Bearer 认证</code>，<code>iam-authz-server</code> 实现了 <code>Bearer</code> 认证。这一讲重点介绍了 <code>iam-apiserver</code> 的认证实现。</p>
<p>用户要访问 <code>iam-apiserver</code>，首先需要通过 <code>Basic 认证</code>，认证通过之后，会返回 <code>JWT Token</code> 和 <code>JWT Token</code> 的过期时间。前端将 <code>Token</code> 缓存在 <code>LocalStorage</code> 或 <code>Cookie</code> 中，后续的请求都通过 <code>Token</code> 来认证。</p>
<p>执行 <code>Basic 认证</code>时，<code>iam-apiserver</code> 会从 <code>HTTP Authorization Header</code> 中解析出<code>用户名</code>和<code>密码</code>，将<code>密码</code>再加密，并和数据库中保存的值进行对比。如果不匹配，则认证失败，否则认证成功。认证成功之后，会返回<code> Token</code>，并在 <code>Token</code> 的 <code>Payload</code> 部分设置<code>用户名</code>，<code>Key</code> 为 <code>username</code> 。</p>
<p>执行<code> Bearer 认证</code>时，<code>iam-apiserver</code> 会从 <code>JWT Token</code> 中解析出 <code>Header</code> 和 <code>Payload</code>，并从 <code>Header</code> 中获取<code>加密算法</code>。接着，用获取到的<code>加密算法</code>和从<code>配置文件</code>中获取到的<code>密钥对</code> <code>Header.Payload</code> 进行再加密，得到 <code>Signature</code>，并对比两次的 <code>Signature</code> 是否相等。如果不相等，则返回 <code>HTTP 401 Unauthorized</code> 错误；如果相等，接下来会判断 <code>Token</code> 是否<code>过期</code>，如果过期则返回认证不通过，否则认证通过。认证通过之后，会将 <code>Payload</code> 中的 <code>username</code> 添加到 <code>gin.Context</code> 类型的变量中，供后面的业务逻辑使用。</p>
]]></content>
      <categories>
        <category>Golang 实战</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IAM</tag>
        <tag>Basic</tag>
        <tag>Jwt</tag>
      </tags>
  </entry>
</search>
