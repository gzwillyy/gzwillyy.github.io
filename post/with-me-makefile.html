<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><style>:root{--body-bg-color:#f5f7f9;--content-bg-color:#fff;--card-bg-color:#f5f5f5;--text-color:#555;--blockquote-color:#666;--link-color:#555;--link-hover-color:#222;--brand-color:#fff;--brand-hover-color:#fff;--table-row-odd-bg-color:#f9f9f9;--table-row-hover-bg-color:#f5f5f5;--menu-item-bg-color:#f5f5f5;--theme-color:#222;--btn-default-bg:#fff;--btn-default-color:#555;--btn-default-border-color:#555;--btn-default-hover-bg:#222;--btn-default-hover-color:#fff;--btn-default-hover-border-color:#222;--highlight-background:#f3f3f3;--highlight-foreground:#444;--highlight-gutter-background:#e1e1e1;--highlight-gutter-foreground:#555;color-scheme:light}html{line-height:1.15;-webkit-text-size-adjust:100%}details,main{display:block}pre{font-size:1em;overflow:auto;padding:10px;position:relative}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}.table-container,textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}summary{display:list-item}[hidden],template{display:none}::selection{background:#262a30;color:#eee}body,html{height:100%}body{margin:0;background:var(--body-bg-color);box-sizing:border-box;color:var(--text-color);font-family:EB Garamond,'Noto Serif SC','PingFang SC','Microsoft YaHei',sans-serif;font-size:1em;line-height:2;min-height:100%;position:relative;transition:padding .2s ease-in-out}h1,h2,h3,h4,h5,h6{font-family:EB Garamond,'Noto Serif SC','PingFang SC','Microsoft YaHei',sans-serif;font-weight:700;line-height:1.5;margin:30px 0 15px}h1{font-size:1.5em}h2{font-size:1.375em}h3{font-size:1.25em}h4{font-size:1.125em}h5{font-size:1em}h6{font-size:.875em}p{margin:0 0 20px}a{background:0 0;border-bottom:1px solid #999;color:var(--link-color);cursor:pointer;outline:0;text-decoration:none;overflow-wrap:break-word}a:hover{border-bottom-color:var(--link-hover-color);color:var(--link-hover-color)}embed,iframe,img,video{display:block;margin-left:auto;margin-right:auto;max-width:100%}hr{box-sizing:content-box;overflow:visible;background-image:repeating-linear-gradient(-45deg,#ddd,#ddd 4px,transparent 4px,transparent 8px);border:0;height:3px;margin:40px 0}blockquote{border-left:4px solid #ddd;color:var(--blockquote-color);margin:0;padding:0 15px}blockquote cite::before{content:'-';padding:0 5px}dt{font-weight:700}dd{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0;font-size:.875em;margin:0 0 20px;width:100%}tbody tr:nth-of-type(odd){background:var(--table-row-odd-bg-color)}tbody tr:hover{background:var(--table-row-hover-bg-color)}caption,td,th{padding:8px}td,th{border:1px solid #ddd;border-bottom:3px solid #ddd}th{font-weight:700;padding-bottom:10px}td{border-bottom-width:1px}.btn{background:var(--btn-default-bg);border:2px solid var(--btn-default-border-color);border-radius:2px;color:var(--btn-default-color);display:inline-block;font-size:.875em;line-height:2;padding:0 20px;transition:background-color .2s ease-in-out}.btn:hover{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.btn+.btn{margin:0 0 8px 8px}.btn .fa-fw{text-align:left;width:1.285714285714286em}.toggle{line-height:0}.toggle .toggle-line{background:#fff;display:block;height:2px;left:0;position:relative;top:0;transition:.4s;width:100%}.toggle .toggle-line:first-child{margin-top:1px}.toggle .toggle-line:not(:first-child){margin-top:4px}.toggle.toggle-arrow :first-child{left:50%;top:2px;transform:rotate(45deg);width:50%}.toggle.toggle-arrow :last-child{left:50%;top:-2px;transform:rotate(-45deg);width:50%}.toggle.toggle-close :nth-child(2){opacity:0}.toggle.toggle-close :first-child{top:6px;transform:rotate(45deg)}.toggle.toggle-close :last-child{top:-6px;transform:rotate(-45deg)}code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}pre[class*=language-].line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}pre[class*=language-].line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:0;font-size:100%;left:-3.8em;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.line-numbers-rows>span{display:block;counter-increment:linenumber}.line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.highlight:hover .copy-btn,pre:hover .copy-btn{opacity:1}figure.highlight .table-container{position:relative}.copy-btn{color:#333;cursor:pointer;line-height:1.6;opacity:0;padding:2px 6px;position:absolute;transition:opacity .2s ease-in-out;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;font-size:.8125em;right:4px;top:8px}code,figure.highlight,kbd,pre{background:var(--highlight-background);color:var(--highlight-foreground)}figure.highlight,pre{line-height:1.6;margin:0 auto 20px}figure.highlight figcaption,pre .caption,pre figcaption{background:var(--highlight-gutter-background);color:var(--highlight-foreground);display:flow-root;font-size:.875em;line-height:1.2;padding:.5em}figure.highlight figcaption a,pre .caption a,pre figcaption a{color:var(--highlight-foreground);float:right}figure.highlight figcaption a:hover,pre .caption a:hover,pre figcaption a:hover{border-bottom-color:var(--highlight-foreground)}code,pre{font-family:JetBrains Mono,consolas,Menlo,monospace,'PingFang SC','Microsoft YaHei'}code{border-radius:3px;font-size:.875em;padding:2px 4px;overflow-wrap:break-word}kbd{border:2px solid #ccc;border-radius:.2em;box-shadow:.1em .1em .2em rgba(0,0,0,.1);font-family:inherit;padding:.1em .3em;white-space:nowrap}figure.highlight{overflow:auto;position:relative}figure.highlight pre{border:0;margin:0;padding:10px 0}figure.highlight table{border:0;margin:0;width:auto}figure.highlight td{border:0;padding:0}figure.highlight .gutter{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}figure.highlight .gutter pre{background:var(--highlight-gutter-background);color:var(--highlight-gutter-foreground);padding-left:10px;padding-right:10px;text-align:right}figure.highlight .code pre{padding-left:10px;width:100%}figure.highlight .marked{background:rgba(0,0,0,.3)}pre .caption,pre figcaption{margin-bottom:10px}.gist table{width:auto}.gist table td{border:0}pre code{background:0 0;padding:0;text-shadow:none}.blockquote-center{border-left:0;margin:40px 0;padding:0;position:relative;text-align:center}.blockquote-center::after,.blockquote-center::before{left:0;line-height:1;opacity:.6;position:absolute;width:100%}.blockquote-center::before{border-top:1px solid #ccc;text-align:left;top:-20px;content:'\f10d';font-family:'Font Awesome 6 Free';font-weight:900}.blockquote-center::after{border-bottom:1px solid #ccc;bottom:-20px;text-align:right;content:'\f10e';font-family:'Font Awesome 6 Free';font-weight:900}.blockquote-center div,.blockquote-center p{text-align:center}.group-picture{margin-bottom:20px}.group-picture .group-picture-row{display:flex;gap:3px;margin-bottom:3px}.group-picture .group-picture-column{flex:1}.group-picture .group-picture-column img{height:100%;margin:0;object-fit:cover;width:100%}.post-body .label{color:#555;padding:0 2px}.post-body .label.default{background:#f0f0f0}.post-body .label.primary{background:#efe6f7}.post-body .label.info{background:#e5f2f8}.post-body .label.success{background:#e7f4e9}.post-body .label.warning{background:#fcf6e1}.post-body .label.danger{background:#fae8eb}.post-body .link-grid{display:grid;grid-gap:1.5rem;gap:1.5rem;grid-template-columns:1fr 1fr;margin-bottom:20px;padding:1rem}.post-body .link-grid .link-grid-container{border:solid #ddd;box-shadow:1rem 1rem .5rem rgba(0,0,0,.5);min-height:5rem;min-width:0;padding:.5rem;position:relative;transition:background .3s}.post-body .link-grid .link-grid-container:hover{animation:.5s next-shake;background:var(--card-bg-color)}.post-body .link-grid .link-grid-container:active{box-shadow:.5rem .5rem .25rem rgba(0,0,0,.5);transform:translate(.2rem,.2rem)}.post-body .link-grid .link-grid-container .link-grid-image{border:1px solid #ddd;border-radius:50%;box-sizing:border-box;height:5rem;padding:3px;position:absolute;width:5rem}.post-body .link-grid .link-grid-container p{margin:0 1rem 0 6rem}.post-body .link-grid .link-grid-container p:first-of-type{font-size:1.2em}.post-body .link-grid .link-grid-container p:last-of-type{font-size:.8em;line-height:1.3rem;opacity:.7}.post-body .link-grid .link-grid-container a{border:0;height:100%;left:0;position:absolute;top:0;width:100%}@keyframes next-shake{0%{transform:translate(1pt,1pt) rotate(0)}10%{transform:translate(-1pt,-2pt) rotate(-1deg)}20%{transform:translate(-3pt,0) rotate(1deg)}30%{transform:translate(3pt,2pt) rotate(0)}40%{transform:translate(1pt,-1pt) rotate(1deg)}50%{transform:translate(-1pt,2pt) rotate(-1deg)}60%{transform:translate(-3pt,1pt) rotate(0)}70%{transform:translate(3pt,1pt) rotate(-1deg)}80%{transform:translate(-1pt,-1pt) rotate(1deg)}90%{transform:translate(1pt,2pt) rotate(0)}100%{transform:translate(1pt,-2pt) rotate(-1deg)}}.post-body .note{border-radius:3px;margin-bottom:20px;padding:1em;position:relative;border:1px solid #eee;border-left-width:5px}.post-body .note summary{cursor:pointer;outline:0}.post-body .note summary p{display:inline}.post-body .note h2,.post-body .note h3,.post-body .note h4,.post-body .note h5,.post-body .note h6{border-bottom:initial;margin:0;padding-top:0}.post-body .note :first-child{margin-top:0}.post-body .note :last-child{margin-bottom:0}.post-body .note.default{border-left-color:#777}.post-body .note.default h2,.post-body .note.default h3,.post-body .note.default h4,.post-body .note.default h5,.post-body .note.default h6{color:#777}.post-body .note.primary{border-left-color:#6f42c1}.post-body .note.primary h2,.post-body .note.primary h3,.post-body .note.primary h4,.post-body .note.primary h5,.post-body .note.primary h6{color:#6f42c1}.post-body .note.info{border-left-color:#428bca}.post-body .note.info h2,.post-body .note.info h3,.post-body .note.info h4,.post-body .note.info h5,.post-body .note.info h6{color:#428bca}.post-body .note.success{border-left-color:#5cb85c}.post-body .note.success h2,.post-body .note.success h3,.post-body .note.success h4,.post-body .note.success h5,.post-body .note.success h6{color:#5cb85c}.post-body .note.warning{border-left-color:#f0ad4e}.post-body .note.warning h2,.post-body .note.warning h3,.post-body .note.warning h4,.post-body .note.warning h5,.post-body .note.warning h6{color:#f0ad4e}.post-body .note.danger{border-left-color:#d9534f}.post-body .note.danger h2,.post-body .note.danger h3,.post-body .note.danger h4,.post-body .note.danger h5,.post-body .note.danger h6{color:#d9534f}.post-body .tabs{margin-bottom:20px}.post-body .tabs,.tabs-comment{padding-top:10px}.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{background:var(--content-bg-color);display:flex;display:flex;flex-wrap:wrap;justify-content:center;margin:0;padding:0;position:-webkit-sticky;position:sticky;top:0;z-index:5}.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border-bottom:1px solid #ddd;border-left:1px solid transparent;border-right:1px solid transparent;border-radius:0;border-top:3px solid transparent;flex-grow:1;list-style-type:none}@media (max-width:413px){.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{display:block;margin-bottom:5px}.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border-bottom:1px solid transparent;border-left:3px solid transparent;border-right:1px solid transparent;border-top:1px solid transparent;border-radius:0}}.post-body .tabs ul.nav-tabs li.tab a,.tabs-comment ul.nav-tabs li.tab a{border-bottom:initial;display:block;line-height:1.8;padding:.25em .75em;text-align:center;transition:.2s ease-out}.post-body .tabs ul.nav-tabs li.tab a i,.tabs-comment ul.nav-tabs li.tab a i{width:1.285714285714286em}.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#fc6423 #ddd transparent}@media (max-width:413px){.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#ddd #ddd #ddd #fc6423}}.post-body .tabs ul.nav-tabs li.tab.active a,.tabs-comment ul.nav-tabs li.tab.active a{cursor:default}.post-body .tabs .tab-content,.tabs-comment .tab-content{border:1px solid #ddd;border-radius:0;border-top-color:transparent}@media (max-width:413px){.post-body .tabs .tab-content,.tabs-comment .tab-content{border-radius:0;border-top-color:#ddd}}.post-body .tabs .tab-content .tab-pane,.tabs-comment .tab-content .tab-pane{padding:20px 20px 0}.post-body .tabs .tab-content .tab-pane:not(.active),.tabs-comment .tab-content .tab-pane:not(.active){display:none}.pagination .next,.pagination .page-number,.pagination .prev,.pagination .space{display:inline-block;margin:-1px 10px 0;padding:0 10px}.pagination .page-number.current{background:#ccc;border-color:#ccc;color:var(--content-bg-color)}.pagination{border-top:1px solid #eee;margin:120px 0 0;text-align:center}.pagination .next,.pagination .page-number,.pagination .prev{border-bottom:0;border-top:1px solid #eee;transition:border-color .2s ease-in-out}.pagination .next:hover,.pagination .page-number:hover,.pagination .prev:hover{border-top-color:var(--link-hover-color)}@media (max-width:767px){.post-body .link-grid{grid-template-columns:1fr}.pagination .next,.pagination .page-number,.pagination .prev,.pagination .space{margin:0 5px}.pagination{border-top:0}.pagination .next,.pagination .page-number,.pagination .prev{border-bottom:1px solid #eee;border-top:0}.pagination .next:hover,.pagination .page-number:hover,.pagination .prev:hover{border-bottom-color:var(--link-hover-color)}.site-meta{text-align:center}}.pagination .space{margin:0;padding:0}.comments{margin-top:60px;overflow:hidden}.comment-button-group{display:flex;display:flex;flex-wrap:wrap;justify-content:center;justify-content:center;margin:1em 0}.comment-button-group .comment-button{margin:.1em .2em}.comment-button-group .comment-button.active{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.comment-position{display:none}.comment-position.active{display:block}.tabs-comment{margin-top:4em;padding-top:0}.tabs-comment .comments{margin-top:0;padding-top:0}.headband{background:var(--theme-color);height:3px}@media (max-width:991px){.headband{display:none}}.site-brand-container{display:flex;flex-shrink:0;padding:0 10px}.use-motion .column,.use-motion .site-brand-container .toggle{opacity:0}.site-meta{flex-grow:1;text-align:center}.custom-logo-image{margin-top:20px}@media (max-width:991px){.custom-logo-image{display:none}}.brand{border-bottom:0;color:var(--brand-color);display:inline-block;padding:0}.brand:hover{color:var(--brand-hover-color)}.site-title{font-family:Cinzel Decorative,EB Garamond,'Noto Serif SC','PingFang SC','Microsoft YaHei',sans-serif;font-size:1.375em;font-weight:400;line-height:1.5;margin:0}.site-subtitle{color:#ddd;font-size:.8125em;margin:10px 10px 0}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:0;position:relative;top:-10px}.site-nav-right,.site-nav-toggle{display:none}.site-nav-right .toggle,.site-nav-toggle .toggle{color:var(--text-color);padding:10px;width:22px}.site-nav-right .toggle .toggle-line,.site-nav-toggle .toggle .toggle-line{background:var(--text-color);border-radius:1px}@media (max-width:767px){.site-nav-right,.site-nav-toggle{display:flex;flex-direction:column;justify-content:center}.site-nav{--scroll-height:0;height:0;overflow:hidden;transition:height .2s ease-in-out}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height)}}.menu{margin:0;padding:1em 0;text-align:center}.menu-item{display:inline-block;list-style:none;margin:0 10px}@media (max-width:767px){.menu-item{display:block;margin-top:10px}.menu-item.menu-item-search{display:none}}.menu-item a{border-bottom:0;display:block;font-size:.8125em;transition:border-color .2s ease-in-out}.menu-item a.menu-item-active,.menu-item a:hover{background:var(--menu-item-bg-color)}.menu-item .fa,.menu-item .fab,.menu-item .far,.menu-item .fas{margin-right:8px}.menu-item .badge{display:inline-block;font-weight:700;line-height:1;margin-left:.35em;margin-top:.35em;text-align:center;white-space:nowrap}.use-motion .menu-item{visibility:hidden}.sidebar-inner{color:#999;padding:18px 10px;text-align:center;display:flex;flex-direction:column;justify-content:center}.cc-license .cc-opacity{border-bottom:0;opacity:.7}.cc-license .cc-opacity:hover{opacity:.9}.cc-license img{display:inline-block}.site-author-image{border:1px solid #eee;max-width:120px;padding:2px}.site-author-name{color:var(--text-color);font-weight:600;margin:0}.site-description{color:#999;font-size:.8125em;margin-top:0}.links-of-author a{font-size:.8125em}.links-of-author .fa,.links-of-author .fab,.links-of-author .far,.links-of-author .fas{margin-right:2px}.sidebar .sidebar-button:not(:first-child){margin-top:15px}.sidebar .sidebar-button button{background:0 0;cursor:pointer;line-height:2;padding:0 15px;border-radius:4px}.sidebar .sidebar-button button .fa,.sidebar .sidebar-button button .fab,.sidebar .sidebar-button button .far,.sidebar .sidebar-button button .fas{margin-right:5px}.links-of-blogroll{font-size:.8125em}.links-of-blogroll-title{font-size:.875em;font-weight:600}.links-of-blogroll-list{list-style:none;margin:0;padding:0}.sidebar-nav{display:none;margin:0;padding-bottom:20px;padding-left:0}.sidebar-nav-active .sidebar-nav{display:block}.sidebar-nav li{border-bottom:1px solid transparent;color:var(--text-color);cursor:pointer;display:inline-block;font-size:.875em}.sidebar-nav li.sidebar-nav-overview{margin-left:10px}.sidebar-nav li:hover{color:#fc6423}.sidebar-overview-active .sidebar-nav-overview,.sidebar-toc-active .sidebar-nav-toc{border-bottom-color:#fc6423;color:#fc6423}.sidebar-overview-active .sidebar-nav-overview:hover,.sidebar-toc-active .sidebar-nav-toc:hover{color:#fc6423}.sidebar-panel-container{flex:1;overflow-x:hidden;overflow-y:auto}.sidebar-panel{display:none}.sidebar-overview-active .site-overview-wrap{display:flex;flex-direction:column;justify-content:center;gap:10px}.sidebar-toc-active .post-toc-wrap{display:block}.sidebar-toggle{bottom:61px;height:16px;padding:5px;width:16px;background:#222;cursor:pointer;opacity:.6;position:fixed;z-index:30;right:30px}.sidebar-toggle:hover{opacity:.8}@media (max-width:991px){.sidebar-toggle{right:20px;opacity:.8}}.sidebar-toggle:hover .toggle-line{background:#fc6423}@media (any-hover:hover){body:not(.sidebar-active) .sidebar-toggle:hover :first-child{left:50%;top:2px;transform:rotate(45deg);width:50%}body:not(.sidebar-active) .sidebar-toggle:hover :last-child{left:50%;top:-2px;transform:rotate(-45deg);width:50%}}.sidebar-active .sidebar-toggle :nth-child(2){opacity:0}.sidebar-active .sidebar-toggle :first-child{top:6px;transform:rotate(45deg)}.sidebar-active .sidebar-toggle :last-child{top:-6px;transform:rotate(-45deg)}.post-toc{font-size:.875em}.post-toc ol{list-style:none;margin:0;padding:0 2px 5px 10px;text-align:left}.post-toc ol>ol{padding-left:0}.post-toc ol a{transition:.2s ease-in-out}.post-toc .nav-item{line-height:1.8;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.post-toc .nav .nav-child{display:none}.post-toc .nav .active-current>.nav-child,.post-toc .nav .active-current>.nav-child>.nav-item,.post-toc .nav .active>.nav-child{display:block}.post-toc .nav .active>a{border-bottom-color:#fc6423;color:#fc6423}.post-toc .nav .active-current>a,.post-toc .nav .active-current>a:hover{color:#fc6423}.site-state{display:flex;flex-wrap:wrap;justify-content:center;line-height:1.4}.site-state-item a{border-bottom:0;display:block}.site-state-item-count{display:block;font-size:1em;font-weight:600}.site-state-item-name{color:#999;font-size:.8125em}.footer{color:#999;font-size:.875em;padding:20px 0}.footer.footer-fixed{bottom:0;left:0;position:absolute;right:0}.footer-inner{box-sizing:border-box;text-align:center;display:flex;flex-direction:column;justify-content:center;margin:0 auto;width:calc(100% - 20px)}@media (max-width:767px){.menu-item .badge{float:right;margin-left:0}.footer-inner{width:auto}}@media (min-width:1200px){.footer-inner{width:1160px}}@media (min-width:1600px){.footer-inner{width:73%}}.use-motion .footer{opacity:0}.languages{display:inline-block;font-size:1.125em;position:relative}.languages .lang-select-label span{margin:0 .5em}.languages .lang-select{height:100%;left:0;opacity:0;position:absolute;top:0;width:100%}.with-love{color:red;display:inline-block;margin:0 5px}@keyframes icon-animate{0%,100%{transform:scale(1)}10%,30%{transform:scale(.9)}20%,40%,50%,60%,70%,80%{transform:scale(1.1)}}.back-to-top{font-size:12px;align-items:center;bottom:-100px;color:#fff;display:flex;height:26px;transition:bottom .2s ease-in-out;background:#222;cursor:pointer;opacity:.6;position:fixed;z-index:30;right:30px}.back-to-top span{margin-right:8px;display:none}.back-to-top .fa{text-align:center;width:26px}.back-to-top:hover{opacity:.8;color:#fc6423}.back-to-top.back-to-top-on{bottom:30px}.rtl.post-body a,.rtl.post-body h1,.rtl.post-body h2,.rtl.post-body h3,.rtl.post-body h4,.rtl.post-body h5,.rtl.post-body h6,.rtl.post-body li,.rtl.post-body ol,.rtl.post-body p,.rtl.post-body ul{direction:rtl;font-family:UKIJ Ekran}.rtl.post-title{font-family:UKIJ Ekran}.post-button{margin-top:40px;text-align:center}.use-motion .collection-header,.use-motion .comments,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{visibility:hidden}.posts-collapse .post-content{margin-bottom:35px;margin-left:35px;position:relative}@media (max-width:767px){.posts-collapse .post-content{margin-left:0;margin-right:0}}.posts-collapse .post-content .collection-title{font-size:1.125em;position:relative}.posts-collapse .post-content .collection-title::before{background:#999;border:1px solid #fff;margin-left:-6px;margin-top:-4px;position:absolute;top:50%;border-radius:50%;content:' ';height:10px;width:10px}.posts-collapse .post-content .collection-year{font-size:1.5em;font-weight:700;margin:60px 0;position:relative}.posts-collapse .post-content .collection-year::before{background:#bbb;margin-left:-4px;margin-top:-4px;position:absolute;top:50%;border-radius:50%;content:' ';height:8px;width:8px}.posts-collapse .post-content .collection-header{display:block;margin-left:20px}.posts-collapse .post-content .collection-header small{color:#bbb;margin-left:5px}.posts-collapse .post-content .post-header{border-bottom:1px dashed #ccc;margin:30px 2px 0;padding-left:15px;position:relative;transition:border .2s ease-in-out}.posts-collapse .post-content .post-header::before{background:#bbb;border:1px solid #fff;left:-6px;position:absolute;top:.75em;transition:background .2s ease-in-out;border-radius:50%;content:' ';height:6px;width:6px}.posts-collapse .post-content .post-header:hover{border-bottom-color:#666}.posts-collapse .post-content .post-header:hover::before{background:#222}.posts-collapse .post-content .post-meta-container{display:inline;font-size:.75em;margin-right:10px}.posts-collapse .post-content .post-title{display:inline}.posts-collapse .post-content .post-title a{border-bottom:0;color:var(--link-color)}.posts-collapse .post-content .post-title .fa-external-link-alt{font-size:.875em;margin-left:5px}.posts-collapse .post-content::before{background:#f5f5f5;content:' ';height:100%;margin-left:-2px;position:absolute;top:1.25em;width:4px}.post-body{font-family:EB Garamond,'Noto Serif SC','PingFang SC','Microsoft YaHei',sans-serif;overflow-wrap:break-word}@media (min-width:1200px){.post-body{font-size:1.125em}}@media (min-width:992px){.post-body{text-align:justify}}.post-body h1 .header-anchor,.post-body h1 .headerlink,.post-body h2 .header-anchor,.post-body h2 .headerlink,.post-body h3 .header-anchor,.post-body h3 .headerlink,.post-body h4 .header-anchor,.post-body h4 .headerlink,.post-body h5 .header-anchor,.post-body h5 .headerlink,.post-body h6 .header-anchor,.post-body h6 .headerlink{border-bottom-style:none;color:inherit;float:right;font-size:.875em;margin-left:10px;opacity:0}.post-body h1 .header-anchor::before,.post-body h1 .headerlink::before,.post-body h2 .header-anchor::before,.post-body h2 .headerlink::before,.post-body h3 .header-anchor::before,.post-body h3 .headerlink::before,.post-body h4 .header-anchor::before,.post-body h4 .headerlink::before,.post-body h5 .header-anchor::before,.post-body h5 .headerlink::before,.post-body h6 .header-anchor::before,.post-body h6 .headerlink::before{content:'\f0c1';font-family:'Font Awesome 6 Free';font-weight:900}.post-body h1:hover .header-anchor,.post-body h1:hover .headerlink,.post-body h2:hover .header-anchor,.post-body h2:hover .headerlink,.post-body h3:hover .header-anchor,.post-body h3:hover .headerlink,.post-body h4:hover .header-anchor,.post-body h4:hover .headerlink,.post-body h5:hover .header-anchor,.post-body h5:hover .headerlink,.post-body h6:hover .header-anchor,.post-body h6:hover .headerlink{opacity:.5}.post-body h1:hover .header-anchor:hover,.post-body h1:hover .headerlink:hover,.post-body h2:hover .header-anchor:hover,.post-body h2:hover .headerlink:hover,.post-body h3:hover .header-anchor:hover,.post-body h3:hover .headerlink:hover,.post-body h4:hover .header-anchor:hover,.post-body h4:hover .headerlink:hover,.post-body h5:hover .header-anchor:hover,.post-body h5:hover .headerlink:hover,.post-body h6:hover .header-anchor:hover,.post-body h6:hover .headerlink:hover{opacity:1}.post-body .exturl .fa{font-size:.875em;margin-left:4px}.post-body .fancybox+figcaption,.post-body .image-caption,.post-body img+figcaption{color:#999;font-size:.875em;font-weight:700;line-height:1;margin:-15px auto 15px;text-align:center}.post-body embed,.post-body iframe,.post-body img,.post-body video{margin-bottom:20px}.post-body .video-container{height:0;margin-bottom:20px;overflow:hidden;padding-top:75%;position:relative;width:100%}.post-body .video-container embed,.post-body .video-container iframe,.post-body .video-container object{height:100%;left:0;margin:0;position:absolute;top:0;width:100%}.post-gallery{display:flex;min-height:200px}.post-gallery .post-gallery-image{flex:1}.post-gallery .post-gallery-image:not(:first-child){clip-path:polygon(40px 0,100% 0,100% 100%,0 100%);margin-left:-20px}.post-gallery .post-gallery-image:not(:last-child){margin-right:-20px}.post-gallery .post-gallery-image img{height:100%;object-fit:cover;opacity:1;width:100%}.posts-expand .post-gallery{margin-bottom:60px}.posts-collapse .post-gallery{margin:15px 0}.posts-expand .post-header{font-size:1.125em;margin-bottom:60px;text-align:center}.posts-expand .post-title{font-size:1.5em;font-weight:400;margin:initial;overflow-wrap:break-word}.posts-expand .post-title-link{border-bottom:0;color:var(--link-color);display:inline-block;position:relative}.posts-expand .post-title-link::before{background:var(--link-color);bottom:0;content:'';height:2px;left:0;position:absolute;transform:scaleX(0);transition:transform .2s ease-in-out;width:100%}.posts-expand .post-title-link:hover::before{transform:scaleX(1)}.posts-expand .post-title-link .fa-external-link-alt{font-size:.875em;margin-left:5px}.post-sticky-flag{display:inline-block;margin-right:8px;transform:rotate(30deg)}.posts-expand .post-meta-container{color:#999;font-family:EB Garamond,'Noto Serif SC','PingFang SC','Microsoft YaHei',sans-serif;font-size:.75em;margin-top:3px}.posts-expand .post-meta-container .post-description{font-size:.875em;margin-top:2px}.posts-expand .post-meta-container time{border-bottom:1px dashed #999}.post-meta{display:flex;flex-wrap:wrap;justify-content:center}:not(.post-meta-break)+.post-meta-item::before{content:'|';margin:0 .5em}.post-meta-item-icon{margin-right:3px}@media (max-width:991px){.back-to-top{right:20px;opacity:.8}.post-body{text-align:justify}.post-meta-item-text{display:none}}.post-meta-break{flex-basis:100%;height:0}.post-nav{border-top:1px solid #eee;display:flex;gap:30px;justify-content:space-between;margin-top:1em;padding:10px 5px 0}.post-nav-item{flex:1}.post-nav-item a{border-bottom:0;display:block;font-size:.875em;line-height:1.6}.post-nav-item a:active{top:2px}.post-nav-item .fa{font-size:.75em}.post-nav-item:first-child .fa{margin-right:5px}.post-nav-item:last-child{text-align:right}.post-nav-item:last-child .fa{margin-left:5px}.post-footer{display:flex;flex-direction:column;justify-content:center}.post-eof{background:#ccc;height:1px;margin:80px auto 60px;width:8%}.post-block:last-of-type .post-eof{display:none}.post-tags{margin-top:40px;text-align:center}.post-tags a{display:inline-block;font-size:.8125em}.post-tags a:not(:last-child){margin-right:10px}.social-like{border-top:1px solid #eee;font-size:.875em;margin-top:1em;padding-top:1em;text-align:center}.reward-container{margin:1em 0 0;padding:1em 0;text-align:center}.reward-container button{background:0 0;color:#fc6423;cursor:pointer;line-height:2;padding:0 15px;border:2px solid #fc6423;border-radius:2px;outline:0;transition:.2s ease-in-out;vertical-align:text-top}.reward-container button:hover{background:#fc6423;color:#fff}.post-reward{display:none;padding-top:20px}.post-reward.active{display:block}.post-reward div{display:inline-block}.post-reward div span{display:block}.post-reward img{display:inline-block;margin:.8em 2em 0;max-width:100%;width:180px}@keyframes next-roll{from{transform:rotateZ(30deg)}to{transform:rotateZ(-30deg)}}.category-all-page .category-all-title{text-align:center}.category-all-page .category-all{margin-top:20px}.category-all-page .category-list{list-style:none;margin:0;padding:0}.category-all-page .category-list-item{margin:5px 10px}.category-all-page .category-list-count{color:#bbb}.category-all-page .category-list-count::before{content:' ('}.category-all-page .category-list-count::after{content:') '}.category-all-page .category-list-child{padding-left:10px}.event-list hr{background:#222;margin:20px 0 45px}.event-list hr::after{background:#222;color:#fff;content:'NOW';display:inline-block;font-weight:700;padding:0 5px}.event-list .event{--event-background:#222;--event-foreground:#bbb;--event-title:#fff;background:var(--event-background);padding:15px}.event-list .event .event-summary{border-bottom:0;color:var(--event-title);margin:0;padding:0 0 0 35px;position:relative}.event-list .event .event-summary::before{animation:1s ease-in-out infinite alternate dot-flash;background:var(--event-title);left:0;margin-top:-6px;position:absolute;top:50%;border-radius:50%;content:' ';height:12px;width:12px}.event-list .event:nth-of-type(odd) .event-summary::before{animation-delay:.5s}.event-list .event:not(:last-child){margin-bottom:20px}.event-list .event .event-relative-time{color:var(--event-foreground);display:inline-block;font-size:12px;font-weight:400;padding-left:12px}.event-list .event .event-details{color:var(--event-foreground);display:block;line-height:18px;padding:6px 0 6px 35px}.event-list .event .event-details::before{color:var(--event-foreground);display:inline-block;margin-right:9px;width:14px;font-family:'Font Awesome 6 Free';font-weight:900}.event-list .event .event-details.event-location::before{content:'\f041'}.event-list .event .event-details.event-duration::before{content:'\f017'}.event-list .event .event-details.event-description::before{content:'\f024'}.event-list .event-past{--event-background:#f5f5f5;--event-foreground:#999;--event-title:#222}@keyframes dot-flash{from{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}ul.breadcrumb{font-size:.75em;list-style:none;margin:1em 0;padding:0 2em;text-align:center}ul.breadcrumb li{display:inline}ul.breadcrumb li:not(:first-child)::before{content:'/\00a0';font-weight:400;padding:.5em}ul.breadcrumb li:last-child{font-weight:700}.tag-cloud{text-align:center}.tag-cloud a{display:inline-block;margin:10px}.tag-cloud-0{border-bottom-color:#aaa;color:#aaa}.tag-cloud-1{border-bottom-color:#9a9a9a;color:#9a9a9a}.tag-cloud-2{border-bottom-color:#8b8b8b;color:#8b8b8b}.tag-cloud-3{border-bottom-color:#7c7c7c;color:#7c7c7c}.tag-cloud-4{border-bottom-color:#6c6c6c;color:#6c6c6c}.tag-cloud-5{border-bottom-color:#5d5d5d;color:#5d5d5d}.tag-cloud-6{border-bottom-color:#4e4e4e;color:#4e4e4e}.tag-cloud-7{border-bottom-color:#3e3e3e;color:#3e3e3e}.tag-cloud-8{border-bottom-color:#2f2f2f;color:#2f2f2f}.tag-cloud-9{border-bottom-color:#202020;color:#202020}.tag-cloud-10{border-bottom-color:#111;color:#111}.search-active{overflow:hidden}.search-pop-overlay{background:rgba(0,0,0,0);display:flex;height:100%;left:0;position:fixed;top:0;transition:visibility .4s,background .4s;visibility:hidden;width:100%;z-index:40}.search-active .search-pop-overlay{background:rgba(0,0,0,.3);visibility:visible}.search-popup{background:var(--card-bg-color);border-radius:5px;height:80%;margin:auto;transform:scale(0);transition:transform .4s;width:700px}.search-active .search-popup{transform:scale(1)}@media (max-width:767px){.search-popup{border-radius:0;height:100%;width:100%}}.search-popup .popup-btn-close,.search-popup .search-icon{color:#999;font-size:18px;padding:0 10px}.search-popup .popup-btn-close{cursor:pointer}.search-popup .popup-btn-close:hover .fa{color:#222}.search-popup .search-header{background:#eee;border-top-left-radius:5px;border-top-right-radius:5px;display:flex;padding:5px}.search-popup input.search-input{background:0 0;border:0;outline:0;width:100%}.search-popup input.search-input::-webkit-search-cancel-button{display:none}.search-popup .search-result-container{height:calc(100% - 55px);overflow:auto;padding:5px 25px}.search-popup .search-result-container hr{margin:5px 0 10px}.search-popup .search-result-container hr:first-child{display:none}.search-popup .search-result-list{margin:0 5px;padding:0;width:100%}.search-popup a.search-result-title{font-weight:700}.search-popup p.search-result{border-bottom:1px dashed #ccc;padding:5px 0}.search-popup .search-input-container{flex-grow:1;padding:2px}.search-popup .no-result{display:flex}.search-popup .search-result-icon{color:#ccc;margin:auto}mark.search-keyword{background:0 0;border-bottom:1px dashed #ff2a2a;color:#ff2a2a;font-weight:700}.use-motion .animated{animation-fill-mode:none;visibility:inherit}.use-motion .sidebar .animated{animation-fill-mode:both}.header{background:var(--content-bg-color);border-radius:initial;box-shadow:initial}.main{align-items:stretch;display:flex;justify-content:space-between;margin:0 auto;width:calc(100% - 20px)}@media (max-width:767px){.main{width:auto}}@media (min-width:1200px){.main{width:1160px}}@media (min-width:1600px){.main{width:73%}}@media (max-width:991px){.header{border-radius:initial}.main{display:block;width:auto}}.main-inner{border-radius:initial;box-sizing:border-box;width:calc(100% - 252px)}.footer-inner{padding-left:252px}@media (max-width:991px){.main-inner{border-radius:initial;width:100%}.footer-inner{padding-left:0;padding-right:0;width:auto}}.column{width:240px}.site-brand-container{background:var(--theme-color)}.site-meta{padding:20px 0}.site-nav-right .toggle,.site-nav-toggle .toggle{color:#fff}.site-nav-right .toggle .toggle-line,.site-nav-toggle .toggle .toggle-line{background:#fff}@media (min-width:768px) and (max-width:991px){.site-nav-right,.site-nav-toggle{display:flex;flex-direction:column;justify-content:center}.site-nav{--scroll-height:0;height:0;overflow:hidden;transition:height .2s ease-in-out}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height)}}.menu .menu-item{display:block;margin:0}.menu .menu-item a{padding:5px 20px;position:relative;text-align:left;transition-property:background-color}.menu .menu-item .badge{background:#ccc;border-radius:10px;color:var(--content-bg-color);float:right;padding:2px 5px;text-shadow:1px 1px 0 rgba(0,0,0,.1)}.main-menu .menu-item-active::after{background:#bbb;border-radius:50%;content:' ';height:6px;margin-top:-3px;position:absolute;right:15px;top:50%;width:6px}.sub-menu{margin:0;padding:6px 0}.sub-menu .menu-item{display:inline-block}.sub-menu .menu-item a{background:0 0;margin:5px 10px;padding:initial}.sub-menu .menu-item a:hover{background:0 0;color:#fc6423}.sub-menu .menu-item-active{border-bottom-color:#fc6423;color:#fc6423}.sub-menu .menu-item-active:hover{border-bottom-color:#fc6423}.sidebar{position:-webkit-sticky;position:sticky;top:12px}@media (max-width:991px){.column{width:auto}.site-nav-on .site-brand-container{box-shadow:0 0 16px rgba(0,0,0,.5)}.menu .menu-item.menu-item-search,.sidebar{display:none}}.sidebar-inner{background:var(--content-bg-color);border-radius:initial;box-shadow:initial;box-sizing:border-box;color:var(--text-color);margin-top:12px;max-height:calc(100vh - 24px);visibility:hidden}.site-state-item{padding:0 10px}.sidebar .sidebar-button{border-bottom:1px dotted #ccc;border-top:1px dotted #ccc}.sidebar .sidebar-button button{border:0;color:#fc6423;display:block;width:100%}.sidebar .sidebar-button button:hover{background:0 0;border:0;color:#e34603}.links-of-author{display:flex;flex-wrap:wrap;justify-content:center}.links-of-author-item{margin:5px 0 0;width:50%}.links-of-author-item a{box-sizing:border-box;max-width:100%;overflow:hidden;padding:0 5px;text-overflow:ellipsis;white-space:nowrap;border-bottom:0;border-radius:4px;display:block}.links-of-author-item a:hover{background:var(--body-bg-color)}.main-inner{background:var(--content-bg-color);box-shadow:initial;padding:40px}@media (max-width:991px){.main-inner{padding:20px}}.sub-menu{border-bottom:1px solid #ddd}.post-block:first-of-type{padding-top:40px}@media (max-width:767px){.pagination{margin-bottom:10px}}</style><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity=sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"gzwilly.blog","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="github文档地址: https://github.com/seisman/how-to-write-makefile 概述什么是 makefile ？或许很多 Windows 的程序员都不知道这个东西，因为那些 Windows 的集成开发环境（integrated development environment，IDE）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，makefile" name=description><meta content=article property=og:type><meta content="跟我一起写 makefile" property=og:title><meta content=http://gzwilly.blog/post/with-me-makefile.html property=og:url><meta content=gzwilly'blog property=og:site_name><meta content="github文档地址: https://github.com/seisman/how-to-write-makefile 概述什么是 makefile ？或许很多 Windows 的程序员都不知道这个东西，因为那些 Windows 的集成开发环境（integrated development environment，IDE）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，makefile" property=og:description><meta content=zh_CN property=og:locale><meta content=2023-03-03T03:44:25.000Z property=article:published_time><meta content=2023-03-03T03:44:25.000Z property=article:modified_time><meta content=gzwillyy property=article:author><meta content=makefile property=article:tag><meta content=summary name=twitter:card><link href=http://gzwilly.blog/post/with-me-makefile.html rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://gzwilly.blog/post/with-me-makefile.html","path":"/post/with-me-makefile.html","title":"跟我一起写 makefile"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>跟我一起写 makefile | gzwilly'blog</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>gzwilly'blog</p> <i class=logo-line></i> </a></div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%A6%82%E8%BF%B0><span class=nav-number>1.</span> <span class=nav-text>概述</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5><span class=nav-number>1.1.</span> <span class=nav-text>关于程序的编译和链接</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#makefile-%E4%BB%8B%E7%BB%8D><span class=nav-number>2.</span> <span class=nav-text>makefile 介绍</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#makefile-%E7%9A%84%E8%A7%84%E5%88%99><span class=nav-number>2.1.</span> <span class=nav-text>makefile 的规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B><span class=nav-number>2.2.</span> <span class=nav-text>一个示例</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#make-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84><span class=nav-number>2.3.</span> <span class=nav-text>make 是如何工作的</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#makefile-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F><span class=nav-number>2.4.</span> <span class=nav-text>makefile 中使用变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%A9-make-%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC><span class=nav-number>2.5.</span> <span class=nav-text>让 make 自动推导</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%A6%E7%B1%BB%E9%A3%8E%E6%A0%BC%E7%9A%84-makefiles><span class=nav-number>2.6.</span> <span class=nav-text>另类风格的 makefiles</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B8%85%E7%A9%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99><span class=nav-number>2.7.</span> <span class=nav-text>清空目标文件的规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Makefile-%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88><span class=nav-number>2.8.</span> <span class=nav-text>Makefile 里有什么?</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Makefile-%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D><span class=nav-number>2.9.</span> <span class=nav-text>Makefile 的文件名</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E7%9A%84-Makefile><span class=nav-number>2.10.</span> <span class=nav-text>引用其它的 Makefile</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-MAKEFILES><span class=nav-number>2.11.</span> <span class=nav-text>环境变量 MAKEFILES</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#make-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F><span class=nav-number>2.12.</span> <span class=nav-text>make 的工作方式</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99><span class=nav-number>3.</span> <span class=nav-text>书写规则</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%84%E5%88%99%E4%B8%BE%E4%BE%8B><span class=nav-number>3.1.</span> <span class=nav-text>规则举例</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%84%E5%88%99%E7%9A%84%E8%AF%AD%E6%B3%95><span class=nav-number>3.2.</span> <span class=nav-text>规则的语法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9C%A8%E8%A7%84%E5%88%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6><span class=nav-number>3.3.</span> <span class=nav-text>在规则中使用通配符</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E6%90%9C%E5%AF%BB><span class=nav-number>3.4.</span> <span class=nav-text>文件搜寻</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BC%AA%E7%9B%AE%E6%A0%87><span class=nav-number>3.5.</span> <span class=nav-text>伪目标</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%A4%9A%E7%9B%AE%E6%A0%87><span class=nav-number>3.6.</span> <span class=nav-text>多目标</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F><span class=nav-number>3.7.</span> <span class=nav-text>静态模式</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%80%A7><span class=nav-number>3.8.</span> <span class=nav-text>自动生成依赖性</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%B9%A6%E5%86%99%E5%91%BD%E4%BB%A4><span class=nav-number>4.</span> <span class=nav-text>书写命令</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4><span class=nav-number>4.1.</span> <span class=nav-text>显示命令</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C><span class=nav-number>4.2.</span> <span class=nav-text>命令执行</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99><span class=nav-number>4.3.</span> <span class=nav-text>命令出错</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8C-make><span class=nav-number>4.4.</span> <span class=nav-text>嵌套执行 make</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%8C%85><span class=nav-number>4.5.</span> <span class=nav-text>定义命令包</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F><span class=nav-number>5.</span> <span class=nav-text>使用变量</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E7%A1%80><span class=nav-number>5.1.</span> <span class=nav-text>变量的基础</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F><span class=nav-number>5.2.</span> <span class=nav-text>变量中的变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%98%E9%87%8F%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95><span class=nav-number>5.3.</span> <span class=nav-text>变量高级用法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%BD%E5%8A%A0%E5%8F%98%E9%87%8F%E5%80%BC><span class=nav-number>5.4.</span> <span class=nav-text>追加变量值</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#override-%E6%8C%87%E7%A4%BA%E7%AC%A6><span class=nav-number>5.5.</span> <span class=nav-text>override 指示符</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%A4%9A%E8%A1%8C%E5%8F%98%E9%87%8F><span class=nav-number>5.6.</span> <span class=nav-text>多行变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F><span class=nav-number>5.7.</span> <span class=nav-text>环境变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F><span class=nav-number>5.8.</span> <span class=nav-text>目标变量</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F><span class=nav-number>5.9.</span> <span class=nav-text>模式变量</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD><span class=nav-number>6.</span> <span class=nav-text>使用条件判断</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B><span class=nav-number>6.1.</span> <span class=nav-text>示例</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AF%AD%E6%B3%95><span class=nav-number>6.2.</span> <span class=nav-text>语法</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0><span class=nav-number>7.</span> <span class=nav-text>使用函数</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%AD%E6%B3%95><span class=nav-number>7.1.</span> <span class=nav-text>函数的调用语法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0><span class=nav-number>7.2.</span> <span class=nav-text>字符串处理函数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#subst><span class=nav-number>7.2.1.</span> <span class=nav-text>subst</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#patsubst><span class=nav-number>7.2.2.</span> <span class=nav-text>patsubst</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#strip><span class=nav-number>7.2.3.</span> <span class=nav-text>strip</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#findstring><span class=nav-number>7.2.4.</span> <span class=nav-text>findstring</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#filter><span class=nav-number>7.2.5.</span> <span class=nav-text>filter</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#filter-out><span class=nav-number>7.2.6.</span> <span class=nav-text>filter-out</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#sort><span class=nav-number>7.2.7.</span> <span class=nav-text>sort</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#word><span class=nav-number>7.2.8.</span> <span class=nav-text>word</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#wordlist><span class=nav-number>7.2.9.</span> <span class=nav-text>wordlist</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#words><span class=nav-number>7.2.10.</span> <span class=nav-text>words</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#firstword><span class=nav-number>7.2.11.</span> <span class=nav-text>firstword</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E5%90%8D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0><span class=nav-number>7.3.</span> <span class=nav-text>文件名操作函数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#dir><span class=nav-number>7.3.1.</span> <span class=nav-text>dir</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#notdir><span class=nav-number>7.3.2.</span> <span class=nav-text>notdir</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#su%EF%AC%80ix><span class=nav-number>7.3.3.</span> <span class=nav-text>suﬀix</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#basename><span class=nav-number>7.3.4.</span> <span class=nav-text>basename</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#addsu%EF%AC%80ix><span class=nav-number>7.3.5.</span> <span class=nav-text>addsuﬀix</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#addprefix><span class=nav-number>7.3.6.</span> <span class=nav-text>addprefix</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#join><span class=nav-number>7.3.7.</span> <span class=nav-text>join</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#foreach-%E5%87%BD%E6%95%B0><span class=nav-number>7.4.</span> <span class=nav-text>foreach 函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#if-%E5%87%BD%E6%95%B0><span class=nav-number>7.5.</span> <span class=nav-text>if 函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#call-%E5%87%BD%E6%95%B0><span class=nav-number>7.6.</span> <span class=nav-text>call 函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#origin-%E5%87%BD%E6%95%B0><span class=nav-number>7.7.</span> <span class=nav-text>origin 函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#shell-%E5%87%BD%E6%95%B0><span class=nav-number>7.8.</span> <span class=nav-text>shell 函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8E%A7%E5%88%B6-make-%E7%9A%84%E5%87%BD%E6%95%B0><span class=nav-number>7.9.</span> <span class=nav-text>控制 make 的函数</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#make-%E7%9A%84%E8%BF%90%E8%A1%8C><span class=nav-number>8.</span> <span class=nav-text>make 的运行</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#make-%E7%9A%84%E9%80%80%E5%87%BA%E7%A0%81><span class=nav-number>8.1.</span> <span class=nav-text>make 的退出码</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8C%87%E5%AE%9A-Makefile><span class=nav-number>8.2.</span> <span class=nav-text>指定 Makefile</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87><span class=nav-number>8.3.</span> <span class=nav-text>指定目标</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A3%80%E6%9F%A5%E8%A7%84%E5%88%99><span class=nav-number>8.4.</span> <span class=nav-text>检查规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#make-%E7%9A%84%E5%8F%82%E6%95%B0><span class=nav-number>8.5.</span> <span class=nav-text>make 的参数</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99><span class=nav-number>9.</span> <span class=nav-text>隐含规则</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99><span class=nav-number>9.1.</span> <span class=nav-text>使用隐含规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%80%E8%A7%88><span class=nav-number>9.2.</span> <span class=nav-text>隐含规则一览</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F><span class=nav-number>9.3.</span> <span class=nav-text>隐含规则使用的变量</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82><span class=nav-number>9.3.1.</span> <span class=nav-text>关于命令的变量。</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F><span class=nav-number>9.3.2.</span> <span class=nav-text>关于命令参数的变量</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E9%93%BE><span class=nav-number>9.4.</span> <span class=nav-text>隐含规则链</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99><span class=nav-number>9.5.</span> <span class=nav-text>定义模式规则</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99%E4%BB%8B%E7%BB%8D><span class=nav-number>9.5.1.</span> <span class=nav-text>模式规则介绍</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99%E7%A4%BA%E4%BE%8B><span class=nav-number>9.5.2.</span> <span class=nav-text>模式规则示例</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F><span class=nav-number>9.5.3.</span> <span class=nav-text>自动化变量</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D><span class=nav-number>9.5.4.</span> <span class=nav-text>模式的匹配</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%87%8D%E8%BD%BD%E5%86%85%E5%BB%BA%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99><span class=nav-number>9.5.5.</span> <span class=nav-text>重载内建隐含规则</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%80%81%E5%BC%8F%E9%A3%8E%E6%A0%BC%E7%9A%84%E2%80%9C%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E2%80%9D><span class=nav-number>9.6.</span> <span class=nav-text>老式风格的“后缀规则”</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95><span class=nav-number>9.7.</span> <span class=nav-text>隐含规则搜索算法</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-make-%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6><span class=nav-number>10.</span> <span class=nav-text>使用 make 更新函数库文件</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%88%90%E5%91%98><span class=nav-number>10.1.</span> <span class=nav-text>函数库文件的成员</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%BA%93%E6%88%90%E5%91%98%E7%9A%84%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99><span class=nav-number>10.2.</span> <span class=nav-text>函数库成员的隐含规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99><span class=nav-number>10.3.</span> <span class=nav-text>函数库文件的后缀规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>10.4.</span> <span class=nav-text>注意事项</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><p class=site-author-name itemprop=name>gzwillyy<div class=site-description itemprop=description></div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>69</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>14</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>92</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/gzwillyy" href=https://github.com/gzwillyy target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=http://gzwilly.blog/post/with-me-makefile.html itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.gif itemprop=image> <meta content=gzwillyy itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=gzwilly'blog itemprop=name> <meta itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="跟我一起写 makefile | gzwilly'blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>跟我一起写 makefile</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-03-03 11:44:25" datetime=2023-03-03T11:44:25+08:00>2023-03-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Notes/ itemprop=url rel=index><span itemprop=name>Notes</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><p><code>github</code>文档地址: <a href=https://github.com/seisman/how-to-write-makefile rel=noopener target=_blank>https://github.com/seisman/how-to-write-makefile</a><h1 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h1><p>什么是 <code>makefile</code> ？或许很多 <code>Windows</code> 的程序员都不知道这个东西，因为那些 <code>Windows</code> 的集成开发环境（<code>integrated development environment，IDE</code>）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，<code>makefile</code> 还是要懂。这就好像现在有这么多的 <code>HTML</code> 编辑器，但如果你想成为一个专业人士，你还是要了解 <code>HTML</code> 的标签的含义。特别在 <code>Unix</code> 下的软件编译，你就不能不自己写 <code>makefile</code> 了，会不会写 <code>makefile</code>，从一个侧面说明了一个人是否具备完成大型工程的能力。</p><span id=more></span><p>因为，<code>makefile</code> 关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，<code>makefile</code> 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>makefile</code> 就像一个 <code>Shell</code> 脚本一样，其中也可以执行操作系统的命令。<p><code>makefile</code> 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>make</code> 是一个命令工具，是一个解释 <code>makefile</code> 中指令的命令工具，一般来说，大多数的 <code>IDE</code> 都有这个命令，比如：<code>Delphi</code> 的 <code>make</code>，<code>Visual C++</code>的 <code>nmake</code>，<code>Linux</code> 下<code>GNU</code> 的 <code>make</code>。可见，<code>makefile</code> 都成为了一种在工程方面的编译方法。<p>现在讲述如何写 <code>makefile</code> 的文章比较少，这是我想写这篇文章的原因。当然，不同产商的 <code>make</code> 各不相同，也有不同的语法，但其本质都是在 <code>文件依赖性</code> 上做文章，这里，我仅对 <code>GNU</code> 的 <code>make</code> 进行讲述，我的环境是 <code>RedHat Linux 8.0</code>，<code>make</code> 的版本是 <code>3.80</code>。毕竟，这个 <code>make</code> 是应用最为广泛的，也是用得最多的。而且其还是最遵循于 <code>IEEE 1003.2-1992</code> 标准的（<code>POSIX.2</code>）。<p>在这篇文档中，将以 <code>C/C++</code> 的源码作为基础，所以必然涉及一些关于 <code>C/C++</code> 的编译的知识。关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是 <code>UNIX</code> 下的 <code>GCC</code> 和 <code>CC</code>。<h2 id=关于程序的编译和链接><a class=headerlink href=#关于程序的编译和链接 title=关于程序的编译和链接></a>关于程序的编译和链接</h2><p>在此，我想多说关于程序编译的一些规范和方法。一般来说，无论是 <code>C</code> 还是 <code>C++</code>，首先要把源文件编译成中间代码文件，在 <code>Windows</code> 下也就是 <code>.obj</code> 文件，<code>UNIX </code>下是 <code>.o </code>文件，即 <code>Object File</code>，这个动作叫做编译（<code>compile</code>）。然后再把大量的 <code>Object File</code> 合成执行文件，这个动作叫作链接（<code>link</code>）。编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在<code> C/C++</code> 文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（<code>.o</code> 文件或 <code>.obj</code> 文件）。<p>链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（<code>.o</code> 文件或 <code>.obj</code> 文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（<code>Object File</code>），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在 <code>Windows</code> 下这种包叫“<code>库文件</code>”（<code>Library File</code>），也就是 <code>.lib</code> 文件，在 <code>UNIX</code> 下，是<code>Archive File</code>，也就是 <code>.a</code> 文件。<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 <code>ObjectFile</code>。而在链接程序时，链接器会在所有的 <code>Object File</code> 中找寻函数的实现，如果找不到，那到就会报链接错误码（<code>Linker Error</code>），在 <code>VC </code>下，这种错误一般是：<code>Link 2001 </code>错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的 <code>Object File</code>。<p>好，言归正传，<code>gnu</code> 的 <code>make</code> 有许多的内容，闲言少叙。<h1 id=makefile-介绍><a title="makefile 介绍" class=headerlink href=#makefile-介绍></a>makefile 介绍</h1><p><code>make</code> 命令执行时，需要一个 <code>makefile</code> 文件，以告诉 <code>make</code> 命令需要怎么样的去编译和链接程序。<br>首先，我们用一个示例来说明 <code>makefile</code> 的书写规则，以便给大家一个感性认识。这个示例来源于 <code>gnu</code>的 <code>make</code> 使用手册，在这个示例中，我们的工程有 8 个 <code>c</code> 文件，和 3 个<code>头</code>文件，我们要写一个 <code>makefile</code>来告诉 make 命令如何编译和链接这几个文件。我们的规则是：<ol><li>如果这个工程没有编译过，那么我们的所有 <code>c</code> 文件都要编译并被链接。<li>如果这个工程的某几个 <code>c</code> 文件被修改，那么我们只编译被修改的 <code>c</code> 文件，并链接目标程序。<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 <code>c</code> 文件，并链接目标程序。</ol><p>只要我们的 <code>makefile</code> 写得够好，所有的这一切，我们只用一个 <code>make</code> 命令就可以完成，<code>make</code> 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。<h2 id=makefile-的规则><a title="makefile 的规则" class=headerlink href=#makefile-的规则></a>makefile 的规则</h2><p>在讲述这个 <code>makefile</code> 之前，还是让我们先来粗略地看一看 <code>makefile</code> 的规则。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">target ...</span> <span class="token punctuation">:</span> prerequisites ...
  command
  ...
  ...<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>target</code> ：</strong><br>可以是一个 <code>object file</code>（目标文件），也可以是一个执行文件，还可以是一个标签（<code>label</code>）。对于标签这种特性，在后续的<code>伪目标</code>章节中会有叙述。<p><strong><code>prerequisites</code> ：</strong><br>生成该 <code>target</code> 所依赖的文件和<code>/</code>或 <code>target</code><p><strong><code>command</code> ：</strong><br>该 <code>target</code> 要执行的命令（任意的 <code>shell</code> 命令）<p>这是一个文件的依赖关系，也就是说，target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说:<pre class="line-numbers language-none"><code class=language-none>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这就是 <code>makefile</code> 的规则，也就是 <code>makefile</code> 中最核心的内容。<p>说到底，<code>makefile</code> 的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是 <code>makefile</code> 的主线和核心，但要写好一个 <code>makefile</code> 还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。 内容还多着呢。:)<h2 id=一个示例><a class=headerlink href=#一个示例 title=一个示例></a>一个示例</h2><p>正如前面所说，如果一个工程有 3 个头文件和 8 个 c 文件，为了完成前面所述的那三个规则，我们的 <code>makefile</code> 应该是下面的这个样子的。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h
    cc -c main.c
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> kbd.c defs.h command.h
    cc -c kbd.c
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> command.c defs.h command.h
    cc -c command.c
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> display.c defs.h buffer.h
    cc -c display.c
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> insert.c defs.h buffer.h
    cc -c insert.c
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> search.c defs.h buffer.h
    cc -c search.c
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> files.c defs.h buffer.h command.h
    cc -c files.c
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> utils.c defs.h
    cc -c utils.c
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反斜杠(<code>\ </code>)是换行符的意思。这样比较便于 <code>makefile</code> 的阅读。我们可以把这个内容保存在名字为 <code>makefile</code> 或 <code>Makefile</code> 的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件 <code>edit</code>。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就可以了。<p>在这个 <code>makefile</code> 中，目标文件(<code>target</code>)包含:执行文件 <code>edit</code> 和中间目标文件(<code>*.o</code> )，依赖文件 (<code>prerequisites</code>)就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code>文件又是执行文件 <code>edit</code> 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，<em><strong>一定要以一个 <code>Tab</code> 键作为开头</strong></em>。记住，<code>make</code> 并不管命令是怎么工作的，他只管执行所定义的命令。<p><em><strong><code>make</code>会比较<code>targets</code>文件和<code>prerequisites</code>文件的修改日期，如果<code>prerequisites</code>文件的日期要比<code>targets</code>文件的日期要新，或者<code>target</code>不存在的话，那么，<code>make</code>就会执行后续定义的命令。</strong></em><p>这里要说明一点的是，<code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像 <code>c </code>语言中的 <code>label</code> 一 样，其冒号后什么也没有，那么，<code>make</code> 就不会自动去找它的依赖性，也就不会自动执行其后所定义的命 令。要执行其后的命令，就要在 <code>make</code> 命令后明显得指出这个 <code>label</code> 的名字。这样的方法非常有用，我们 可以在一个 <code>makefile</code> 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。<h2 id=make-是如何工作的><a title="make 是如何工作的" class=headerlink href=#make-是如何工作的></a>make 是如何工作的</h2><p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，<ol><li>make 会在当前目录下找名字叫 <code>Makefile</code> 或 <code>makefile</code> 的文件。<li>如果找到，它会找文件中的第一个目标文件(<code>target</code>)，在上面的例子中，他会找到 <code>edit</code> 这个文 件，并把这个文件作为最终的目标文件。<li>如果 <code>edit</code> 文件不存在，或是 <code>edit</code> 所依赖的后面的 <code>.o </code>文件的文件修改时间要比 <code>edit</code> 这个文件新， 那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。<li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么 <code>make</code> 会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如 果找到则再根据那一个规则生成 <code>.o</code> 文件。(这有点像一个堆栈的过程)<li>当然，你的 <code>C</code> 文件和 <code>H</code> 文件是存在的啦，于是 <code>make</code> 会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成 <code>make</code> 的终极任务，也就是执行文件 <code>edit</code> 了。</ol><p>这就是整个 <code>make</code> 的依赖性，<code>make</code> 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 <code>make</code> 就会直接退出，并 报错，而对于所定义的命令的错误，或是编译不成功，<code>make </code>根本不理。<code>make</code> 只管文件的依赖性，即，如 果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。<p>通过上述分析，我们知道，像 <code>clean</code> 这种，没有被第一个目标文件直接或间接关联，那么它后面所定 义的命令将不会被自动执行，不过，我们可以显示要 <code>make</code> 执行。即命令——<code>make clean</code> ，以此来清除 所有的目标文件，以便重编译。<br>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 <code>file.c</code> ，那 么根据我们的依赖性，我们的目标 <code>file.o</code> 会被重编译(也就是在这个依性关系后面所定义的命令)，于 是 <code>file.o</code> 的文件也是最新的啦，于是 <code>file.o</code> 的文件修改时间要比 <code>edit</code> 要新，所以 <code>edit</code> 也会被重新 链接了(详见 <code>edit</code> 目标文件后定义的命令)。<p>而如果我们改变了 <code>command.h</code> ，那么，<code>kdb.o</code> 、<code>command.o</code> 和 <code>files.o</code> 都会被重编译，并且，<code>edit</code> 会被重链接。<h2 id=makefile-中使用变量><a title="makefile 中使用变量" class=headerlink href=#makefile-中使用变量></a>makefile 中使用变量</h2><p>在上面的例子中，先让我们看看 edit 的规则:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">edit</span> <span class="token punctuation">:</span> main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>我们可以看到 <code>.o </code>文件的字符串被重复了两次，如果我们的工程需要加入一个新的 <code>.o </code>文件，那么我 们需要在两个地方加(应该是三个地方，还有一个地方<code>clean</code> 中)。当然，我们的 <code>makefile</code> 并不复杂，所 以在两个地方加也不累，但如果 <code>makefile</code> 变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而 导致编译失败。所以，为了 <code>makefile</code> 的易维护，在 <code>makefile</code> 中我们可以使用变量。<code>makefile</code> 的变量也就 是一个字符串，理解成 <code>C</code> 语言中的宏可能会更好。<p>比如，我们声明一个变量，叫 <code>objects</code> ，<code>OBJECTS</code>，<code>objs</code> ，<code>OBJS</code> ，<code>obj</code> 或是 <code>OBJ</code> ，反正不管什么 啦，只要能够表示 <code>obj</code> 文件就行了。我们在 makefile 一开始就这样定义:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>于是，我们就可以很方便地在我们的 makefile 中以 $(objects) 的方式来使用这个变量了，于是我 们的改良版 makefile 就变成下面这个样子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>
objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h
    cc -c main.c
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> kbd.c defs.h command.h
    cc -c kbd.c
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> command.c defs.h command.h
    cc -c command.c
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> display.c defs.h buffer.h
    cc -c display.c
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> insert.c defs.h buffer.h
    cc -c insert.c
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> search.c defs.h buffer.h
    cc -c search.c
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> files.c defs.h buffer.h command.h
    cc -c files.c
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> utils.c defs.h
    cc -c utils.c
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。<h2 id=让-make-自动推导><a title="让 make 自动推导" class=headerlink href=#让-make-自动推导></a>让 make 自动推导</h2><p><code>GNU</code> 的 <code>make</code> 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的 <code>make</code> 会自动识别，并自己推导命令。<p>只要 <code>make</code> 看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果 <code>make</code> 找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的 <code>makefile</code> 再也不用写得这么复杂。我们的新 <code>makefile</code> 又出炉了。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
  cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol">main.o</span> <span class="token punctuation">:</span> defs.h
<span class="token target symbol">kbd.o</span> <span class="token punctuation">:</span> defs.h command.h
<span class="token target symbol">command.o</span> <span class="token punctuation">:</span> defs.h command.h
<span class="token target symbol">display.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">insert.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">search.o</span> <span class="token punctuation">:</span> defs.h buffer.h
<span class="token target symbol">files.o</span> <span class="token punctuation">:</span> defs.h buffer.h command.h
<span class="token target symbol">utils.o</span> <span class="token punctuation">:</span> defs.h

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
  rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法，也就是 <code>make</code> 的 <code>隐晦规则</code> 。上面文件内容中，<code>.PHONY</code> 表示 <code>clean</code> 是个伪目标文件。<h2 id=另类风格的-makefiles><a title="另类风格的 makefiles" class=headerlink href=#另类风格的-makefiles></a>另类风格的 makefiles</h2><p>既然我们的 <code>make</code> 可以自动推导命令，那么我看到那堆 <code>.o</code> 和 <code>.h</code> 的依赖就有点不爽，那么多的重复的 <code>.h</code> ，能不能把其收拢起来，好吧，没有问题，这个对于 <code>make</code> 来说很容易，谁叫它提供了自动推导命令和文件的功能呢?来看看最新风格的 <code>makefile</code> 吧。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

<span class="token target symbol">edit</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token target symbol"><span class="token variable">$</span>(objects)</span> <span class="token punctuation">:</span> defs.h

<span class="token target symbol">kbd.o command.o files.o</span> <span class="token punctuation">:</span> command.h
<span class="token target symbol">display.o insert.o search.o files.o</span> <span class="token punctuation">:</span> buffer.h

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种风格，让我们的 <code>makefile</code> 变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多， 要加入几个新的 <code>.o</code> 文件，那就理不清楚了。<h2 id=清空目标文件的规则><a class=headerlink href=#清空目标文件的规则 title=清空目标文件的规则></a>清空目标文件的规则</h2><p>每个 <code>Makefile</code> 中都应该写一个清空目标文件(<code>.o</code> 和执行文件)的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”(呵呵，还记得我的《编程修养》吗)。一般的风格都是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>更为稳健的做法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm edit <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>前面说过，<code>.PHONY</code> 表示 <code>clean</code> 是一个“<code>伪目标</code>”。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也 许某些文件出现问题，但不要管，继续做后面的事。当然，<code>clean </code>的规则不要放在文件的开头，不然，这就会变成 <code>make</code> 的默认目标，相信谁也不愿意这样。不成文的规矩是——“<code>clean 从来都是放在文件的最后</code>”。<p>上面就是一个 <code>makefile</code> 的概貌，也是 <code>makefile</code> 的基础，下面还有很多 <code>makefile</code> 的相关细节，准备好 了吗?准备好了就来。<h2 id=Makefile-里有什么><a title="Makefile 里有什么?" class=headerlink href=#Makefile-里有什么></a>Makefile 里有什么?</h2><p><code>Makefile</code> 里主要包含了五个东西:显式规则、隐晦规则、变量定义、文件指示和注释。<ol><li><p><code>显式规则</code>。显式规则说明了如何生成一个或多个目标文件。这是由 <code>Makefile</code> 的书写者明显指出要 生成的文件、文件的依赖文件和生成的命令。</p><li><p><code>隐晦规则</code>。由于我们的 <code>make</code> 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 <code>Make-file</code>，这是由 <code>make</code> 所支持的。</p><li><p><code>变量的定义</code>。在 <code>Makefile</code> 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 <code>C</code> 语言中的宏，当 <code>Makefile</code> 被执行时，其中的变量都会被扩展到相应的引用位置上。</p><li><p><code>文件指示</code>。其包括了三个部分，一个是在一个 <code>Makefile</code> 中引用另一个 <code>Makefile</code>，就像 <code>C</code> 语言中的 <code>include</code> 一样;另一个是指根据某些情况指定 <code>Makefile</code> 中的有效部分，就像 <code>C</code> 语言中的预编译 <code>#if</code> 一样;还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p><li><p><code>注释</code>。<code>Makefile</code> 中只有行注释，和 <code>UNIX</code> 的 <code>Shell</code> 脚本一样，其注释是用 <code>#</code> 字符，这个就像 <code>C/C++</code> 中的 // 一样。如果你要在你的 <code>Makefile</code> 中使用 <code>#</code> 字符，可以用反斜杠进行转义，如:<code>\#</code> 。</p></ol><p>最后，还值得一提的是，在 <code>Makefile</code> 中的命令，必须要以 <code>Tab</code> 键开始<h2 id=Makefile-的文件名><a title="Makefile 的文件名" class=headerlink href=#Makefile-的文件名></a>Makefile 的文件名</h2><p>默认的情况下，<code>make</code> 命令会在当前目录下按顺序找寻文件名为“<code>GNUmakefile</code>”、“<code>makefile</code>”、“<code>Make-file</code>”的文件，找到了解释这个文件。在这三个文件名中，最好使用“<code>Makefile</code>”这个文件名，因为，这 个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“<code>GNUmakefile</code>”，这个文件是 <code>GNU</code> 的 <code>make</code> 识别的。有另外一些 <code>make</code> 只对全小写的“<code>makefile</code>”文件名敏感，但是基本上来说，大多数的 <code>make</code> 都支持“<code>makefile</code>”和“<code>Makefile</code>”这两种默认文件名。<p>当然，你可以使用别的文件名来书写 <code>Makefile</code>，比如:“<code>Make.Linux</code>”，“<code>Make.Solaris</code>”，“<code>Make.AIX</code>” 等，如果要指定特定的 <code>Makefile</code>，你可以使用 <code>make</code> 的 <code>-f</code> 和 <code>--file</code> 参数，如:<code>make -f Make.Linux</code> 或 <code>make --file Make.AIX</code> 。<h2 id=引用其它的-Makefile><a title="引用其它的 Makefile" class=headerlink href=#引用其它的-Makefile></a>引用其它的 Makefile</h2><p>在 <code>Makefile</code> 使用 <code>include</code> 关键字可以把别的 <code>Makefile</code> 包含进来，这很像 <code>C</code> 语言的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code> 的语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">include</span> &LTfilename><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p><code>filename</code> 可以是当前操作系统 Shell 的文件模式(可以包含路径和通配符)。<p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。<code>include</code> 和 <code>&LTfilename></code> 可以用一个或多个空格隔开。举个例子，你有这样几个 <code>Makefile:a.mk</code> 、<code>b.mk</code> 、<code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code> ，其包含了 <code>e.mk</code> 和 <code>f.mk</code> ，那么，下面的语句:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">include</span> foo.make *.mk <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p><code>make</code> 命令开始时，会找寻 <code>include</code> 所指出的其它 <code>Makefile</code>，并把其内容安置在当前的位置。就好像 <code>C/C++</code> 的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，<code>make</code> 会在当前目录下首先寻找，如果当前目录下没有找到，那么，<code>make</code> 还会在下面的几个目录下找:<ol><li><p>如果 <code>make</code> 执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么 <code>make</code> 就会在这个参数所指定的目录下去寻找。</p><li><p>如果目录<code>&LTprefix>/include</code>(一般是: <code>/usr/local/bin</code> 或 <code>/usr/include</code> )存在的话，<code>make</code>也会去找。</p></ol><p>如果有文件没有找到的话，<code>make</code> 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 <code>makefile</code> 的读取，<code>make</code>会再重试这些没有找到，或是不能读取的文件，如果还是不行，<code>make</code> 才会出现一条致命信息。如果你想让 <code>make</code> 不理那些无法读取的文件，而继续执行，你可以在 <code>include</code> 前加一个减号 “<code>-</code>”。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">-include</span> &LTfilename><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其表示，无论 <code>include</code> 过程中出现什么错误，都不要报错继续执行。和其它版本 <code>make</code> 兼容的相关命令是 <code>sinclude</code>，其作用和这一个是一样的。<h2 id=环境变量-MAKEFILES><a title="环境变量 MAKEFILES" class=headerlink href=#环境变量-MAKEFILES></a>环境变量 MAKEFILES</h2><p>如果你的当前环境中定义了环境变量 <code>MAKEFILES</code> ，那么，<code>make</code> 会把这个变量中的值做一个类似于 <code>include</code> 的动作。这个变量中的值是其它的 <code>Makefile</code>，用空格分隔。只是，它和 <code>include</code> 不同的是，从这个环境变量中引入的 <code>Makefile</code> 的“<code>目标</code>”不会起作用，如果环境变量中定义的文件发现错误，<code>make</code> 也 会不理。<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 <code>make</code> 时，所有的 <code>Makefile</code> 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也 许有时候你的 <code>Makefile</code> 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。<h2 id=make-的工作方式><a title="make 的工作方式" class=headerlink href=#make-的工作方式></a>make 的工作方式</h2><p><code>GNU</code> 的 <code>make</code> 工作时的执行步骤如下:(想来其它的 <code>make</code> 也是类似)<ol><li>读入所有的 <code>Makefile</code><li>读入被 <code>include</code> 的其它 <code>Makefile</code>。<li>初始化文件中的变量。<li>推导隐晦规则，并分析所有规则。<li>为所有的目标文件创建依赖关系链。<li>根据依赖关系，决定哪些目标要重新生成。<li>执行生成命令。</ol><p><code>1-5</code> 步为第一个阶段，<code>6-7</code> 为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，<code>make</code> 会 把其展开在使用的位置。但 <code>make</code> 并不会完全马上展开，<code>make</code> 使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对 <code>make</code> 更为熟悉。有了这个基础， 后续部分也就容易看懂了。<h1 id=书写规则><a class=headerlink href=#书写规则 title=书写规则></a>书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。<p>在 <code>Makefile</code> 中，规则的顺序是很重要的，因为，<code>Makefile</code> 中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 <code>make</code> 知道你的最终目标是什么。一般来说，定义在 <code>Makefile</code> 中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。<code>make</code> 所完成的也就是这个目标。<h2 id=规则举例><a class=headerlink href=#规则举例 title=规则举例></a>规则举例</h2><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo.o</span><span class="token punctuation">:</span> foo.c defs.h  <span class="token comment"># foo模块</span>
    cc -c -g foo.c<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>看到这个例子，各位应该不是很陌生了，前面也已说过，<code>foo.o</code> 是我们的目标，<code>foo.c</code> 和 <code>defs.h</code> 是 目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code> (以 <code>Tab</code> 键开头)。这个规则告诉我们两件事:<ol><li>文件的依赖关系，<code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code> 和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code>文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。<li>生成或更新 <code>foo.o</code> 文件，就是那个 <code>cc</code> 命令。它说明了如何生成 <code>foo.o</code> 这个文件。(当然，<code>foo.c</code> 文 件 <code>include</code> 了 <code>defs.h</code> 文件)</ol><h2 id=规则的语法><a class=headerlink href=#规则的语法 title=规则的语法></a>规则的语法</h2><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">targets</span> <span class="token punctuation">:</span> prerequisites
    command
    ...<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>或是这样:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">targets</span> <span class="token punctuation">:</span> prerequisites <span class="token punctuation">;</span> command
    command
    ...<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><code>targets</code> 是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也 有可能是多个文件。<br><code>command</code> 是命令行，如果其不与“<code>target:prerequisites</code>”在一行，那么，必须以 <code>Tab</code> 键开头，如果 和 <code>prerequisites</code> 在一行，那么可以用分号做为分隔。(见上)<br><code>prerequisites</code> 也就是目标所依赖的文件(或依赖目标)。如果其中的某个文件要比目标文件要新，那 么，目标就被认为是“<code>过时的</code>”，被认为是需要重生成的。这个在前面已经讲过了。<br>如果命令太长，你可以使用反斜杠(<code>\ </code>)作为换行符。<code>make</code> 对一行上有多少个字符没有限制。规则 告诉 <code>make</code> 两件事，文件的依赖关系和如何生成目标文件。<br>一般来说，<code>make</code> 会以 <code>UNIX</code> 的标准 <code>Shell</code>，也就是 <code>/bin/sh</code> 来执行命令。<h2 id=在规则中使用通配符><a class=headerlink href=#在规则中使用通配符 title=在规则中使用通配符></a>在规则中使用通配符</h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make 支持三个通配符:<br><code>*</code> ，<code>?</code> 和 <code>~</code> 。这是和 <code>Unix</code> 的 <code>B-Shell</code> 是相同的。<br>波浪号(<code>~</code> )字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code> ，这就表示当前用户的 <code>$HOME</code> 目 录下的 <code>test</code> 目录。而 <code>~hchen/test</code> 则表示用户 <code>hchen</code> 的宿主目录下的 <code>test</code> 目录。(这些都是 <code>Unix</code> 下的 小知识了，<code>make</code> 也支持)而在 <code>Windows</code> 或是 <code>MS-DOS</code> 下，用户没有宿主目录，那么波浪号所指的目录 则根据环境变量“<code>HOME</code>”而定。<br>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为 <code>c</code> 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如: <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。<p>例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm -f *.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>其实在这个 <code>clean:</code> 后面可以加上你想做的一些事情，如果你想看到在编译完后看看 <code>main.c</code> 的源代码，你可以在加上 <code>cat</code> 这个命令，例子如下:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    cat main.c
    rm -f *.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>其结果你试一下就知道的。上面这个例子我不不多说了，这是操作系统 <code>Shell</code> 所支持的通配符。这是在命令中的通配符。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">print</span><span class="token punctuation">:</span> *.c
    lpr -p <span class="token variable">$?</span>
    touch print<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>上面这个例子说明了通配符也可以在我们的规则中，目标 <code>print</code> 依赖于所有的 <code>.c</code> 文件。其中的 <code>$?</code> 是一个自动化变量，我会在后面给你讲述。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> *.o<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>上面这个例子，表示了通配符同样可以用在变量中。并不是说 <code>*.o</code> 会展开，不 <code>!objects</code> 的值就是 <code>*.o</code> 。<code>Makefile</code> 中的变量其实就是 <code>C/C++</code> 中的宏。如果你要让通配符在变量中展开，也就是让 <code>objects</code> 的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.o<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>另给一个变量使用通配符的例子:<ol><li>列出一确定文件夹中的所有.c文件。</ol><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ol start=2><li>列出 <code>(1)</code> 中所有文件对应的 <code>.o</code> 文件，在 <code>(3)</code> 中我们可以看到它是由 <code>make</code> 自动编译出的:</ol><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ol start=3><li>由 <code>(1)</code> <code>(2)</code> 两步，可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件</ol><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token target symbol">foo</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这种用法由关键字“<code>wildcard</code>”，“<code>patsubst</code>”指出，关于 <code>Makefile</code> 的关键字，我们将在后面讨论。<h2 id=文件搜寻><a class=headerlink href=#文件搜寻 title=文件搜寻></a>文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当 <code>make</code> 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 <code>make</code>，让 <code>make</code> 在自动去找。<p><code>Makefile</code> 文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，<code>make</code> 只会在当 前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，<code>make</code> 就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>上面的定义指定两个目录，“<code>src</code>”和“<code>../headers</code>”，<code>make</code> 会按照这个顺序进行搜索。目录由“<code>冒号</code>”分隔。(当然，当前目录永远是最高优先搜索的地方)<p>另一个设置文件搜索路径的方法是使用 <code>make</code> 的“<code>vpath</code>”关键字(注意，它是全小写的)，这不是变量，这是一个 <code>make</code> 的关键字，这和上面提到的那个 <code>VPATH</code> 变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">vpath</span> &LTpattern> &LTdirectories>
    为符合模式 &LTpattern> 的文件指定搜索目录 &LTdirectories>。
<span class="token keyword">vpath</span> &LTpattern>
    清除符合模式 &LTpattern> 的文件的搜索目录。
<span class="token keyword">vpath</span>
    清除所有已被设置好了的文件搜索目录。<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>vpath</code> 使用方法中的 <code>&LTpattern></code> 需要包含 <code>%</code> 字符。<code>%</code> 的意思是匹配零或若干字符，(需引用 <code>%</code> ，使用 <code>\</code> )例如，<code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<code>&LTpattern></code> 指定了要搜索的文件集，而 <code>&LTdirectories></code> 则 指定了 <code>&LTpattern></code> 的文件集的搜索的目录。例如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">vpath</span> %.h ../headers<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>该语句表示，要求 <code>make</code> 在“<code>../headers</code>”目录下搜索所有以 <code>.h</code> 结尾的文件。(如果某文件在当前目 录没有找到的话)<p>我们可以连续地使用 <code>vpath</code> 语句，以指定不同搜索策略。如果连续的 <code>vpath</code> 语句中出现了相同的 <code>&LTpattern></code> ，或是被重复了的 <code>&LTpattern></code>，那么，<code>make</code> 会按照 <code>vpath</code> 语句的先后顺序来执行搜索。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">vpath</span> %.c foo
<span class="token keyword">vpath</span> %   blish
<span class="token keyword">vpath</span> %.c bar<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>其表示 <code>.c</code> 结尾的文件，先在“<code>foo</code>”目录，然后是“<code>blish</code>”，最后是“<code>bar</code>”目录。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">vpath %.c foo</span><span class="token punctuation">:</span>bar
<span class="token keyword">vpath</span> %   blish<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>而上面的语句则表示 <code>.c</code>结尾的文件，先在“<code>foo</code>”目录，然后是“<code>bar</code>”目录，最后才是“<code>blish</code>”目录。<h2 id=伪目标><a class=headerlink href=#伪目标 title=伪目标></a>伪目标</h2><p>最早先的一个例子中，我们提到过一个“<code>clean</code>”的目标，这是一个“<code>伪目标</code>”，<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm *.o temp<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>正像我们前面例子中的“<code>clean</code>”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“<code>目标</code>”以备完整地重编译而用。(以“<code>make clean</code>”来使用该目标)<p>因为，我们并不生成“<code>clean</code>”这个文件。“<code>伪目标</code>”并不是一个文件，只是一个标签，由于“<code>伪目标</code>” 不是文件，所以 <code>make</code> 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“<code>目标</code>”才能让其生效。当然，“<code>伪目标</code>”的取名不能和文件名重名，不然其就失去了“<code>伪目标</code>”的意义了。<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“<code>.PHONY</code>”来显式地指明一个目标是“<code>伪目标</code>”，向 <code>make</code> 说明，不管是否有这个文件，这个目标就是“<code>伪目标</code>”。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>只要有这个声明，不管是否有“<code>clean</code>”文件，要运行“<code>clean</code>”这个目标，只有“<code>make clean</code>”这样。 于是整个过程可以这样写:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span> <span class="token punctuation">:</span>
    rm *.o temp<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为 “<code>默认目标</code>”，只要将其放在第一个。一个示例就是，如果你的 <code>Makefile</code> 需要一口气生成若干个可执行文件，但你只想简单地敲一个 <code>make</code> 完事，并且，所有的目标文件都写在一个 <code>Makefile</code> 中，那么你可以使用“<code>伪目标</code>”这个特性:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">all</span> <span class="token punctuation">:</span> prog1 prog2 prog3

<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> all
<span class="token target symbol">prog1</span> <span class="token punctuation">:</span> prog1.o utils.o
    cc -o prog1 prog1.o utils.o
<span class="token target symbol">prog2</span> <span class="token punctuation">:</span> prog2.o
    cc -o prog2 prog2.o
<span class="token target symbol">prog3</span> <span class="token punctuation">:</span> prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，<code>Makefile</code> 中的第一个目标会被作为其默认目标。我们声明了一个“<code>all</code>”的伪目标，其依赖 于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“<code>all</code>”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“<code>all</code>”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。<code>.PHONY : all</code> 声明了“<code>all</code>”这个目标为“<code>伪目标</code>”。(注:这里的显式“<code>.PHONY : all</code>”不写的话一般情况也可以正确的执行，这样 <code>make</code> 可通过隐式规则推导出，“<code>all</code>”是 一个伪目标，执行 <code>make</code> 不会生成“<code>all</code>”文件，而执行后面的多个目标。建议:显式写出是一个好习惯。)<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。<br>看下面的例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> cleanall cleanobj cleandiff

<span class="token target symbol">cleanall</span> <span class="token punctuation">:</span> cleanobj cleandiff
    rm program

<span class="token target symbol">cleanobj</span> <span class="token punctuation">:</span>
    rm *.o

<span class="token target symbol">cleandiff</span> <span class="token punctuation">:</span>
    rm *.diff<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“<code>make cleanall</code>”将清除所有要被清除的文件。“<code>cleanobj</code>”和“<code>cleandiff</code>”这两个伪目标有点像“<code>子程序</code>”的意思。我们可以输入“<code>make cleanall</code>”和“<code>make cleanobj</code>”和“<code>make cleandiff</code>”命令来达到清除不同种类文件的目的。<h2 id=多目标><a class=headerlink href=#多目标 title=多目标></a>多目标</h2><p><code>Makefile</code> 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@ </code>(关于自动化变量，将在后面讲述)，这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">bigoutput littleoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> output,,<span class="token variable">$@</span><span class="token punctuation">)</span> > <span class="token variable">$@</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>上述规则等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">bigoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -big > bigoutput
<span class="token target symbol">littleoutput</span> <span class="token punctuation">:</span> text.g
    generate text.g -little > littleoutput<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个 <code>Makefile</code> 的函数，函数名为 <code>subst</code>，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，<code>$@</code> 表示目标的集合，就像一个数组，<code>$@</code> 依次取出目标，并执于命令。<h2 id=静态模式><a class=headerlink href=#静态模式 title=静态模式></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">&LTtargets ...></span> <span class="token punctuation">:</span> &LTtarget-pattern> <span class="token punctuation">:</span> &LTprereq-patterns ...>
    &LTcommands>
    ...<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><code>targets</code> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。<br><code>target-pattern</code> 是指明了 <code>targets</code> 的模式，也就是的目标集模式。<br><code>prereq-patterns</code> 是目标的依赖模式，它对 <code>target-pattern</code> 形成的模式再进行一次依赖目标的定义。<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 <code>&LTtarget- pattern></code> 定义成 <code>%.o</code> ，意思是我们的<code> &LTtarget></code>; 集合中都是以 <code>.o </code>结尾的，而如果我们的 <code>&LTprereq- patterns></code> 定义成 <code>%.c</code> ，意思是对 <code>&LTtarget-pattern></code> 所形成的目标集进行二次定义，其计算方法是，取 <code>&LTtarget-pattern></code> 模式<br>中的 <code>% </code>(也就是去掉了 <code>.o</code> 这个结尾)，并为其加上 <code>.c</code> 这个结尾，形成的新集合。<p>所以，我们的“<code>目标模式</code>”或是“<code>依赖模式</code>”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么 你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。<p>看一个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> foo.o bar.o

<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$<</span> -o <span class="token variable">$@</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，指明了我们的目标从 <code>$object</code> 中获取，<code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o</code> <code>bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o </code>的 <code>%</code> ，也就是 <code>foo</code> <code>bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c</code> <code>bar.c</code> 。而命令中的 <code>$<</code> 和 <code>$@</code> 则是自动化变量，<code>$<</code> 表示第一个依赖文件，<code>$@</code> 表示目标集(也就是“<code>foo.o</code> <code>bar.o</code>”)。于是，上面的规则展开后等价 于下面的规则:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c -o foo.o
<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c -o bar.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的“<code>静态模式规则</code>”就可以写完一堆 规则，实在是太有效率了。“<code>静态模式规则</code>”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>files <span class="token operator">=</span> foo.elc bar.o lose.o

<span class="token target symbol"><span class="token variable">$</span>(filter %.o,<span class="token variable">$</span>(files))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$<</span> -o <span class="token variable">$@</span>

<span class="token target symbol"><span class="token variable">$</span>(filter %.elc,<span class="token variable">$</span>(files))</span><span class="token punctuation">:</span> %.elc<span class="token punctuation">:</span> %.el
    emacs -f batch-byte-compile <span class="token variable">$<</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>$(filter %.o,$(files))</code> 表示调用 <code>Makefile</code> 的 <code>filter</code> 函数，过滤“<code>$files</code>”集，只要其中模式为“<code>%.o</code>”的 内容。其它的内容，我就不用多说了吧。这个例子展示了 <code>Makefile</code> 中更大的弹性。<h2 id=自动生成依赖性><a class=headerlink href=#自动生成依赖性 title=自动生成依赖性></a>自动生成依赖性</h2><p>在 <code>Makefile</code> 中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的 <code>main.c</code> 中有一句 <code>#include "defs.h"</code> ，那么我们的依赖关系应该是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>但是，如果是一个比较大型的工程，你必需清楚哪些 <code>C</code> 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 <code>Makefile</code>，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 <code>C/C++</code> 编译的一个功能。大多数的 <code>C/C++</code> 编译器都支持一个“<code>-M</code>”的 选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>cc -M main.c<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其输出是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编 译器自动生成了。需要提醒一句的是，如果你使用 <code>GNU</code> 的 <code>C/C++ </code>编译器，你得用 <code>-MM </code>参数，不然，<code>-M</code> 参数会把一些标准库的头文件也包含进来。<p><code>gcc -M main.c</code> 的输出是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c defs.h /usr/<span class="token keyword">include</span>/stdio.h /usr/<span class="token keyword">include</span>/features.h \
    /usr/<span class="token keyword">include</span>/sys/cdefs.h /usr/<span class="token keyword">include</span>/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="token keyword">include</span>/stddef.h \
    /usr/<span class="token keyword">include</span>/bits/types.h /usr/<span class="token keyword">include</span>/bits/pthreadtypes.h \
    /usr/<span class="token keyword">include</span>/bits/sched.h /usr/<span class="token keyword">include</span>/libio.h \
    /usr/<span class="token keyword">include</span>/_G_config.h /usr/<span class="token keyword">include</span>/wchar.h \
    /usr/<span class="token keyword">include</span>/bits/wchar.h /usr/<span class="token keyword">include</span>/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="token keyword">include</span>/stdarg.h \
    /usr/<span class="token keyword">include</span>/bits/stdio_lim.h<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>gcc -MM main.c</code> 的输出则是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c defs.h<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>那么，编译器的这个功能如何与我们的 <code>Makefile</code> 联系在一起呢。因为这样一来，我们的 <code>Makefile</code> 也 要根据这些源文件重新生成，让 <code>Makefile</code> 自已依赖于源文件?这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。<code>GNU</code> 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的 <code>Makefile</code> 文件，<code>.d</code> 文件中就存放对应 <code>.c</code> 文件 的依赖关系。<p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让 <code>make</code> 自动更新或生成 <code>.d</code> 文件，并把其 包含在我们的主 <code>Makefile</code> 中，这样，我们就可以自动化地生成每个文件的依赖关系了。<p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.d</span><span class="token punctuation">:</span> %.c
    <span class="token operator">@</span>set -e<span class="token punctuation">;</span> rm -f <span class="token variable">$@;</span> \
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -M <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$<</span> > <span class="token variable">$@.$$$$;</span> \
    sed <span class="token string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> < <span class="token variable">$@.$$$$</span> > <span class="token variable">$@;</span> \ rm -f <span class="token variable">$@.$$$$</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件，<code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$<</code> ，也就是 <code>.c</code> 文件生成依赖文件，<code>$@</code> 表示模式 <code>%.d</code> 文件， 如果有一个 <code>C</code> 文件是 <code>name.c</code>，那么 <code>%</code> 就是 <code>name</code> ，<code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能 是“<code>name.d.12345</code>”，第三行使用 <code>sed</code> 命令做了一个替换，关于 <code>sed</code> 命令的用法请参看相关的使用文档。 第四行就是删除临时文件。<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>转成:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">main.o main.d</span> <span class="token punctuation">:</span> main.c defs.h<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 <code>.d</code> 文件中加入的 不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 <code>Makefile</code> 中。我们可以使用 <code>Makefile</code> 的“<code>include</code>”命令，来引入别的 <code>Makefile</code> 文件(前面讲过)，例如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>sources <span class="token operator">=</span> foo.c bar.c

<span class="token target symbol">include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>上述语句中的 <code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code> ，关于这个“<code>替换</code>”的内容，在后面我会有更为详细的讲述。当然，你得注意次序， 因为 <code>include</code> 是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目标会成为默认目标。<h1 id=书写命令><a class=headerlink href=#书写命令 title=书写命令></a>书写命令</h1><p>每条规则中的命令和操作系统 <code>Shell</code> 的命令行是一致的。<code>make</code> 会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以 <code>Tab</code> 键开头的，那么 <code>make</code> 会认为其是一个空命令。<p>我们在 <code>UNIX</code> 下可能会使用不同的 <code>Shell</code>，但是 <code>make</code> 的命令默认是被 <code>/bin/sh ——UNIX</code> 的标准 <code>Shell</code> 解释执行的。除非你特别指定一个其它的 <code>Shell</code>。<code>Makefile</code> 中，<code>#</code> 是注释符，很像 <code>C/C++</code> 中的 <code>//</code> ，其后的本行字符都被注释。<h2 id=显示命令><a class=headerlink href=#显示命令 title=显示命令></a>显示命令</h2><p>通常，<code>make</code> 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，<br>这个命令将不被 <code>make</code> 显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token operator">@</span>echo 正在编译XXX模块......<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>当 <code>make</code> 执行时，会输出“<code>正在编译 XXX 模块⋯⋯</code>”字串，但不会输出命令，如果没有“<code>@</code>”，那么，<code>make</code> 将输出:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>echo 正在编译XXX模块......
正在编译XXX模块......<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>如果 <code>make</code> 执行时，带入 <code>make</code> 参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令， 这个功能很有利于我们调试我们的 <code>Makefile</code>，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。<p>而 <code>make</code> 参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。<h2 id=命令执行><a class=headerlink href=#命令执行 title=命令执行></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，<code>make</code> 会一条一条的执行其后的命令。 需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比 如你的第一条命令是 <code>cd</code> 命令，你希望第二条命令得在 <code>cd</code> 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如:<p>示例一:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">exec</span><span class="token punctuation">:</span>
    cd /home/hchen
    pwd<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>示例二:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">exec</span><span class="token punctuation">:</span>
    cd /home/hchen<span class="token punctuation">;</span> pwd<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当我们执行 <code>make exec</code> 时，第一个例子中的 <code>cd</code> 没有作用，<code>pwd</code> 会打印出当前的 <code>Makefile</code> 目录，而 第二个例子中，<code>cd</code> 就起作用了，<code>pwd</code> 会打印出“<code>/home/hchen</code>”。<p><code>make</code> 一般是使用环境变量 <code>SHELL</code> 中所定义的系统 <code>Shell</code> 来执行命令，默认情况下使用 <code>UNIX</code> 的标 准 <code>Shell——/bin/sh</code> 来执行命令。但在 <code>MS-DOS</code> 下有点特殊，因为 <code>MS-DOS</code> 下没有 <code>SHELL</code> 环境变量， 当然你也可以指定。如果你指定了 <code>UNIX</code> 风格的目录形式，首先，<code>make</code> 会在 <code>SHELL</code> 所指定的路径中找 寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在 <code>PATH</code> 环境 变量中所定义的所有路径中寻找。<code>MS-DOS</code> 中，如果你定义的命令解释器没有找到，其会给你的命令解 释器加上诸如 <code>.exe</code> 、<code>.com</code> 、<code>.bat</code> 、<code>.sh</code> 等后缀。<h2 id=命令出错><a class=headerlink href=#命令出错 title=命令出错></a>命令出错</h2><p>每当命令运行完后，<code>make</code> 会检测每个命令的返回码，如果命令返回成功，那么 <code>make</code> 会执行下一条 命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错 了(命令退出码非零)，那么 <code>make</code> 就会终止执行当前规则，这将有可能终止所有规则的执行。<p>有些时候，命令的出错并不表示就是错误的。例如 <code>mkdir</code> 命令，我们一定需要建立一个目录，如果 目录不存在，那么 <code>mkdir</code> 就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用 <code>mkdir</code> 的意思就是一定要有这样的一个目录，于是我们就不希望 <code>mkdir</code> 出错而终止规则的运行。<p>为了做到这一点，忽略命令的出错，我们可以在 <code>Makefile</code> 的命令行前加一个减号 <code>-</code> (在 <code>Tab</code> 键之 后)，标记为不管命令出不出错都认为是成功的。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">clean</span><span class="token punctuation">:</span>
    -rm -f *.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>还有一个全局的办法是，给 <code>make</code> 加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，<code>Makefile</code> 中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。 这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。<p>还有一个要提一下的 <code>make</code> 的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。<h2 id=嵌套执行-make><a title="嵌套执行 make" class=headerlink href=#嵌套执行-make></a>嵌套执行 make</h2><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在 每个目录中都书写一个该目录的 <code>Makefile</code>，这有利于让我们的 <code>Makefile</code> 变得更加地简洁，而不至于把所 有的东西全部写在一个 <code>Makefile</code> 中，这样会很难维护我们的 <code>Makefile</code>，这个技术对于我们模块编译和分段编译有着非常大的好处。<p>例如，我们有一个子目录叫 <code>subdir</code>，这个目录下有个 <code>Makefile</code> 文件，来指明了这个目录下文件的编译规则。那么我们总控的 <code>Makefile</code> 可以这样书写:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir && <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>定义 <code>$(MAKE)</code> 宏变量的意思是，也许我们的 <code>make</code> 需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“<code>subdir</code>”目录，然后执行 <code>make</code> 命令。<br>我们把这个 <code>Makefile</code> 叫做“<code>总控 Makefile</code>”，<code>总控 Makefile</code> 的变量可以传递到下级的 <code>Makefile</code> 中 (如果你显示的声明)，但是不会覆盖下层的 <code>Makefile</code> 中所定义的变量，除非指定了 <code>-e</code> 参数。<br>如果你要传递变量到下级 <code>Makefile</code> 中，那么你可以使用这样的声明:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">export</span> &LTvariable ...><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如果你不想让某些变量传递到下级 <code>Makefile</code> 中，那么你可以这样声明:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">unexport</span> &LTvariable ...><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如:<br>示例一:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">export</span> variable <span class="token operator">=</span> value<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">=</span> value
<span class="token keyword">export</span> variable<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">export</span> variable <span class="token operator">:=</span> value<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">:=</span> value
<span class="token keyword">export</span> variable<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>示例二:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">export</span> variable <span class="token operator">+=</span> value<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">+=</span> value
<span class="token keyword">export</span> variable<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>如果你要传递所有的变量，那么，只要一个 export 就行了。后面什么也不用跟，表示传递所有的变量。<br>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否 <code>export</code>， 其总是要传递到下层 <code>Makefile</code> 中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了 <code>make</code> 的参数信息，如果我们执行“<code>总控 Makefile</code>”时有 <code>make</code> 参数或是在上层 <code>Makefile</code> 中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会 是这些参数，并会传递到下层 <code>Makefile</code> 中，这是一个系统级的环境变量。<br>但是 <code>make</code> 命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> (有关 <code>Makefile</code> 参数 的细节将在后面说明)，如果你不想往下层传递参数，那么，你可以这样来:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>
    cd subdir && <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> MAKEFLAGS<span class="token operator">=</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>如果你定义了环境变量 <code>MAKEFLAGS</code> ，那么你得确信其中的选项是大家都会用到的，如果其中有 <code>-t</code> , <code>-n</code> 和 <code>-q</code> 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。<p>还有一个在“<code>嵌套执行</code>”中比较有用的参数，<code>-w</code> 或是 <code>--print-directory</code> 会在 <code>make</code> 的过程中输出 一些信息，让你看到目前的工作目录。比如，如果我们的下级 <code>make</code> 目录是“<code>/home/hchen/gnu/make</code>”， 如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看到:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">make</span><span class="token punctuation">:</span> Entering directory `/home/hchen/gnu/make'.<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>而在完成下层 <code>make</code> 后离开目录时，我们会看到:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">make</span><span class="token punctuation">:</span> Leaving directory `/home/hchen/gnu/make'<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>当你使用 <code>-C</code> 参数来指定 <code>make</code> 下层 <code>Makefile</code> 时，<code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> (<code>--slient</code> )或是 <code>--no-print-directory</code> ，那么，<code>-w</code> 总是失效的。<h2 id=定义命令包><a class=headerlink href=#定义命令包 title=定义命令包></a>定义命令包</h2><p>如果 <code>Makefile</code> 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">define</span> run-yacc
yacc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">firstword</span> <span class="token variable">$^</span><span class="token punctuation">)</span>
mv y.tab.c <span class="token variable">$@</span>
<span class="token keyword">endef</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>这里，“<code>run-yacc</code>”是这个命令包的名字，其不要和 <code>Makefile</code> 中的变量重名。在 <code>define</code> 和 <code>endef</code> 中 的两行就是命令序列。这个命令包中的第一个命令是运行 <code>Yacc</code> 程序，因为 <code>Yacc</code> 程序总是生成“<code>y.tab.c</code>” 的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo.c</span> <span class="token punctuation">:</span> foo.y
    <span class="token variable">$</span><span class="token punctuation">(</span>run-yacc<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“<code>run- yacc</code>”中的 <code>$^</code> 就是 <code>foo.y</code> ，<code>$@</code> 就是 <code>foo.c</code>(有关这种以 <code>$</code> 开头的特殊变量，我们会在后面介绍)，<code>make</code> 在执行命令包时，命令包中的每个命令会被依次独立执行。<h1 id=使用变量><a class=headerlink href=#使用变量 title=使用变量></a>使用变量</h1><p>在 Makefile 中的定义的变量，就像是 <code>C/C++</code> 语言中的宏一样，他代表了一个文本字串，在 <code>Makefile</code> 中执行的时候其会自动原模原样地展开在所使用的地方。其与 <code>C/C++</code> 所不同的是，你可以在 <code>Makefile</code> 中改变其值。在 <code>Makefile</code> 中，变量可以使用在“<code>目标</code>”，“<code>依赖目标</code>”，“<code>命令</code>”或是 <code>Makefile</code> 的其它部分中。<p>变量的命名字可以包含字符、数字，下划线(可以是数字开头)，但不应该含有 : 、# 、= 或是空 字符(空格、回车等)。变量是大小写敏感的，“<code>foo</code>”、“<code>Foo</code>”和“<code>FOO</code>”是三个不同的变量名。传统的 <code>Makefile</code> 的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如:<code>MakeFlags</code>。这样可以 避免和系统的变量冲突，而发生意外的事情。<p>有一些变量是很奇怪字串，如 <code>$<</code> 、<code>$@</code> 等，这些是自动化变量，我会在后面介绍。<h2 id=变量的基础><a class=headerlink href=#变量的基础 title=变量的基础></a>变量的基础</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>{}</code> 把变量给包括起来。如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code> 来表示。<p>变量可以使用在许多地方，如规则中的“<code>目标</code>”、“<code>依赖</code>”、“<code>命令</code>”以及新的变量中。先看一个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> program.o foo.o utils.o

<span class="token target symbol">program</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    cc -o program <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>(objects)</span> <span class="token punctuation">:</span> defs.h<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量会在使用它的地方精确地展开，就像 <code>C/C++</code> 中的宏一样，例如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foo <span class="token operator">=</span> c
<span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> -<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> prog.<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>展开后得到:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.c
    cc -c prog.c<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当然，千万不要在你的 <code>Makefile</code> 中这样干，这里只是举个例子来表明 <code>Makefile</code> 中的变量在使用处展开的真实样子。可见其就是一个“<code>替代</code>”的原理。<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量 加上括号，那也可以，但我还是强烈建议你给变量加上括号。<h2 id=变量中的变量><a class=headerlink href=#变量中的变量 title=变量中的变量></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在 <code>Makefile</code> 中有两种方式来在用变量定义变量的值。<p>先看第一种方式，也就是简单的使用 <code>=</code> 号，在 <code>=</code> 左侧是变量，右侧是变量的值，右侧变量的值可以 定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义 的值。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
bar <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>ugh<span class="token punctuation">)</span>
ugh <span class="token operator">=</span> Huh?

<span class="token target symbol">all</span><span class="token punctuation">:</span>
    echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们执行“<code>make all</code>”将会打出变量 <code>$(foo)</code> 的值是 <code>Huh</code>? (<code>$(foo)</code> 的值是 <code>$(bar)</code> ，<code>$(bar)</code> 的值 是 <code>$(ugh)</code> ，<code>$(ugh)</code> 的值是 <code>Huh</code>? )可见，变量是可以使用后面的变量来定义的。<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>CFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>include_dirs<span class="token punctuation">)</span> -O
include_dirs <span class="token operator">=</span> -Ifoo -Ibar<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当 <code>CFLAGS</code> 在命令中被展开时，会是 <code>-Ifoo</code> <code>-Ibar</code> <code>-O</code> 。但这种形式也有不好的地方，那就是递归定 义，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>CFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -O<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>或:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>A <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>
B <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>这会让 <code>make</code> 陷入无限的变量展开过程中去，当然，我们的 <code>make</code> 是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的 <code>make</code> 运行时非常慢，更糟糕的是， 他会使用得两个 <code>make</code> 的函数“<code>wildcard</code>”和“<code>shell</code>”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。<p>为了避免上面的这种方法，我们可以使用 <code>make</code> 中的另一种用变量来定义变量的方法。这种方法使用的是 <code>:=</code> 操作符，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>x <span class="token operator">:=</span> foo
y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
bar x <span class="token operator">:=</span> later<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>y <span class="token operator">:=</span> foo bar
x <span class="token operator">:=</span> later<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> bar
x <span class="token operator">:=</span> foo<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>那么，<code>y</code> 的值是“<code>bar</code>”，而不是“<code>foo bar</code>”。<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了 make 的函数、条件表达式和一个系统变量“<code>MAKELEVEL</code>”的使用:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>0,<span class="token variable">$</span><span class="token punctuation">{</span>MAKELEVEL<span class="token punctuation">}</span><span class="token punctuation">)</span>
cur-dir <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>
whoami <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> whoami<span class="token punctuation">)</span>
host-type <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> arch<span class="token punctuation">)</span>
MAKE <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>MAKE<span class="token punctuation">}</span> host-type<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">{</span>host-type<span class="token punctuation">}</span> whoami<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">{</span>whoami<span class="token punctuation">}</span>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于条件表达式和函数，我们在后面再说，对于系统变量“<code>MAKELEVEL</code>”，其意思是，如果我们的 <code>make</code> 有一个嵌套执行的动作(参见前面的“嵌套使用 <code>make</code>”)，那么，这个变量会记录了我们的当前 <code>Makefile</code> 的调用层数。<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是 一个空格，那么我们可以这样来:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>nullstring <span class="token operator">:=</span>
space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># end of the line</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p><code>nullstring</code> 是一个 <code>Empty</code> 变量，其中什么也没有，而我们的 <code>space</code> 的值是一个空格。因为在操作符 的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 <code>Empty</code> 变量来标明变量的值开始了， 而后面采用“<code>#</code>”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意 这里关于“<code>#</code>”的使用，注释符“<code>#</code>”的这种特性值得我们注意，如果我们这样定义一个变量:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>dir <span class="token operator">:=</span> /foo/bar <span class="token comment"># directory to put the frobs in</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p><code>dir</code> 这个变量的值是“<code>/foo/bar</code>”，后面还跟了 <code>4</code> 个空格，如果我们这样使用这个变量来指定别的目录——“<code>$(dir)/file</code>”那么就完蛋了。<p>还有一个比较有用的操作符是 <code>?=</code> ，先看示例:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>FOO <span class="token operator">?=</span> bar<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其含义是，如果 <code>FOO</code> 没有被定义过，那么变量 <code>FOO</code> 的值就是“<code>bar</code>”，如果 <code>FOO</code> 先前被定义过，<br>那么这条语将什么也不做，其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> FOO<span class="token punctuation">)</span>, undefined<span class="token punctuation">)</span>
    FOO <span class="token operator">=</span> bar
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h2 id=变量高级用法><a class=headerlink href=#变量高级用法 title=变量高级用法></a>变量高级用法</h2><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。<br>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>${var:a=b}</code> ，其意思是，把变量 “<code>var</code>”中所有以“<code>a</code>”字串“结尾”的“<code>a</code>”替换成“<code>b</code>”字串。这里的“<code>结尾</code>”意思是“<code>空格</code>”或是“<code>结束符</code>”。 还是看一个示例吧:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foo <span class="token operator">:=</span> a.o b.o c.o
bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>这个示例中，我们先定义了一个 <code>$(foo)</code> 变量，而第二行的意思是把 <code>$(foo)</code> 中所有以 <code>.o</code> 字串“结 尾”全部替换成 <code>.c</code> ，所以我们的 <code>$(bar)</code> 的值就是“<code>a.c</code> <code>b.c</code> <code>c.c</code>”。<p>另外一种变量替换的技术是以“<code>静态模式</code>”(参见前面章节)定义的，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foo <span class="token operator">:=</span> a.o b.o c.o
bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>%.o<span class="token operator">=</span>%.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个 <code>%</code> 字符，这个例子同样让 <code>$(bar)</code> 变 量的值为“<code>a.c</code> <code>b.c</code> <code>c.c</code>”。<br>第二种高级用法是——“<code>把变量的值再当成变量</code>”。先看一个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>x<span class="token operator">=</span>y
y<span class="token operator">=</span>z
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>$(x)</code> 的值是“<code>y</code>”，所以 <code>$($(x))</code> 就是 <code>$(y)</code>，于是 <code>$(a)</code> 的值就是“<code>z</code>”。(注意，是 “<code>x=y</code>”，而不是“<code>x=$(y)</code>”)<br> 我们还可以使用更多的层次:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>x<span class="token operator">=</span>y
y<span class="token operator">=</span>z
z<span class="token operator">=</span>u
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>$(a)</code> 的值是“<code>u</code>”，相关的推导留给读者自己去做吧。 让我们再复杂一点，使用上“<code>在变量定义中使用变量</code>”的第一个方式，来看一个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>x <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> y<span class="token operator">=</span>z
z <span class="token operator">=</span> Hello
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这里的 <code>$($(x))</code> 被替换成了 <code>$($(y))</code> ，因为 <code>$(y)</code> 值是“<code>z</code>”，所以，最终结果是: <code>a:=$(z)</code> ，也就 是“<code>Hello</code>”。<p>再复杂一点，我们再加上函数:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>x <span class="token operator">=</span> variable1 variable2 <span class="token operator">:=</span> Hello
y <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> 1,2,<span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> z<span class="token operator">=</span>y
a <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这个例子中，<code>$($($(z)))</code> 扩展为 <code>$($(y))</code> ，而其再次被扩展为 <code>$($(subst 1,2,$(x)))</code> 。<code>$(x)</code> 的 值是“<code>variable1</code>”，<code>subst</code> 函数把“<code>variable1</code>”中的所有“<code>1</code>”字串替换成“<code>2</code>”字串，于是，“<code>variable1</code>”变 成“<code>variable2</code>”，再取其值，所以，最终，<code>$(a)</code> 的值就是 <code>$(variable2)</code> 的值——“<code>Hello</code>”。<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>first_second <span class="token operator">=</span> Hello
a <span class="token operator">=</span> first
b <span class="token operator">=</span> second
all <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$a_$b</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>$a_$b</code> 组成了“<code>first_second</code>”，于是，<code>$(all)</code> 的值就是“<code>Hello</code>”。<p>再来看看结合第一种技术的例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>a_objects <span class="token operator">:=</span> a.o b.o c.o
1_objects <span class="token operator">:=</span> 1.o 2.o 3.o

sources <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>_objects<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子中，如果 <code>$(a1)</code> 的值是“<code>a</code>”的话，那么，<code>$(sources)</code> 的值就是“<code>a.c</code> <code>b.c</code> <code>c.c</code>”;如果 <code>$(a1)</code> 的值是“<code>1</code>”，那么 <code>$(sources)</code> 的值是“<code>1.c</code> <code>2.c</code> <code>3.c</code>”。<p>再来看一个这种技术和“<code>函数</code>”与“<code>条件语句</code>”一同使用的例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifdef</span> do_sort
  func <span class="token operator">:=</span> sort
<span class="token keyword">else</span>
  func <span class="token operator">:=</span> strip
<span class="token keyword">endif</span>

bar <span class="token operator">:=</span> a d b g q c

foo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例中，如果定义了“<code>do_sort</code>”，那么: <code>foo := $(sort a d b g q c)</code> ，于是 <code>$(foo)</code> 的值就 是“<code>a b c d g q</code>”，而如果没有定义“<code>do_sort</code>”，那么: <code>foo := $(strip a d b g q c)</code> ，调用的就是 <code>strip</code> 函数。<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>dir <span class="token operator">=</span> foo
<span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_sources <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> <span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>/*.c<span class="token punctuation">)</span>
<span class="token keyword">define</span> <span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_print
lpr <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>_sources<span class="token punctuation">)</span>
<span class="token keyword">endef</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子中定义了三个变量:“<code>dir</code>”，“<code>foo_sources</code>”和“<code>foo_print</code>”。<h2 id=追加变量值><a class=headerlink href=#追加变量值 title=追加变量值></a>追加变量值</h2><p>我们可以使用 <code>+=</code> 操作符给变量追加值，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> main.o foo.o bar.o utils.o
objects <span class="token operator">+=</span> another.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>于是，我们的 <code>$(objects)</code> 值变成:“<code>main.o</code> <code>foo.o</code> <code>bar.o</code> <code>utils.o</code> <code>another.o</code>”(<code>another.o</code> 被追加进去了)<br>使用 <code>+=</code> 操作符，可以模拟为下面的这种例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> main.o foo.o bar.o utils.o
objects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> another.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>所不同的是，用 <code>+=</code> 更为简洁。<p>如果变量之前没有定义过，那么，<code>+=</code> 会自动变成 <code>=</code> ，如果前面有变量定义，那么 <code>+=</code> 会继承于前次<br>操作的赋值符。如果前一次的是 <code>:=</code> ，那么 <code>+=</code> 会以 <code>:=</code> 作为其赋值符，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">:=</span> value
variable <span class="token operator">+=</span> more<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">:=</span> value
variable <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span> more<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>但如果是这种情况:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>variable <span class="token operator">=</span> value
variable <span class="token operator">+=</span> more<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>由于前次的赋值符是 <code>=</code> ，所以 <code>+=</code> 也会以 <code>=</code> 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以 <code>make</code> 会自动为我们解决这个问题，我们不必担心这个问题。<h2 id=override-指示符><a title="override 指示符" class=headerlink href=#override-指示符></a>override 指示符</h2><p>如果有变量是通常 <code>make</code> 的命令行参数设置的，那么 <code>Makefile</code> 中对这个变量的赋值会被忽略。如果你想在 <code>Makefile</code> 中设置这类参数的值，那么，你可以使用“<code>override</code>”指示符。其语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">override</span> &LTvariable><span class="token punctuation">;</span> <span class="token operator">=</span> &LTvalue><span class="token punctuation">;</span>
<span class="token keyword">override</span> &LTvariable><span class="token punctuation">;</span> <span class="token operator">:=</span> &LTvalue><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当然，你还可以追加:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">override</span> &LTvariable><span class="token punctuation">;</span> <span class="token operator">+=</span> &LTmore text><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>对于多行的变量定义，我们用 <code>define</code> 指示符，在 <code>define</code> 指示符前，也同样可以使用 <code>override</code> 指示符， 如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">override</span> <span class="token keyword">define</span> foo
bar
<span class="token keyword">endef</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h2 id=多行变量><a class=headerlink href=#多行变量 title=多行变量></a>多行变量</h2><p>还有一种设置变量值的方法是使用 define 关键字。使用 define 关键字设置变量的值可以有换行，这有利于定义一系列的命令(前面我们讲过“命令包”的技术就是利用这个关键字)。<p><code>define</code> 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 <code>endef</code> 关键字结束。其工作方式和“<code>=</code>”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以 <code>[Tab]</code> 键开头，所以如果你用 <code>define</code> 定义的命令变量中没有以 <code>Tab</code> 键开头，那么 <code>make</code> 就不会把其认为是命令。<p>下面的这个示例展示了 <code>define</code> 的用法:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">define</span> two-lines
echo foo
echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
<span class="token keyword">endef</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><h2 id=环境变量><a class=headerlink href=#环境变量 title=环境变量></a>环境变量</h2><p><code>make</code> 运行时的系统环境变量可以在 <code>make</code> 开始运行时被载入到 <code>Makefile</code> 文件中，但是如果 <code>Makefile</code> 中已定义了这个变量，或是这个变量由 <code>make</code> 命令行带入，那么系统的环境变量的值将被覆盖。(如果 <code>make</code> 指定了“<code>-e</code>”参数，那么，系统环境变量将覆盖 <code>Makefile</code> 中定义的变量)<p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的 <code>Makefile</code> 中使用 这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果 <code>Makefile</code> 中定义了 <code>CFLAGS</code>，那么 则会使用 <code>Makefile</code> 中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很 像“<code>全局变量</code>”和“<code>局部变量</code>”的特性。<p>当 <code>make</code> 嵌套调用时(参见前面的“嵌套调用”章节)，上层 <code>Makefile</code> 中定义的变量会以系统环境变 量的方式传递到下层的 <code>Makefile</code> 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义 在文件中的变量，如果要向下层 <code>Makefile</code> 传递，则需要使用 <code>export</code> 关键字来声明。(参见前面章节)<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的 <code>Makefile</code> 时，拥有的是同一套系统变量，这可能会带来更多的麻烦。<h2 id=目标变量><a class=headerlink href=#目标变量 title=目标变量></a>目标变量</h2><p>前面我们所讲的在 <code>Makefile</code> 中定义的变量都是“<code>全局变量</code>”，在整个文件，我们都可以访问这些变量。当然，“<code>自动化变量</code>”除外，如 <code>$<</code> 等这种类量的自动化变量就属于“<code>规则型变量</code>”，这种变量的值依赖于规则的目标和依赖目标的定义。<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“<code>Target-specific Variable</code>”，它可以 和“<code>全局变量</code>”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。<p>其语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">&LTtarget ...></span> <span class="token punctuation">:</span> &LTvariable-assignment><span class="token punctuation">;</span>
<span class="token target symbol">&LTtarget ...></span> <span class="token punctuation">:</span> overide &LTvariable-assignment><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p><code>&LTvariable-assignment></code>; 可以是前面讲过的各种赋值表达式，如 <code>=</code> 、<code>:=</code> 、<code>+=</code> 或是 <code>?=</code> 。第二个语法 是针对于 <code>make</code> 命令行带入的变量，或是系统环境变量。<br>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">prog</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g

<span class="token target symbol">prog</span> <span class="token punctuation">:</span> prog.o foo.o bar.o
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o

<span class="token target symbol">prog.o</span> <span class="token punctuation">:</span> prog.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.c

<span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c

<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，不管全局的<code> $(CFLAGS)</code> 的值是什么，在 <code>prog</code> 目标，以及其所引发的所有规则中 (<code>prog.o</code> <code>foo.o</code> <code>bar.o</code> 的规则)，<code>$(CFLAGS)</code> 的值都是 <code>-g</code><h2 id=模式变量><a class=headerlink href=#模式变量 title=模式变量></a>模式变量</h2><p>在 <code>GNU</code> 的 <code>make</code> 中，还支持模式变量(<code>Pattern-specific Variable</code>)，通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“<code>模式</code>”，可以把变量定义 在符合这种模式的所有目标上。<p>我们知道，<code>make</code>的“<code>模式</code>”一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code>结 尾的目标定义目标变量:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -O<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>同样，模式变量的语法和“目标变量”一样:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">&LTpattern ...>;</span> <span class="token punctuation">:</span> &LTvariable-assignment><span class="token punctuation">;</span>
<span class="token target symbol">&LTpattern ...>;</span> <span class="token punctuation">:</span> <span class="token keyword">override</span> &LTvariable-assignment><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p><code>override</code> 同样是针对于系统环境传入的变量，或是 <code>make</code> 命令行指定的变量。<h1 id=使用条件判断><a class=headerlink href=#使用条件判断 title=使用条件判断></a>使用条件判断</h1><p>使用条件判断，可以让 <code>make</code> 根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。<h2 id=示例><a class=headerlink href=#示例 title=示例></a>示例</h2><p>下面的例子，判断 <code>$(CC)</code> 变量是否 <code>gcc</code> ，如果是的话，则使用 <code>GNU</code> 函数编译目标。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>
libs_for_gcc <span class="token operator">=</span> -lgnu
normal_libs <span class="token operator">=</span>

<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>,gcc<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span>
<span class="token keyword">endif</span>
<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，在上面示例的这个规则中，目标 <code>foo</code> 可以根据变量 <code>$(CC)</code> 值来选取不同的函数库来编译程序。<p>我们可以从上面的示例中看到三个关键字:<code>ifeq</code> 、<code>else</code> 和 <code>endif</code> 。<code>ifeq</code> 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。<code>else</code> 表示条件 表达式为假的情况。<code>endif</code> 表示一个条件语句的结束，任何一个条件表达式都应该以 <code>endif</code> 结束。<p>当我们的变量 <code>$(CC)</code> 值是 <code>gcc</code> 时，目标 <code>foo</code> 的规则是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>而当我们的变量 <code>$(CC)</code> 值不是 <code>gcc</code> 时(比如 <code>cc</code> )，目标 <code>foo</code> 的规则是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当然，我们还可以把上面的那个例子写得更简洁一些:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>libs_for_gcc <span class="token operator">=</span> -lgnu
normal_libs <span class="token operator">=</span>

<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>,gcc<span class="token punctuation">)</span>
    libs<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span>
<span class="token keyword">else</span>
    libs<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span>
<span class="token keyword">endif</span>

<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=语法><a class=headerlink href=#语法 title=语法></a>语法</h2><p>条件表达式的语法为:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>&LTconditional-directive>
&LTtext-if-true>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>以及:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>&LTconditional-directive>
&LTtext-if-true>
<span class="token keyword">else</span>
&LTtext-if-false>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>&LTconditional-directive></code> 表示条件关键字，如 <code>ifeq</code> 。这个关键字有四个。<p>第一个是我们前面所见过的 <code>ifeq</code><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>&LTarg1>, &LTarg2><span class="token punctuation">)</span>
<span class="token keyword">ifeq</span> <span class="token string">'&LTarg1>'</span> <span class="token string">'&LTarg2>'</span>
<span class="token keyword">ifeq</span> <span class="token string">"&LTarg1>"</span> <span class="token string">"&LTarg2>"</span>
<span class="token keyword">ifeq</span> <span class="token string">"&LTarg1>"</span> <span class="token string">'&LTarg2>'</span>
<span class="token keyword">ifeq</span> <span class="token string">'&LTarg1>'</span> <span class="token string">"&LTarg2>"</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同。当然，参数中我们还可以使用 <code>make</code> 的函数。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>,<span class="token punctuation">)</span>
&LTtext-if-empty>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这个示例中使用了 <code>strip</code> 函数，如果这个函数的返回值是空(<code>Empty</code>)，那么 <code>&LTtext-if-empty></code> 就 生效。<p>第二个条件关键字是 <code>ifneq</code> 。语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>&LTarg1>, &LTarg2><span class="token punctuation">)</span>
<span class="token keyword">ifneq</span> <span class="token string">'&LTarg1>'</span> <span class="token string">'&LTarg2>'</span>
<span class="token keyword">ifneq</span> <span class="token string">"&LTarg1>"</span> <span class="token string">"&LTarg2>"</span>
<span class="token keyword">ifneq</span> <span class="token string">"&LTarg1>"</span> <span class="token string">'&LTarg2>'</span>
<span class="token keyword">ifneq</span> <span class="token string">'&LTarg1>'</span> <span class="token string">"&LTarg2>"</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真。和 <code>ifeq</code> 类似。<p>第三个条件关键字是 <code>ifdef</code> 。语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifdef</span> &LTvariable-name><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如果变量 <code>&LTvariable-name></code> 的值非空，那到表达式为真。否则，表达式为假。当然，<code>&LTvariable-name></code> 同样可以是一个函数的返回值。注意，<code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前 位置。还是来看两个例子:<p>示例一:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>bar <span class="token operator">=</span>
foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
<span class="token keyword">ifdef</span> foo
    frobozz <span class="token operator">=</span> yes
<span class="token keyword">else</span>
    frobozz <span class="token operator">=</span> no
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例二:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foo <span class="token operator">=</span>
<span class="token keyword">ifdef</span> foo
    frobozz <span class="token operator">=</span> yes
<span class="token keyword">else</span>
    frobozz <span class="token operator">=</span> no
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个例子中，<code>$(frobozz)</code> 值是 <code>yes</code> ，第二个则是 <code>no</code>。<p>第四个条件关键字是 <code>ifndef</code> 。其语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifndef</span> &LTvariable-name><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这个我就不多说了，和 <code>ifdef</code> 是相反的意思。<p>在 <code>&LTconditional-directive></code> 这一行上，多余的空格是被允许的，但是不能以 <code>Tab</code> 键作为开始(不 然就被认为是命令)。而注释符 # 同样也是安全的。<code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了。<p>特别注意的是，<code>make</code> 是在读取 <code>Makefile</code> 时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量(如 <code>$@</code> 等)放入条件表达式中，因为自动化变量是在运行时才有的。<p>而且为了避免混乱，<code>make</code> 不允许把整个条件语句分成两部分放在不同的文件中。<h1 id=使用函数><a class=headerlink href=#使用函数 title=使用函数></a>使用函数</h1><p>在 <code>Makefile</code> 中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。<code>make</code> 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使 用。<h2 id=函数的调用语法><a class=headerlink href=#函数的调用语法 title=函数的调用语法></a>函数的调用语法</h2><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span>&LTfunction> &LTarguments><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>或是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">{</span>&LTfunction> &LTarguments><span class="token punctuation">}</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这里，<code>&LTfunction></code> 就是函数名，<code>make</code> 支持的函数不多。<code>&LTarguments></code> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“<code>空格</code>”分隔。函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是<code>?</code>函数中的参数可以使用变量，为了风格的统一，函数和变量的括号 最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b, ${x})</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。<p>还是来看一个示例:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>comma<span class="token operator">:=</span> ,
empty<span class="token operator">:=</span>
space<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>
foo<span class="token operator">:=</span> a b c
bar<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>$(comma)</code> 的值是一个逗号。<code>$(space)</code> 使用了 <code>$(empty)</code> 定义了一个空格，<code>$(foo)</code> 的值是 <code>a</code> <code>b</code> <code>c</code> ，<code>$(bar)</code> 的定义用，调用了函数 <code>subst</code> ，这是一个替换函数，这个函数有三个参数，第 一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是 把 <code>$(foo)</code> 中的空格替换成逗号，所以 <code>$(bar)</code> 的值是 <code>a</code>,<code>b</code>,<code>c</code> 。<h2 id=字符串处理函数><a class=headerlink href=#字符串处理函数 title=字符串处理函数></a>字符串处理函数</h2><h3 id=subst><a class=headerlink href=#subst title=subst></a>subst</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> &LTfrom>,&LTto>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 字符串替换函数<li><code>功能</code>: 把字串<code>&LTtext></code>中的<code>&LTfrom></code>字符串替换成<code>&LTto></code>。<li><code>返回</code>: 函数返回被替换过后的字符串。<li><code>示例</code>: <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ee,EE,feet on the street<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre> 把 <code>feet</code> <code>on</code> <code>the</code> <code>street</code> 中的 <code>ee</code> 替换成 <code>EE</code> ，返回结果是 <code>fEEt</code> <code>on</code> <code>the</code> <code>strEEt</code> 。</ul><h3 id=patsubst><a class=headerlink href=#patsubst title=patsubst></a>patsubst</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> &LTpattern>,&LTreplacement>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><p><code>名称</code>: 模式字符串替换函数。</p><li><p><code>功能</code>: 查找<code>&LTtext></code>中的单词(单词以“<code>空格</code>”、“<code>Tab</code>”或“<code>回车</code>”“<code>换行</code>”分隔)是否符合模式 <code>&LTpattern></code> ，如果匹配的话，则以 <code>&LTreplacement></code> 替换。这里，<code>&LTpattern></code> 可以包括通配符 <code>%</code> ， 表示任意长度的字串。如果 <code>&LTreplacement></code> 中也包含 <code>%</code> ，那么，<code>&LTreplacement></code> 中的这个 <code>%</code> 将是 <code>&LTpattern></code> 中的那个 <code>%</code> 所代表的字串。(可以用 <code>\</code> 来转义，以 <code>\%</code>来表示真实含义的 <code>%</code> 字符)</p><li><p><code>返回</code>: 函数返回被替换过后的字符串。</p><li><p><code>示例</code>:</p> <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,x.c.c bar.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre> <p>把字串 <code>x.c.c</code> <code>bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o</code> <code>bar.o</code></p><li><p><code>备注</code>: 这和我们前面“<code>变量章节</code>”说过的相关知识有点相似。如 <code>$(var:&LTpattern>=&LTreplacement>; )</code> 相当于 <code>$(patsubst &LTpattern>,&LTreplacement>,$(var))</code> ， 而 <code>$(var: &LTsuffix>=&LTreplacement>)</code> 则相当于 <code>$(patsubst %&LTsuffix>,%&LTreplacement>,$(var))</code> 。<br> 例如有:</p> <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects <span class="token operator">=</span> foo.o bar.o baz.o，<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre> <p>那么，$(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</p></ul><h3 id=strip><a class=headerlink href=#strip title=strip></a>strip</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> &LTstring><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 去空格函数。<li><code>功能</code>: 去掉<code>&LTstring></code>字串中开头和结尾的空字符。<li><code>返回</code>: 返回被去掉空格的字符串值。<li><code>示例</code>: <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> a b c <span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre> 把字串去掉开头和结尾的空格，结果是 <code>a</code> <code>b</code> <code>c</code>。</ul><h3 id=findstring><a class=headerlink href=#findstring title=findstring></a>findstring</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> &LTfind>,&LTin><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>:查找字符串函数<li><code>功能</code>:在字串<code>&LTin></code>中查找<code>&LTfind></code>字串。<li><code>返回</code>:如果找到，那么返回<code>&LTfind></code>，否则返回空字符串。<li><code>示例</code>: <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> a,a b c<span class="token punctuation">)</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> a,b c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre> 第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</ul><h3 id=filter><a class=headerlink href=#filter title=filter></a>filter</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> &LTpattern...>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 过滤函数<li><code>功能</code>: 以<code>&LTpattern></code>模式过滤<code>&LTtext></code>字符串中的单词，保留符合模式<code>&LTpattern></code>的单词。可以有多个模式。<li><code>返回</code>: 返回符合模式<code>&LTpattern></code>的字串。<li><code>示例</code>: <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>sources <span class="token operator">:=</span> foo.c bar.c baz.s ugh.h
<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>
    cc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> %.c %.s,<span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span> -o foo<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre> <code>$(filter %.c %.s,$(sources))</code> 返回的值是 <code>foo.c</code> <code>bar.c</code> <code>baz.s</code> 。</ul><h3 id=filter-out><a class=headerlink href=#filter-out title=filter-out></a>filter-out</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter-out</span> &LTpattern...>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 反过滤函数<li><code>功能</code>: 以<code>&LTpattern></code>模式过滤<code>&LTtext></code>字符串中的单词，去除符合模式<code>&LTpattern></code>的单词。可以有多个模式。<li><code>返回</code>: 返回不符合模式<code>&LTpattern></code>的字串。<li><code>示例</code>: <pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>objects<span class="token operator">=</span>main1.o foo.o main2.o bar.o
mains<span class="token operator">=</span>main1.o main2.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre> <code>$(filter-out $(mains)</code>,<code>$(objects))</code> 返回值是 <code>foo.o</code> <code>bar.o</code> 。</ul><h3 id=sort><a class=headerlink href=#sort title=sort></a>sort</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">sort</span> &LTlist><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 排序函数<li><code>功能</code>: 给字符串<code>&LTlist></code>中的单词排序(升序)。<li><code>返回</code>: 返回排序后的字符串。<li><code>示例</code>: <code>$(sortfoobarlose)</code> 返回 <code>barfoolose</code>。<li><code>备注</code>: <code>sort</code>函数会去掉<code>&LTlist></code>中相同的单词。</ul><h3 id=word><a class=headerlink href=#word title=word></a>word</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> &LTn>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取单词函数<li><code>功能</code>: 取字符串<code>&LTtext></code>中第<code>&LTn></code>个单词。(从一开始)<li><code>返回</code>: 返回字符串<code>&LTtext></code>中第<code>&LTn></code>个单词。如果<code>&LTn></code>比<code>&LTtext></code>中的单词数要大，那么返回空字符串。<li><code>示例</code>: <code>$(word2,foobarbaz)</code> 返回值是 <code>bar</code>。</ul><h3 id=wordlist><a class=headerlink href=#wordlist title=wordlist></a>wordlist</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wordlist</span> &LTss>,&LTe>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取单词串函数<li><code>功能</code>: 从字符串<code>&LTtext></code>中取从<code>&LTss></code>开始到<code>&LTe></code>的单词串。<code>&LTss></code>和<code>&LTe></code>是一个数字。<li><code>返回</code>: 返回字符串<code>&LTtext></code>中从<code>&LTss></code>到<code>&LTe></code>的单词字串。如果<code>&LTss></code>比<code>&LTtext></code>中的单词数要大， 那么返回空字符串。如果 <code>&LTe></code> 大于 <code>&LTtext></code> 的单词数，那么返回从 <code>&LTss></code> 开始，到 <code>&LTtext></code> 结束的 单词串。<li><code>示例</code>: <code>$(wordlist2,3,foobarbaz)</code> 返回值是 <code>barbaz</code></ul><h3 id=words><a class=headerlink href=#words title=words></a>words</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">words</span> &LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 单词个数统计函数<li><code>功能</code>: 统计<code>&LTtext></code>中字符串中的单词个数。<li><code>返回</code>: 返回<code>&LTtext></code>中的单词数。<li><code>示例</code>: <code>$(words,foobarbaz)</code>返回值是<code>3</code>。<li><code>备注</code>: 如果我们要取 <code>&LTtext></code> 中最后的一个单词，我们可以这样: <code>$(word $(words &LTtext>), &LTtext>)</code> 。</ul><h3 id=firstword><a class=headerlink href=#firstword title=firstword></a>firstword</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">firstword</span> &LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 首单词函数——<code>firstword</code>。<li><code>功能</code>: 取字符串<code>&LTtext></code>中的第一个单词。<li><code>返回</code>: 返回字符串<code>&LTtext></code>的第一个单词。<li><code>示例</code>: <code>$(firstwordfoobar)</code>返回值是<code>foo</code>。<li><code>备注</code>: 这个函数可以用word函数来实现: <code>$(word1,&LTtext>)</code>。</ul><p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实 中应用的例子。我们知道，<code>make</code> 使用 <code>VPATH</code> 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code> ，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">override</span> CFLAGS <span class="token operator">+=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %,-I%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token punctuation">:</span>, ,<span class="token variable">$</span><span class="token punctuation">(</span>VPATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code> ，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是 <code>cc</code> 或 <code>gcc</code> 搜索头文件路径的参数。<h2 id=文件名操作函数><a class=headerlink href=#文件名操作函数 title=文件名操作函数></a>文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。<h3 id=dir><a class=headerlink href=#dir title=dir></a>dir</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> &LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取目录函数——<code>dir</code>。<li><code>功能</code>: 从文件名序列<code>&LTnames></code>中取出目录部分。目录部分是指最后一个反斜杠(<code>/</code>)之前的部分。 如果没有反斜杠，那么返回 <code>./ </code>。<li><code>返回</code>: 返回文件名序列<code>&LTnames></code>的目录部分。<li><code>示例</code>: <code>$(dirsrc/foo.chacks)</code> 返回值是 <code>src/./</code>。</ul><h3 id=notdir><a class=headerlink href=#notdir title=notdir></a>notdir</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> &LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取文件函数——<code>notdir</code>。<li><code>功能</code>: 从文件名序列<code>&LTnames></code>中取出非目录部分。非目录部分是指最後一个反斜杠(<code>/</code>)之后的部分。<li><code>返回</code>: 返回文件名序列<code>&LTnames></code>的非目录部分。<li><code>示例</code>: <code>$(notdirsrc/foo.chacks)</code>返回值是<code>foo.chacks</code>。</ul><h3 id=suﬀix><a class=headerlink href=#suﬀix title=suﬀix></a>suﬀix</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">suffix</span> &LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取後缀函数——<code>suﬀix</code>。<li><code>功能</code>: 从文件名序列<code>&LTnames></code>中取出各个文件名的后缀。<li><code>返回</code>: 返回文件名序列<code>&LTnames></code>的后缀序列，如果文件没有后缀，则返回空字串。<li><code>示例</code>: <code>$(suffixsrc/foo.csrc-1.0/bar.chacks)</code> 返回值是 <code>.c.c</code>。</ul><h3 id=basename><a class=headerlink href=#basename title=basename></a>basename</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">basename</span> &LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 取前缀函数——<code>basename</code>。<li><code>功能</code>: 从文件名序列<code>&LTnames></code>中取出各个文件名的前缀部分。<li><code>返回</code>: 返回文件名序列<code>&LTnames></code>的前缀序列，如果文件没有前缀，则返回空字串。<li><code>示例</code>: <code>$(basenamesrc/foo.csrc-1.0/bar.chacks)</code> 返回值是 <code>src/foosrc-1.0/barhacks</code>。</ul><h3 id=addsuﬀix><a class=headerlink href=#addsuﬀix title=addsuﬀix></a>addsuﬀix</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">addsuffix</span> &LTsuffix>,&LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 加后缀函数——<code>addsuﬀix</code>。<li><code>功能</code>: 把后缀<code>&LTsuffix></code>加到<code>&LTnames></code>中的每个单词后面。<li><code>返回</code>: 返回加过后缀的文件名序列。<li><code>示例</code>: <code>$(addsuffix.c,foobar)</code> 返回值是 <code>foo.cbar.c</code>。</ul><h3 id=addprefix><a class=headerlink href=#addprefix title=addprefix></a>addprefix</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span>addprefix &LTprefix>,&LTnames...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 加前缀函数——<code>addprefix</code>。<li><code>功能</code>: 把前缀<code>&LTprefix></code>加到<code>&LTnames></code>中的每个单词前面。<li><code>返回</code>: 返回加过前缀的文件名序列。<li><code>示例</code>: <code>$(addprefixsrc/,foobar)</code> 返回值是 <code>src/foosrc/bar</code>。</ul><h3 id=join><a class=headerlink href=#join title=join></a>join</h3><pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">join</span> &LTlist1>,&LTlist2><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li><code>名称</code>: 连接函数——<code>join</code>。<li><code>功能</code>: 把 <code>&LTlist2></code> 中的单词对应地加到 <code>&LTlist1></code> 的单词后面。如果 <code>&LTlist1></code> 的单词个数要比 <code>&LTlist2></code> 的多，那么，<code>&LTlist1></code> 中的多出来的单词将保持原样。如果 <code>&LTlist2></code> 的单词个数要比 <code>&LTlist1></code> 多，那么，<code>&LTlist2></code> 多出来的单词将被复制到 <code>&LTlist1></code> 中。<li><code>返回</code>: 返回连接过后的字符串。<li><code>示例</code>: <code>$(joinaaabbb,111222333)</code> 返回值是 <code>aaa111</code> <code>bbb222</code> <code>333</code>。</ul><h2 id=foreach-函数><a title="foreach 函数" class=headerlink href=#foreach-函数></a>foreach 函数</h2><p><code>foreach</code> 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，<code>Makefile</code> 中的 <code>foreach</code> 函数几乎是仿照于 <code>Unix</code> 标准 <code>Shell(/bin/sh)</code> 中的 <code>for</code> 语句，或是 <code>C-Shell(/bin/csh)</code> 中的 <code>foreach</code> 语句 而构建的。它的语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> &LTvar>,&LTlist>,&LTtext><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这个函数的意思是，把参数 <code>&LTlist></code> 中的单词逐一取出放到参数 <code>&LTvar></code>所指定的变量中，然后再执行 <code>&LTtext></code> 所包含的表达式。每一次 <code>&LTtext></code> 会返回一个字符串，循环过程中，<code>&LTtext></code> 的所返回的每个 字符串会以空格分隔，最后当整个循环结束时，<code>&LTtext></code> 所返回的每个字符串所组成的整个字符串(以空格分隔)将会是 <code>foreach</code> 函数的返回值。<p>所以，<code>&LTvar></code> 最好是一个变量名，<code>&LTlist></code> 可以是一个表达式，而 <code>&LTtext></code> 中一般会使用 <code>&LTvar></code> 这个 参数来依次枚举 <code>&LTlist></code> 中的单词。举个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>names <span class="token operator">:=</span> a b c d

files <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> n,<span class="token variable">$</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>.o<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>上面的例子中，<code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中，<code>$(n).o</code> 每次根据 <code>$(n)</code> 计算出 一个值，这些值以空格分隔，最后作为 <code>foreach</code> 函数的返回，所以，<code>$(files)</code> 的值是 <code>a.o</code> <code>b.o</code> <code>c.o</code> <code>d.o</code> 。<p>注意，<code>foreach</code> 中的 <code>&LTvar></code> 参数是一个临时的局部变量，<code>foreach</code> 函数执行完后，参数 <code>&LTvar></code> 的变量 将不在作用，其作用域只在 <code>foreach</code> 函数当中。<h2 id=if-函数><a title="if 函数" class=headerlink href=#if-函数></a>if 函数</h2><p><code>if</code> 函数很像 <code>GNU</code> 的 <code>make</code> 所支持的条件语句——<code>ifeq</code>(参见前面所述的章节)，<code>if</code> 函数的语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> &LTcondition>,&LTthen-part><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>或是<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> &LTcondition>,&LTthen-part>,<<span class="token keyword">else</span>-part><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>可见，<code>if</code> 函数可以包含“<code>else</code>”部分，或是不含。即 <code>if</code> 函数的参数可以是两个，也可以是三个。 <code>&LTcondition></code> 参数是 <code>if</code> 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<code>&LTthen-part></code> 会被计算，否则 <code>&LTelse-part></code> 会被计算。<p>而 <code>if</code> 函数的返回值是，如果 <code>&LTcondition></code> 为真(非空字符串)，那个 <code>&LTthen-part></code> 会是整个函数 的返回值，如果 <code>&LTcondition></code> 为假(空字符串)，那么 <code>&LTelse-part></code> 会是整个函数的返回值，此时如果 <code>&LTelse-part></code> 没有被定义，那么，整个函数返回空字串。<p>所以，<code>&LTthen-part></code> 和 <code>&LTelse-part></code> 只会有一个被计算。<h2 id=call-函数><a title="call 函数" class=headerlink href=#call-函数></a>call 函数</h2><p><code>call</code> 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以 <code>call</code> 函数来向这个表达式传递参数。其语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> &LTexpression>,&LTparm1>,&LTparm2>,...,&LTparmn><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>当 <code>make</code> 执行这个函数时，<code>&LTexpression></code> 参数中的变量，如 <code>$(1)</code> 、<code>$(2)</code> 等，会被参数 <code>&LTparm1></code> 、 <code>&LTparm2></code> 、<code>&LTparm3></code> 依次取代。而 <code>&LTexpression></code> 的返回值就是 <code>call</code> 函数的返回值。例如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>reverse <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span>

foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> reverse,a,b<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>那么，<code>foo</code> 的值就是 <code>a</code> <code>b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>reverse <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>

foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> reverse,a,b<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>此时的 <code>foo</code> 的值就是 <code>b</code> <code>a</code> 。<p>需要注意: 在向 <code>call</code> 函数传递参数时要尤其注意空格的使用。<code>call</code> 函数在处理参数时，第 <code>2</code> 个及其 之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 <code>call</code> 函数提供参数时，最安全 的做法是去除所有多余的空格。<h2 id=origin-函数><a title="origin 函数" class=headerlink href=#origin-函数></a>origin 函数</h2><p><code>origin</code> 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的?其语法是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">origin</span> &LTvariable><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>注意，<code>&LTvariable> </code>是变量的名字，不应该是引用。所以你最好不要在 <code>&LTvariable></code>中使用 <code>$</code> 字符。<code>Origin</code> 函数会以其返回值来告诉你这个变量的“<code>出生情况</code>”，下面，是 <code>origin</code> 函数的返回值:<p><code>undefined</code> : 如果<code> &LTvariable></code> 从来没有定义过，<code>origin</code> 函数返回这个值 <code>undefined</code><br><code>default</code> : 如果 <code>&LTvariable></code> 是一个默认的定义，比如“<code>CC</code>”这个变量，这种变量我们将在后面讲述。<br><code>environment</code> : 如果 <code>&LTvariable></code> 是一个环境变量，并且当 <code>Makefile</code> 被执行时，<code>-e </code>参数没有被打开。<br><code>file</code> : 如果 <code>&LTvariable></code> 这个变量被定义在 <code>Makefile</code> 中。<br><code>command line</code> : 如果 <code>&LTvariable></code> 这个变量是被命令行定义的。<br><code>override</code> : 如果<code> &LTvariable></code> 是被 <code>override</code> 指示符重新定义的。<br><code>automatic</code> : 如果 <code>&LTvariable></code> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。<p>这些信息对于我们编写 <code>Makefile</code> 是非常有用的，例如，假设我们有一个 <code>Makefile</code> 其包了一个定义文件 <code>Make.def</code>，在 <code>Make.def</code> 中定义了一个变量“<code>bletch</code>”，而我们的环境中也有一个环境变量“<code>bletch</code>”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于 <code>Make.def</code> 或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的 <code>Makefile</code> 中，我们可以这样写:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifdef</span> bletch
    <span class="token keyword">ifeq</span> <span class="token string">"$(origin bletch)"</span> <span class="token string">"environment"</span>
        bletch <span class="token operator">=</span> barf, gag, etc.
    <span class="token keyword">endif</span>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，你也许会说，使用 <code>override</code> 关键字不就可以重新定义环境中的变量了吗?为什么需要使用这样的步骤?是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code> 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。<h2 id=shell-函数><a title="shell 函数" class=headerlink href=#shell-函数></a>shell 函数</h2><p><code>shell</code> 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统 <code>Shell</code> 的命令。它和反引号“<code>‘</code>” 是相同的功能。这就是说，<code>shell</code> 函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操 作系统命令以及字符串处理命令 <code>awk</code>，<code>sed</code> 等等命令来生成一个变量，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>contents <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> cat foo<span class="token punctuation">)</span>
files <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> echo *.c<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>注意，这个函数会新生成一个 <code>Shell</code> 程序来执行命令，所以你要注意其运行性能，如果你的 <code>Makefile</code> 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 <code>Makefile</code> 的隐晦的规则可能会让你的 <code>shell</code> 函数执行的次数比你想像的多得多。<h2 id=控制-make-的函数><a title="控制 make 的函数" class=headerlink href=#控制-make-的函数></a>控制 make 的函数</h2><p><code>make</code> 提供了一些函数来控制 <code>make</code> 的运行。通常，你需要检测一些运行 <code>Makefile</code> 时的运行时信息，并且根据这些信息来决定，你是让 <code>make</code> 继续执行，还是停止。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> &LTtext ...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>产生一个致命的错误，<code>&LTtext ...></code> 是错误信息。注意，<code>error</code> 函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如:<p>示例一:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token keyword">ifdef</span> ERROR_001
    <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> error is <span class="token variable">$</span><span class="token punctuation">(</span>ERROR_001<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>示例二:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>ERR <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> found an error!<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> err


<span class="token target symbol">err</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>ERR<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例一会在变量 <code>ERROR_001</code> 定义了后执行时产生 <code>error</code> 调用，而示例二则在目录 <code>err</code> 被执行时才 发生 <code>error</code> 调用。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">warning</span> &LTtext ...><span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这个函数很像 <code>error</code> 函数，只是它并不会让 <code>make</code> 退出，只是输出一段警告信息，而 <code>make</code> 继续执行。<h1 id=make-的运行><a title="make 的运行" class=headerlink href=#make-的运行></a>make 的运行</h1><p>一般来说，最简单的就是直接在命令行下输入 <code>make</code> 命令，<code>make</code> 命令会找当前目录的 <code>makefile</code> 来执行，一切都是自动的。但也有时你也许只想让 <code>make</code> 重编译某些文件，而不是整个工程，而又有的时候你 有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用 <code>make</code> 命令 的。<h2 id=make-的退出码><a title="make 的退出码" class=headerlink href=#make-的退出码></a>make 的退出码</h2><p>make 命令执行后有三个退出码:<p><code>0</code> : 表示成功执行<br><code>1</code> : 如果 make 运行时出现任何错误，其返回 <code>1</code><br><code>2</code> : 如果你使用了 <code>make</code> 的“<code>-q</code>”选项，并且 <code>make</code> 使得一些目标不需要更新，那么返回 <code>2</code>。 <code>Make</code> 的相关参数我们会在后续章节中讲述。<h2 id=指定-Makefile><a title="指定 Makefile" class=headerlink href=#指定-Makefile></a>指定 Makefile</h2><p>前面我们说过，<code>GNU make</code> 找寻默认的 <code>Makefile</code> 的规则是在当前目录下依次找三个文件——“<code>GNU-makefile</code>”、“<code>makefile</code>”和“<code>Makefile</code>”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。<p>当前，我们也可以给 <code>make</code> 命令指定一个特殊名字的 <code>Makefile</code>。要达到这个功能，我们要使用 <code>make</code> 的 <code>-f</code> 或是 <code>--file</code>参数(<code>--makefile</code> 参数也行)。例如，我们有个 <code>makefile</code> 的名字是“<code>hchen.mk</code>”，那么，我们可以这样来让 <code>make</code> 来执行这个文件:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>make –f hchen.mk<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如果在 <code>make</code> 的命令行是，你不只一次地使用了 <code>-f</code> 参数，那么，所有指定的 <code>makefile</code> 将会被连在一起传递给 <code>make</code> 执行。<h2 id=指定目标><a class=headerlink href=#指定目标 title=指定目标></a>指定目标</h2><p>一般来说，<code>make</code> 的最终目标是 <code>makefile</code> 中的第一个目标，而其它目标一般是由这个目标连带出来 的。这是 <code>make</code> 的默认行为。当然，一般来说，你的 <code>makefile</code> 中的第一个目标是由许多个目标组成，你可以指示 <code>make</code>，让其完成你所指定的目标。要达到这一目的很简单，需在 <code>make</code> 命令后直接跟目标的名 字就可以完成(如前面提到的“<code>make clean</code>”形式)<p>任何在 makefile 中的目标都可以被指定成终极目标，但是除了以 <code>-</code> 打头，或是包含了 <code>=</code>的目标，因 为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为 <code>make</code> 的终极目标，也就是说，只要 <code>make</code> 可以找到其隐含规则推导规则，那么这个隐含目标同样可以被 指定成终极目标。<p>有一个 <code>make</code> 的环境变量叫 <code>MAKECMDGOALS</code> ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>sources <span class="token operator">=</span> foo.c bar.c
<span class="token keyword">ifneq</span> <span class="token punctuation">(</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAKECMDGOALS<span class="token punctuation">)</span>,clean<span class="token punctuation">)</span>
<span class="token target symbol">    include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>基于上面的这个例子，只要我们输入的命令不是“<code>make clean</code>”，那么 <code>makefile</code> 会自动包含“<code>foo.d</code>” 和“<code>bar.d</code>”这两个 <code>makefile</code>。<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all
<span class="token target symbol">all</span><span class="token punctuation">:</span> prog1 prog2 prog3 prog4<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>从这个例子中，我们可以看到，这个 <code>makefile</code> 中有四个需要编译的程序——“<code>prog1</code>”“，<code>prog2</code>”，“<code>prog3</code>” 和“<code>prog4</code>”，我们可以使用“<code>make all</code>”命令来编译所有的目标(如果把 <code>all</code> 置成第一个目标，那么只需 执行“<code>make</code>”)，我们也可以使用“<code>make prog2</code>”来单独编译目标“<code>prog2</code>”。<p>即然 <code>make</code> 可以指定所有 <code>makefile</code> 中的目标，那么也包括“<code>伪目标</code>”，于是我们可以根据这种性质来让我们的 <code>makefile</code> 根据指定的不同的目标来完成不同的事。在 <code>Unix</code> 世界中，软件发布时，特别是 <code>GNU</code> 这种开源软件的发布时，其 <code>makefile</code> 都包含了编译、安装、打包等功能。我们可以参照这种规则来书写 我们的 <code>makefile</code> 中的目标。<ul><li><code>all</code> : 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。<li><code>clean</code> : 这个伪目标功能是删除所有被 <code>make</code> 创建的文件。<li><code>install</code> : 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。<li><code>print</code> : 这个伪目标的功能是例出改变过的源文件。<li><code>tar</code> : 这个伪目标功能是把源程序打包备份。也就是一个 <code>tar</code> 文件。<li><code>dist</code> : 这个伪目标功能是创建一个压缩文件，一般是把 <code>tar</code> 文件压成 <code>Z</code> 文件。或是 <code>gz</code> 文件。<li><code>TAGS</code> : 这个伪目标功能是更新所有的目标，以备完整地重编译使用。<li><code>check</code> 和 <code>test</code> : 这两个伪目标一般用来测试 <code>makefile</code> 的流程</ul><p>当然一个项目的 <code>makefile</code> 中也不一定要书写这样的目标，这些东西都是 <code>GNU</code> 的东西，但是我想， <code>GNU</code> 搞出这些东西一定有其可取之处(等你的 <code>UNIX</code> 下的程序文件一多时你就会发现这些功能很有用了)，这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些， 规范的好处就是——不用解释，大家都明白。而且如果你的 <code>makefile</code> 中有这些功能，一是很实用，二是 可以显得你的 <code>makefile</code> 很专业(不是那种初学者的作品)。<h2 id=检查规则><a class=headerlink href=#检查规则 title=检查规则></a>检查规则</h2><p>有时候，我们不想让我们的 <code>makefile</code> 中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用 <code>make</code> 命令的下述参数:<p><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code> : 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来， 但不执行，这些参数对于我们调试 <code>makefile</code> 很有用处。<p><code>-t</code>,<code>--touch</code> : 这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，<code>make</code> 假装编译目标， 但不是真正的编译目标，只是把目标变成已编译过的状态。<p><code>-q</code>, <code>--question</code> : 这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。<p><code>-W &LTfile></code>, <code>--what-if=&LTfile></code>, <code>--assume-new=&LTfile></code>, <code>--new-file=&LTfile></code> : 这个参数需要指定一个文件。一般是是源文件(或依赖文件)，<code>Make</code> 会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“<code>-n</code>”参数一同使用，来查看这个依赖文件所发生的规则命令。<p>另外一个很有意思的用法是结合 <code>-p</code> 和 <code>-v</code> 来输出 <code>makefile</code> 被执行时的信息(这个将在后面讲述)。<h2 id=make-的参数><a title="make 的参数" class=headerlink href=#make-的参数></a>make 的参数</h2><p>下面列举了所有 <code>GNU make 3.80</code> 版的参数定义。其它版本和产商的 <code>make</code> 大同小异，不过其它产商的 <code>make</code> 的具体参数还是请参考各自的产品文档。<p><code>-b</code>, <code>-m</code> : 这两个参数的作用是忽略和其它版本 <code>make</code> 的兼容性。<p><code>-B</code>, <code>--always-make</code> : 认为所有的目标都需要更新(重编译)。<p><code>-C &LTdir></code>, <code>--directory=&LTdir></code> : 指定读取 <code>makefile</code> 的目录。如果有多个“<code>-C</code>”参数，<code>make</code> 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如:“<code>make -C ~hchen/test -C prog</code>”等价于“<code>make -C ~hchen/test/prog</code>”。<p><code>-debug[=&LToptions>]</code> : 输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试 信息。下面是 <code>&LToptions></code> 的取值:<br>• <code>a</code> : 也就是 <code>all</code>，输出所有的调试信息。(会非常的多)<br>• <code>b</code> : 也就是 <code>basic</code>，只输出简单的调试信息。即输出不需要重编译的目标。<br>• <code>v</code> : 也就是 <code>verbose</code>，在 b 选项的级别之上。输出的信息包括哪个 <code>makefile</code> 被解析，不需要被 重编译的依赖文件(或是依赖目标)等。<br>• <code>i</code> : 也就是 <code>implicit</code>，输出所有的隐含规则。<br>• <code>j</code> : 也就是 <code>jobs</code>，输出执行规则中命令的详细信息，如命令的 <code>PID</code>、<code>返回码</code>等。<br>• <code>m</code> : 也就是<code> makefile</code>，输出 <code>make</code> 读取 <code>makefile</code>，更新 <code>makefile</code>，执行 <code>makefile</code> 的信息。<p><code>-d</code> : 相当于“<code>–debug=a</code>”。<p><code>-e</code>, <code>--environment-overrides</code> : 指明环境变量的值覆盖 makefile 中定义的变量的值<p><code>-f=&LTfile></code>, <code>--file=&LTfile></code>, <code>--makefile=&LTfile></code> : 指定需要执行的 <code>makefile</code>。<p><code>-h</code>, <code>--help</code> : 显示帮助信息。<p><code>-i</code> , <code>--ignore-errors</code> : 在执行时忽略所有的错误。<p><code>-I &LTdir></code>, <code>--include-dir=&LTdir></code> : 指定一个被包含 <code>makefile</code> 的搜索目标。可以使用多个“<code>-I</code>”参数来指定多个目录。<p><code>-j [&LTjobsnum>]</code>, <code>--jobs[=&LTjobsnum>]</code> : 指同时运行命令的个数。如果没有这个参数，<code>make</code> 运行命令时能运行多少就运行多少。如果有一 个以上的“<code>-j</code>”参数，那么仅最后一个“<code>-j</code>”才是有效的。(注意这个参数在 <code>MS-DOS</code> 中是无用的)<p><code>-k</code>, <code>--keep-going</code> : 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。<p><code>-l &LTload></code>,<code> --load-average[=&LTload>]</code>, <code>-max-load[=&LTload>]</code> : 指定 <code>make</code> 运行命令的负载。<p><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code> : 仅输出执行过程中的命令序列，但并不执行。<p><code>-o &LTfile></code>, <code>--old-file=&LTfile></code>, <code>--assume-old=&LTfile></code> : 不重新生成的指定的 <code>&LTfile></code>，即使这个目标的依赖文件新于它。<p><code>-p</code>, <code>--print-data-base</code> : 输出 <code>makefile</code> 中的所有数据，包括所有的规则和变量。这个参数会让一个简单的 <code>makefile</code> 都会输 出一堆信息。如果你只是想输出信息而不想执行 <code>makefile</code>，你可以使用“<code>make -qp</code>”命令。如果你 想查看执行 <code>makefile</code> 前的预设变量和规则，你可以使用“<code>make –p –f /dev/null</code>”。这个参数输出的信息会包含着你的 <code>makefile</code> 文件的文件名和行号，所以，用这个参数来调试你的 <code>makefile</code> 会是很有用的，特别是当你的环境变量很复杂的时候。<p><code>-q</code>, <code>--question</code> : 不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是 <code>0</code> 则说明要更新，如果是 <code>2</code> 则说明有错误发生。<p><code>-r</code>, <code>--no-builtin-rules</code> : 禁止 <code>make</code> 使用任何隐含规则。<p><code>-R</code>, <code>--no-builtin-variabes</code> : 禁止 <code>make</code> 使用任何作用于变量上的隐含规则。<p><code>-s</code>, <code>--silent</code>, <code>--quiet</code> : 在命令运行时不输出命令的输出。<p><code>-S</code>, <code>--no-keep-going</code>, <code>--stop</code> : 取消“<code>-k</code>”选项的作用。因为有些时候，<code>make</code> 的选项是从环境变量“<code>MAKEFLAGS</code>”中继承下来 的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。<p><code>-t</code>, <code>--touch</code> : 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。<p><code>-v</code>, <code>--version</code> : 输出 <code>make</code> 程序的版本、版权等关于 <code>make</code> 的信息。<p><code>-w</code>, <code>--print-directory</code> : 输出运行 <code>makefile</code> 之前和之后的信息。这个参数对于跟踪嵌套式调用 <code>make</code> 时很有用。<p><code>--no-print-directory</code> : 禁止“<code>-w</code>”选项。<p><code>-W &LTfile></code>, <code>--what-if=&LTfile></code>, <code>--new-file=&LTfile></code>, <code>--assume-file=&LTfile></code> : 假定目标<code> &LTfile></code>; 需要更新，如果和“<code>-n</code>”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“<code>-n</code>”那么就像运行 <code>UNIX</code> 的“<code>touch</code>”命令一样，使得 <code>&LTfile></code>; 的修改时间为当前时间。<p><code>--warn-undefined-variables</code> : 只要 <code>make</code> 发现有未定义的变量，那么就输出警告信息。<h1 id=隐含规则><a class=headerlink href=#隐含规则 title=隐含规则></a>隐含规则</h1><p>在我们使用 <code>Makefile</code> 时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译 <code>C/C++</code> 的源程序为中间目标文件(<code>Unix</code> 下是 <code>.o </code>文件，<code>Windows</code> 下是 <code>.obj</code> 文件)。本章讲述的就是一 些在 <code>Makefile</code> 中的“<code>隐含的</code>”，早先约定了的，不需要我们再写出来的规则。<p>“<code>隐含规则</code>”也就是一种惯例，<code>make</code> 会按照这种“<code>惯例</code>”心照不喧地来运行，那怕我们的 <code>Makefile</code> 中没有书写这样的规则。例如，把 <code>.c</code> 文件编译成 <code>.o</code> 文件这一规则，你根本就不用写出来，<code>make</code> 会自动推导出这种规则，并生成我们需要的 <code>.o</code> 文件。<p>“<code>隐含规则</code>”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量 <code>CFLAGS</code> 可以控制编译时的编译器参数。<p>我们还可以通过“<code>模式规则</code>”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多 的限制。使用“<code>模式规则</code>”会显得更智能和清楚，但“后缀规则”可以用来保证我们 <code>Makefile</code> 的兼容性。 我们了解了“<code>隐含规则</code>”，可以让其为我们更好的服务，也会让我们知道一些“<code>约定俗成</code>”了的东西，而 不至于使得我们在运行 <code>Makefile</code> 时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“<code>隐含规则</code>”也会给我们造成不小的麻烦。只有了解了它，我们才能更 好地使用它。<h2 id=使用隐含规则><a class=headerlink href=#使用隐含规则 title=使用隐含规则></a>使用隐含规则</h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，<code>make</code> 会试图去自动推导产生这个目标的规则和命令，如果 <code>make</code> 可以自动推导生成这个目标的规则和命令，那 么这个行为就是隐含规则的自动推导。当然，隐含规则是 <code>make</code> 事先约定好的一些东西。例如，我们有下 面的一个 <code>Makefile</code>:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo</span> <span class="token punctuation">:</span> foo.o bar.o
    cc –o foo foo.o bar.o <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>我们可以注意到，这个 <code>Makefile</code> 中并没有写下如何生成 <code>foo.o</code> 和 <code>bar.o</code> 这两目标的规则和命令。因为 <code>make</code> 的“<code>隐含规则</code>”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。<p><code>make</code> 会在自己的“<code>隐含规则</code>”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，<code>make</code> 调用的隐含规则是，把 <code>.o</code> 的目标的依赖文件置成 <code>.c</code> ，并使用 <code>C</code> 的编译命令 <code>cc –c $(CFLAGS) foo.c </code>来生成 <code>foo.o</code> 的目标。也就是说，我们完全没有必要写下下面的两条规则:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.c
    cc –c foo.c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span>
<span class="token target symbol">bar.o</span> <span class="token punctuation">:</span> bar.c
    cc –c bar.c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>因为，这已经是“<code>约定</code>”好了的事了，<code>make</code> 和我们约定好了用 <code>C</code> 编译器 c<code>c</code> 生成 <code>.o</code> 文件的规则， 这就是隐含规则。<p>当然，如果我们为 <code>.o</code> 文件书写了自己的规则，那么 <code>make</code> 就不会自动推导并调用隐含规则，它会按 照我们写好的规则忠实地执行。<p>还有，在 <code>make</code> 的“<code>隐含规则库</code>”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使 用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，<code>make</code> 也不会管。如下面这条规则(没有命令):<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foo.o</span> <span class="token punctuation">:</span> foo.p<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>依赖文件 <code>foo.p</code> (<code>Pascal</code> 程序的源文件)有可能变得没有意义。如果目录下存在了 <code>foo.c</code> 文件，那 么我们的隐含规则一样会生效，并会通过 <code>foo.c</code> 调用 <code>C</code> 的编译器生成 <code>foo.o</code> 文件。因为，在隐含规则 中，<code>Pascal</code> 的规则出现在 <code>C</code> 的规则之后，所以，<code>make</code> 找到可以生成 <code>foo.o</code> 的 <code>C</code>的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“<code>依赖规则</code>”，而不写命令。<h2 id=隐含规则一览><a class=headerlink href=#隐含规则一览 title=隐含规则一览></a>隐含规则一览</h2><p>这里我们将讲述所有预先设置(也就是 <code>make</code> 内建)的隐含规则，如果我们不明确地写下规则， 那么，<code>make</code> 就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用 <code>make</code> 的参数 <code>-r</code> 或 <code>--no-builtin-rules</code> 选项来取消所有的预设置的隐含规则。<p>当然，即使是我们指定了 <code>-r</code> 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了 “<code>后缀规则</code>”来定义的，所以，只要隐含规则中有“<code>后缀列表</code>”(也就一系统定义在目标 <code>.SUFFIXES</code> 的依赖目标)，那么隐含规则就会生效。默认的后缀列表是:<code>.out</code>, <code>.a</code>, <code>.ln</code>, <code>.o</code>, <code>.c</code>, <code>.cc</code>, <code>.C</code>, <code>.p</code>, <code>.f</code>, <code>.F</code>, <code>.r</code>, <code>.y</code>, <code>.l</code>, <code>.s</code>,<code>.S</code>, <code>.mod</code>, <code>.sym</code>, <code>.def</code>, <code>.h</code>, <code>.info</code>, <code>.dvi</code>, <code>.tex</code>, <code>.texinfo</code>, <code>.texi</code>, <code>.txinfo</code>, <code>.w</code>, <code>.ch</code> <code>.web</code>, <code>.sh</code>, <code>.elc</code>, <code>.el</code>。具体的细节， 我们会在后面讲述。<p>还是先来看一看常用的隐含规则吧。<ol><li>编译 <code>C</code> 程序的隐含规则。</ol><p><code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.c</code> ，并且其生成命令是 <code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code><ol start=2><li>编译 <code>C++</code> 程序的隐含规则。</ol><p><code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.cc</code> 或是 <code>&LTn>.C</code> ，并且其生成命令是 <code>$(CXX) –c $(CPPFLAGS) $(CXXFLAGS)</code> 。(建议使用 <code>.cc</code> 作为 <code>C++</code> 源文件的后缀，而不是 <code>.C</code> )<ol start=3><li>编译 <code>Pascal</code> 程序的隐含规则。</ol><p><code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.p</code> ，并且其生成命令是 <code>$(PC) –c $(PFLAGS)</code> 。<ol start=4><li>编译 <code>Fortran/Ratfor</code> 程序的隐含规则。</ol><p><code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.r</code> 或 <code>&LTn>.F</code> 或 <code>&LTn>.f </code>，并且其生成命令是:<ul><li><code>.f $(FC) –c $(FFLAGS)</code><li><code>.F $(FC) –c $(FFLAGS) $(CPPFLAGS)</code><li><code>.f $(FC) –c $(FFLAGS) $(RFLAGS)</code></ul><ol start=5><li>预处理 <code>Fortran/Ratfor</code> 程序的隐含规则。</ol><p><code>&LTn>.f</code> 的目标的依赖目标会自动推导为 <code>&LTn>.r</code> 或 <code>&LTn>.F</code> 。这个规则只是转换 <code>Ratfor</code> 或有预处理的 <code>Fortran</code> 程序到一个标准的 <code>Fortran</code> 程序。其使用的命令是:<ul><li><code>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)</code><li><code>.r $(FC) –F $(FFLAGS) $(RFLAGS)</code></ul><ol start=6><li>编译 <code>Modula-2</code> 程序的隐含规则。</ol><p><code>&LTn>.sym</code> 的目标的依赖目标会自动推导为 <code>&LTn>.def</code> ，并且其生成命令是:<code>$(M2C) $(M2FLAGS) $(DEFFLAGS)</code> 。<code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.mod</code> ，并且其生成命令是:<code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code> 。<ol start=7><li>汇编和汇编预处理的隐含规则。</ol><p><code>&LTn>.o</code> 的目标的依赖目标会自动推导为 <code>&LTn>.s</code> ，默认使用编译器 <code>as</code> ，并且其生成命令是:<code>$ (AS) $(ASFLAGS)</code> 。<code>&LTn>.s</code> 的目标的依赖目标会自动推导为 <code>&LTn>.S</code> ，默认使用 <code>C</code> 预编译器 <code>cpp</code> ，并且其生成命令是: <code>$(AS) $(ASFLAGS)</code> 。<ol start=8><li>链接 <code>Object</code> 文件的隐含规则。</ol><p><code>&LTn></code> 目标依赖于 <code>&LTn>.o</code> ，通过运行 <code>C</code> 的编译器来运行链接程序生成(一般是 <code>ld</code> )，其生成命令 是:<code>$(CC) $(LDFLAGS) &LTn>.o $(LOADLIBES) $(LDLIBS)</code> 。这个规则对于只有一个源文件的工程有效，同时也对多个 <code>Object</code> 文件(由不同的源文件生成)的也有效。例如如下规则:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">x</span> <span class="token punctuation">:</span> y.o z.o<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>并且 <code>x.c</code> 、<code>y.c</code> 和 <code>z.c</code> 都存在时，隐含规则将执行如下命令:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有一个源文件(如上例中的 <code>x.c</code>)和你的目标名字(如上例中的 <code>x</code>)相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。<ol start=9><li><code>Yacc C</code> 程序时的隐含规则。</ol><p><code>&LTn>.c</code> 的依赖文件被自动推导为 <code>n.y </code>(<code>Yacc</code> 生成的文件)，其生成命令是:<code>$(YACC) $(YFALGS)</code>。(“<code>Yacc</code>”是一个语法分析器，关于其细节请查看相关资料)<ol start=10><li>Lex C 程序时的隐含规则。</ol><p><code>&LTn>.c</code> 的依赖文件被自动推导为 <code>n.l</code>(<code>Lex</code> 生成的文件)，其生成命令是:<code>$(LEX) $(LFALGS)</code> 。(关于“<code>Lex</code>”的细节请查看相关资料)<ol start=11><li>Lex Ratfor 程序时的隐含规则。</ol><p><code>&LTn>.r</code> 的依赖文件被自动推导为 <code>n.l</code> (<code>Lex</code> 生成的文件)，其生成命令是:<code>$(LEX) $(LFALGS)</code> 。<ol start=12><li>从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则。</ol><p><code>&LTn>.ln</code>(<code>lint</code> 生成的文件)的依赖文件被自动推导为 <code>n.c</code> ，其生成命令是:<code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code> 。对于 <code>&LTn>.y</code> 和 <code>&LTn>.l</code> 也是同样的规则。<h2 id=隐含规则使用的变量><a class=headerlink href=#隐含规则使用的变量 title=隐含规则使用的变量></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的 <code>makefile</code> 中改变这 些变量的值，或是在 <code>make</code> 的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用 <code>make</code> 的 <code>-R</code> 或 <code>--no–builtin-variables</code> 参数来取消你所定义的变量对隐含规则的作用。<p>例如，第一条隐含规则——编译 <code>C </code>程序的隐含规则的命令是 <code>$(CC) –c $(CFLAGS) $(CPPFLAGS)</code> 。 <code>Make</code> 默认的编译命令是 <code>cc</code> ，如果你把变量 <code>$(CC)</code> 重定义成 <code>gcc</code> ，把变量 <code>$(CFLAGS)</code> 重定义成 <code>-g</code> ，那么，隐含规则中的命令全部会以 <code>gcc –c -g $(CPPFLAGS)</code> 的样子来执行了。<p>我们可以把隐含规则中使用的变量分成两种:一种是命令相关的，如 <code>CC</code> ;一种是参数相的关，如 <code>CFLAGS</code> 。下面是所有隐含规则中会用到的变量:<h3 id=关于命令的变量。><a class=headerlink href=#关于命令的变量。 title=关于命令的变量。></a>关于命令的变量。</h3><ul><li><code>AR</code> : 函数库打包程序。默认命令是 <code>ar</code><li><code>AS</code> : 汇编语言编译程序。默认命令是 <code>as</code><li><code>CC</code> : <code>C</code> 语言编译程序。默认命令是 <code>cc</code><li><code>CXX</code> : <code>C++</code> 语言编译程序。默认命令是 <code>g++</code><li><code>CO</code> : 从 <code>RCS</code> 文件中扩展文件程序。默认命令是 <code>co</code><li><code>CPP</code> : <code>C</code> 程序的预处理器(输出是标准输出设备)。默认命令是 <code>$(CC) –E * FC : Fortran</code> 和 <code>Ratfor</code> 的编译器和预处理程序。默认命令是 <code>f77</code><li><code>GET</code> : 从 <code>SCCS</code> 文件中扩展文件的程序。默认命令是 <code>get</code><li><code>LEX</code> : <code>Lex</code> 方法分析器程序(针对于 <code>C</code> 或 <code>Ratfor</code>)。默认命令是 <code>lex</code><li><code>PC</code> : <code>Pascal</code> 语言编译程序。默认命令是 <code>pc</code><li><code>YACC</code> : <code>Yacc</code> 文法分析器(针对于 <code>C</code> 程序)。默认命令是 <code>yacc</code><li><code>YACCR</code> : <code>Yacc</code> 文法分析器(针对于 <code>Ratfor</code> 程序)。默认命令是 <code>yacc –r</code><li><code>MAKEINFO</code> : 转换 <code>Texinfo</code> 源文件(<code>.texi</code>)到 <code>Info</code> 文件程序。默认命令是 <code>makeinfo</code><li><code>TEX</code> : 从 <code>TeX</code> 源文件创建 <code>TeX DVI</code> 文件的程序。默认命令是 <code>tex</code><li><code>TEXI2DVI</code> : 从 <code>Texinfo</code> 源文件创建军 <code>TeX DVI</code> 文件的程序。默认命令是 <code>texi2dvi</code><li><code>WEAVE</code> : 转换 <code>Web</code> 到 <code>TeX</code> 的程序。默认命令是 <code>weave</code><li><code>CWEAVE</code> : 转换 <code>C Web</code> 到 <code>TeX</code> 的程序。默认命令是 <code>cweave</code><li><code>TANGLE</code> : 转换 <code>Web</code> 到 <code>Pascal</code> 语言的程序。默认命令是 <code>tangle</code><li><code>CTANGLE</code> : 转换 <code>C Web</code> 到 <code>C</code>。默认命令是 <code>ctangle</code><li><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></ul><h3 id=关于命令参数的变量><a class=headerlink href=#关于命令参数的变量 title=关于命令参数的变量></a>关于命令参数的变量</h3><p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。<ul><li><code>ARFLAGS</code> : 函数库打包程序 <code>AR</code> 命令的参数。默认值是 <code>rv</code><li><code>ASFLAGS</code> : 汇编语言编译器参数。(当明显地调用 <code>.s</code> 或 <code>.S</code> 文件时)<li><code>CFLAGS</code> : <code>C</code> 语言编译器参数。<li><code>CXXFLAGS</code> : <code>C++</code> 语言编译器参数。<li><code>COFLAGS</code> : <code>RCS</code> 命令参数。<li><code>CPPFLAGS</code> : <code>C</code> 预处理器参数。(<code>C</code> 和 <code>Fortran</code> 编译器也会用到)。<li><code>FFLAGS</code> : <code>Fortran</code> 语言编译器参数。<li><code>GFLAGS</code> : <code>SCCS</code> “<code>get</code>”程序参数。<li><code>LDFLAGS</code> : 链接器参数。(如:<code>ld</code> )<li><code>LFLAGS</code> : <code>Lex</code> 文法分析器参数。<li><code>PFLAGS</code> : <code>Pascal</code> 语言编译器参数。<li><code>RFLAGS</code> : <code>Ratfor</code> 程序的 <code>Fortran</code> 编译器参数。<li><code>YFLAGS</code> : <code>Yacc</code> 文法分析器参数。</ul><h2 id=隐含规则链><a class=headerlink href=#隐含规则链 title=隐含规则链></a>隐含规则链</h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 <code>.o</code> 的文件生成，可能会是先被 <code>Yacc</code> 的 [<code>.y</code>] 文件先成 <code>.c</code> ，然后再被 <code>C</code> 的编译器生成。我们把这一系列的隐含规则叫做“<code>隐含规则链”</code>。<p>在上面的例子中，如果文件 <code>.c</code> 存在，那么就直接调用 <code>C</code> 的编译器的隐含规则，如果没有 <code>.c </code>文件， 但有一个 <code>.y</code> 文件，那么 <code>Yacc</code> 的隐含规则会被调用，生成 <code>.c</code> 文件，然后，再调用 <code>C</code> 编译的隐含规则最 终由 <code>.c</code> 生成 <code>.o</code> 文件，达到目标。<p>我们把这种 <code>.c</code> 的文件(或是目标)，叫做中间目标。不管怎么样，<code>make</code> 会努力自动推导生成目标的 一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成?怎么我的 <code>makefile</code> 发疯了?<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同:第一个不同是除非中间的目标 不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生 的中间目标文件会被以 <code>rm -f</code> 删除。<p>通常，一个被 <code>makefile</code> 指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明 一个文件或是目标是中介目标，你可以使用伪目标 <code>.INTERMEDIATE</code> 来强制声明。(如:<code>.INTERMEDIATE : mid</code> )<p>你也可以阻止 <code>make</code> 自动删除中间目标，要做到这一点，你可以使用伪目标 <code>.SECONDARY</code> 来强制声明 (如:<code>.SECONDARY : sec</code> )。你还可以把你的目标，以模式的方式来指定(如:<code>%.o</code> )成伪目标 <code>.PRECIOUS</code> 的依赖目标，以保存被隐含规则所生成的中间文件。<p>在“<code>隐含规则链</code>”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在 <code>make</code> 自动推导 时出现无限递归的情况。<p><code>Make</code> 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 <code>foo.c</code> 生成目标程序 <code>foo</code> ，按道理，<code>make</code> 会编译生成中间文件 <code>foo.o</code> ，然后链接成 <code>foo</code> ，但在实际情况下，这一动作可以被一条 <code>cc</code> 的命令完成(<code>cc –o foo foo.c</code> )，于是优化过的规则就不会生成中间文件。<h2 id=定义模式规则><a class=headerlink href=#定义模式规则 title=定义模式规则></a>定义模式规则</h2><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目 标的定义需要有 <code>%</code> 字符。<code>%</code> 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 <code>%</code> ，只是依 赖目标中的 <code>%</code> 的取值，取决于其目标。<p>有一点需要注意的是，<code>%</code> 的展开发生在变量和函数的展开之后，变量和函数的展开发生在 <code>make</code> 载 入 <code>Makefile</code> 时，而模式规则中的 <code>%</code> 则发生在运行时。<h3 id=模式规则介绍><a class=headerlink href=#模式规则介绍 title=模式规则介绍></a>模式规则介绍</h3><p>模式规则中，至少在规则的目标定义中要包含 <code>%</code> ，否则，就是一般的规则。目标中的 <code>%</code> 定义表示对 文件名的匹配，<code>%</code> 表示长度任意的非空字符串。例如:<code>%.c</code> 表示以 <code>.c</code> 结尾的文件名(文件名的长度至少为 <code>3</code>)，而 <code>s.%.c </code>则表示以 <code>s.</code> 开头，<code>.c</code> 结尾的文件名(文件名的长度至少为 <code>5</code>)。<p>如果 <code>%</code> 定义在目标中，那么，依赖中的 <code>%</code> 的值决定了目标中的 <code>%</code> 的值，也就是说，依赖中的模式的 <code>%</code> 决定了目标中 <code>%</code> 的样子。例如有一个模式规则如下:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c <span class="token punctuation">;</span> &LTcommand ......><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其含义是，指出了怎么从所有的 <code>.c</code> 文件生成相应的 <code>.o</code> 文件的规则。如果要生成的目标是 <code>a.o</code> <code>b.o</code> ，那么 <code>%c</code> 就是 <code>a.c</code> <code>b.c</code> 。<p>一旦依赖目标中的 <code>%</code> 模式被确定，那么，<code>make</code> 会被要求去匹配当前目录下所有的文件名，一旦找到，<code>make</code> 就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，<code>make</code> 就会产生所有的模式目标，此时，<code>make</code> 关心的是依赖的文件名和生成目标的命令这两件事。<h3 id=模式规则示例><a class=headerlink href=#模式规则示例 title=模式规则示例></a>模式规则示例</h3><p>下面这个例子表示了, 把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$<</span> -o <span class="token variable">$@</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>其中，<code>$@</code> 表示所有的目标的挨个值，<code>$<</code> 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“<code>自动化变量</code>”，后面会详细讲述。<p>下面的这个例子中有两个目标是模式的:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.tab.c %.tab.h</span><span class="token punctuation">:</span> %.y
    bison -d <span class="token variable">$<</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>这条规则告诉 <code>make</code> 把所有的 <code>.y</code> 文件都以 <code>bison -d &LTn>.y </code>执行，然后生成 <code>&LTn>.tab.c</code> 和 <code>&LTn>. tab.h </code>文件。(其中，<code>&LTn></code> 表示一个任意字符串)。如果我们的执行程序 <code>foo</code> 依赖于文件 <code>parse.tab.o </code>和 <code>scan.o</code> ，并且文件 <code>scan.o</code> 依赖于文件 <code>parse.tab.h</code> ，如果 <code>parse.y</code> 文件被更新了，那么根据上述的 规则，<code>bison -d parse.y</code> 就会被执行一次，于是，<code>parse.tab.o</code> 和 <code>scan.o</code> 的依赖文件就齐了。(假设， <code>parse.tab.o</code> 由 <code>parse.tab.c</code> 生成，和 <code>scan.o</code> 由 <code>scan.c</code> 生成，而 <code>foo</code> 由 <code>parse.tab.o </code>和 <code>scan.o</code> 链接生成，而且 <code>foo</code> 和其 <code>.o</code> 文件的依赖关系也写好，那么，所有的目标都会得到满足)<h3 id=自动化变量><a class=headerlink href=#自动化变量 title=自动化变量></a>自动化变量</h3><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标?因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对 它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取 出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。<p>下面是所有的自动化变量及其说明:<ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<code>$@</code> 就是匹配于目标中模 式定义的集合。<li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a</code>(<code>bar.o</code>) ，那么，<code>$%</code> 就是 <code>bar.o </code>，<code>$@</code> 就是<code> foo.a</code> 。如果目标不是函数库文件(<code>Unix</code> 下是 <code>.a</code> ，<code>Windows</code> 下是 <code>.lib</code> )，那么，其值为空。<li><code>$<</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式(即 <code>%</code> )定义的，那么 <code>$<</code> 将是符合模 式的一系列的文件集。注意，其是一个一个取出来的。<li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。<li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。<li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。<li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么，<code>$*</code> 的值就是 <code>dir/foo</code> 。这个变量对于构造有关联的文件名是比较有效。如果目标 中没有模式的定义，那么 <code>$* </code>也就不能被推导出，但是，如果目标文件的后缀是 <code>make</code> 所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如:如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是 <code>make</code> 所能识别的后缀名， 所以，<code>$*</code> 的值就是 <code>foo</code> 。这个特性是 <code>GNU make</code> 的，很有可能不兼容于其它版本的 <code>make</code>，所以， 你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是 <code>make</code> 所不能 识别的，那么 <code>$*</code> 就是空值。</ul><p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code> 在显式规则中很有用，例如，假设有一个函数库文件叫 <code>lib</code> ，其由其它几个 <code>object</code> 文件更新。那么把 <code>object</code> 文件打包的比较有效率的 <code>Makefile</code> 规则是:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">lib</span> <span class="token punctuation">:</span> foo.o bar.o lose.o win.o
    ar r lib <span class="token variable">$?</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>在上述所列出来的自动量变量中。四个变量(<code>$@</code> 、<code>$<</code> 、<code>$%</code> 、<code>$*</code> )在扩展时只会有一个文件，而另 三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的 文件名，只需要搭配上 <code>D</code> 或 <code>F</code> 字样。这是 <code>GNU make</code> 中老版本的特性，在新版本中，我们使用函数 <code>dir</code> 或 <code>notdir</code> 就可以做到了。<code>D</code> 的含义就是 <code>Directory</code>，就是目录，<code>F</code> 的含义就是 <code>File</code>，就是文件。<p>下面是对于上面的七个变量分别加上 <code>D</code> 或是 <code>F</code> 的含义:<p><code>$(@D)</code> : 表示 <code>$@</code> 的目录部分(不以斜杠作为结尾)，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而 如果 <code>$@</code> 中没有包含斜杠的话，其值就是 . (当前目录)。<br><code>$(@F)</code> : 表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是 <code>foo.o</code> ，$(@F) 相当于函数 $(notdir $@) 。<br><code>$(*D)</code>, <code>$(*F)</code> : 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code> 返回 <code>dir</code> ， 而 <code>$(*F)</code> 返回 <code>foo</code><br><code>$(%D)</code>, <code>$(%F)</code> : 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code>archive</code>(<code>member</code>) 形式的目标中 的 <code>member</code> 中包含了不同的目录很有用。<br><code>$(&LTD)</code>, <code>$(&LTF)</code> : 分别表示依赖文件的目录部分和文件部分。<br><code>$(^D)</code>, <code>$(^F)</code> : 分别表示所有依赖文件的目录部分和文件部分。(无相同的)<br><code>$(+D)</code>, <code>$(+F)</code> : 分别表示所有依赖文件的目录部分和文件部分。(可以有相同的)<br><code>$(?D)</code>, <code>$(?F)</code> : 分别表示被更新的依赖文件的目录部分和文件部分。<p>最后想提醒一下的是，对于 <code>$<</code> ，为了避免产生不必要的麻烦，我们最好给 <code>$</code> 后面的那个特定字符都加上圆括号，比如，<code>$(<)</code> 就要比 <code>$<</code> 要好一些。<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“<code>显式规则</code>”和“<code>静态模式规则</code>”(参见前面“书写规则”一章)。其在隐含规则中并没有意义。<h3 id=模式的匹配><a class=headerlink href=#模式的匹配 title=模式的匹配></a>模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的 <code>%</code> ，或是没有前后缀，直接就是一个 <code>% </code>。因为 <code>%</code> 代表一个或多个字符，所以在定义好了的模式中，我们把 <code>%</code> 所匹配的内容叫做“<code>茎</code>”，例如 <code>%.c</code> 所匹配 的文件“<code>test.c</code>”中“<code>test</code>”就是“<code>茎</code>”。因为在目标和依赖目标中同时有 <code>%</code> 时，依赖目标的“<code>茎</code>”会传给 目标，当做目标中的“<code>茎</code>”。<p>当一个模式匹配包含有斜杠(实际也不经常包含)的文件时，那么在进行模式匹配时，目录部分会首 先被移开，然后进行匹配，成功后，再把目录加回去。在进行“<code>茎</code>”的传递时，我们需要知道这个步骤。 例如有一个模式 <code>e%t</code> ，文件 <code>src/eat</code> 匹配于该模式，于是 <code>src/a</code> 就是其“<code>茎</code>”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 <code>c%r</code> ，那么，目标就是 <code>src/car</code> 。(“<code>茎</code>”被传递)<h3 id=重载内建隐含规则><a class=headerlink href=#重载内建隐含规则 title=重载内建隐含规则></a>重载内建隐含规则</h3><p>你可以重载内建的隐含规则(或是定义一个全新的)，例如你可以重新构造和内建隐含规则不同的命令，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -D<span class="token variable">$</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>你可以取消内建的隐含规则，只要不在后面写命令就行。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.s<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。<h2 id=老式风格的“后缀规则”><a class=headerlink href=#老式风格的“后缀规则” title=老式风格的“后缀规则”></a>老式风格的“后缀规则”</h2><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规 则更强更清晰。为了和老版本的 <code>Makefile</code> 兼容，<code>GNU make</code> 同样兼容于这些东西。后缀规则有两种方式:“<code>双后缀</code>”和“<code>单后缀</code>”。<p>双后缀规则定义了一对后缀:目标文件的后缀和依赖目标(源文件)的后缀。如 <code>.c.o</code> 相当于 <code>%o : %c</code> 。单后缀规则只定义一个后缀，也就是源文件的后缀。<br>如 <code>.c</code> 相当于 <code>% : %.c</code> 。<p>后缀规则中所定义的后缀应该是 <code>make</code> 所认识的，如果一个后缀是 <code>make</code> 所认识的，那么这个规则 就是单后缀规则，而如果两个连在一起的后缀都被 <code>make</code> 所认识，那就是双后缀规则。例如:<code>.c</code> 和 <code>.o</code> 都 是 <code>make</code> 所知道。因而，如果你定义了一个规则是 <code>.c.o</code> 那么其就是双后缀规则，意义就是 <code>.c</code> 是源文件 的后缀，<code>.o</code> 是目标文件的后缀。如下示例:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">.c.o</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$<</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">.c.o</span><span class="token punctuation">:</span> foo.h
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$<</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>这个例子，就是说，文件 <code>.c.o</code> 依赖于文件 <code>foo.h</code> ，而不是我们想要的这样:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">%.o</span><span class="token punctuation">:</span> %.c foo.h
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$<</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。<br>而要让 <code>make</code> 知道一些特定的后缀，我们可以使用伪目标 <code>.SUFFIXES</code> 来定义或是删除，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> .hack .win<span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>把后缀 .hack 和 .win 加入后缀列表中的末尾。<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> <span class="token comment"># 删除默认的后缀</span>
<span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> .c .o .h <span class="token comment"># 定义自己的后缀</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>先清除默认后缀，后定义自己的后缀列表。<p><code>make</code> 的参数 <code>-r</code> 或 <code>-no-builtin-rules</code> 也会使用得默认的后缀列表为空。而变量 <code>SUFFIXE</code> 被用来定义默认的后缀列表，你可以用 <code>.SUFFIXES</code> 来改变后缀列表，但请不要改变变量 <code>SUFFIXE</code> 的值。<h2 id=隐含规则搜索算法><a class=headerlink href=#隐含规则搜索算法 title=隐含规则搜索算法></a>隐含规则搜索算法</h2><p>比如我们有一个目标叫 <code>T</code>。下面是搜索目标 <code>T</code> 的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在 <code>Makefile</code> 被载入内存时，会被转换成模式规则。如果目标是 <code>archive</code>(<code>member</code>) 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标 <code>T</code>，如果没有找到的话，那么进入第二次，第二次会把 <code>member</code> 当作 <code>T</code> 来搜索。<ol><li><p>把 <code>T</code> 的目录部分分离出来。叫 <code>D</code>，而剩余部分叫 <code>N</code>。(如:如果 <code>T</code> 是 <code>src/foo.o</code> ，那么，<code>D</code> 就是 <code>src/</code> ，<code>N</code> 就是 <code>foo.o</code> )</p><li><p>创建所有匹配于 <code>T</code> 或是 <code>N</code> 的模式规则列表。</p><li><p>如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p><li><p>移除列表中没有命令的规则。</p><li><p>对于第一个在列表中的模式规则:</p> <ol><li>推导其“<code>茎</code>”<code>S</code>，<code>S</code> 应该是 <code>T</code> 或是 <code>N</code> 匹配于模式中 <code>%</code> 非空的部分。<li>计算依赖文件。把依赖文件中的<code>%</code>都替换成“<code>茎</code>”<code>S</code>。如果目标模式中没有包含斜框字符，而把 <code>D</code> 加在第一个依赖文件的开头。<li>测试是否所有的依赖文件都存在或是理当存在。(如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”)<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</ol><li><p>如果经过第 <code>5</code> 步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模 式规则:</p> <ol><li>如果规则是终止规则，那就忽略它，继续下一条模式规则。<li>计算依赖文件。(同第 <code>5</code> 步)<li>测试所有的依赖文件是否存在或是理当存在。<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退 出该算法。<li>如果没有隐含规则可以使用，查看 <code>.DEFAULT</code> 规则，如果有，采用，把 <code>.DEFAULT</code> 的命令给 <code>T</code> 使用。</ol></ol><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。<h1 id=使用-make-更新函数库文件><a title="使用 make 更新函数库文件" class=headerlink href=#使用-make-更新函数库文件></a>使用 make 更新函数库文件</h1><p>函数库文件也就是对 <code>Object</code> 文件(程序编译的中间文件)的打包文件。在 <code>Unix</code> 下，一般是由命令 <code>ar</code> 来完成打包工作。<h2 id=函数库文件的成员><a class=headerlink href=#函数库文件的成员 title=函数库文件的成员></a>函数库文件的成员</h2><p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>archive<span class="token punctuation">(</span>member<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 <code>ar</code> 命令来服务 的。如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">foolib(hack.o)</span> <span class="token punctuation">:</span> hack.o
    ar cr foolib hack.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>如果要指定多个 <code>member</code>，那就以空格分开，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foolib<span class="token punctuation">(</span>hack.o kludge.o<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>其等价于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foolib<span class="token punctuation">(</span>hack.o<span class="token punctuation">)</span> foolib<span class="token punctuation">(</span>kludge.o<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>你还可以使用 Shell 的文件通配符来定义，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>foolib<span class="token punctuation">(</span>*.o<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><h2 id=函数库成员的隐含规则><a class=headerlink href=#函数库成员的隐含规则 title=函数库成员的隐含规则></a>函数库成员的隐含规则</h2><p>当 <code>make</code> 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 <code>a</code>(<code>m</code>) 形式的，其会把目 标变成 (<code>m</code>) 。于是，如果我们的成员是<code> %.o</code> 的模式定义，并且如果我们使用 <code>make foo.a(bar.o)</code> 的形式调用 <code>Makefile</code> 时，隐含规则会去找 <code>bar.o</code> 的规则，如果没有定义 <code>bar.o</code> 的规则，那么内建隐含规则生效，<code>make</code> 会去找 <code>bar.c</code> 文件来生成 <code>bar.o</code> ，如果找得到的话，<code>make</code> 执行的命令大致如下:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile>cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>还有一个变量要注意的是 <code>$%</code> ，这是专属函数库文件的自动化变量，有关其说明请参见“<code>自动化变量</code>”一节。<h2 id=函数库文件的后缀规则><a class=headerlink href=#函数库文件的后缀规则 title=函数库文件的后缀规则></a>函数库文件的后缀规则</h2><p>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">.c.a</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$<</span> -o <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> r <span class="token variable">$@</span> <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$*.o</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>其等效于:<pre class="line-numbers language-makefile" data-language=makefile><code class=language-makefile><span class="token target symbol">(%.o)</span> <span class="token punctuation">:</span> %.c
    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$<</span> -o <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> r <span class="token variable">$@</span> <span class="token variable">$*.o</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$*.o</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><h2 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h2><p>在进行函数库打包文件生成时，请小心使用 <code>make</code> 的并行机制(<code>-j</code> 参数)。如果多个 <code>ar</code> 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在 <code>make</code> 未来的版本中， 应该提供一种机制来避免并行操作发生在函数打包文件上。<p>但就目前而言，你还是应该不要尽量不要使用 <code>-j</code> 参数。</div><footer class=post-footer><div class=post-tags><a href=/tags/makefile/ rel=tag># makefile</a></div><div class=post-nav><div class=post-nav-item><a title="01 | IAM项目安装" href=/post/2023-golang-practice-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-01-iam-project-install.html rel=prev> <i class="fa fa-chevron-left"></i> 01 | IAM项目安装 </a></div><div class=post-nav-item><a title="Python语言开发环境(一) linux 服务器配置" href=/post/2023-python-python-workspace-centos8.html rel=next> Python语言开发环境(一) linux 服务器配置 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>gzwillyy</span></div></div></footer><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>